/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model acesso_sistema
 *
 */
export type acesso_sistema =
  $Result.DefaultSelection<Prisma.$acesso_sistemaPayload>;
/**
 * Model agenrec
 *
 */
export type agenrec = $Result.DefaultSelection<Prisma.$agenrecPayload>;
/**
 * Model area
 *
 */
export type area = $Result.DefaultSelection<Prisma.$areaPayload>;
/**
 * Model avaliacao
 *
 */
export type avaliacao = $Result.DefaultSelection<Prisma.$avaliacaoPayload>;
/**
 * Model avaliado
 *
 */
export type avaliado = $Result.DefaultSelection<Prisma.$avaliadoPayload>;
/**
 * Model chamado
 *
 */
export type chamado = $Result.DefaultSelection<Prisma.$chamadoPayload>;
/**
 * Model cidade
 *
 */
export type cidade = $Result.DefaultSelection<Prisma.$cidadePayload>;
/**
 * Model classificacao
 *
 */
export type classificacao =
  $Result.DefaultSelection<Prisma.$classificacaoPayload>;
/**
 * Model cliente
 *
 */
export type cliente = $Result.DefaultSelection<Prisma.$clientePayload>;
/**
 * Model composicao
 *
 */
export type composicao = $Result.DefaultSelection<Prisma.$composicaoPayload>;
/**
 * Model contato
 *
 */
export type contato = $Result.DefaultSelection<Prisma.$contatoPayload>;
/**
 * Model ctiss
 *
 */
export type ctiss = $Result.DefaultSelection<Prisma.$ctissPayload>;
/**
 * Model despesa
 *
 */
export type despesa = $Result.DefaultSelection<Prisma.$despesaPayload>;
/**
 * Model desprec
 *
 */
export type desprec = $Result.DefaultSelection<Prisma.$desprecPayload>;
/**
 * Model empresa
 *
 */
export type empresa = $Result.DefaultSelection<Prisma.$empresaPayload>;
/**
 * Model fase
 *
 */
export type fase = $Result.DefaultSelection<Prisma.$fasePayload>;
/**
 * Model fatdes
 *
 */
export type fatdes = $Result.DefaultSelection<Prisma.$fatdesPayload>;
/**
 * Model fatfun
 *
 */
export type fatfun = $Result.DefaultSelection<Prisma.$fatfunPayload>;
/**
 * Model fatrec
 *
 */
export type fatrec = $Result.DefaultSelection<Prisma.$fatrecPayload>;
/**
 * Model fatura
 *
 */
export type fatura = $Result.DefaultSelection<Prisma.$faturaPayload>;
/**
 * Model faturamento
 *
 */
export type faturamento = $Result.DefaultSelection<Prisma.$faturamentoPayload>;
/**
 * Model grupo
 *
 */
export type grupo = $Result.DefaultSelection<Prisma.$grupoPayload>;
/**
 * Model histchamado
 *
 */
export type histchamado = $Result.DefaultSelection<Prisma.$histchamadoPayload>;
/**
 * Model itavaliado
 *
 */
export type itavaliado = $Result.DefaultSelection<Prisma.$itavaliadoPayload>;
/**
 * Model itmatriz
 *
 */
export type itmatriz = $Result.DefaultSelection<Prisma.$itmatrizPayload>;
/**
 * Model layout
 *
 */
export type layout = $Result.DefaultSelection<Prisma.$layoutPayload>;
/**
 * Model lista
 *
 */
export type lista = $Result.DefaultSelection<Prisma.$listaPayload>;
/**
 * Model matriz
 *
 */
export type matriz = $Result.DefaultSelection<Prisma.$matrizPayload>;
/**
 * Model mensagem
 *
 */
export type mensagem = $Result.DefaultSelection<Prisma.$mensagemPayload>;
/**
 * Model meta
 *
 */
export type meta = $Result.DefaultSelection<Prisma.$metaPayload>;
/**
 * Model modulo_sistema
 *
 */
export type modulo_sistema =
  $Result.DefaultSelection<Prisma.$modulo_sistemaPayload>;
/**
 * Model nfse
 *
 */
export type nfse = $Result.DefaultSelection<Prisma.$nfsePayload>;
/**
 * Model nivel
 *
 */
export type nivel = $Result.DefaultSelection<Prisma.$nivelPayload>;
/**
 * Model os
 *
 */
export type os = $Result.DefaultSelection<Prisma.$osPayload>;
/**
 * Model parametros
 *
 */
export type parametros = $Result.DefaultSelection<Prisma.$parametrosPayload>;
/**
 * Model parcela
 *
 */
export type parcela = $Result.DefaultSelection<Prisma.$parcelaPayload>;
/**
 * Model pauta
 *
 */
export type pauta = $Result.DefaultSelection<Prisma.$pautaPayload>;
/**
 * Model ponto
 *
 */
export type ponto = $Result.DefaultSelection<Prisma.$pontoPayload>;
/**
 * Model projeto
 *
 */
export type projeto = $Result.DefaultSelection<Prisma.$projetoPayload>;
/**
 * Model recurso
 *
 */
export type recurso = $Result.DefaultSelection<Prisma.$recursoPayload>;
/**
 * Model rescon
 *
 */
export type rescon = $Result.DefaultSelection<Prisma.$resconPayload>;
/**
 * Model status
 *
 */
export type status = $Result.DefaultSelection<Prisma.$statusPayload>;
/**
 * Model tarefa
 *
 */
export type tarefa = $Result.DefaultSelection<Prisma.$tarefaPayload>;
/**
 * Model tela_sistema
 *
 */
export type tela_sistema =
  $Result.DefaultSelection<Prisma.$tela_sistemaPayload>;
/**
 * Model telefone
 *
 */
export type telefone = $Result.DefaultSelection<Prisma.$telefonePayload>;
/**
 * Model tipotrf
 *
 */
export type tipotrf = $Result.DefaultSelection<Prisma.$tipotrfPayload>;
/**
 * Model tpdesp
 *
 */
export type tpdesp = $Result.DefaultSelection<Prisma.$tpdespPayload>;
/**
 * Model usuario
 *
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>;
/**
 * Model valor
 *
 */
export type valor = $Result.DefaultSelection<Prisma.$valorPayload>;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Acesso_sistemas
 * const acesso_sistemas = await prisma.acesso_sistema.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Acesso_sistemas
   * const acesso_sistemas = await prisma.acesso_sistema.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.acesso_sistema`: Exposes CRUD operations for the **acesso_sistema** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Acesso_sistemas
   * const acesso_sistemas = await prisma.acesso_sistema.findMany()
   * ```
   */
  get acesso_sistema(): Prisma.acesso_sistemaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agenrec`: Exposes CRUD operations for the **agenrec** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Agenrecs
   * const agenrecs = await prisma.agenrec.findMany()
   * ```
   */
  get agenrec(): Prisma.agenrecDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **area** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Areas
   * const areas = await prisma.area.findMany()
   * ```
   */
  get area(): Prisma.areaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avaliacao`: Exposes CRUD operations for the **avaliacao** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Avaliacaos
   * const avaliacaos = await prisma.avaliacao.findMany()
   * ```
   */
  get avaliacao(): Prisma.avaliacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avaliado`: Exposes CRUD operations for the **avaliado** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Avaliados
   * const avaliados = await prisma.avaliado.findMany()
   * ```
   */
  get avaliado(): Prisma.avaliadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chamado`: Exposes CRUD operations for the **chamado** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Chamados
   * const chamados = await prisma.chamado.findMany()
   * ```
   */
  get chamado(): Prisma.chamadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cidade`: Exposes CRUD operations for the **cidade** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Cidades
   * const cidades = await prisma.cidade.findMany()
   * ```
   */
  get cidade(): Prisma.cidadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classificacao`: Exposes CRUD operations for the **classificacao** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Classificacaos
   * const classificacaos = await prisma.classificacao.findMany()
   * ```
   */
  get classificacao(): Prisma.classificacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **cliente** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Clientes
   * const clientes = await prisma.cliente.findMany()
   * ```
   */
  get cliente(): Prisma.clienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.composicao`: Exposes CRUD operations for the **composicao** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Composicaos
   * const composicaos = await prisma.composicao.findMany()
   * ```
   */
  get composicao(): Prisma.composicaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contato`: Exposes CRUD operations for the **contato** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Contatoes
   * const contatoes = await prisma.contato.findMany()
   * ```
   */
  get contato(): Prisma.contatoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ctiss`: Exposes CRUD operations for the **ctiss** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Ctisses
   * const ctisses = await prisma.ctiss.findMany()
   * ```
   */
  get ctiss(): Prisma.ctissDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.despesa`: Exposes CRUD operations for the **despesa** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Despesas
   * const despesas = await prisma.despesa.findMany()
   * ```
   */
  get despesa(): Prisma.despesaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.desprec`: Exposes CRUD operations for the **desprec** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Desprecs
   * const desprecs = await prisma.desprec.findMany()
   * ```
   */
  get desprec(): Prisma.desprecDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **empresa** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Empresas
   * const empresas = await prisma.empresa.findMany()
   * ```
   */
  get empresa(): Prisma.empresaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fase`: Exposes CRUD operations for the **fase** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Fases
   * const fases = await prisma.fase.findMany()
   * ```
   */
  get fase(): Prisma.faseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fatdes`: Exposes CRUD operations for the **fatdes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Fatdes
   * const fatdes = await prisma.fatdes.findMany()
   * ```
   */
  get fatdes(): Prisma.fatdesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fatfun`: Exposes CRUD operations for the **fatfun** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Fatfuns
   * const fatfuns = await prisma.fatfun.findMany()
   * ```
   */
  get fatfun(): Prisma.fatfunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fatrec`: Exposes CRUD operations for the **fatrec** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Fatrecs
   * const fatrecs = await prisma.fatrec.findMany()
   * ```
   */
  get fatrec(): Prisma.fatrecDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fatura`: Exposes CRUD operations for the **fatura** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Faturas
   * const faturas = await prisma.fatura.findMany()
   * ```
   */
  get fatura(): Prisma.faturaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faturamento`: Exposes CRUD operations for the **faturamento** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Faturamentos
   * const faturamentos = await prisma.faturamento.findMany()
   * ```
   */
  get faturamento(): Prisma.faturamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grupo`: Exposes CRUD operations for the **grupo** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Grupos
   * const grupos = await prisma.grupo.findMany()
   * ```
   */
  get grupo(): Prisma.grupoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.histchamado`: Exposes CRUD operations for the **histchamado** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Histchamados
   * const histchamados = await prisma.histchamado.findMany()
   * ```
   */
  get histchamado(): Prisma.histchamadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itavaliado`: Exposes CRUD operations for the **itavaliado** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Itavaliados
   * const itavaliados = await prisma.itavaliado.findMany()
   * ```
   */
  get itavaliado(): Prisma.itavaliadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itmatriz`: Exposes CRUD operations for the **itmatriz** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Itmatrizs
   * const itmatrizs = await prisma.itmatriz.findMany()
   * ```
   */
  get itmatriz(): Prisma.itmatrizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.layout`: Exposes CRUD operations for the **layout** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Layouts
   * const layouts = await prisma.layout.findMany()
   * ```
   */
  get layout(): Prisma.layoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lista`: Exposes CRUD operations for the **lista** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Listas
   * const listas = await prisma.lista.findMany()
   * ```
   */
  get lista(): Prisma.listaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matriz`: Exposes CRUD operations for the **matriz** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Matrizs
   * const matrizs = await prisma.matriz.findMany()
   * ```
   */
  get matriz(): Prisma.matrizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mensagem`: Exposes CRUD operations for the **mensagem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Mensagems
   * const mensagems = await prisma.mensagem.findMany()
   * ```
   */
  get mensagem(): Prisma.mensagemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meta`: Exposes CRUD operations for the **meta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Metas
   * const metas = await prisma.meta.findMany()
   * ```
   */
  get meta(): Prisma.metaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modulo_sistema`: Exposes CRUD operations for the **modulo_sistema** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Modulo_sistemas
   * const modulo_sistemas = await prisma.modulo_sistema.findMany()
   * ```
   */
  get modulo_sistema(): Prisma.modulo_sistemaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nfse`: Exposes CRUD operations for the **nfse** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Nfses
   * const nfses = await prisma.nfse.findMany()
   * ```
   */
  get nfse(): Prisma.nfseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nivel`: Exposes CRUD operations for the **nivel** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Nivels
   * const nivels = await prisma.nivel.findMany()
   * ```
   */
  get nivel(): Prisma.nivelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.os`: Exposes CRUD operations for the **os** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Os
   * const os = await prisma.os.findMany()
   * ```
   */
  get os(): Prisma.osDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parametros`: Exposes CRUD operations for the **parametros** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Parametros
   * const parametros = await prisma.parametros.findMany()
   * ```
   */
  get parametros(): Prisma.parametrosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parcela`: Exposes CRUD operations for the **parcela** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Parcelas
   * const parcelas = await prisma.parcela.findMany()
   * ```
   */
  get parcela(): Prisma.parcelaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pauta`: Exposes CRUD operations for the **pauta** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Pautas
   * const pautas = await prisma.pauta.findMany()
   * ```
   */
  get pauta(): Prisma.pautaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ponto`: Exposes CRUD operations for the **ponto** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Pontos
   * const pontos = await prisma.ponto.findMany()
   * ```
   */
  get ponto(): Prisma.pontoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projeto`: Exposes CRUD operations for the **projeto** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Projetos
   * const projetos = await prisma.projeto.findMany()
   * ```
   */
  get projeto(): Prisma.projetoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurso`: Exposes CRUD operations for the **recurso** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Recursos
   * const recursos = await prisma.recurso.findMany()
   * ```
   */
  get recurso(): Prisma.recursoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rescon`: Exposes CRUD operations for the **rescon** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Rescons
   * const rescons = await prisma.rescon.findMany()
   * ```
   */
  get rescon(): Prisma.resconDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.status`: Exposes CRUD operations for the **status** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Statuses
   * const statuses = await prisma.status.findMany()
   * ```
   */
  get status(): Prisma.statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tarefa`: Exposes CRUD operations for the **tarefa** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tarefas
   * const tarefas = await prisma.tarefa.findMany()
   * ```
   */
  get tarefa(): Prisma.tarefaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tela_sistema`: Exposes CRUD operations for the **tela_sistema** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tela_sistemas
   * const tela_sistemas = await prisma.tela_sistema.findMany()
   * ```
   */
  get tela_sistema(): Prisma.tela_sistemaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telefone`: Exposes CRUD operations for the **telefone** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Telefones
   * const telefones = await prisma.telefone.findMany()
   * ```
   */
  get telefone(): Prisma.telefoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipotrf`: Exposes CRUD operations for the **tipotrf** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tipotrfs
   * const tipotrfs = await prisma.tipotrf.findMany()
   * ```
   */
  get tipotrf(): Prisma.tipotrfDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tpdesp`: Exposes CRUD operations for the **tpdesp** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tpdesps
   * const tpdesps = await prisma.tpdesp.findMany()
   * ```
   */
  get tpdesp(): Prisma.tpdespDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   */
  get usuario(): Prisma.usuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.valor`: Exposes CRUD operations for the **valor** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Valors
   * const valors = await prisma.valor.findMany()
   * ```
   */
  get valor(): Prisma.valorDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    acesso_sistema: 'acesso_sistema';
    agenrec: 'agenrec';
    area: 'area';
    avaliacao: 'avaliacao';
    avaliado: 'avaliado';
    chamado: 'chamado';
    cidade: 'cidade';
    classificacao: 'classificacao';
    cliente: 'cliente';
    composicao: 'composicao';
    contato: 'contato';
    ctiss: 'ctiss';
    despesa: 'despesa';
    desprec: 'desprec';
    empresa: 'empresa';
    fase: 'fase';
    fatdes: 'fatdes';
    fatfun: 'fatfun';
    fatrec: 'fatrec';
    fatura: 'fatura';
    faturamento: 'faturamento';
    grupo: 'grupo';
    histchamado: 'histchamado';
    itavaliado: 'itavaliado';
    itmatriz: 'itmatriz';
    layout: 'layout';
    lista: 'lista';
    matriz: 'matriz';
    mensagem: 'mensagem';
    meta: 'meta';
    modulo_sistema: 'modulo_sistema';
    nfse: 'nfse';
    nivel: 'nivel';
    os: 'os';
    parametros: 'parametros';
    parcela: 'parcela';
    pauta: 'pauta';
    ponto: 'ponto';
    projeto: 'projeto';
    recurso: 'recurso';
    rescon: 'rescon';
    status: 'status';
    tarefa: 'tarefa';
    tela_sistema: 'tela_sistema';
    telefone: 'telefone';
    tipotrf: 'tipotrf';
    tpdesp: 'tpdesp';
    usuario: 'usuario';
    valor: 'valor';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    gerprojDb?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'acesso_sistema'
        | 'agenrec'
        | 'area'
        | 'avaliacao'
        | 'avaliado'
        | 'chamado'
        | 'cidade'
        | 'classificacao'
        | 'cliente'
        | 'composicao'
        | 'contato'
        | 'ctiss'
        | 'despesa'
        | 'desprec'
        | 'empresa'
        | 'fase'
        | 'fatdes'
        | 'fatfun'
        | 'fatrec'
        | 'fatura'
        | 'faturamento'
        | 'grupo'
        | 'histchamado'
        | 'itavaliado'
        | 'itmatriz'
        | 'layout'
        | 'lista'
        | 'matriz'
        | 'mensagem'
        | 'meta'
        | 'modulo_sistema'
        | 'nfse'
        | 'nivel'
        | 'os'
        | 'parametros'
        | 'parcela'
        | 'pauta'
        | 'ponto'
        | 'projeto'
        | 'recurso'
        | 'rescon'
        | 'status'
        | 'tarefa'
        | 'tela_sistema'
        | 'telefone'
        | 'tipotrf'
        | 'tpdesp'
        | 'usuario'
        | 'valor';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      acesso_sistema: {
        payload: Prisma.$acesso_sistemaPayload<ExtArgs>;
        fields: Prisma.acesso_sistemaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.acesso_sistemaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.acesso_sistemaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>;
          };
          findFirst: {
            args: Prisma.acesso_sistemaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.acesso_sistemaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>;
          };
          findMany: {
            args: Prisma.acesso_sistemaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>[];
          };
          create: {
            args: Prisma.acesso_sistemaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>;
          };
          createMany: {
            args: Prisma.acesso_sistemaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.acesso_sistemaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>[];
          };
          delete: {
            args: Prisma.acesso_sistemaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>;
          };
          update: {
            args: Prisma.acesso_sistemaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>;
          };
          deleteMany: {
            args: Prisma.acesso_sistemaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.acesso_sistemaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.acesso_sistemaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>[];
          };
          upsert: {
            args: Prisma.acesso_sistemaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$acesso_sistemaPayload>;
          };
          aggregate: {
            args: Prisma.Acesso_sistemaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAcesso_sistema>;
          };
          groupBy: {
            args: Prisma.acesso_sistemaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Acesso_sistemaGroupByOutputType>[];
          };
          count: {
            args: Prisma.acesso_sistemaCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Acesso_sistemaCountAggregateOutputType>
              | number;
          };
        };
      };
      agenrec: {
        payload: Prisma.$agenrecPayload<ExtArgs>;
        fields: Prisma.agenrecFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.agenrecFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.agenrecFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>;
          };
          findFirst: {
            args: Prisma.agenrecFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.agenrecFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>;
          };
          findMany: {
            args: Prisma.agenrecFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>[];
          };
          create: {
            args: Prisma.agenrecCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>;
          };
          createMany: {
            args: Prisma.agenrecCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.agenrecCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>[];
          };
          delete: {
            args: Prisma.agenrecDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>;
          };
          update: {
            args: Prisma.agenrecUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>;
          };
          deleteMany: {
            args: Prisma.agenrecDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.agenrecUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.agenrecUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>[];
          };
          upsert: {
            args: Prisma.agenrecUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$agenrecPayload>;
          };
          aggregate: {
            args: Prisma.AgenrecAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAgenrec>;
          };
          groupBy: {
            args: Prisma.agenrecGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AgenrecGroupByOutputType>[];
          };
          count: {
            args: Prisma.agenrecCountArgs<ExtArgs>;
            result: $Utils.Optional<AgenrecCountAggregateOutputType> | number;
          };
        };
      };
      area: {
        payload: Prisma.$areaPayload<ExtArgs>;
        fields: Prisma.areaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.areaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.areaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>;
          };
          findFirst: {
            args: Prisma.areaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.areaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>;
          };
          findMany: {
            args: Prisma.areaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>[];
          };
          create: {
            args: Prisma.areaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>;
          };
          createMany: {
            args: Prisma.areaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.areaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>[];
          };
          delete: {
            args: Prisma.areaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>;
          };
          update: {
            args: Prisma.areaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>;
          };
          deleteMany: {
            args: Prisma.areaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.areaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.areaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>[];
          };
          upsert: {
            args: Prisma.areaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$areaPayload>;
          };
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateArea>;
          };
          groupBy: {
            args: Prisma.areaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AreaGroupByOutputType>[];
          };
          count: {
            args: Prisma.areaCountArgs<ExtArgs>;
            result: $Utils.Optional<AreaCountAggregateOutputType> | number;
          };
        };
      };
      avaliacao: {
        payload: Prisma.$avaliacaoPayload<ExtArgs>;
        fields: Prisma.avaliacaoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.avaliacaoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.avaliacaoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>;
          };
          findFirst: {
            args: Prisma.avaliacaoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.avaliacaoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>;
          };
          findMany: {
            args: Prisma.avaliacaoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>[];
          };
          create: {
            args: Prisma.avaliacaoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>;
          };
          createMany: {
            args: Prisma.avaliacaoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.avaliacaoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>[];
          };
          delete: {
            args: Prisma.avaliacaoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>;
          };
          update: {
            args: Prisma.avaliacaoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>;
          };
          deleteMany: {
            args: Prisma.avaliacaoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.avaliacaoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.avaliacaoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>[];
          };
          upsert: {
            args: Prisma.avaliacaoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliacaoPayload>;
          };
          aggregate: {
            args: Prisma.AvaliacaoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAvaliacao>;
          };
          groupBy: {
            args: Prisma.avaliacaoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AvaliacaoGroupByOutputType>[];
          };
          count: {
            args: Prisma.avaliacaoCountArgs<ExtArgs>;
            result: $Utils.Optional<AvaliacaoCountAggregateOutputType> | number;
          };
        };
      };
      avaliado: {
        payload: Prisma.$avaliadoPayload<ExtArgs>;
        fields: Prisma.avaliadoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.avaliadoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.avaliadoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>;
          };
          findFirst: {
            args: Prisma.avaliadoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.avaliadoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>;
          };
          findMany: {
            args: Prisma.avaliadoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>[];
          };
          create: {
            args: Prisma.avaliadoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>;
          };
          createMany: {
            args: Prisma.avaliadoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.avaliadoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>[];
          };
          delete: {
            args: Prisma.avaliadoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>;
          };
          update: {
            args: Prisma.avaliadoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>;
          };
          deleteMany: {
            args: Prisma.avaliadoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.avaliadoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.avaliadoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>[];
          };
          upsert: {
            args: Prisma.avaliadoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$avaliadoPayload>;
          };
          aggregate: {
            args: Prisma.AvaliadoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAvaliado>;
          };
          groupBy: {
            args: Prisma.avaliadoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AvaliadoGroupByOutputType>[];
          };
          count: {
            args: Prisma.avaliadoCountArgs<ExtArgs>;
            result: $Utils.Optional<AvaliadoCountAggregateOutputType> | number;
          };
        };
      };
      chamado: {
        payload: Prisma.$chamadoPayload<ExtArgs>;
        fields: Prisma.chamadoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.chamadoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.chamadoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>;
          };
          findFirst: {
            args: Prisma.chamadoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.chamadoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>;
          };
          findMany: {
            args: Prisma.chamadoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>[];
          };
          create: {
            args: Prisma.chamadoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>;
          };
          createMany: {
            args: Prisma.chamadoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.chamadoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>[];
          };
          delete: {
            args: Prisma.chamadoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>;
          };
          update: {
            args: Prisma.chamadoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>;
          };
          deleteMany: {
            args: Prisma.chamadoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.chamadoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.chamadoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>[];
          };
          upsert: {
            args: Prisma.chamadoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$chamadoPayload>;
          };
          aggregate: {
            args: Prisma.ChamadoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateChamado>;
          };
          groupBy: {
            args: Prisma.chamadoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ChamadoGroupByOutputType>[];
          };
          count: {
            args: Prisma.chamadoCountArgs<ExtArgs>;
            result: $Utils.Optional<ChamadoCountAggregateOutputType> | number;
          };
        };
      };
      cidade: {
        payload: Prisma.$cidadePayload<ExtArgs>;
        fields: Prisma.cidadeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.cidadeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.cidadeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>;
          };
          findFirst: {
            args: Prisma.cidadeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.cidadeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>;
          };
          findMany: {
            args: Prisma.cidadeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>[];
          };
          create: {
            args: Prisma.cidadeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>;
          };
          createMany: {
            args: Prisma.cidadeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.cidadeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>[];
          };
          delete: {
            args: Prisma.cidadeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>;
          };
          update: {
            args: Prisma.cidadeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>;
          };
          deleteMany: {
            args: Prisma.cidadeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.cidadeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.cidadeUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>[];
          };
          upsert: {
            args: Prisma.cidadeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>;
          };
          aggregate: {
            args: Prisma.CidadeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCidade>;
          };
          groupBy: {
            args: Prisma.cidadeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CidadeGroupByOutputType>[];
          };
          count: {
            args: Prisma.cidadeCountArgs<ExtArgs>;
            result: $Utils.Optional<CidadeCountAggregateOutputType> | number;
          };
        };
      };
      classificacao: {
        payload: Prisma.$classificacaoPayload<ExtArgs>;
        fields: Prisma.classificacaoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.classificacaoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.classificacaoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>;
          };
          findFirst: {
            args: Prisma.classificacaoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.classificacaoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>;
          };
          findMany: {
            args: Prisma.classificacaoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>[];
          };
          create: {
            args: Prisma.classificacaoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>;
          };
          createMany: {
            args: Prisma.classificacaoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.classificacaoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>[];
          };
          delete: {
            args: Prisma.classificacaoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>;
          };
          update: {
            args: Prisma.classificacaoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>;
          };
          deleteMany: {
            args: Prisma.classificacaoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.classificacaoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.classificacaoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>[];
          };
          upsert: {
            args: Prisma.classificacaoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$classificacaoPayload>;
          };
          aggregate: {
            args: Prisma.ClassificacaoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClassificacao>;
          };
          groupBy: {
            args: Prisma.classificacaoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClassificacaoGroupByOutputType>[];
          };
          count: {
            args: Prisma.classificacaoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ClassificacaoCountAggregateOutputType>
              | number;
          };
        };
      };
      cliente: {
        payload: Prisma.$clientePayload<ExtArgs>;
        fields: Prisma.clienteFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.clienteFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.clienteFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>;
          };
          findFirst: {
            args: Prisma.clienteFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.clienteFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>;
          };
          findMany: {
            args: Prisma.clienteFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[];
          };
          create: {
            args: Prisma.clienteCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>;
          };
          createMany: {
            args: Prisma.clienteCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.clienteCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[];
          };
          delete: {
            args: Prisma.clienteDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>;
          };
          update: {
            args: Prisma.clienteUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>;
          };
          deleteMany: {
            args: Prisma.clienteDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.clienteUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.clienteUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[];
          };
          upsert: {
            args: Prisma.clienteUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$clientePayload>;
          };
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCliente>;
          };
          groupBy: {
            args: Prisma.clienteGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClienteGroupByOutputType>[];
          };
          count: {
            args: Prisma.clienteCountArgs<ExtArgs>;
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number;
          };
        };
      };
      composicao: {
        payload: Prisma.$composicaoPayload<ExtArgs>;
        fields: Prisma.composicaoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.composicaoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.composicaoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>;
          };
          findFirst: {
            args: Prisma.composicaoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.composicaoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>;
          };
          findMany: {
            args: Prisma.composicaoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>[];
          };
          create: {
            args: Prisma.composicaoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>;
          };
          createMany: {
            args: Prisma.composicaoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.composicaoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>[];
          };
          delete: {
            args: Prisma.composicaoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>;
          };
          update: {
            args: Prisma.composicaoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>;
          };
          deleteMany: {
            args: Prisma.composicaoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.composicaoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.composicaoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>[];
          };
          upsert: {
            args: Prisma.composicaoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$composicaoPayload>;
          };
          aggregate: {
            args: Prisma.ComposicaoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateComposicao>;
          };
          groupBy: {
            args: Prisma.composicaoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ComposicaoGroupByOutputType>[];
          };
          count: {
            args: Prisma.composicaoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ComposicaoCountAggregateOutputType>
              | number;
          };
        };
      };
      contato: {
        payload: Prisma.$contatoPayload<ExtArgs>;
        fields: Prisma.contatoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.contatoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.contatoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>;
          };
          findFirst: {
            args: Prisma.contatoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.contatoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>;
          };
          findMany: {
            args: Prisma.contatoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>[];
          };
          create: {
            args: Prisma.contatoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>;
          };
          createMany: {
            args: Prisma.contatoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.contatoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>[];
          };
          delete: {
            args: Prisma.contatoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>;
          };
          update: {
            args: Prisma.contatoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>;
          };
          deleteMany: {
            args: Prisma.contatoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.contatoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.contatoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>[];
          };
          upsert: {
            args: Prisma.contatoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$contatoPayload>;
          };
          aggregate: {
            args: Prisma.ContatoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateContato>;
          };
          groupBy: {
            args: Prisma.contatoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ContatoGroupByOutputType>[];
          };
          count: {
            args: Prisma.contatoCountArgs<ExtArgs>;
            result: $Utils.Optional<ContatoCountAggregateOutputType> | number;
          };
        };
      };
      ctiss: {
        payload: Prisma.$ctissPayload<ExtArgs>;
        fields: Prisma.ctissFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ctissFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ctissFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>;
          };
          findFirst: {
            args: Prisma.ctissFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ctissFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>;
          };
          findMany: {
            args: Prisma.ctissFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>[];
          };
          create: {
            args: Prisma.ctissCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>;
          };
          createMany: {
            args: Prisma.ctissCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ctissCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>[];
          };
          delete: {
            args: Prisma.ctissDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>;
          };
          update: {
            args: Prisma.ctissUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>;
          };
          deleteMany: {
            args: Prisma.ctissDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ctissUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ctissUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>[];
          };
          upsert: {
            args: Prisma.ctissUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ctissPayload>;
          };
          aggregate: {
            args: Prisma.CtissAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCtiss>;
          };
          groupBy: {
            args: Prisma.ctissGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CtissGroupByOutputType>[];
          };
          count: {
            args: Prisma.ctissCountArgs<ExtArgs>;
            result: $Utils.Optional<CtissCountAggregateOutputType> | number;
          };
        };
      };
      despesa: {
        payload: Prisma.$despesaPayload<ExtArgs>;
        fields: Prisma.despesaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.despesaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.despesaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>;
          };
          findFirst: {
            args: Prisma.despesaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.despesaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>;
          };
          findMany: {
            args: Prisma.despesaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>[];
          };
          create: {
            args: Prisma.despesaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>;
          };
          createMany: {
            args: Prisma.despesaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.despesaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>[];
          };
          delete: {
            args: Prisma.despesaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>;
          };
          update: {
            args: Prisma.despesaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>;
          };
          deleteMany: {
            args: Prisma.despesaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.despesaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.despesaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>[];
          };
          upsert: {
            args: Prisma.despesaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$despesaPayload>;
          };
          aggregate: {
            args: Prisma.DespesaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDespesa>;
          };
          groupBy: {
            args: Prisma.despesaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DespesaGroupByOutputType>[];
          };
          count: {
            args: Prisma.despesaCountArgs<ExtArgs>;
            result: $Utils.Optional<DespesaCountAggregateOutputType> | number;
          };
        };
      };
      desprec: {
        payload: Prisma.$desprecPayload<ExtArgs>;
        fields: Prisma.desprecFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.desprecFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.desprecFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>;
          };
          findFirst: {
            args: Prisma.desprecFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.desprecFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>;
          };
          findMany: {
            args: Prisma.desprecFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>[];
          };
          create: {
            args: Prisma.desprecCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>;
          };
          createMany: {
            args: Prisma.desprecCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.desprecCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>[];
          };
          delete: {
            args: Prisma.desprecDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>;
          };
          update: {
            args: Prisma.desprecUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>;
          };
          deleteMany: {
            args: Prisma.desprecDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.desprecUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.desprecUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>[];
          };
          upsert: {
            args: Prisma.desprecUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$desprecPayload>;
          };
          aggregate: {
            args: Prisma.DesprecAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDesprec>;
          };
          groupBy: {
            args: Prisma.desprecGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DesprecGroupByOutputType>[];
          };
          count: {
            args: Prisma.desprecCountArgs<ExtArgs>;
            result: $Utils.Optional<DesprecCountAggregateOutputType> | number;
          };
        };
      };
      empresa: {
        payload: Prisma.$empresaPayload<ExtArgs>;
        fields: Prisma.empresaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.empresaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.empresaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>;
          };
          findFirst: {
            args: Prisma.empresaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.empresaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>;
          };
          findMany: {
            args: Prisma.empresaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>[];
          };
          create: {
            args: Prisma.empresaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>;
          };
          createMany: {
            args: Prisma.empresaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.empresaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>[];
          };
          delete: {
            args: Prisma.empresaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>;
          };
          update: {
            args: Prisma.empresaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>;
          };
          deleteMany: {
            args: Prisma.empresaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.empresaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.empresaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>[];
          };
          upsert: {
            args: Prisma.empresaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$empresaPayload>;
          };
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEmpresa>;
          };
          groupBy: {
            args: Prisma.empresaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EmpresaGroupByOutputType>[];
          };
          count: {
            args: Prisma.empresaCountArgs<ExtArgs>;
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number;
          };
        };
      };
      fase: {
        payload: Prisma.$fasePayload<ExtArgs>;
        fields: Prisma.faseFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.faseFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.faseFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>;
          };
          findFirst: {
            args: Prisma.faseFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.faseFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>;
          };
          findMany: {
            args: Prisma.faseFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>[];
          };
          create: {
            args: Prisma.faseCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>;
          };
          createMany: {
            args: Prisma.faseCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.faseCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>[];
          };
          delete: {
            args: Prisma.faseDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>;
          };
          update: {
            args: Prisma.faseUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>;
          };
          deleteMany: {
            args: Prisma.faseDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.faseUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.faseUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>[];
          };
          upsert: {
            args: Prisma.faseUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fasePayload>;
          };
          aggregate: {
            args: Prisma.FaseAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFase>;
          };
          groupBy: {
            args: Prisma.faseGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FaseGroupByOutputType>[];
          };
          count: {
            args: Prisma.faseCountArgs<ExtArgs>;
            result: $Utils.Optional<FaseCountAggregateOutputType> | number;
          };
        };
      };
      fatdes: {
        payload: Prisma.$fatdesPayload<ExtArgs>;
        fields: Prisma.fatdesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.fatdesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.fatdesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>;
          };
          findFirst: {
            args: Prisma.fatdesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.fatdesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>;
          };
          findMany: {
            args: Prisma.fatdesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>[];
          };
          create: {
            args: Prisma.fatdesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>;
          };
          createMany: {
            args: Prisma.fatdesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.fatdesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>[];
          };
          delete: {
            args: Prisma.fatdesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>;
          };
          update: {
            args: Prisma.fatdesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>;
          };
          deleteMany: {
            args: Prisma.fatdesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.fatdesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.fatdesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>[];
          };
          upsert: {
            args: Prisma.fatdesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatdesPayload>;
          };
          aggregate: {
            args: Prisma.FatdesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFatdes>;
          };
          groupBy: {
            args: Prisma.fatdesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FatdesGroupByOutputType>[];
          };
          count: {
            args: Prisma.fatdesCountArgs<ExtArgs>;
            result: $Utils.Optional<FatdesCountAggregateOutputType> | number;
          };
        };
      };
      fatfun: {
        payload: Prisma.$fatfunPayload<ExtArgs>;
        fields: Prisma.fatfunFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.fatfunFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.fatfunFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>;
          };
          findFirst: {
            args: Prisma.fatfunFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.fatfunFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>;
          };
          findMany: {
            args: Prisma.fatfunFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>[];
          };
          create: {
            args: Prisma.fatfunCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>;
          };
          createMany: {
            args: Prisma.fatfunCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.fatfunCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>[];
          };
          delete: {
            args: Prisma.fatfunDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>;
          };
          update: {
            args: Prisma.fatfunUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>;
          };
          deleteMany: {
            args: Prisma.fatfunDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.fatfunUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.fatfunUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>[];
          };
          upsert: {
            args: Prisma.fatfunUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatfunPayload>;
          };
          aggregate: {
            args: Prisma.FatfunAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFatfun>;
          };
          groupBy: {
            args: Prisma.fatfunGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FatfunGroupByOutputType>[];
          };
          count: {
            args: Prisma.fatfunCountArgs<ExtArgs>;
            result: $Utils.Optional<FatfunCountAggregateOutputType> | number;
          };
        };
      };
      fatrec: {
        payload: Prisma.$fatrecPayload<ExtArgs>;
        fields: Prisma.fatrecFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.fatrecFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.fatrecFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>;
          };
          findFirst: {
            args: Prisma.fatrecFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.fatrecFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>;
          };
          findMany: {
            args: Prisma.fatrecFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>[];
          };
          create: {
            args: Prisma.fatrecCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>;
          };
          createMany: {
            args: Prisma.fatrecCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.fatrecCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>[];
          };
          delete: {
            args: Prisma.fatrecDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>;
          };
          update: {
            args: Prisma.fatrecUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>;
          };
          deleteMany: {
            args: Prisma.fatrecDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.fatrecUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.fatrecUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>[];
          };
          upsert: {
            args: Prisma.fatrecUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$fatrecPayload>;
          };
          aggregate: {
            args: Prisma.FatrecAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFatrec>;
          };
          groupBy: {
            args: Prisma.fatrecGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FatrecGroupByOutputType>[];
          };
          count: {
            args: Prisma.fatrecCountArgs<ExtArgs>;
            result: $Utils.Optional<FatrecCountAggregateOutputType> | number;
          };
        };
      };
      fatura: {
        payload: Prisma.$faturaPayload<ExtArgs>;
        fields: Prisma.faturaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.faturaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.faturaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>;
          };
          findFirst: {
            args: Prisma.faturaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.faturaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>;
          };
          findMany: {
            args: Prisma.faturaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>[];
          };
          create: {
            args: Prisma.faturaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>;
          };
          createMany: {
            args: Prisma.faturaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.faturaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>[];
          };
          delete: {
            args: Prisma.faturaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>;
          };
          update: {
            args: Prisma.faturaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>;
          };
          deleteMany: {
            args: Prisma.faturaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.faturaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.faturaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>[];
          };
          upsert: {
            args: Prisma.faturaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturaPayload>;
          };
          aggregate: {
            args: Prisma.FaturaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFatura>;
          };
          groupBy: {
            args: Prisma.faturaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FaturaGroupByOutputType>[];
          };
          count: {
            args: Prisma.faturaCountArgs<ExtArgs>;
            result: $Utils.Optional<FaturaCountAggregateOutputType> | number;
          };
        };
      };
      faturamento: {
        payload: Prisma.$faturamentoPayload<ExtArgs>;
        fields: Prisma.faturamentoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.faturamentoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.faturamentoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>;
          };
          findFirst: {
            args: Prisma.faturamentoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.faturamentoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>;
          };
          findMany: {
            args: Prisma.faturamentoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>[];
          };
          create: {
            args: Prisma.faturamentoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>;
          };
          createMany: {
            args: Prisma.faturamentoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.faturamentoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>[];
          };
          delete: {
            args: Prisma.faturamentoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>;
          };
          update: {
            args: Prisma.faturamentoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>;
          };
          deleteMany: {
            args: Prisma.faturamentoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.faturamentoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.faturamentoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>[];
          };
          upsert: {
            args: Prisma.faturamentoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$faturamentoPayload>;
          };
          aggregate: {
            args: Prisma.FaturamentoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFaturamento>;
          };
          groupBy: {
            args: Prisma.faturamentoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FaturamentoGroupByOutputType>[];
          };
          count: {
            args: Prisma.faturamentoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FaturamentoCountAggregateOutputType>
              | number;
          };
        };
      };
      grupo: {
        payload: Prisma.$grupoPayload<ExtArgs>;
        fields: Prisma.grupoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.grupoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.grupoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>;
          };
          findFirst: {
            args: Prisma.grupoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.grupoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>;
          };
          findMany: {
            args: Prisma.grupoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>[];
          };
          create: {
            args: Prisma.grupoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>;
          };
          createMany: {
            args: Prisma.grupoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.grupoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>[];
          };
          delete: {
            args: Prisma.grupoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>;
          };
          update: {
            args: Prisma.grupoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>;
          };
          deleteMany: {
            args: Prisma.grupoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.grupoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.grupoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>[];
          };
          upsert: {
            args: Prisma.grupoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$grupoPayload>;
          };
          aggregate: {
            args: Prisma.GrupoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGrupo>;
          };
          groupBy: {
            args: Prisma.grupoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GrupoGroupByOutputType>[];
          };
          count: {
            args: Prisma.grupoCountArgs<ExtArgs>;
            result: $Utils.Optional<GrupoCountAggregateOutputType> | number;
          };
        };
      };
      histchamado: {
        payload: Prisma.$histchamadoPayload<ExtArgs>;
        fields: Prisma.histchamadoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.histchamadoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.histchamadoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>;
          };
          findFirst: {
            args: Prisma.histchamadoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.histchamadoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>;
          };
          findMany: {
            args: Prisma.histchamadoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>[];
          };
          create: {
            args: Prisma.histchamadoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>;
          };
          createMany: {
            args: Prisma.histchamadoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.histchamadoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>[];
          };
          delete: {
            args: Prisma.histchamadoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>;
          };
          update: {
            args: Prisma.histchamadoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>;
          };
          deleteMany: {
            args: Prisma.histchamadoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.histchamadoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.histchamadoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>[];
          };
          upsert: {
            args: Prisma.histchamadoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$histchamadoPayload>;
          };
          aggregate: {
            args: Prisma.HistchamadoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateHistchamado>;
          };
          groupBy: {
            args: Prisma.histchamadoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<HistchamadoGroupByOutputType>[];
          };
          count: {
            args: Prisma.histchamadoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<HistchamadoCountAggregateOutputType>
              | number;
          };
        };
      };
      itavaliado: {
        payload: Prisma.$itavaliadoPayload<ExtArgs>;
        fields: Prisma.itavaliadoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.itavaliadoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.itavaliadoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>;
          };
          findFirst: {
            args: Prisma.itavaliadoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.itavaliadoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>;
          };
          findMany: {
            args: Prisma.itavaliadoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>[];
          };
          create: {
            args: Prisma.itavaliadoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>;
          };
          createMany: {
            args: Prisma.itavaliadoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.itavaliadoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>[];
          };
          delete: {
            args: Prisma.itavaliadoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>;
          };
          update: {
            args: Prisma.itavaliadoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>;
          };
          deleteMany: {
            args: Prisma.itavaliadoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.itavaliadoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.itavaliadoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>[];
          };
          upsert: {
            args: Prisma.itavaliadoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itavaliadoPayload>;
          };
          aggregate: {
            args: Prisma.ItavaliadoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateItavaliado>;
          };
          groupBy: {
            args: Prisma.itavaliadoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ItavaliadoGroupByOutputType>[];
          };
          count: {
            args: Prisma.itavaliadoCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ItavaliadoCountAggregateOutputType>
              | number;
          };
        };
      };
      itmatriz: {
        payload: Prisma.$itmatrizPayload<ExtArgs>;
        fields: Prisma.itmatrizFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.itmatrizFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.itmatrizFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>;
          };
          findFirst: {
            args: Prisma.itmatrizFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.itmatrizFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>;
          };
          findMany: {
            args: Prisma.itmatrizFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>[];
          };
          create: {
            args: Prisma.itmatrizCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>;
          };
          createMany: {
            args: Prisma.itmatrizCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.itmatrizCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>[];
          };
          delete: {
            args: Prisma.itmatrizDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>;
          };
          update: {
            args: Prisma.itmatrizUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>;
          };
          deleteMany: {
            args: Prisma.itmatrizDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.itmatrizUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.itmatrizUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>[];
          };
          upsert: {
            args: Prisma.itmatrizUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$itmatrizPayload>;
          };
          aggregate: {
            args: Prisma.ItmatrizAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateItmatriz>;
          };
          groupBy: {
            args: Prisma.itmatrizGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ItmatrizGroupByOutputType>[];
          };
          count: {
            args: Prisma.itmatrizCountArgs<ExtArgs>;
            result: $Utils.Optional<ItmatrizCountAggregateOutputType> | number;
          };
        };
      };
      layout: {
        payload: Prisma.$layoutPayload<ExtArgs>;
        fields: Prisma.layoutFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.layoutFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.layoutFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>;
          };
          findFirst: {
            args: Prisma.layoutFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.layoutFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>;
          };
          findMany: {
            args: Prisma.layoutFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>[];
          };
          create: {
            args: Prisma.layoutCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>;
          };
          createMany: {
            args: Prisma.layoutCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.layoutCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>[];
          };
          delete: {
            args: Prisma.layoutDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>;
          };
          update: {
            args: Prisma.layoutUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>;
          };
          deleteMany: {
            args: Prisma.layoutDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.layoutUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.layoutUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>[];
          };
          upsert: {
            args: Prisma.layoutUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$layoutPayload>;
          };
          aggregate: {
            args: Prisma.LayoutAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLayout>;
          };
          groupBy: {
            args: Prisma.layoutGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LayoutGroupByOutputType>[];
          };
          count: {
            args: Prisma.layoutCountArgs<ExtArgs>;
            result: $Utils.Optional<LayoutCountAggregateOutputType> | number;
          };
        };
      };
      lista: {
        payload: Prisma.$listaPayload<ExtArgs>;
        fields: Prisma.listaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.listaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.listaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>;
          };
          findFirst: {
            args: Prisma.listaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.listaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>;
          };
          findMany: {
            args: Prisma.listaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>[];
          };
          create: {
            args: Prisma.listaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>;
          };
          createMany: {
            args: Prisma.listaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.listaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>[];
          };
          delete: {
            args: Prisma.listaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>;
          };
          update: {
            args: Prisma.listaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>;
          };
          deleteMany: {
            args: Prisma.listaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.listaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.listaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>[];
          };
          upsert: {
            args: Prisma.listaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$listaPayload>;
          };
          aggregate: {
            args: Prisma.ListaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLista>;
          };
          groupBy: {
            args: Prisma.listaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ListaGroupByOutputType>[];
          };
          count: {
            args: Prisma.listaCountArgs<ExtArgs>;
            result: $Utils.Optional<ListaCountAggregateOutputType> | number;
          };
        };
      };
      matriz: {
        payload: Prisma.$matrizPayload<ExtArgs>;
        fields: Prisma.matrizFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.matrizFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.matrizFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>;
          };
          findFirst: {
            args: Prisma.matrizFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.matrizFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>;
          };
          findMany: {
            args: Prisma.matrizFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>[];
          };
          create: {
            args: Prisma.matrizCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>;
          };
          createMany: {
            args: Prisma.matrizCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.matrizCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>[];
          };
          delete: {
            args: Prisma.matrizDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>;
          };
          update: {
            args: Prisma.matrizUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>;
          };
          deleteMany: {
            args: Prisma.matrizDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.matrizUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.matrizUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>[];
          };
          upsert: {
            args: Prisma.matrizUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$matrizPayload>;
          };
          aggregate: {
            args: Prisma.MatrizAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMatriz>;
          };
          groupBy: {
            args: Prisma.matrizGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MatrizGroupByOutputType>[];
          };
          count: {
            args: Prisma.matrizCountArgs<ExtArgs>;
            result: $Utils.Optional<MatrizCountAggregateOutputType> | number;
          };
        };
      };
      mensagem: {
        payload: Prisma.$mensagemPayload<ExtArgs>;
        fields: Prisma.mensagemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.mensagemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.mensagemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>;
          };
          findFirst: {
            args: Prisma.mensagemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.mensagemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>;
          };
          findMany: {
            args: Prisma.mensagemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>[];
          };
          create: {
            args: Prisma.mensagemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>;
          };
          createMany: {
            args: Prisma.mensagemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.mensagemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>[];
          };
          delete: {
            args: Prisma.mensagemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>;
          };
          update: {
            args: Prisma.mensagemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>;
          };
          deleteMany: {
            args: Prisma.mensagemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.mensagemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.mensagemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>[];
          };
          upsert: {
            args: Prisma.mensagemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$mensagemPayload>;
          };
          aggregate: {
            args: Prisma.MensagemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMensagem>;
          };
          groupBy: {
            args: Prisma.mensagemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MensagemGroupByOutputType>[];
          };
          count: {
            args: Prisma.mensagemCountArgs<ExtArgs>;
            result: $Utils.Optional<MensagemCountAggregateOutputType> | number;
          };
        };
      };
      meta: {
        payload: Prisma.$metaPayload<ExtArgs>;
        fields: Prisma.metaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.metaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.metaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>;
          };
          findFirst: {
            args: Prisma.metaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.metaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>;
          };
          findMany: {
            args: Prisma.metaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>[];
          };
          create: {
            args: Prisma.metaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>;
          };
          createMany: {
            args: Prisma.metaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.metaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>[];
          };
          delete: {
            args: Prisma.metaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>;
          };
          update: {
            args: Prisma.metaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>;
          };
          deleteMany: {
            args: Prisma.metaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.metaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.metaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>[];
          };
          upsert: {
            args: Prisma.metaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$metaPayload>;
          };
          aggregate: {
            args: Prisma.MetaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMeta>;
          };
          groupBy: {
            args: Prisma.metaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MetaGroupByOutputType>[];
          };
          count: {
            args: Prisma.metaCountArgs<ExtArgs>;
            result: $Utils.Optional<MetaCountAggregateOutputType> | number;
          };
        };
      };
      modulo_sistema: {
        payload: Prisma.$modulo_sistemaPayload<ExtArgs>;
        fields: Prisma.modulo_sistemaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.modulo_sistemaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.modulo_sistemaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>;
          };
          findFirst: {
            args: Prisma.modulo_sistemaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.modulo_sistemaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>;
          };
          findMany: {
            args: Prisma.modulo_sistemaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>[];
          };
          create: {
            args: Prisma.modulo_sistemaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>;
          };
          createMany: {
            args: Prisma.modulo_sistemaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.modulo_sistemaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>[];
          };
          delete: {
            args: Prisma.modulo_sistemaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>;
          };
          update: {
            args: Prisma.modulo_sistemaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>;
          };
          deleteMany: {
            args: Prisma.modulo_sistemaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.modulo_sistemaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.modulo_sistemaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>[];
          };
          upsert: {
            args: Prisma.modulo_sistemaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$modulo_sistemaPayload>;
          };
          aggregate: {
            args: Prisma.Modulo_sistemaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateModulo_sistema>;
          };
          groupBy: {
            args: Prisma.modulo_sistemaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Modulo_sistemaGroupByOutputType>[];
          };
          count: {
            args: Prisma.modulo_sistemaCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Modulo_sistemaCountAggregateOutputType>
              | number;
          };
        };
      };
      nfse: {
        payload: Prisma.$nfsePayload<ExtArgs>;
        fields: Prisma.nfseFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.nfseFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.nfseFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>;
          };
          findFirst: {
            args: Prisma.nfseFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.nfseFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>;
          };
          findMany: {
            args: Prisma.nfseFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>[];
          };
          create: {
            args: Prisma.nfseCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>;
          };
          createMany: {
            args: Prisma.nfseCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.nfseCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>[];
          };
          delete: {
            args: Prisma.nfseDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>;
          };
          update: {
            args: Prisma.nfseUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>;
          };
          deleteMany: {
            args: Prisma.nfseDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.nfseUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.nfseUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>[];
          };
          upsert: {
            args: Prisma.nfseUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nfsePayload>;
          };
          aggregate: {
            args: Prisma.NfseAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNfse>;
          };
          groupBy: {
            args: Prisma.nfseGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NfseGroupByOutputType>[];
          };
          count: {
            args: Prisma.nfseCountArgs<ExtArgs>;
            result: $Utils.Optional<NfseCountAggregateOutputType> | number;
          };
        };
      };
      nivel: {
        payload: Prisma.$nivelPayload<ExtArgs>;
        fields: Prisma.nivelFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.nivelFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.nivelFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>;
          };
          findFirst: {
            args: Prisma.nivelFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.nivelFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>;
          };
          findMany: {
            args: Prisma.nivelFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>[];
          };
          create: {
            args: Prisma.nivelCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>;
          };
          createMany: {
            args: Prisma.nivelCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.nivelCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>[];
          };
          delete: {
            args: Prisma.nivelDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>;
          };
          update: {
            args: Prisma.nivelUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>;
          };
          deleteMany: {
            args: Prisma.nivelDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.nivelUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.nivelUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>[];
          };
          upsert: {
            args: Prisma.nivelUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$nivelPayload>;
          };
          aggregate: {
            args: Prisma.NivelAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNivel>;
          };
          groupBy: {
            args: Prisma.nivelGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NivelGroupByOutputType>[];
          };
          count: {
            args: Prisma.nivelCountArgs<ExtArgs>;
            result: $Utils.Optional<NivelCountAggregateOutputType> | number;
          };
        };
      };
      os: {
        payload: Prisma.$osPayload<ExtArgs>;
        fields: Prisma.osFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.osFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.osFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>;
          };
          findFirst: {
            args: Prisma.osFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.osFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>;
          };
          findMany: {
            args: Prisma.osFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>[];
          };
          create: {
            args: Prisma.osCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>;
          };
          createMany: {
            args: Prisma.osCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.osCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>[];
          };
          delete: {
            args: Prisma.osDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>;
          };
          update: {
            args: Prisma.osUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>;
          };
          deleteMany: {
            args: Prisma.osDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.osUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.osUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>[];
          };
          upsert: {
            args: Prisma.osUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$osPayload>;
          };
          aggregate: {
            args: Prisma.OsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOs>;
          };
          groupBy: {
            args: Prisma.osGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OsGroupByOutputType>[];
          };
          count: {
            args: Prisma.osCountArgs<ExtArgs>;
            result: $Utils.Optional<OsCountAggregateOutputType> | number;
          };
        };
      };
      parametros: {
        payload: Prisma.$parametrosPayload<ExtArgs>;
        fields: Prisma.parametrosFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.parametrosFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.parametrosFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>;
          };
          findFirst: {
            args: Prisma.parametrosFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.parametrosFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>;
          };
          findMany: {
            args: Prisma.parametrosFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>[];
          };
          create: {
            args: Prisma.parametrosCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>;
          };
          createMany: {
            args: Prisma.parametrosCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.parametrosCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>[];
          };
          delete: {
            args: Prisma.parametrosDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>;
          };
          update: {
            args: Prisma.parametrosUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>;
          };
          deleteMany: {
            args: Prisma.parametrosDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.parametrosUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.parametrosUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>[];
          };
          upsert: {
            args: Prisma.parametrosUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parametrosPayload>;
          };
          aggregate: {
            args: Prisma.ParametrosAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateParametros>;
          };
          groupBy: {
            args: Prisma.parametrosGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ParametrosGroupByOutputType>[];
          };
          count: {
            args: Prisma.parametrosCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ParametrosCountAggregateOutputType>
              | number;
          };
        };
      };
      parcela: {
        payload: Prisma.$parcelaPayload<ExtArgs>;
        fields: Prisma.parcelaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.parcelaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.parcelaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>;
          };
          findFirst: {
            args: Prisma.parcelaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.parcelaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>;
          };
          findMany: {
            args: Prisma.parcelaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>[];
          };
          create: {
            args: Prisma.parcelaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>;
          };
          createMany: {
            args: Prisma.parcelaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.parcelaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>[];
          };
          delete: {
            args: Prisma.parcelaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>;
          };
          update: {
            args: Prisma.parcelaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>;
          };
          deleteMany: {
            args: Prisma.parcelaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.parcelaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.parcelaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>[];
          };
          upsert: {
            args: Prisma.parcelaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$parcelaPayload>;
          };
          aggregate: {
            args: Prisma.ParcelaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateParcela>;
          };
          groupBy: {
            args: Prisma.parcelaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ParcelaGroupByOutputType>[];
          };
          count: {
            args: Prisma.parcelaCountArgs<ExtArgs>;
            result: $Utils.Optional<ParcelaCountAggregateOutputType> | number;
          };
        };
      };
      pauta: {
        payload: Prisma.$pautaPayload<ExtArgs>;
        fields: Prisma.pautaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.pautaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.pautaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>;
          };
          findFirst: {
            args: Prisma.pautaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.pautaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>;
          };
          findMany: {
            args: Prisma.pautaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>[];
          };
          create: {
            args: Prisma.pautaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>;
          };
          createMany: {
            args: Prisma.pautaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.pautaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>[];
          };
          delete: {
            args: Prisma.pautaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>;
          };
          update: {
            args: Prisma.pautaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>;
          };
          deleteMany: {
            args: Prisma.pautaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.pautaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.pautaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>[];
          };
          upsert: {
            args: Prisma.pautaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pautaPayload>;
          };
          aggregate: {
            args: Prisma.PautaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePauta>;
          };
          groupBy: {
            args: Prisma.pautaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PautaGroupByOutputType>[];
          };
          count: {
            args: Prisma.pautaCountArgs<ExtArgs>;
            result: $Utils.Optional<PautaCountAggregateOutputType> | number;
          };
        };
      };
      ponto: {
        payload: Prisma.$pontoPayload<ExtArgs>;
        fields: Prisma.pontoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.pontoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.pontoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>;
          };
          findFirst: {
            args: Prisma.pontoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.pontoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>;
          };
          findMany: {
            args: Prisma.pontoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>[];
          };
          create: {
            args: Prisma.pontoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>;
          };
          createMany: {
            args: Prisma.pontoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.pontoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>[];
          };
          delete: {
            args: Prisma.pontoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>;
          };
          update: {
            args: Prisma.pontoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>;
          };
          deleteMany: {
            args: Prisma.pontoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.pontoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.pontoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>[];
          };
          upsert: {
            args: Prisma.pontoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$pontoPayload>;
          };
          aggregate: {
            args: Prisma.PontoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePonto>;
          };
          groupBy: {
            args: Prisma.pontoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PontoGroupByOutputType>[];
          };
          count: {
            args: Prisma.pontoCountArgs<ExtArgs>;
            result: $Utils.Optional<PontoCountAggregateOutputType> | number;
          };
        };
      };
      projeto: {
        payload: Prisma.$projetoPayload<ExtArgs>;
        fields: Prisma.projetoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.projetoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.projetoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>;
          };
          findFirst: {
            args: Prisma.projetoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.projetoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>;
          };
          findMany: {
            args: Prisma.projetoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>[];
          };
          create: {
            args: Prisma.projetoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>;
          };
          createMany: {
            args: Prisma.projetoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.projetoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>[];
          };
          delete: {
            args: Prisma.projetoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>;
          };
          update: {
            args: Prisma.projetoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>;
          };
          deleteMany: {
            args: Prisma.projetoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.projetoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.projetoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>[];
          };
          upsert: {
            args: Prisma.projetoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>;
          };
          aggregate: {
            args: Prisma.ProjetoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProjeto>;
          };
          groupBy: {
            args: Prisma.projetoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProjetoGroupByOutputType>[];
          };
          count: {
            args: Prisma.projetoCountArgs<ExtArgs>;
            result: $Utils.Optional<ProjetoCountAggregateOutputType> | number;
          };
        };
      };
      recurso: {
        payload: Prisma.$recursoPayload<ExtArgs>;
        fields: Prisma.recursoFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.recursoFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.recursoFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>;
          };
          findFirst: {
            args: Prisma.recursoFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.recursoFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>;
          };
          findMany: {
            args: Prisma.recursoFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>[];
          };
          create: {
            args: Prisma.recursoCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>;
          };
          createMany: {
            args: Prisma.recursoCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.recursoCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>[];
          };
          delete: {
            args: Prisma.recursoDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>;
          };
          update: {
            args: Prisma.recursoUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>;
          };
          deleteMany: {
            args: Prisma.recursoDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.recursoUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.recursoUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>[];
          };
          upsert: {
            args: Prisma.recursoUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>;
          };
          aggregate: {
            args: Prisma.RecursoAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRecurso>;
          };
          groupBy: {
            args: Prisma.recursoGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RecursoGroupByOutputType>[];
          };
          count: {
            args: Prisma.recursoCountArgs<ExtArgs>;
            result: $Utils.Optional<RecursoCountAggregateOutputType> | number;
          };
        };
      };
      rescon: {
        payload: Prisma.$resconPayload<ExtArgs>;
        fields: Prisma.resconFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.resconFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.resconFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>;
          };
          findFirst: {
            args: Prisma.resconFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.resconFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>;
          };
          findMany: {
            args: Prisma.resconFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>[];
          };
          create: {
            args: Prisma.resconCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>;
          };
          createMany: {
            args: Prisma.resconCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.resconCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>[];
          };
          delete: {
            args: Prisma.resconDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>;
          };
          update: {
            args: Prisma.resconUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>;
          };
          deleteMany: {
            args: Prisma.resconDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.resconUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.resconUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>[];
          };
          upsert: {
            args: Prisma.resconUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$resconPayload>;
          };
          aggregate: {
            args: Prisma.ResconAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRescon>;
          };
          groupBy: {
            args: Prisma.resconGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ResconGroupByOutputType>[];
          };
          count: {
            args: Prisma.resconCountArgs<ExtArgs>;
            result: $Utils.Optional<ResconCountAggregateOutputType> | number;
          };
        };
      };
      status: {
        payload: Prisma.$statusPayload<ExtArgs>;
        fields: Prisma.statusFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.statusFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.statusFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          findFirst: {
            args: Prisma.statusFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.statusFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          findMany: {
            args: Prisma.statusFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[];
          };
          create: {
            args: Prisma.statusCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          createMany: {
            args: Prisma.statusCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.statusCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[];
          };
          delete: {
            args: Prisma.statusDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          update: {
            args: Prisma.statusUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          deleteMany: {
            args: Prisma.statusDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.statusUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.statusUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[];
          };
          upsert: {
            args: Prisma.statusUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          aggregate: {
            args: Prisma.StatusAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStatus>;
          };
          groupBy: {
            args: Prisma.statusGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StatusGroupByOutputType>[];
          };
          count: {
            args: Prisma.statusCountArgs<ExtArgs>;
            result: $Utils.Optional<StatusCountAggregateOutputType> | number;
          };
        };
      };
      tarefa: {
        payload: Prisma.$tarefaPayload<ExtArgs>;
        fields: Prisma.tarefaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.tarefaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.tarefaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>;
          };
          findFirst: {
            args: Prisma.tarefaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.tarefaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>;
          };
          findMany: {
            args: Prisma.tarefaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>[];
          };
          create: {
            args: Prisma.tarefaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>;
          };
          createMany: {
            args: Prisma.tarefaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.tarefaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>[];
          };
          delete: {
            args: Prisma.tarefaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>;
          };
          update: {
            args: Prisma.tarefaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>;
          };
          deleteMany: {
            args: Prisma.tarefaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.tarefaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.tarefaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>[];
          };
          upsert: {
            args: Prisma.tarefaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>;
          };
          aggregate: {
            args: Prisma.TarefaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTarefa>;
          };
          groupBy: {
            args: Prisma.tarefaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TarefaGroupByOutputType>[];
          };
          count: {
            args: Prisma.tarefaCountArgs<ExtArgs>;
            result: $Utils.Optional<TarefaCountAggregateOutputType> | number;
          };
        };
      };
      tela_sistema: {
        payload: Prisma.$tela_sistemaPayload<ExtArgs>;
        fields: Prisma.tela_sistemaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.tela_sistemaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.tela_sistemaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>;
          };
          findFirst: {
            args: Prisma.tela_sistemaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.tela_sistemaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>;
          };
          findMany: {
            args: Prisma.tela_sistemaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>[];
          };
          create: {
            args: Prisma.tela_sistemaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>;
          };
          createMany: {
            args: Prisma.tela_sistemaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.tela_sistemaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>[];
          };
          delete: {
            args: Prisma.tela_sistemaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>;
          };
          update: {
            args: Prisma.tela_sistemaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>;
          };
          deleteMany: {
            args: Prisma.tela_sistemaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.tela_sistemaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.tela_sistemaUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>[];
          };
          upsert: {
            args: Prisma.tela_sistemaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tela_sistemaPayload>;
          };
          aggregate: {
            args: Prisma.Tela_sistemaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTela_sistema>;
          };
          groupBy: {
            args: Prisma.tela_sistemaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Tela_sistemaGroupByOutputType>[];
          };
          count: {
            args: Prisma.tela_sistemaCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<Tela_sistemaCountAggregateOutputType>
              | number;
          };
        };
      };
      telefone: {
        payload: Prisma.$telefonePayload<ExtArgs>;
        fields: Prisma.telefoneFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.telefoneFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.telefoneFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>;
          };
          findFirst: {
            args: Prisma.telefoneFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.telefoneFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>;
          };
          findMany: {
            args: Prisma.telefoneFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>[];
          };
          create: {
            args: Prisma.telefoneCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>;
          };
          createMany: {
            args: Prisma.telefoneCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.telefoneCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>[];
          };
          delete: {
            args: Prisma.telefoneDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>;
          };
          update: {
            args: Prisma.telefoneUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>;
          };
          deleteMany: {
            args: Prisma.telefoneDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.telefoneUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.telefoneUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>[];
          };
          upsert: {
            args: Prisma.telefoneUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$telefonePayload>;
          };
          aggregate: {
            args: Prisma.TelefoneAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTelefone>;
          };
          groupBy: {
            args: Prisma.telefoneGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TelefoneGroupByOutputType>[];
          };
          count: {
            args: Prisma.telefoneCountArgs<ExtArgs>;
            result: $Utils.Optional<TelefoneCountAggregateOutputType> | number;
          };
        };
      };
      tipotrf: {
        payload: Prisma.$tipotrfPayload<ExtArgs>;
        fields: Prisma.tipotrfFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.tipotrfFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.tipotrfFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>;
          };
          findFirst: {
            args: Prisma.tipotrfFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.tipotrfFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>;
          };
          findMany: {
            args: Prisma.tipotrfFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>[];
          };
          create: {
            args: Prisma.tipotrfCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>;
          };
          createMany: {
            args: Prisma.tipotrfCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.tipotrfCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>[];
          };
          delete: {
            args: Prisma.tipotrfDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>;
          };
          update: {
            args: Prisma.tipotrfUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>;
          };
          deleteMany: {
            args: Prisma.tipotrfDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.tipotrfUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.tipotrfUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>[];
          };
          upsert: {
            args: Prisma.tipotrfUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tipotrfPayload>;
          };
          aggregate: {
            args: Prisma.TipotrfAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTipotrf>;
          };
          groupBy: {
            args: Prisma.tipotrfGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TipotrfGroupByOutputType>[];
          };
          count: {
            args: Prisma.tipotrfCountArgs<ExtArgs>;
            result: $Utils.Optional<TipotrfCountAggregateOutputType> | number;
          };
        };
      };
      tpdesp: {
        payload: Prisma.$tpdespPayload<ExtArgs>;
        fields: Prisma.tpdespFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.tpdespFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.tpdespFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>;
          };
          findFirst: {
            args: Prisma.tpdespFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.tpdespFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>;
          };
          findMany: {
            args: Prisma.tpdespFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>[];
          };
          create: {
            args: Prisma.tpdespCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>;
          };
          createMany: {
            args: Prisma.tpdespCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.tpdespCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>[];
          };
          delete: {
            args: Prisma.tpdespDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>;
          };
          update: {
            args: Prisma.tpdespUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>;
          };
          deleteMany: {
            args: Prisma.tpdespDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.tpdespUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.tpdespUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>[];
          };
          upsert: {
            args: Prisma.tpdespUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$tpdespPayload>;
          };
          aggregate: {
            args: Prisma.TpdespAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTpdesp>;
          };
          groupBy: {
            args: Prisma.tpdespGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TpdespGroupByOutputType>[];
          };
          count: {
            args: Prisma.tpdespCountArgs<ExtArgs>;
            result: $Utils.Optional<TpdespCountAggregateOutputType> | number;
          };
        };
      };
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>;
        fields: Prisma.usuarioFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>;
          };
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>;
          };
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[];
          };
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>;
          };
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.usuarioCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[];
          };
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>;
          };
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>;
          };
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.usuarioUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[];
          };
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>;
          };
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUsuario>;
          };
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UsuarioGroupByOutputType>[];
          };
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>;
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number;
          };
        };
      };
      valor: {
        payload: Prisma.$valorPayload<ExtArgs>;
        fields: Prisma.valorFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.valorFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.valorFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>;
          };
          findFirst: {
            args: Prisma.valorFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.valorFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>;
          };
          findMany: {
            args: Prisma.valorFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>[];
          };
          create: {
            args: Prisma.valorCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>;
          };
          createMany: {
            args: Prisma.valorCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.valorCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>[];
          };
          delete: {
            args: Prisma.valorDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>;
          };
          update: {
            args: Prisma.valorUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>;
          };
          deleteMany: {
            args: Prisma.valorDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.valorUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.valorUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>[];
          };
          upsert: {
            args: Prisma.valorUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$valorPayload>;
          };
          aggregate: {
            args: Prisma.ValorAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateValor>;
          };
          groupBy: {
            args: Prisma.valorGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ValorGroupByOutputType>[];
          };
          count: {
            args: Prisma.valorCountArgs<ExtArgs>;
            result: $Utils.Optional<ValorCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    acesso_sistema?: acesso_sistemaOmit;
    agenrec?: agenrecOmit;
    area?: areaOmit;
    avaliacao?: avaliacaoOmit;
    avaliado?: avaliadoOmit;
    chamado?: chamadoOmit;
    cidade?: cidadeOmit;
    classificacao?: classificacaoOmit;
    cliente?: clienteOmit;
    composicao?: composicaoOmit;
    contato?: contatoOmit;
    ctiss?: ctissOmit;
    despesa?: despesaOmit;
    desprec?: desprecOmit;
    empresa?: empresaOmit;
    fase?: faseOmit;
    fatdes?: fatdesOmit;
    fatfun?: fatfunOmit;
    fatrec?: fatrecOmit;
    fatura?: faturaOmit;
    faturamento?: faturamentoOmit;
    grupo?: grupoOmit;
    histchamado?: histchamadoOmit;
    itavaliado?: itavaliadoOmit;
    itmatriz?: itmatrizOmit;
    layout?: layoutOmit;
    lista?: listaOmit;
    matriz?: matrizOmit;
    mensagem?: mensagemOmit;
    meta?: metaOmit;
    modulo_sistema?: modulo_sistemaOmit;
    nfse?: nfseOmit;
    nivel?: nivelOmit;
    os?: osOmit;
    parametros?: parametrosOmit;
    parcela?: parcelaOmit;
    pauta?: pautaOmit;
    ponto?: pontoOmit;
    projeto?: projetoOmit;
    recurso?: recursoOmit;
    rescon?: resconOmit;
    status?: statusOmit;
    tarefa?: tarefaOmit;
    tela_sistema?: tela_sistemaOmit;
    telefone?: telefoneOmit;
    tipotrf?: tipotrfOmit;
    tpdesp?: tpdespOmit;
    usuario?: usuarioOmit;
    valor?: valorOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T['emit'] extends 'event'
        ? T['level']
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    meta: number;
    tarefa: number;
  };

  export type AreaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meta?: boolean | AreaCountOutputTypeCountMetaArgs;
    tarefa?: boolean | AreaCountOutputTypeCountTarefaArgs;
  };

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountMetaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: metaWhereInput;
  };

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountTarefaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tarefaWhereInput;
  };

  /**
   * Count Type AvaliacaoCountOutputType
   */

  export type AvaliacaoCountOutputType = {
    avaliado: number;
  };

  export type AvaliacaoCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliado?: boolean | AvaliacaoCountOutputTypeCountAvaliadoArgs;
  };

  // Custom InputTypes
  /**
   * AvaliacaoCountOutputType without action
   */
  export type AvaliacaoCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AvaliacaoCountOutputType
     */
    select?: AvaliacaoCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AvaliacaoCountOutputType without action
   */
  export type AvaliacaoCountOutputTypeCountAvaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: avaliadoWhereInput;
  };

  /**
   * Count Type AvaliadoCountOutputType
   */

  export type AvaliadoCountOutputType = {
    itavaliado: number;
  };

  export type AvaliadoCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    itavaliado?: boolean | AvaliadoCountOutputTypeCountItavaliadoArgs;
  };

  // Custom InputTypes
  /**
   * AvaliadoCountOutputType without action
   */
  export type AvaliadoCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AvaliadoCountOutputType
     */
    select?: AvaliadoCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AvaliadoCountOutputType without action
   */
  export type AvaliadoCountOutputTypeCountItavaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: itavaliadoWhereInput;
  };

  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    chamados: number;
    fatrec: number;
    projeto: number;
  };

  export type ClienteCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    chamados?: boolean | ClienteCountOutputTypeCountChamadosArgs;
    fatrec?: boolean | ClienteCountOutputTypeCountFatrecArgs;
    projeto?: boolean | ClienteCountOutputTypeCountProjetoArgs;
  };

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountChamadosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: chamadoWhereInput;
  };

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountFatrecArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: fatrecWhereInput;
  };

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountProjetoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: projetoWhereInput;
  };

  /**
   * Count Type FaseCountOutputType
   */

  export type FaseCountOutputType = {
    meta: number;
    tarefa: number;
  };

  export type FaseCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meta?: boolean | FaseCountOutputTypeCountMetaArgs;
    tarefa?: boolean | FaseCountOutputTypeCountTarefaArgs;
  };

  // Custom InputTypes
  /**
   * FaseCountOutputType without action
   */
  export type FaseCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FaseCountOutputType
     */
    select?: FaseCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FaseCountOutputType without action
   */
  export type FaseCountOutputTypeCountMetaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: metaWhereInput;
  };

  /**
   * FaseCountOutputType without action
   */
  export type FaseCountOutputTypeCountTarefaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tarefaWhereInput;
  };

  /**
   * Count Type ItmatrizCountOutputType
   */

  export type ItmatrizCountOutputType = {
    itavaliado: number;
  };

  export type ItmatrizCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    itavaliado?: boolean | ItmatrizCountOutputTypeCountItavaliadoArgs;
  };

  // Custom InputTypes
  /**
   * ItmatrizCountOutputType without action
   */
  export type ItmatrizCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ItmatrizCountOutputType
     */
    select?: ItmatrizCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ItmatrizCountOutputType without action
   */
  export type ItmatrizCountOutputTypeCountItavaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: itavaliadoWhereInput;
  };

  /**
   * Count Type MatrizCountOutputType
   */

  export type MatrizCountOutputType = {
    itmatriz: number;
  };

  export type MatrizCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    itmatriz?: boolean | MatrizCountOutputTypeCountItmatrizArgs;
  };

  // Custom InputTypes
  /**
   * MatrizCountOutputType without action
   */
  export type MatrizCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MatrizCountOutputType
     */
    select?: MatrizCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * MatrizCountOutputType without action
   */
  export type MatrizCountOutputTypeCountItmatrizArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: itmatrizWhereInput;
  };

  /**
   * Count Type Modulo_sistemaCountOutputType
   */

  export type Modulo_sistemaCountOutputType = {
    acesso_sistema: number;
    tela_sistema: number;
  };

  export type Modulo_sistemaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acesso_sistema?:
      | boolean
      | Modulo_sistemaCountOutputTypeCountAcesso_sistemaArgs;
    tela_sistema?: boolean | Modulo_sistemaCountOutputTypeCountTela_sistemaArgs;
  };

  // Custom InputTypes
  /**
   * Modulo_sistemaCountOutputType without action
   */
  export type Modulo_sistemaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Modulo_sistemaCountOutputType
     */
    select?: Modulo_sistemaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * Modulo_sistemaCountOutputType without action
   */
  export type Modulo_sistemaCountOutputTypeCountAcesso_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: acesso_sistemaWhereInput;
  };

  /**
   * Modulo_sistemaCountOutputType without action
   */
  export type Modulo_sistemaCountOutputTypeCountTela_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tela_sistemaWhereInput;
  };

  /**
   * Count Type NivelCountOutputType
   */

  export type NivelCountOutputType = {
    recurso: number;
  };

  export type NivelCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    recurso?: boolean | NivelCountOutputTypeCountRecursoArgs;
  };

  // Custom InputTypes
  /**
   * NivelCountOutputType without action
   */
  export type NivelCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the NivelCountOutputType
     */
    select?: NivelCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * NivelCountOutputType without action
   */
  export type NivelCountOutputTypeCountRecursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: recursoWhereInput;
  };

  /**
   * Count Type ProjetoCountOutputType
   */

  export type ProjetoCountOutputType = {
    avaliacao: number;
    meta: number;
    tarefa: number;
    valor: number;
  };

  export type ProjetoCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliacao?: boolean | ProjetoCountOutputTypeCountAvaliacaoArgs;
    meta?: boolean | ProjetoCountOutputTypeCountMetaArgs;
    tarefa?: boolean | ProjetoCountOutputTypeCountTarefaArgs;
    valor?: boolean | ProjetoCountOutputTypeCountValorArgs;
  };

  // Custom InputTypes
  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProjetoCountOutputType
     */
    select?: ProjetoCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountAvaliacaoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: avaliacaoWhereInput;
  };

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountMetaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: metaWhereInput;
  };

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountTarefaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tarefaWhereInput;
  };

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountValorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: valorWhereInput;
  };

  /**
   * Count Type RecursoCountOutputType
   */

  export type RecursoCountOutputType = {
    agenrec: number;
    avaliado: number;
    projeto: number;
    tarefa_tarefa_codrecresp_tarefaTorecurso: number;
    tarefa_tarefa_codrec_tarefaTorecurso: number;
    chamado: number;
  };

  export type RecursoCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    agenrec?: boolean | RecursoCountOutputTypeCountAgenrecArgs;
    avaliado?: boolean | RecursoCountOutputTypeCountAvaliadoArgs;
    projeto?: boolean | RecursoCountOutputTypeCountProjetoArgs;
    tarefa_tarefa_codrecresp_tarefaTorecurso?:
      | boolean
      | RecursoCountOutputTypeCountTarefa_tarefa_codrecresp_tarefaTorecursoArgs;
    tarefa_tarefa_codrec_tarefaTorecurso?:
      | boolean
      | RecursoCountOutputTypeCountTarefa_tarefa_codrec_tarefaTorecursoArgs;
    chamado?: boolean | RecursoCountOutputTypeCountChamadoArgs;
  };

  // Custom InputTypes
  /**
   * RecursoCountOutputType without action
   */
  export type RecursoCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecursoCountOutputType
     */
    select?: RecursoCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RecursoCountOutputType without action
   */
  export type RecursoCountOutputTypeCountAgenrecArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: agenrecWhereInput;
  };

  /**
   * RecursoCountOutputType without action
   */
  export type RecursoCountOutputTypeCountAvaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: avaliadoWhereInput;
  };

  /**
   * RecursoCountOutputType without action
   */
  export type RecursoCountOutputTypeCountProjetoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: projetoWhereInput;
  };

  /**
   * RecursoCountOutputType without action
   */
  export type RecursoCountOutputTypeCountTarefa_tarefa_codrecresp_tarefaTorecursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tarefaWhereInput;
  };

  /**
   * RecursoCountOutputType without action
   */
  export type RecursoCountOutputTypeCountTarefa_tarefa_codrec_tarefaTorecursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tarefaWhereInput;
  };

  /**
   * RecursoCountOutputType without action
   */
  export type RecursoCountOutputTypeCountChamadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: chamadoWhereInput;
  };

  /**
   * Count Type TarefaCountOutputType
   */

  export type TarefaCountOutputType = {
    os: number;
  };

  export type TarefaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    os?: boolean | TarefaCountOutputTypeCountOsArgs;
  };

  // Custom InputTypes
  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TarefaCountOutputType
     */
    select?: TarefaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeCountOsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: osWhereInput;
  };

  /**
   * Count Type Tela_sistemaCountOutputType
   */

  export type Tela_sistemaCountOutputType = {
    acesso_sistema: number;
  };

  export type Tela_sistemaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acesso_sistema?:
      | boolean
      | Tela_sistemaCountOutputTypeCountAcesso_sistemaArgs;
  };

  // Custom InputTypes
  /**
   * Tela_sistemaCountOutputType without action
   */
  export type Tela_sistemaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Tela_sistemaCountOutputType
     */
    select?: Tela_sistemaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * Tela_sistemaCountOutputType without action
   */
  export type Tela_sistemaCountOutputTypeCountAcesso_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: acesso_sistemaWhereInput;
  };

  /**
   * Count Type TipotrfCountOutputType
   */

  export type TipotrfCountOutputType = {
    valor: number;
  };

  export type TipotrfCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    valor?: boolean | TipotrfCountOutputTypeCountValorArgs;
  };

  // Custom InputTypes
  /**
   * TipotrfCountOutputType without action
   */
  export type TipotrfCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TipotrfCountOutputType
     */
    select?: TipotrfCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TipotrfCountOutputType without action
   */
  export type TipotrfCountOutputTypeCountValorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: valorWhereInput;
  };

  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    acesso_sistema: number;
    recurso: number;
  };

  export type UsuarioCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acesso_sistema?: boolean | UsuarioCountOutputTypeCountAcesso_sistemaArgs;
    recurso?: boolean | UsuarioCountOutputTypeCountRecursoArgs;
  };

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAcesso_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: acesso_sistemaWhereInput;
  };

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRecursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: recursoWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model acesso_sistema
   */

  export type AggregateAcesso_sistema = {
    _count: Acesso_sistemaCountAggregateOutputType | null;
    _avg: Acesso_sistemaAvgAggregateOutputType | null;
    _sum: Acesso_sistemaSumAggregateOutputType | null;
    _min: Acesso_sistemaMinAggregateOutputType | null;
    _max: Acesso_sistemaMaxAggregateOutputType | null;
  };

  export type Acesso_sistemaAvgAggregateOutputType = {
    cod_usuario: number | null;
    cod_modulo: number | null;
    cod_tela: number | null;
  };

  export type Acesso_sistemaSumAggregateOutputType = {
    cod_usuario: number | null;
    cod_modulo: number | null;
    cod_tela: number | null;
  };

  export type Acesso_sistemaMinAggregateOutputType = {
    cod_usuario: number | null;
    cod_modulo: number | null;
    cod_tela: number | null;
    incluir: string | null;
    modificar: string | null;
    eliminar: string | null;
  };

  export type Acesso_sistemaMaxAggregateOutputType = {
    cod_usuario: number | null;
    cod_modulo: number | null;
    cod_tela: number | null;
    incluir: string | null;
    modificar: string | null;
    eliminar: string | null;
  };

  export type Acesso_sistemaCountAggregateOutputType = {
    cod_usuario: number;
    cod_modulo: number;
    cod_tela: number;
    incluir: number;
    modificar: number;
    eliminar: number;
    _all: number;
  };

  export type Acesso_sistemaAvgAggregateInputType = {
    cod_usuario?: true;
    cod_modulo?: true;
    cod_tela?: true;
  };

  export type Acesso_sistemaSumAggregateInputType = {
    cod_usuario?: true;
    cod_modulo?: true;
    cod_tela?: true;
  };

  export type Acesso_sistemaMinAggregateInputType = {
    cod_usuario?: true;
    cod_modulo?: true;
    cod_tela?: true;
    incluir?: true;
    modificar?: true;
    eliminar?: true;
  };

  export type Acesso_sistemaMaxAggregateInputType = {
    cod_usuario?: true;
    cod_modulo?: true;
    cod_tela?: true;
    incluir?: true;
    modificar?: true;
    eliminar?: true;
  };

  export type Acesso_sistemaCountAggregateInputType = {
    cod_usuario?: true;
    cod_modulo?: true;
    cod_tela?: true;
    incluir?: true;
    modificar?: true;
    eliminar?: true;
    _all?: true;
  };

  export type Acesso_sistemaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which acesso_sistema to aggregate.
     */
    where?: acesso_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of acesso_sistemas to fetch.
     */
    orderBy?:
      | acesso_sistemaOrderByWithRelationInput
      | acesso_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: acesso_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` acesso_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` acesso_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned acesso_sistemas
     **/
    _count?: true | Acesso_sistemaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Acesso_sistemaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Acesso_sistemaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Acesso_sistemaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Acesso_sistemaMaxAggregateInputType;
  };

  export type GetAcesso_sistemaAggregateType<
    T extends Acesso_sistemaAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAcesso_sistema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcesso_sistema[P]>
      : GetScalarType<T[P], AggregateAcesso_sistema[P]>;
  };

  export type acesso_sistemaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: acesso_sistemaWhereInput;
    orderBy?:
      | acesso_sistemaOrderByWithAggregationInput
      | acesso_sistemaOrderByWithAggregationInput[];
    by: Acesso_sistemaScalarFieldEnum[] | Acesso_sistemaScalarFieldEnum;
    having?: acesso_sistemaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Acesso_sistemaCountAggregateInputType | true;
    _avg?: Acesso_sistemaAvgAggregateInputType;
    _sum?: Acesso_sistemaSumAggregateInputType;
    _min?: Acesso_sistemaMinAggregateInputType;
    _max?: Acesso_sistemaMaxAggregateInputType;
  };

  export type Acesso_sistemaGroupByOutputType = {
    cod_usuario: number;
    cod_modulo: number;
    cod_tela: number;
    incluir: string;
    modificar: string;
    eliminar: string;
    _count: Acesso_sistemaCountAggregateOutputType | null;
    _avg: Acesso_sistemaAvgAggregateOutputType | null;
    _sum: Acesso_sistemaSumAggregateOutputType | null;
    _min: Acesso_sistemaMinAggregateOutputType | null;
    _max: Acesso_sistemaMaxAggregateOutputType | null;
  };

  type GetAcesso_sistemaGroupByPayload<T extends acesso_sistemaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Acesso_sistemaGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof Acesso_sistemaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Acesso_sistemaGroupByOutputType[P]>
            : GetScalarType<T[P], Acesso_sistemaGroupByOutputType[P]>;
        }
      >
    >;

  export type acesso_sistemaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_usuario?: boolean;
      cod_modulo?: boolean;
      cod_tela?: boolean;
      incluir?: boolean;
      modificar?: boolean;
      eliminar?: boolean;
      modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
      tela_sistema?: boolean | tela_sistemaDefaultArgs<ExtArgs>;
      usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['acesso_sistema']
  >;

  export type acesso_sistemaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_usuario?: boolean;
      cod_modulo?: boolean;
      cod_tela?: boolean;
      incluir?: boolean;
      modificar?: boolean;
      eliminar?: boolean;
      modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
      tela_sistema?: boolean | tela_sistemaDefaultArgs<ExtArgs>;
      usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['acesso_sistema']
  >;

  export type acesso_sistemaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_usuario?: boolean;
      cod_modulo?: boolean;
      cod_tela?: boolean;
      incluir?: boolean;
      modificar?: boolean;
      eliminar?: boolean;
      modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
      tela_sistema?: boolean | tela_sistemaDefaultArgs<ExtArgs>;
      usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['acesso_sistema']
  >;

  export type acesso_sistemaSelectScalar = {
    cod_usuario?: boolean;
    cod_modulo?: boolean;
    cod_tela?: boolean;
    incluir?: boolean;
    modificar?: boolean;
    eliminar?: boolean;
  };

  export type acesso_sistemaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_usuario'
    | 'cod_modulo'
    | 'cod_tela'
    | 'incluir'
    | 'modificar'
    | 'eliminar',
    ExtArgs['result']['acesso_sistema']
  >;
  export type acesso_sistemaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
    tela_sistema?: boolean | tela_sistemaDefaultArgs<ExtArgs>;
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
  };
  export type acesso_sistemaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
    tela_sistema?: boolean | tela_sistemaDefaultArgs<ExtArgs>;
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
  };
  export type acesso_sistemaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
    tela_sistema?: boolean | tela_sistemaDefaultArgs<ExtArgs>;
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
  };

  export type $acesso_sistemaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'acesso_sistema';
    objects: {
      modulo_sistema: Prisma.$modulo_sistemaPayload<ExtArgs>;
      tela_sistema: Prisma.$tela_sistemaPayload<ExtArgs>;
      usuario: Prisma.$usuarioPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_usuario: number;
        cod_modulo: number;
        cod_tela: number;
        incluir: string;
        modificar: string;
        eliminar: string;
      },
      ExtArgs['result']['acesso_sistema']
    >;
    composites: {};
  };

  type acesso_sistemaGetPayload<
    S extends boolean | null | undefined | acesso_sistemaDefaultArgs,
  > = $Result.GetResult<Prisma.$acesso_sistemaPayload, S>;

  type acesso_sistemaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    acesso_sistemaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Acesso_sistemaCountAggregateInputType | true;
  };

  export interface acesso_sistemaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['acesso_sistema'];
      meta: { name: 'acesso_sistema' };
    };
    /**
     * Find zero or one Acesso_sistema that matches the filter.
     * @param {acesso_sistemaFindUniqueArgs} args - Arguments to find a Acesso_sistema
     * @example
     * // Get one Acesso_sistema
     * const acesso_sistema = await prisma.acesso_sistema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends acesso_sistemaFindUniqueArgs>(
      args: SelectSubset<T, acesso_sistemaFindUniqueArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Acesso_sistema that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {acesso_sistemaFindUniqueOrThrowArgs} args - Arguments to find a Acesso_sistema
     * @example
     * // Get one Acesso_sistema
     * const acesso_sistema = await prisma.acesso_sistema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends acesso_sistemaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, acesso_sistemaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Acesso_sistema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acesso_sistemaFindFirstArgs} args - Arguments to find a Acesso_sistema
     * @example
     * // Get one Acesso_sistema
     * const acesso_sistema = await prisma.acesso_sistema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends acesso_sistemaFindFirstArgs>(
      args?: SelectSubset<T, acesso_sistemaFindFirstArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Acesso_sistema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acesso_sistemaFindFirstOrThrowArgs} args - Arguments to find a Acesso_sistema
     * @example
     * // Get one Acesso_sistema
     * const acesso_sistema = await prisma.acesso_sistema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends acesso_sistemaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, acesso_sistemaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Acesso_sistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acesso_sistemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Acesso_sistemas
     * const acesso_sistemas = await prisma.acesso_sistema.findMany()
     *
     * // Get first 10 Acesso_sistemas
     * const acesso_sistemas = await prisma.acesso_sistema.findMany({ take: 10 })
     *
     * // Only select the `cod_usuario`
     * const acesso_sistemaWithCod_usuarioOnly = await prisma.acesso_sistema.findMany({ select: { cod_usuario: true } })
     *
     */
    findMany<T extends acesso_sistemaFindManyArgs>(
      args?: SelectSubset<T, acesso_sistemaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Acesso_sistema.
     * @param {acesso_sistemaCreateArgs} args - Arguments to create a Acesso_sistema.
     * @example
     * // Create one Acesso_sistema
     * const Acesso_sistema = await prisma.acesso_sistema.create({
     *   data: {
     *     // ... data to create a Acesso_sistema
     *   }
     * })
     *
     */
    create<T extends acesso_sistemaCreateArgs>(
      args: SelectSubset<T, acesso_sistemaCreateArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Acesso_sistemas.
     * @param {acesso_sistemaCreateManyArgs} args - Arguments to create many Acesso_sistemas.
     * @example
     * // Create many Acesso_sistemas
     * const acesso_sistema = await prisma.acesso_sistema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends acesso_sistemaCreateManyArgs>(
      args?: SelectSubset<T, acesso_sistemaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Acesso_sistemas and returns the data saved in the database.
     * @param {acesso_sistemaCreateManyAndReturnArgs} args - Arguments to create many Acesso_sistemas.
     * @example
     * // Create many Acesso_sistemas
     * const acesso_sistema = await prisma.acesso_sistema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Acesso_sistemas and only return the `cod_usuario`
     * const acesso_sistemaWithCod_usuarioOnly = await prisma.acesso_sistema.createManyAndReturn({
     *   select: { cod_usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends acesso_sistemaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, acesso_sistemaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Acesso_sistema.
     * @param {acesso_sistemaDeleteArgs} args - Arguments to delete one Acesso_sistema.
     * @example
     * // Delete one Acesso_sistema
     * const Acesso_sistema = await prisma.acesso_sistema.delete({
     *   where: {
     *     // ... filter to delete one Acesso_sistema
     *   }
     * })
     *
     */
    delete<T extends acesso_sistemaDeleteArgs>(
      args: SelectSubset<T, acesso_sistemaDeleteArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Acesso_sistema.
     * @param {acesso_sistemaUpdateArgs} args - Arguments to update one Acesso_sistema.
     * @example
     * // Update one Acesso_sistema
     * const acesso_sistema = await prisma.acesso_sistema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends acesso_sistemaUpdateArgs>(
      args: SelectSubset<T, acesso_sistemaUpdateArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Acesso_sistemas.
     * @param {acesso_sistemaDeleteManyArgs} args - Arguments to filter Acesso_sistemas to delete.
     * @example
     * // Delete a few Acesso_sistemas
     * const { count } = await prisma.acesso_sistema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends acesso_sistemaDeleteManyArgs>(
      args?: SelectSubset<T, acesso_sistemaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Acesso_sistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acesso_sistemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Acesso_sistemas
     * const acesso_sistema = await prisma.acesso_sistema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends acesso_sistemaUpdateManyArgs>(
      args: SelectSubset<T, acesso_sistemaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Acesso_sistemas and returns the data updated in the database.
     * @param {acesso_sistemaUpdateManyAndReturnArgs} args - Arguments to update many Acesso_sistemas.
     * @example
     * // Update many Acesso_sistemas
     * const acesso_sistema = await prisma.acesso_sistema.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Acesso_sistemas and only return the `cod_usuario`
     * const acesso_sistemaWithCod_usuarioOnly = await prisma.acesso_sistema.updateManyAndReturn({
     *   select: { cod_usuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends acesso_sistemaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, acesso_sistemaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Acesso_sistema.
     * @param {acesso_sistemaUpsertArgs} args - Arguments to update or create a Acesso_sistema.
     * @example
     * // Update or create a Acesso_sistema
     * const acesso_sistema = await prisma.acesso_sistema.upsert({
     *   create: {
     *     // ... data to create a Acesso_sistema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Acesso_sistema we want to update
     *   }
     * })
     */
    upsert<T extends acesso_sistemaUpsertArgs>(
      args: SelectSubset<T, acesso_sistemaUpsertArgs<ExtArgs>>,
    ): Prisma__acesso_sistemaClient<
      $Result.GetResult<
        Prisma.$acesso_sistemaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Acesso_sistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acesso_sistemaCountArgs} args - Arguments to filter Acesso_sistemas to count.
     * @example
     * // Count the number of Acesso_sistemas
     * const count = await prisma.acesso_sistema.count({
     *   where: {
     *     // ... the filter for the Acesso_sistemas we want to count
     *   }
     * })
     **/
    count<T extends acesso_sistemaCountArgs>(
      args?: Subset<T, acesso_sistemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Acesso_sistemaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Acesso_sistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Acesso_sistemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Acesso_sistemaAggregateArgs>(
      args: Subset<T, Acesso_sistemaAggregateArgs>,
    ): Prisma.PrismaPromise<GetAcesso_sistemaAggregateType<T>>;

    /**
     * Group by Acesso_sistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {acesso_sistemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends acesso_sistemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: acesso_sistemaGroupByArgs['orderBy'] }
        : { orderBy?: acesso_sistemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, acesso_sistemaGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAcesso_sistemaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the acesso_sistema model
     */
    readonly fields: acesso_sistemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for acesso_sistema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__acesso_sistemaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    modulo_sistema<T extends modulo_sistemaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, modulo_sistemaDefaultArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      | $Result.GetResult<
          Prisma.$modulo_sistemaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tela_sistema<T extends tela_sistemaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, tela_sistemaDefaultArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      | $Result.GetResult<
          Prisma.$tela_sistemaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usuarioDefaultArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      | $Result.GetResult<
          Prisma.$usuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the acesso_sistema model
   */
  interface acesso_sistemaFieldRefs {
    readonly cod_usuario: FieldRef<'acesso_sistema', 'Int'>;
    readonly cod_modulo: FieldRef<'acesso_sistema', 'Int'>;
    readonly cod_tela: FieldRef<'acesso_sistema', 'Int'>;
    readonly incluir: FieldRef<'acesso_sistema', 'String'>;
    readonly modificar: FieldRef<'acesso_sistema', 'String'>;
    readonly eliminar: FieldRef<'acesso_sistema', 'String'>;
  }

  // Custom InputTypes
  /**
   * acesso_sistema findUnique
   */
  export type acesso_sistemaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which acesso_sistema to fetch.
     */
    where: acesso_sistemaWhereUniqueInput;
  };

  /**
   * acesso_sistema findUniqueOrThrow
   */
  export type acesso_sistemaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which acesso_sistema to fetch.
     */
    where: acesso_sistemaWhereUniqueInput;
  };

  /**
   * acesso_sistema findFirst
   */
  export type acesso_sistemaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which acesso_sistema to fetch.
     */
    where?: acesso_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of acesso_sistemas to fetch.
     */
    orderBy?:
      | acesso_sistemaOrderByWithRelationInput
      | acesso_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for acesso_sistemas.
     */
    cursor?: acesso_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` acesso_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` acesso_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of acesso_sistemas.
     */
    distinct?: Acesso_sistemaScalarFieldEnum | Acesso_sistemaScalarFieldEnum[];
  };

  /**
   * acesso_sistema findFirstOrThrow
   */
  export type acesso_sistemaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which acesso_sistema to fetch.
     */
    where?: acesso_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of acesso_sistemas to fetch.
     */
    orderBy?:
      | acesso_sistemaOrderByWithRelationInput
      | acesso_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for acesso_sistemas.
     */
    cursor?: acesso_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` acesso_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` acesso_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of acesso_sistemas.
     */
    distinct?: Acesso_sistemaScalarFieldEnum | Acesso_sistemaScalarFieldEnum[];
  };

  /**
   * acesso_sistema findMany
   */
  export type acesso_sistemaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which acesso_sistemas to fetch.
     */
    where?: acesso_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of acesso_sistemas to fetch.
     */
    orderBy?:
      | acesso_sistemaOrderByWithRelationInput
      | acesso_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing acesso_sistemas.
     */
    cursor?: acesso_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` acesso_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` acesso_sistemas.
     */
    skip?: number;
    distinct?: Acesso_sistemaScalarFieldEnum | Acesso_sistemaScalarFieldEnum[];
  };

  /**
   * acesso_sistema create
   */
  export type acesso_sistemaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * The data needed to create a acesso_sistema.
     */
    data: XOR<acesso_sistemaCreateInput, acesso_sistemaUncheckedCreateInput>;
  };

  /**
   * acesso_sistema createMany
   */
  export type acesso_sistemaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many acesso_sistemas.
     */
    data: acesso_sistemaCreateManyInput | acesso_sistemaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * acesso_sistema createManyAndReturn
   */
  export type acesso_sistemaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * The data used to create many acesso_sistemas.
     */
    data: acesso_sistemaCreateManyInput | acesso_sistemaCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * acesso_sistema update
   */
  export type acesso_sistemaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * The data needed to update a acesso_sistema.
     */
    data: XOR<acesso_sistemaUpdateInput, acesso_sistemaUncheckedUpdateInput>;
    /**
     * Choose, which acesso_sistema to update.
     */
    where: acesso_sistemaWhereUniqueInput;
  };

  /**
   * acesso_sistema updateMany
   */
  export type acesso_sistemaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update acesso_sistemas.
     */
    data: XOR<
      acesso_sistemaUpdateManyMutationInput,
      acesso_sistemaUncheckedUpdateManyInput
    >;
    /**
     * Filter which acesso_sistemas to update
     */
    where?: acesso_sistemaWhereInput;
    /**
     * Limit how many acesso_sistemas to update.
     */
    limit?: number;
  };

  /**
   * acesso_sistema updateManyAndReturn
   */
  export type acesso_sistemaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * The data used to update acesso_sistemas.
     */
    data: XOR<
      acesso_sistemaUpdateManyMutationInput,
      acesso_sistemaUncheckedUpdateManyInput
    >;
    /**
     * Filter which acesso_sistemas to update
     */
    where?: acesso_sistemaWhereInput;
    /**
     * Limit how many acesso_sistemas to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * acesso_sistema upsert
   */
  export type acesso_sistemaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * The filter to search for the acesso_sistema to update in case it exists.
     */
    where: acesso_sistemaWhereUniqueInput;
    /**
     * In case the acesso_sistema found by the `where` argument doesn't exist, create a new acesso_sistema with this data.
     */
    create: XOR<acesso_sistemaCreateInput, acesso_sistemaUncheckedCreateInput>;
    /**
     * In case the acesso_sistema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<acesso_sistemaUpdateInput, acesso_sistemaUncheckedUpdateInput>;
  };

  /**
   * acesso_sistema delete
   */
  export type acesso_sistemaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    /**
     * Filter which acesso_sistema to delete.
     */
    where: acesso_sistemaWhereUniqueInput;
  };

  /**
   * acesso_sistema deleteMany
   */
  export type acesso_sistemaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which acesso_sistemas to delete
     */
    where?: acesso_sistemaWhereInput;
    /**
     * Limit how many acesso_sistemas to delete.
     */
    limit?: number;
  };

  /**
   * acesso_sistema without action
   */
  export type acesso_sistemaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
  };

  /**
   * Model agenrec
   */

  export type AggregateAgenrec = {
    _count: AgenrecCountAggregateOutputType | null;
    _avg: AgenrecAvgAggregateOutputType | null;
    _sum: AgenrecSumAggregateOutputType | null;
    _min: AgenrecMinAggregateOutputType | null;
    _max: AgenrecMaxAggregateOutputType | null;
  };

  export type AgenrecAvgAggregateOutputType = {
    cod_agenrec: number | null;
    cod_recurso: number | null;
    status_agenrec: number | null;
    custo_agenrec: Decimal | null;
    receita_agenrec: Decimal | null;
    tpcusto_agenrec: number | null;
  };

  export type AgenrecSumAggregateOutputType = {
    cod_agenrec: number | null;
    cod_recurso: number | null;
    status_agenrec: number | null;
    custo_agenrec: Decimal | null;
    receita_agenrec: Decimal | null;
    tpcusto_agenrec: number | null;
  };

  export type AgenrecMinAggregateOutputType = {
    cod_agenrec: number | null;
    cod_recurso: number | null;
    data_agenrec: Date | null;
    hrini_agenrec: string | null;
    hrfim_agenrec: string | null;
    status_agenrec: number | null;
    obs_agenrec: string | null;
    custo_agenrec: Decimal | null;
    receita_agenrec: Decimal | null;
    tpcusto_agenrec: number | null;
  };

  export type AgenrecMaxAggregateOutputType = {
    cod_agenrec: number | null;
    cod_recurso: number | null;
    data_agenrec: Date | null;
    hrini_agenrec: string | null;
    hrfim_agenrec: string | null;
    status_agenrec: number | null;
    obs_agenrec: string | null;
    custo_agenrec: Decimal | null;
    receita_agenrec: Decimal | null;
    tpcusto_agenrec: number | null;
  };

  export type AgenrecCountAggregateOutputType = {
    cod_agenrec: number;
    cod_recurso: number;
    data_agenrec: number;
    hrini_agenrec: number;
    hrfim_agenrec: number;
    status_agenrec: number;
    obs_agenrec: number;
    custo_agenrec: number;
    receita_agenrec: number;
    tpcusto_agenrec: number;
    _all: number;
  };

  export type AgenrecAvgAggregateInputType = {
    cod_agenrec?: true;
    cod_recurso?: true;
    status_agenrec?: true;
    custo_agenrec?: true;
    receita_agenrec?: true;
    tpcusto_agenrec?: true;
  };

  export type AgenrecSumAggregateInputType = {
    cod_agenrec?: true;
    cod_recurso?: true;
    status_agenrec?: true;
    custo_agenrec?: true;
    receita_agenrec?: true;
    tpcusto_agenrec?: true;
  };

  export type AgenrecMinAggregateInputType = {
    cod_agenrec?: true;
    cod_recurso?: true;
    data_agenrec?: true;
    hrini_agenrec?: true;
    hrfim_agenrec?: true;
    status_agenrec?: true;
    obs_agenrec?: true;
    custo_agenrec?: true;
    receita_agenrec?: true;
    tpcusto_agenrec?: true;
  };

  export type AgenrecMaxAggregateInputType = {
    cod_agenrec?: true;
    cod_recurso?: true;
    data_agenrec?: true;
    hrini_agenrec?: true;
    hrfim_agenrec?: true;
    status_agenrec?: true;
    obs_agenrec?: true;
    custo_agenrec?: true;
    receita_agenrec?: true;
    tpcusto_agenrec?: true;
  };

  export type AgenrecCountAggregateInputType = {
    cod_agenrec?: true;
    cod_recurso?: true;
    data_agenrec?: true;
    hrini_agenrec?: true;
    hrfim_agenrec?: true;
    status_agenrec?: true;
    obs_agenrec?: true;
    custo_agenrec?: true;
    receita_agenrec?: true;
    tpcusto_agenrec?: true;
    _all?: true;
  };

  export type AgenrecAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which agenrec to aggregate.
     */
    where?: agenrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of agenrecs to fetch.
     */
    orderBy?:
      | agenrecOrderByWithRelationInput
      | agenrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: agenrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` agenrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` agenrecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned agenrecs
     **/
    _count?: true | AgenrecCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AgenrecAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AgenrecSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AgenrecMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AgenrecMaxAggregateInputType;
  };

  export type GetAgenrecAggregateType<T extends AgenrecAggregateArgs> = {
    [P in keyof T & keyof AggregateAgenrec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgenrec[P]>
      : GetScalarType<T[P], AggregateAgenrec[P]>;
  };

  export type agenrecGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: agenrecWhereInput;
    orderBy?:
      | agenrecOrderByWithAggregationInput
      | agenrecOrderByWithAggregationInput[];
    by: AgenrecScalarFieldEnum[] | AgenrecScalarFieldEnum;
    having?: agenrecScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AgenrecCountAggregateInputType | true;
    _avg?: AgenrecAvgAggregateInputType;
    _sum?: AgenrecSumAggregateInputType;
    _min?: AgenrecMinAggregateInputType;
    _max?: AgenrecMaxAggregateInputType;
  };

  export type AgenrecGroupByOutputType = {
    cod_agenrec: number;
    cod_recurso: number;
    data_agenrec: Date;
    hrini_agenrec: string;
    hrfim_agenrec: string;
    status_agenrec: number;
    obs_agenrec: string | null;
    custo_agenrec: Decimal | null;
    receita_agenrec: Decimal | null;
    tpcusto_agenrec: number | null;
    _count: AgenrecCountAggregateOutputType | null;
    _avg: AgenrecAvgAggregateOutputType | null;
    _sum: AgenrecSumAggregateOutputType | null;
    _min: AgenrecMinAggregateOutputType | null;
    _max: AgenrecMaxAggregateOutputType | null;
  };

  type GetAgenrecGroupByPayload<T extends agenrecGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AgenrecGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AgenrecGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgenrecGroupByOutputType[P]>
            : GetScalarType<T[P], AgenrecGroupByOutputType[P]>;
        }
      >
    >;

  export type agenrecSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_agenrec?: boolean;
      cod_recurso?: boolean;
      data_agenrec?: boolean;
      hrini_agenrec?: boolean;
      hrfim_agenrec?: boolean;
      status_agenrec?: boolean;
      obs_agenrec?: boolean;
      custo_agenrec?: boolean;
      receita_agenrec?: boolean;
      tpcusto_agenrec?: boolean;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['agenrec']
  >;

  export type agenrecSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_agenrec?: boolean;
      cod_recurso?: boolean;
      data_agenrec?: boolean;
      hrini_agenrec?: boolean;
      hrfim_agenrec?: boolean;
      status_agenrec?: boolean;
      obs_agenrec?: boolean;
      custo_agenrec?: boolean;
      receita_agenrec?: boolean;
      tpcusto_agenrec?: boolean;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['agenrec']
  >;

  export type agenrecSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_agenrec?: boolean;
      cod_recurso?: boolean;
      data_agenrec?: boolean;
      hrini_agenrec?: boolean;
      hrfim_agenrec?: boolean;
      status_agenrec?: boolean;
      obs_agenrec?: boolean;
      custo_agenrec?: boolean;
      receita_agenrec?: boolean;
      tpcusto_agenrec?: boolean;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['agenrec']
  >;

  export type agenrecSelectScalar = {
    cod_agenrec?: boolean;
    cod_recurso?: boolean;
    data_agenrec?: boolean;
    hrini_agenrec?: boolean;
    hrfim_agenrec?: boolean;
    status_agenrec?: boolean;
    obs_agenrec?: boolean;
    custo_agenrec?: boolean;
    receita_agenrec?: boolean;
    tpcusto_agenrec?: boolean;
  };

  export type agenrecOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_agenrec'
    | 'cod_recurso'
    | 'data_agenrec'
    | 'hrini_agenrec'
    | 'hrfim_agenrec'
    | 'status_agenrec'
    | 'obs_agenrec'
    | 'custo_agenrec'
    | 'receita_agenrec'
    | 'tpcusto_agenrec',
    ExtArgs['result']['agenrec']
  >;
  export type agenrecInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
  };
  export type agenrecIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
  };
  export type agenrecIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
  };

  export type $agenrecPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'agenrec';
    objects: {
      recurso: Prisma.$recursoPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_agenrec: number;
        cod_recurso: number;
        data_agenrec: Date;
        hrini_agenrec: string;
        hrfim_agenrec: string;
        status_agenrec: number;
        obs_agenrec: string | null;
        custo_agenrec: Prisma.Decimal | null;
        receita_agenrec: Prisma.Decimal | null;
        tpcusto_agenrec: number | null;
      },
      ExtArgs['result']['agenrec']
    >;
    composites: {};
  };

  type agenrecGetPayload<
    S extends boolean | null | undefined | agenrecDefaultArgs,
  > = $Result.GetResult<Prisma.$agenrecPayload, S>;

  type agenrecCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<agenrecFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AgenrecCountAggregateInputType | true;
  };

  export interface agenrecDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['agenrec'];
      meta: { name: 'agenrec' };
    };
    /**
     * Find zero or one Agenrec that matches the filter.
     * @param {agenrecFindUniqueArgs} args - Arguments to find a Agenrec
     * @example
     * // Get one Agenrec
     * const agenrec = await prisma.agenrec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agenrecFindUniqueArgs>(
      args: SelectSubset<T, agenrecFindUniqueArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Agenrec that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agenrecFindUniqueOrThrowArgs} args - Arguments to find a Agenrec
     * @example
     * // Get one Agenrec
     * const agenrec = await prisma.agenrec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agenrecFindUniqueOrThrowArgs>(
      args: SelectSubset<T, agenrecFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Agenrec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenrecFindFirstArgs} args - Arguments to find a Agenrec
     * @example
     * // Get one Agenrec
     * const agenrec = await prisma.agenrec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agenrecFindFirstArgs>(
      args?: SelectSubset<T, agenrecFindFirstArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Agenrec that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenrecFindFirstOrThrowArgs} args - Arguments to find a Agenrec
     * @example
     * // Get one Agenrec
     * const agenrec = await prisma.agenrec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agenrecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, agenrecFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Agenrecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenrecFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agenrecs
     * const agenrecs = await prisma.agenrec.findMany()
     *
     * // Get first 10 Agenrecs
     * const agenrecs = await prisma.agenrec.findMany({ take: 10 })
     *
     * // Only select the `cod_agenrec`
     * const agenrecWithCod_agenrecOnly = await prisma.agenrec.findMany({ select: { cod_agenrec: true } })
     *
     */
    findMany<T extends agenrecFindManyArgs>(
      args?: SelectSubset<T, agenrecFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Agenrec.
     * @param {agenrecCreateArgs} args - Arguments to create a Agenrec.
     * @example
     * // Create one Agenrec
     * const Agenrec = await prisma.agenrec.create({
     *   data: {
     *     // ... data to create a Agenrec
     *   }
     * })
     *
     */
    create<T extends agenrecCreateArgs>(
      args: SelectSubset<T, agenrecCreateArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Agenrecs.
     * @param {agenrecCreateManyArgs} args - Arguments to create many Agenrecs.
     * @example
     * // Create many Agenrecs
     * const agenrec = await prisma.agenrec.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends agenrecCreateManyArgs>(
      args?: SelectSubset<T, agenrecCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Agenrecs and returns the data saved in the database.
     * @param {agenrecCreateManyAndReturnArgs} args - Arguments to create many Agenrecs.
     * @example
     * // Create many Agenrecs
     * const agenrec = await prisma.agenrec.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Agenrecs and only return the `cod_agenrec`
     * const agenrecWithCod_agenrecOnly = await prisma.agenrec.createManyAndReturn({
     *   select: { cod_agenrec: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends agenrecCreateManyAndReturnArgs>(
      args?: SelectSubset<T, agenrecCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Agenrec.
     * @param {agenrecDeleteArgs} args - Arguments to delete one Agenrec.
     * @example
     * // Delete one Agenrec
     * const Agenrec = await prisma.agenrec.delete({
     *   where: {
     *     // ... filter to delete one Agenrec
     *   }
     * })
     *
     */
    delete<T extends agenrecDeleteArgs>(
      args: SelectSubset<T, agenrecDeleteArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Agenrec.
     * @param {agenrecUpdateArgs} args - Arguments to update one Agenrec.
     * @example
     * // Update one Agenrec
     * const agenrec = await prisma.agenrec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends agenrecUpdateArgs>(
      args: SelectSubset<T, agenrecUpdateArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Agenrecs.
     * @param {agenrecDeleteManyArgs} args - Arguments to filter Agenrecs to delete.
     * @example
     * // Delete a few Agenrecs
     * const { count } = await prisma.agenrec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends agenrecDeleteManyArgs>(
      args?: SelectSubset<T, agenrecDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Agenrecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenrecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agenrecs
     * const agenrec = await prisma.agenrec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends agenrecUpdateManyArgs>(
      args: SelectSubset<T, agenrecUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Agenrecs and returns the data updated in the database.
     * @param {agenrecUpdateManyAndReturnArgs} args - Arguments to update many Agenrecs.
     * @example
     * // Update many Agenrecs
     * const agenrec = await prisma.agenrec.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Agenrecs and only return the `cod_agenrec`
     * const agenrecWithCod_agenrecOnly = await prisma.agenrec.updateManyAndReturn({
     *   select: { cod_agenrec: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends agenrecUpdateManyAndReturnArgs>(
      args: SelectSubset<T, agenrecUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Agenrec.
     * @param {agenrecUpsertArgs} args - Arguments to update or create a Agenrec.
     * @example
     * // Update or create a Agenrec
     * const agenrec = await prisma.agenrec.upsert({
     *   create: {
     *     // ... data to create a Agenrec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agenrec we want to update
     *   }
     * })
     */
    upsert<T extends agenrecUpsertArgs>(
      args: SelectSubset<T, agenrecUpsertArgs<ExtArgs>>,
    ): Prisma__agenrecClient<
      $Result.GetResult<
        Prisma.$agenrecPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Agenrecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenrecCountArgs} args - Arguments to filter Agenrecs to count.
     * @example
     * // Count the number of Agenrecs
     * const count = await prisma.agenrec.count({
     *   where: {
     *     // ... the filter for the Agenrecs we want to count
     *   }
     * })
     **/
    count<T extends agenrecCountArgs>(
      args?: Subset<T, agenrecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgenrecCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Agenrec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgenrecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AgenrecAggregateArgs>(
      args: Subset<T, AgenrecAggregateArgs>,
    ): Prisma.PrismaPromise<GetAgenrecAggregateType<T>>;

    /**
     * Group by Agenrec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenrecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends agenrecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agenrecGroupByArgs['orderBy'] }
        : { orderBy?: agenrecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, agenrecGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetAgenrecGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the agenrec model
     */
    readonly fields: agenrecFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agenrec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agenrecClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    recurso<T extends recursoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, recursoDefaultArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      | $Result.GetResult<
          Prisma.$recursoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the agenrec model
   */
  interface agenrecFieldRefs {
    readonly cod_agenrec: FieldRef<'agenrec', 'Int'>;
    readonly cod_recurso: FieldRef<'agenrec', 'Int'>;
    readonly data_agenrec: FieldRef<'agenrec', 'DateTime'>;
    readonly hrini_agenrec: FieldRef<'agenrec', 'String'>;
    readonly hrfim_agenrec: FieldRef<'agenrec', 'String'>;
    readonly status_agenrec: FieldRef<'agenrec', 'Int'>;
    readonly obs_agenrec: FieldRef<'agenrec', 'String'>;
    readonly custo_agenrec: FieldRef<'agenrec', 'Decimal'>;
    readonly receita_agenrec: FieldRef<'agenrec', 'Decimal'>;
    readonly tpcusto_agenrec: FieldRef<'agenrec', 'Int'>;
  }

  // Custom InputTypes
  /**
   * agenrec findUnique
   */
  export type agenrecFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * Filter, which agenrec to fetch.
     */
    where: agenrecWhereUniqueInput;
  };

  /**
   * agenrec findUniqueOrThrow
   */
  export type agenrecFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * Filter, which agenrec to fetch.
     */
    where: agenrecWhereUniqueInput;
  };

  /**
   * agenrec findFirst
   */
  export type agenrecFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * Filter, which agenrec to fetch.
     */
    where?: agenrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of agenrecs to fetch.
     */
    orderBy?:
      | agenrecOrderByWithRelationInput
      | agenrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for agenrecs.
     */
    cursor?: agenrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` agenrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` agenrecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of agenrecs.
     */
    distinct?: AgenrecScalarFieldEnum | AgenrecScalarFieldEnum[];
  };

  /**
   * agenrec findFirstOrThrow
   */
  export type agenrecFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * Filter, which agenrec to fetch.
     */
    where?: agenrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of agenrecs to fetch.
     */
    orderBy?:
      | agenrecOrderByWithRelationInput
      | agenrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for agenrecs.
     */
    cursor?: agenrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` agenrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` agenrecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of agenrecs.
     */
    distinct?: AgenrecScalarFieldEnum | AgenrecScalarFieldEnum[];
  };

  /**
   * agenrec findMany
   */
  export type agenrecFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * Filter, which agenrecs to fetch.
     */
    where?: agenrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of agenrecs to fetch.
     */
    orderBy?:
      | agenrecOrderByWithRelationInput
      | agenrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing agenrecs.
     */
    cursor?: agenrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` agenrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` agenrecs.
     */
    skip?: number;
    distinct?: AgenrecScalarFieldEnum | AgenrecScalarFieldEnum[];
  };

  /**
   * agenrec create
   */
  export type agenrecCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * The data needed to create a agenrec.
     */
    data: XOR<agenrecCreateInput, agenrecUncheckedCreateInput>;
  };

  /**
   * agenrec createMany
   */
  export type agenrecCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many agenrecs.
     */
    data: agenrecCreateManyInput | agenrecCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * agenrec createManyAndReturn
   */
  export type agenrecCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * The data used to create many agenrecs.
     */
    data: agenrecCreateManyInput | agenrecCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * agenrec update
   */
  export type agenrecUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * The data needed to update a agenrec.
     */
    data: XOR<agenrecUpdateInput, agenrecUncheckedUpdateInput>;
    /**
     * Choose, which agenrec to update.
     */
    where: agenrecWhereUniqueInput;
  };

  /**
   * agenrec updateMany
   */
  export type agenrecUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update agenrecs.
     */
    data: XOR<agenrecUpdateManyMutationInput, agenrecUncheckedUpdateManyInput>;
    /**
     * Filter which agenrecs to update
     */
    where?: agenrecWhereInput;
    /**
     * Limit how many agenrecs to update.
     */
    limit?: number;
  };

  /**
   * agenrec updateManyAndReturn
   */
  export type agenrecUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * The data used to update agenrecs.
     */
    data: XOR<agenrecUpdateManyMutationInput, agenrecUncheckedUpdateManyInput>;
    /**
     * Filter which agenrecs to update
     */
    where?: agenrecWhereInput;
    /**
     * Limit how many agenrecs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * agenrec upsert
   */
  export type agenrecUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * The filter to search for the agenrec to update in case it exists.
     */
    where: agenrecWhereUniqueInput;
    /**
     * In case the agenrec found by the `where` argument doesn't exist, create a new agenrec with this data.
     */
    create: XOR<agenrecCreateInput, agenrecUncheckedCreateInput>;
    /**
     * In case the agenrec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agenrecUpdateInput, agenrecUncheckedUpdateInput>;
  };

  /**
   * agenrec delete
   */
  export type agenrecDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    /**
     * Filter which agenrec to delete.
     */
    where: agenrecWhereUniqueInput;
  };

  /**
   * agenrec deleteMany
   */
  export type agenrecDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which agenrecs to delete
     */
    where?: agenrecWhereInput;
    /**
     * Limit how many agenrecs to delete.
     */
    limit?: number;
  };

  /**
   * agenrec without action
   */
  export type agenrecDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
  };

  /**
   * Model area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null;
    _avg: AreaAvgAggregateOutputType | null;
    _sum: AreaSumAggregateOutputType | null;
    _min: AreaMinAggregateOutputType | null;
    _max: AreaMaxAggregateOutputType | null;
  };

  export type AreaAvgAggregateOutputType = {
    cod_area: number | null;
  };

  export type AreaSumAggregateOutputType = {
    cod_area: number | null;
  };

  export type AreaMinAggregateOutputType = {
    cod_area: number | null;
    nome_area: string | null;
  };

  export type AreaMaxAggregateOutputType = {
    cod_area: number | null;
    nome_area: string | null;
  };

  export type AreaCountAggregateOutputType = {
    cod_area: number;
    nome_area: number;
    _all: number;
  };

  export type AreaAvgAggregateInputType = {
    cod_area?: true;
  };

  export type AreaSumAggregateInputType = {
    cod_area?: true;
  };

  export type AreaMinAggregateInputType = {
    cod_area?: true;
    nome_area?: true;
  };

  export type AreaMaxAggregateInputType = {
    cod_area?: true;
    nome_area?: true;
  };

  export type AreaCountAggregateInputType = {
    cod_area?: true;
    nome_area?: true;
    _all?: true;
  };

  export type AreaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which area to aggregate.
     */
    where?: areaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of areas to fetch.
     */
    orderBy?: areaOrderByWithRelationInput | areaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: areaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` areas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` areas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned areas
     **/
    _count?: true | AreaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AreaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AreaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AreaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AreaMaxAggregateInputType;
  };

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
    [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>;
  };

  export type areaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: areaWhereInput;
    orderBy?:
      | areaOrderByWithAggregationInput
      | areaOrderByWithAggregationInput[];
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum;
    having?: areaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AreaCountAggregateInputType | true;
    _avg?: AreaAvgAggregateInputType;
    _sum?: AreaSumAggregateInputType;
    _min?: AreaMinAggregateInputType;
    _max?: AreaMaxAggregateInputType;
  };

  export type AreaGroupByOutputType = {
    cod_area: number;
    nome_area: string;
    _count: AreaCountAggregateOutputType | null;
    _avg: AreaAvgAggregateOutputType | null;
    _sum: AreaSumAggregateOutputType | null;
    _min: AreaMinAggregateOutputType | null;
    _max: AreaMaxAggregateOutputType | null;
  };

  type GetAreaGroupByPayload<T extends areaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AreaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
          : GetScalarType<T[P], AreaGroupByOutputType[P]>;
      }
    >
  >;

  export type areaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_area?: boolean;
      nome_area?: boolean;
      meta?: boolean | area$metaArgs<ExtArgs>;
      tarefa?: boolean | area$tarefaArgs<ExtArgs>;
      _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['area']
  >;

  export type areaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_area?: boolean;
      nome_area?: boolean;
    },
    ExtArgs['result']['area']
  >;

  export type areaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_area?: boolean;
      nome_area?: boolean;
    },
    ExtArgs['result']['area']
  >;

  export type areaSelectScalar = {
    cod_area?: boolean;
    nome_area?: boolean;
  };

  export type areaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<'cod_area' | 'nome_area', ExtArgs['result']['area']>;
  export type areaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meta?: boolean | area$metaArgs<ExtArgs>;
    tarefa?: boolean | area$tarefaArgs<ExtArgs>;
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type areaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type areaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $areaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'area';
    objects: {
      meta: Prisma.$metaPayload<ExtArgs>[];
      tarefa: Prisma.$tarefaPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_area: number;
        nome_area: string;
      },
      ExtArgs['result']['area']
    >;
    composites: {};
  };

  type areaGetPayload<S extends boolean | null | undefined | areaDefaultArgs> =
    $Result.GetResult<Prisma.$areaPayload, S>;

  type areaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<areaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AreaCountAggregateInputType | true;
  };

  export interface areaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['area'];
      meta: { name: 'area' };
    };
    /**
     * Find zero or one Area that matches the filter.
     * @param {areaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends areaFindUniqueArgs>(
      args: SelectSubset<T, areaFindUniqueArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {areaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends areaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, areaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends areaFindFirstArgs>(
      args?: SelectSubset<T, areaFindFirstArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends areaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, areaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     *
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     *
     * // Only select the `cod_area`
     * const areaWithCod_areaOnly = await prisma.area.findMany({ select: { cod_area: true } })
     *
     */
    findMany<T extends areaFindManyArgs>(
      args?: SelectSubset<T, areaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Area.
     * @param {areaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     *
     */
    create<T extends areaCreateArgs>(
      args: SelectSubset<T, areaCreateArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Areas.
     * @param {areaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends areaCreateManyArgs>(
      args?: SelectSubset<T, areaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {areaCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Areas and only return the `cod_area`
     * const areaWithCod_areaOnly = await prisma.area.createManyAndReturn({
     *   select: { cod_area: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends areaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, areaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Area.
     * @param {areaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     *
     */
    delete<T extends areaDeleteArgs>(
      args: SelectSubset<T, areaDeleteArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Area.
     * @param {areaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends areaUpdateArgs>(
      args: SelectSubset<T, areaUpdateArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Areas.
     * @param {areaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends areaDeleteManyArgs>(
      args?: SelectSubset<T, areaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends areaUpdateManyArgs>(
      args: SelectSubset<T, areaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Areas and returns the data updated in the database.
     * @param {areaUpdateManyAndReturnArgs} args - Arguments to update many Areas.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Areas and only return the `cod_area`
     * const areaWithCod_areaOnly = await prisma.area.updateManyAndReturn({
     *   select: { cod_area: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends areaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, areaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Area.
     * @param {areaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends areaUpsertArgs>(
      args: SelectSubset<T, areaUpsertArgs<ExtArgs>>,
    ): Prisma__areaClient<
      $Result.GetResult<
        Prisma.$areaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
     **/
    count<T extends areaCountArgs>(
      args?: Subset<T, areaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AreaAggregateArgs>(
      args: Subset<T, AreaAggregateArgs>,
    ): Prisma.PrismaPromise<GetAreaAggregateType<T>>;

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends areaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: areaGroupByArgs['orderBy'] }
        : { orderBy?: areaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, areaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetAreaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the area model
     */
    readonly fields: areaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__areaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meta<T extends area$metaArgs<ExtArgs> = {}>(
      args?: Subset<T, area$metaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$metaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    tarefa<T extends area$tarefaArgs<ExtArgs> = {}>(
      args?: Subset<T, area$tarefaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$tarefaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the area model
   */
  interface areaFieldRefs {
    readonly cod_area: FieldRef<'area', 'Int'>;
    readonly nome_area: FieldRef<'area', 'String'>;
  }

  // Custom InputTypes
  /**
   * area findUnique
   */
  export type areaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * Filter, which area to fetch.
     */
    where: areaWhereUniqueInput;
  };

  /**
   * area findUniqueOrThrow
   */
  export type areaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * Filter, which area to fetch.
     */
    where: areaWhereUniqueInput;
  };

  /**
   * area findFirst
   */
  export type areaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * Filter, which area to fetch.
     */
    where?: areaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of areas to fetch.
     */
    orderBy?: areaOrderByWithRelationInput | areaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for areas.
     */
    cursor?: areaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` areas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` areas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[];
  };

  /**
   * area findFirstOrThrow
   */
  export type areaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * Filter, which area to fetch.
     */
    where?: areaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of areas to fetch.
     */
    orderBy?: areaOrderByWithRelationInput | areaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for areas.
     */
    cursor?: areaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` areas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` areas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[];
  };

  /**
   * area findMany
   */
  export type areaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * Filter, which areas to fetch.
     */
    where?: areaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of areas to fetch.
     */
    orderBy?: areaOrderByWithRelationInput | areaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing areas.
     */
    cursor?: areaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` areas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` areas.
     */
    skip?: number;
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[];
  };

  /**
   * area create
   */
  export type areaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * The data needed to create a area.
     */
    data: XOR<areaCreateInput, areaUncheckedCreateInput>;
  };

  /**
   * area createMany
   */
  export type areaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many areas.
     */
    data: areaCreateManyInput | areaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * area createManyAndReturn
   */
  export type areaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * The data used to create many areas.
     */
    data: areaCreateManyInput | areaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * area update
   */
  export type areaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * The data needed to update a area.
     */
    data: XOR<areaUpdateInput, areaUncheckedUpdateInput>;
    /**
     * Choose, which area to update.
     */
    where: areaWhereUniqueInput;
  };

  /**
   * area updateMany
   */
  export type areaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update areas.
     */
    data: XOR<areaUpdateManyMutationInput, areaUncheckedUpdateManyInput>;
    /**
     * Filter which areas to update
     */
    where?: areaWhereInput;
    /**
     * Limit how many areas to update.
     */
    limit?: number;
  };

  /**
   * area updateManyAndReturn
   */
  export type areaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * The data used to update areas.
     */
    data: XOR<areaUpdateManyMutationInput, areaUncheckedUpdateManyInput>;
    /**
     * Filter which areas to update
     */
    where?: areaWhereInput;
    /**
     * Limit how many areas to update.
     */
    limit?: number;
  };

  /**
   * area upsert
   */
  export type areaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * The filter to search for the area to update in case it exists.
     */
    where: areaWhereUniqueInput;
    /**
     * In case the area found by the `where` argument doesn't exist, create a new area with this data.
     */
    create: XOR<areaCreateInput, areaUncheckedCreateInput>;
    /**
     * In case the area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<areaUpdateInput, areaUncheckedUpdateInput>;
  };

  /**
   * area delete
   */
  export type areaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
    /**
     * Filter which area to delete.
     */
    where: areaWhereUniqueInput;
  };

  /**
   * area deleteMany
   */
  export type areaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which areas to delete
     */
    where?: areaWhereInput;
    /**
     * Limit how many areas to delete.
     */
    limit?: number;
  };

  /**
   * area.meta
   */
  export type area$metaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    where?: metaWhereInput;
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[];
    cursor?: metaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[];
  };

  /**
   * area.tarefa
   */
  export type area$tarefaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    where?: tarefaWhereInput;
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    cursor?: tarefaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * area without action
   */
  export type areaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the area
     */
    select?: areaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the area
     */
    omit?: areaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areaInclude<ExtArgs> | null;
  };

  /**
   * Model avaliacao
   */

  export type AggregateAvaliacao = {
    _count: AvaliacaoCountAggregateOutputType | null;
    _avg: AvaliacaoAvgAggregateOutputType | null;
    _sum: AvaliacaoSumAggregateOutputType | null;
    _min: AvaliacaoMinAggregateOutputType | null;
    _max: AvaliacaoMaxAggregateOutputType | null;
  };

  export type AvaliacaoAvgAggregateOutputType = {
    cod_avaliacao: number | null;
    codrec_avaliacao: number | null;
    codpro_avaliacao: number | null;
  };

  export type AvaliacaoSumAggregateOutputType = {
    cod_avaliacao: number | null;
    codrec_avaliacao: number | null;
    codpro_avaliacao: number | null;
  };

  export type AvaliacaoMinAggregateOutputType = {
    cod_avaliacao: number | null;
    anomes_avaliacao: string | null;
    data_avaliacao: Date | null;
    codrec_avaliacao: number | null;
    status_avaliacao: string | null;
    codpro_avaliacao: number | null;
  };

  export type AvaliacaoMaxAggregateOutputType = {
    cod_avaliacao: number | null;
    anomes_avaliacao: string | null;
    data_avaliacao: Date | null;
    codrec_avaliacao: number | null;
    status_avaliacao: string | null;
    codpro_avaliacao: number | null;
  };

  export type AvaliacaoCountAggregateOutputType = {
    cod_avaliacao: number;
    anomes_avaliacao: number;
    data_avaliacao: number;
    codrec_avaliacao: number;
    status_avaliacao: number;
    codpro_avaliacao: number;
    _all: number;
  };

  export type AvaliacaoAvgAggregateInputType = {
    cod_avaliacao?: true;
    codrec_avaliacao?: true;
    codpro_avaliacao?: true;
  };

  export type AvaliacaoSumAggregateInputType = {
    cod_avaliacao?: true;
    codrec_avaliacao?: true;
    codpro_avaliacao?: true;
  };

  export type AvaliacaoMinAggregateInputType = {
    cod_avaliacao?: true;
    anomes_avaliacao?: true;
    data_avaliacao?: true;
    codrec_avaliacao?: true;
    status_avaliacao?: true;
    codpro_avaliacao?: true;
  };

  export type AvaliacaoMaxAggregateInputType = {
    cod_avaliacao?: true;
    anomes_avaliacao?: true;
    data_avaliacao?: true;
    codrec_avaliacao?: true;
    status_avaliacao?: true;
    codpro_avaliacao?: true;
  };

  export type AvaliacaoCountAggregateInputType = {
    cod_avaliacao?: true;
    anomes_avaliacao?: true;
    data_avaliacao?: true;
    codrec_avaliacao?: true;
    status_avaliacao?: true;
    codpro_avaliacao?: true;
    _all?: true;
  };

  export type AvaliacaoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which avaliacao to aggregate.
     */
    where?: avaliacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliacaos to fetch.
     */
    orderBy?:
      | avaliacaoOrderByWithRelationInput
      | avaliacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: avaliacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliacaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned avaliacaos
     **/
    _count?: true | AvaliacaoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AvaliacaoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AvaliacaoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AvaliacaoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AvaliacaoMaxAggregateInputType;
  };

  export type GetAvaliacaoAggregateType<T extends AvaliacaoAggregateArgs> = {
    [P in keyof T & keyof AggregateAvaliacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvaliacao[P]>
      : GetScalarType<T[P], AggregateAvaliacao[P]>;
  };

  export type avaliacaoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: avaliacaoWhereInput;
    orderBy?:
      | avaliacaoOrderByWithAggregationInput
      | avaliacaoOrderByWithAggregationInput[];
    by: AvaliacaoScalarFieldEnum[] | AvaliacaoScalarFieldEnum;
    having?: avaliacaoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AvaliacaoCountAggregateInputType | true;
    _avg?: AvaliacaoAvgAggregateInputType;
    _sum?: AvaliacaoSumAggregateInputType;
    _min?: AvaliacaoMinAggregateInputType;
    _max?: AvaliacaoMaxAggregateInputType;
  };

  export type AvaliacaoGroupByOutputType = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date;
    codrec_avaliacao: number;
    status_avaliacao: string;
    codpro_avaliacao: number;
    _count: AvaliacaoCountAggregateOutputType | null;
    _avg: AvaliacaoAvgAggregateOutputType | null;
    _sum: AvaliacaoSumAggregateOutputType | null;
    _min: AvaliacaoMinAggregateOutputType | null;
    _max: AvaliacaoMaxAggregateOutputType | null;
  };

  type GetAvaliacaoGroupByPayload<T extends avaliacaoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AvaliacaoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AvaliacaoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
            : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>;
        }
      >
    >;

  export type avaliacaoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_avaliacao?: boolean;
      anomes_avaliacao?: boolean;
      data_avaliacao?: boolean;
      codrec_avaliacao?: boolean;
      status_avaliacao?: boolean;
      codpro_avaliacao?: boolean;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
      avaliado?: boolean | avaliacao$avaliadoArgs<ExtArgs>;
      _count?: boolean | AvaliacaoCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['avaliacao']
  >;

  export type avaliacaoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_avaliacao?: boolean;
      anomes_avaliacao?: boolean;
      data_avaliacao?: boolean;
      codrec_avaliacao?: boolean;
      status_avaliacao?: boolean;
      codpro_avaliacao?: boolean;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['avaliacao']
  >;

  export type avaliacaoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_avaliacao?: boolean;
      anomes_avaliacao?: boolean;
      data_avaliacao?: boolean;
      codrec_avaliacao?: boolean;
      status_avaliacao?: boolean;
      codpro_avaliacao?: boolean;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['avaliacao']
  >;

  export type avaliacaoSelectScalar = {
    cod_avaliacao?: boolean;
    anomes_avaliacao?: boolean;
    data_avaliacao?: boolean;
    codrec_avaliacao?: boolean;
    status_avaliacao?: boolean;
    codpro_avaliacao?: boolean;
  };

  export type avaliacaoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_avaliacao'
    | 'anomes_avaliacao'
    | 'data_avaliacao'
    | 'codrec_avaliacao'
    | 'status_avaliacao'
    | 'codpro_avaliacao',
    ExtArgs['result']['avaliacao']
  >;
  export type avaliacaoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    avaliado?: boolean | avaliacao$avaliadoArgs<ExtArgs>;
    _count?: boolean | AvaliacaoCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type avaliacaoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
  };
  export type avaliacaoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
  };

  export type $avaliacaoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'avaliacao';
    objects: {
      projeto: Prisma.$projetoPayload<ExtArgs>;
      avaliado: Prisma.$avaliadoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_avaliacao: number;
        anomes_avaliacao: string;
        data_avaliacao: Date;
        codrec_avaliacao: number;
        status_avaliacao: string;
        codpro_avaliacao: number;
      },
      ExtArgs['result']['avaliacao']
    >;
    composites: {};
  };

  type avaliacaoGetPayload<
    S extends boolean | null | undefined | avaliacaoDefaultArgs,
  > = $Result.GetResult<Prisma.$avaliacaoPayload, S>;

  type avaliacaoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    avaliacaoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AvaliacaoCountAggregateInputType | true;
  };

  export interface avaliacaoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['avaliacao'];
      meta: { name: 'avaliacao' };
    };
    /**
     * Find zero or one Avaliacao that matches the filter.
     * @param {avaliacaoFindUniqueArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends avaliacaoFindUniqueArgs>(
      args: SelectSubset<T, avaliacaoFindUniqueArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Avaliacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {avaliacaoFindUniqueOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends avaliacaoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, avaliacaoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Avaliacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacaoFindFirstArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends avaliacaoFindFirstArgs>(
      args?: SelectSubset<T, avaliacaoFindFirstArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Avaliacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacaoFindFirstOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends avaliacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, avaliacaoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Avaliacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany()
     *
     * // Get first 10 Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany({ take: 10 })
     *
     * // Only select the `cod_avaliacao`
     * const avaliacaoWithCod_avaliacaoOnly = await prisma.avaliacao.findMany({ select: { cod_avaliacao: true } })
     *
     */
    findMany<T extends avaliacaoFindManyArgs>(
      args?: SelectSubset<T, avaliacaoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Avaliacao.
     * @param {avaliacaoCreateArgs} args - Arguments to create a Avaliacao.
     * @example
     * // Create one Avaliacao
     * const Avaliacao = await prisma.avaliacao.create({
     *   data: {
     *     // ... data to create a Avaliacao
     *   }
     * })
     *
     */
    create<T extends avaliacaoCreateArgs>(
      args: SelectSubset<T, avaliacaoCreateArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Avaliacaos.
     * @param {avaliacaoCreateManyArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends avaliacaoCreateManyArgs>(
      args?: SelectSubset<T, avaliacaoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Avaliacaos and returns the data saved in the database.
     * @param {avaliacaoCreateManyAndReturnArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Avaliacaos and only return the `cod_avaliacao`
     * const avaliacaoWithCod_avaliacaoOnly = await prisma.avaliacao.createManyAndReturn({
     *   select: { cod_avaliacao: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends avaliacaoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, avaliacaoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Avaliacao.
     * @param {avaliacaoDeleteArgs} args - Arguments to delete one Avaliacao.
     * @example
     * // Delete one Avaliacao
     * const Avaliacao = await prisma.avaliacao.delete({
     *   where: {
     *     // ... filter to delete one Avaliacao
     *   }
     * })
     *
     */
    delete<T extends avaliacaoDeleteArgs>(
      args: SelectSubset<T, avaliacaoDeleteArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Avaliacao.
     * @param {avaliacaoUpdateArgs} args - Arguments to update one Avaliacao.
     * @example
     * // Update one Avaliacao
     * const avaliacao = await prisma.avaliacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends avaliacaoUpdateArgs>(
      args: SelectSubset<T, avaliacaoUpdateArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Avaliacaos.
     * @param {avaliacaoDeleteManyArgs} args - Arguments to filter Avaliacaos to delete.
     * @example
     * // Delete a few Avaliacaos
     * const { count } = await prisma.avaliacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends avaliacaoDeleteManyArgs>(
      args?: SelectSubset<T, avaliacaoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends avaliacaoUpdateManyArgs>(
      args: SelectSubset<T, avaliacaoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Avaliacaos and returns the data updated in the database.
     * @param {avaliacaoUpdateManyAndReturnArgs} args - Arguments to update many Avaliacaos.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Avaliacaos and only return the `cod_avaliacao`
     * const avaliacaoWithCod_avaliacaoOnly = await prisma.avaliacao.updateManyAndReturn({
     *   select: { cod_avaliacao: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends avaliacaoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, avaliacaoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Avaliacao.
     * @param {avaliacaoUpsertArgs} args - Arguments to update or create a Avaliacao.
     * @example
     * // Update or create a Avaliacao
     * const avaliacao = await prisma.avaliacao.upsert({
     *   create: {
     *     // ... data to create a Avaliacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avaliacao we want to update
     *   }
     * })
     */
    upsert<T extends avaliacaoUpsertArgs>(
      args: SelectSubset<T, avaliacaoUpsertArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      $Result.GetResult<
        Prisma.$avaliacaoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacaoCountArgs} args - Arguments to filter Avaliacaos to count.
     * @example
     * // Count the number of Avaliacaos
     * const count = await prisma.avaliacao.count({
     *   where: {
     *     // ... the filter for the Avaliacaos we want to count
     *   }
     * })
     **/
    count<T extends avaliacaoCountArgs>(
      args?: Subset<T, avaliacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvaliacaoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AvaliacaoAggregateArgs>(
      args: Subset<T, AvaliacaoAggregateArgs>,
    ): Prisma.PrismaPromise<GetAvaliacaoAggregateType<T>>;

    /**
     * Group by Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends avaliacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: avaliacaoGroupByArgs['orderBy'] }
        : { orderBy?: avaliacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, avaliacaoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAvaliacaoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the avaliacao model
     */
    readonly fields: avaliacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for avaliacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__avaliacaoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, projetoDefaultArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      | $Result.GetResult<
          Prisma.$projetoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    avaliado<T extends avaliacao$avaliadoArgs<ExtArgs> = {}>(
      args?: Subset<T, avaliacao$avaliadoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$avaliadoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the avaliacao model
   */
  interface avaliacaoFieldRefs {
    readonly cod_avaliacao: FieldRef<'avaliacao', 'Int'>;
    readonly anomes_avaliacao: FieldRef<'avaliacao', 'String'>;
    readonly data_avaliacao: FieldRef<'avaliacao', 'DateTime'>;
    readonly codrec_avaliacao: FieldRef<'avaliacao', 'Int'>;
    readonly status_avaliacao: FieldRef<'avaliacao', 'String'>;
    readonly codpro_avaliacao: FieldRef<'avaliacao', 'Int'>;
  }

  // Custom InputTypes
  /**
   * avaliacao findUnique
   */
  export type avaliacaoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliacao to fetch.
     */
    where: avaliacaoWhereUniqueInput;
  };

  /**
   * avaliacao findUniqueOrThrow
   */
  export type avaliacaoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliacao to fetch.
     */
    where: avaliacaoWhereUniqueInput;
  };

  /**
   * avaliacao findFirst
   */
  export type avaliacaoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliacao to fetch.
     */
    where?: avaliacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliacaos to fetch.
     */
    orderBy?:
      | avaliacaoOrderByWithRelationInput
      | avaliacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for avaliacaos.
     */
    cursor?: avaliacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliacaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[];
  };

  /**
   * avaliacao findFirstOrThrow
   */
  export type avaliacaoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliacao to fetch.
     */
    where?: avaliacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliacaos to fetch.
     */
    orderBy?:
      | avaliacaoOrderByWithRelationInput
      | avaliacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for avaliacaos.
     */
    cursor?: avaliacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliacaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[];
  };

  /**
   * avaliacao findMany
   */
  export type avaliacaoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliacaos to fetch.
     */
    where?: avaliacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliacaos to fetch.
     */
    orderBy?:
      | avaliacaoOrderByWithRelationInput
      | avaliacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing avaliacaos.
     */
    cursor?: avaliacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliacaos.
     */
    skip?: number;
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[];
  };

  /**
   * avaliacao create
   */
  export type avaliacaoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * The data needed to create a avaliacao.
     */
    data: XOR<avaliacaoCreateInput, avaliacaoUncheckedCreateInput>;
  };

  /**
   * avaliacao createMany
   */
  export type avaliacaoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many avaliacaos.
     */
    data: avaliacaoCreateManyInput | avaliacaoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * avaliacao createManyAndReturn
   */
  export type avaliacaoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * The data used to create many avaliacaos.
     */
    data: avaliacaoCreateManyInput | avaliacaoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * avaliacao update
   */
  export type avaliacaoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * The data needed to update a avaliacao.
     */
    data: XOR<avaliacaoUpdateInput, avaliacaoUncheckedUpdateInput>;
    /**
     * Choose, which avaliacao to update.
     */
    where: avaliacaoWhereUniqueInput;
  };

  /**
   * avaliacao updateMany
   */
  export type avaliacaoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update avaliacaos.
     */
    data: XOR<
      avaliacaoUpdateManyMutationInput,
      avaliacaoUncheckedUpdateManyInput
    >;
    /**
     * Filter which avaliacaos to update
     */
    where?: avaliacaoWhereInput;
    /**
     * Limit how many avaliacaos to update.
     */
    limit?: number;
  };

  /**
   * avaliacao updateManyAndReturn
   */
  export type avaliacaoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * The data used to update avaliacaos.
     */
    data: XOR<
      avaliacaoUpdateManyMutationInput,
      avaliacaoUncheckedUpdateManyInput
    >;
    /**
     * Filter which avaliacaos to update
     */
    where?: avaliacaoWhereInput;
    /**
     * Limit how many avaliacaos to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * avaliacao upsert
   */
  export type avaliacaoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * The filter to search for the avaliacao to update in case it exists.
     */
    where: avaliacaoWhereUniqueInput;
    /**
     * In case the avaliacao found by the `where` argument doesn't exist, create a new avaliacao with this data.
     */
    create: XOR<avaliacaoCreateInput, avaliacaoUncheckedCreateInput>;
    /**
     * In case the avaliacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<avaliacaoUpdateInput, avaliacaoUncheckedUpdateInput>;
  };

  /**
   * avaliacao delete
   */
  export type avaliacaoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    /**
     * Filter which avaliacao to delete.
     */
    where: avaliacaoWhereUniqueInput;
  };

  /**
   * avaliacao deleteMany
   */
  export type avaliacaoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which avaliacaos to delete
     */
    where?: avaliacaoWhereInput;
    /**
     * Limit how many avaliacaos to delete.
     */
    limit?: number;
  };

  /**
   * avaliacao.avaliado
   */
  export type avaliacao$avaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    where?: avaliadoWhereInput;
    orderBy?:
      | avaliadoOrderByWithRelationInput
      | avaliadoOrderByWithRelationInput[];
    cursor?: avaliadoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AvaliadoScalarFieldEnum | AvaliadoScalarFieldEnum[];
  };

  /**
   * avaliacao without action
   */
  export type avaliacaoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
  };

  /**
   * Model avaliado
   */

  export type AggregateAvaliado = {
    _count: AvaliadoCountAggregateOutputType | null;
    _avg: AvaliadoAvgAggregateOutputType | null;
    _sum: AvaliadoSumAggregateOutputType | null;
    _min: AvaliadoMinAggregateOutputType | null;
    _max: AvaliadoMaxAggregateOutputType | null;
  };

  export type AvaliadoAvgAggregateOutputType = {
    codaval_avaliado: number | null;
    codrec_avaliado: number | null;
  };

  export type AvaliadoSumAggregateOutputType = {
    codaval_avaliado: number | null;
    codrec_avaliado: number | null;
  };

  export type AvaliadoMinAggregateOutputType = {
    codaval_avaliado: number | null;
    codrec_avaliado: number | null;
    status_avaliado: string | null;
    data_avaliado: Date | null;
    hora_avaliado: string | null;
    usuario_avaliado: string | null;
  };

  export type AvaliadoMaxAggregateOutputType = {
    codaval_avaliado: number | null;
    codrec_avaliado: number | null;
    status_avaliado: string | null;
    data_avaliado: Date | null;
    hora_avaliado: string | null;
    usuario_avaliado: string | null;
  };

  export type AvaliadoCountAggregateOutputType = {
    codaval_avaliado: number;
    codrec_avaliado: number;
    status_avaliado: number;
    data_avaliado: number;
    hora_avaliado: number;
    usuario_avaliado: number;
    _all: number;
  };

  export type AvaliadoAvgAggregateInputType = {
    codaval_avaliado?: true;
    codrec_avaliado?: true;
  };

  export type AvaliadoSumAggregateInputType = {
    codaval_avaliado?: true;
    codrec_avaliado?: true;
  };

  export type AvaliadoMinAggregateInputType = {
    codaval_avaliado?: true;
    codrec_avaliado?: true;
    status_avaliado?: true;
    data_avaliado?: true;
    hora_avaliado?: true;
    usuario_avaliado?: true;
  };

  export type AvaliadoMaxAggregateInputType = {
    codaval_avaliado?: true;
    codrec_avaliado?: true;
    status_avaliado?: true;
    data_avaliado?: true;
    hora_avaliado?: true;
    usuario_avaliado?: true;
  };

  export type AvaliadoCountAggregateInputType = {
    codaval_avaliado?: true;
    codrec_avaliado?: true;
    status_avaliado?: true;
    data_avaliado?: true;
    hora_avaliado?: true;
    usuario_avaliado?: true;
    _all?: true;
  };

  export type AvaliadoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which avaliado to aggregate.
     */
    where?: avaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliados to fetch.
     */
    orderBy?:
      | avaliadoOrderByWithRelationInput
      | avaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: avaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned avaliados
     **/
    _count?: true | AvaliadoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AvaliadoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AvaliadoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AvaliadoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AvaliadoMaxAggregateInputType;
  };

  export type GetAvaliadoAggregateType<T extends AvaliadoAggregateArgs> = {
    [P in keyof T & keyof AggregateAvaliado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvaliado[P]>
      : GetScalarType<T[P], AggregateAvaliado[P]>;
  };

  export type avaliadoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: avaliadoWhereInput;
    orderBy?:
      | avaliadoOrderByWithAggregationInput
      | avaliadoOrderByWithAggregationInput[];
    by: AvaliadoScalarFieldEnum[] | AvaliadoScalarFieldEnum;
    having?: avaliadoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AvaliadoCountAggregateInputType | true;
    _avg?: AvaliadoAvgAggregateInputType;
    _sum?: AvaliadoSumAggregateInputType;
    _min?: AvaliadoMinAggregateInputType;
    _max?: AvaliadoMaxAggregateInputType;
  };

  export type AvaliadoGroupByOutputType = {
    codaval_avaliado: number;
    codrec_avaliado: number;
    status_avaliado: string;
    data_avaliado: Date | null;
    hora_avaliado: string | null;
    usuario_avaliado: string | null;
    _count: AvaliadoCountAggregateOutputType | null;
    _avg: AvaliadoAvgAggregateOutputType | null;
    _sum: AvaliadoSumAggregateOutputType | null;
    _min: AvaliadoMinAggregateOutputType | null;
    _max: AvaliadoMaxAggregateOutputType | null;
  };

  type GetAvaliadoGroupByPayload<T extends avaliadoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AvaliadoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AvaliadoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvaliadoGroupByOutputType[P]>
            : GetScalarType<T[P], AvaliadoGroupByOutputType[P]>;
        }
      >
    >;

  export type avaliadoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codaval_avaliado?: boolean;
      codrec_avaliado?: boolean;
      status_avaliado?: boolean;
      data_avaliado?: boolean;
      hora_avaliado?: boolean;
      usuario_avaliado?: boolean;
      avaliacao?: boolean | avaliacaoDefaultArgs<ExtArgs>;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
      itavaliado?: boolean | avaliado$itavaliadoArgs<ExtArgs>;
      _count?: boolean | AvaliadoCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['avaliado']
  >;

  export type avaliadoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codaval_avaliado?: boolean;
      codrec_avaliado?: boolean;
      status_avaliado?: boolean;
      data_avaliado?: boolean;
      hora_avaliado?: boolean;
      usuario_avaliado?: boolean;
      avaliacao?: boolean | avaliacaoDefaultArgs<ExtArgs>;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['avaliado']
  >;

  export type avaliadoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codaval_avaliado?: boolean;
      codrec_avaliado?: boolean;
      status_avaliado?: boolean;
      data_avaliado?: boolean;
      hora_avaliado?: boolean;
      usuario_avaliado?: boolean;
      avaliacao?: boolean | avaliacaoDefaultArgs<ExtArgs>;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['avaliado']
  >;

  export type avaliadoSelectScalar = {
    codaval_avaliado?: boolean;
    codrec_avaliado?: boolean;
    status_avaliado?: boolean;
    data_avaliado?: boolean;
    hora_avaliado?: boolean;
    usuario_avaliado?: boolean;
  };

  export type avaliadoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'codaval_avaliado'
    | 'codrec_avaliado'
    | 'status_avaliado'
    | 'data_avaliado'
    | 'hora_avaliado'
    | 'usuario_avaliado',
    ExtArgs['result']['avaliado']
  >;
  export type avaliadoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliacao?: boolean | avaliacaoDefaultArgs<ExtArgs>;
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    itavaliado?: boolean | avaliado$itavaliadoArgs<ExtArgs>;
    _count?: boolean | AvaliadoCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type avaliadoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliacao?: boolean | avaliacaoDefaultArgs<ExtArgs>;
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
  };
  export type avaliadoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliacao?: boolean | avaliacaoDefaultArgs<ExtArgs>;
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
  };

  export type $avaliadoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'avaliado';
    objects: {
      avaliacao: Prisma.$avaliacaoPayload<ExtArgs>;
      recurso: Prisma.$recursoPayload<ExtArgs>;
      itavaliado: Prisma.$itavaliadoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        codaval_avaliado: number;
        codrec_avaliado: number;
        status_avaliado: string;
        data_avaliado: Date | null;
        hora_avaliado: string | null;
        usuario_avaliado: string | null;
      },
      ExtArgs['result']['avaliado']
    >;
    composites: {};
  };

  type avaliadoGetPayload<
    S extends boolean | null | undefined | avaliadoDefaultArgs,
  > = $Result.GetResult<Prisma.$avaliadoPayload, S>;

  type avaliadoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<avaliadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AvaliadoCountAggregateInputType | true;
  };

  export interface avaliadoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['avaliado'];
      meta: { name: 'avaliado' };
    };
    /**
     * Find zero or one Avaliado that matches the filter.
     * @param {avaliadoFindUniqueArgs} args - Arguments to find a Avaliado
     * @example
     * // Get one Avaliado
     * const avaliado = await prisma.avaliado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends avaliadoFindUniqueArgs>(
      args: SelectSubset<T, avaliadoFindUniqueArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Avaliado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {avaliadoFindUniqueOrThrowArgs} args - Arguments to find a Avaliado
     * @example
     * // Get one Avaliado
     * const avaliado = await prisma.avaliado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends avaliadoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, avaliadoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Avaliado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliadoFindFirstArgs} args - Arguments to find a Avaliado
     * @example
     * // Get one Avaliado
     * const avaliado = await prisma.avaliado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends avaliadoFindFirstArgs>(
      args?: SelectSubset<T, avaliadoFindFirstArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Avaliado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliadoFindFirstOrThrowArgs} args - Arguments to find a Avaliado
     * @example
     * // Get one Avaliado
     * const avaliado = await prisma.avaliado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends avaliadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, avaliadoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Avaliados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avaliados
     * const avaliados = await prisma.avaliado.findMany()
     *
     * // Get first 10 Avaliados
     * const avaliados = await prisma.avaliado.findMany({ take: 10 })
     *
     * // Only select the `codaval_avaliado`
     * const avaliadoWithCodaval_avaliadoOnly = await prisma.avaliado.findMany({ select: { codaval_avaliado: true } })
     *
     */
    findMany<T extends avaliadoFindManyArgs>(
      args?: SelectSubset<T, avaliadoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Avaliado.
     * @param {avaliadoCreateArgs} args - Arguments to create a Avaliado.
     * @example
     * // Create one Avaliado
     * const Avaliado = await prisma.avaliado.create({
     *   data: {
     *     // ... data to create a Avaliado
     *   }
     * })
     *
     */
    create<T extends avaliadoCreateArgs>(
      args: SelectSubset<T, avaliadoCreateArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Avaliados.
     * @param {avaliadoCreateManyArgs} args - Arguments to create many Avaliados.
     * @example
     * // Create many Avaliados
     * const avaliado = await prisma.avaliado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends avaliadoCreateManyArgs>(
      args?: SelectSubset<T, avaliadoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Avaliados and returns the data saved in the database.
     * @param {avaliadoCreateManyAndReturnArgs} args - Arguments to create many Avaliados.
     * @example
     * // Create many Avaliados
     * const avaliado = await prisma.avaliado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Avaliados and only return the `codaval_avaliado`
     * const avaliadoWithCodaval_avaliadoOnly = await prisma.avaliado.createManyAndReturn({
     *   select: { codaval_avaliado: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends avaliadoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, avaliadoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Avaliado.
     * @param {avaliadoDeleteArgs} args - Arguments to delete one Avaliado.
     * @example
     * // Delete one Avaliado
     * const Avaliado = await prisma.avaliado.delete({
     *   where: {
     *     // ... filter to delete one Avaliado
     *   }
     * })
     *
     */
    delete<T extends avaliadoDeleteArgs>(
      args: SelectSubset<T, avaliadoDeleteArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Avaliado.
     * @param {avaliadoUpdateArgs} args - Arguments to update one Avaliado.
     * @example
     * // Update one Avaliado
     * const avaliado = await prisma.avaliado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends avaliadoUpdateArgs>(
      args: SelectSubset<T, avaliadoUpdateArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Avaliados.
     * @param {avaliadoDeleteManyArgs} args - Arguments to filter Avaliados to delete.
     * @example
     * // Delete a few Avaliados
     * const { count } = await prisma.avaliado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends avaliadoDeleteManyArgs>(
      args?: SelectSubset<T, avaliadoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Avaliados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avaliados
     * const avaliado = await prisma.avaliado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends avaliadoUpdateManyArgs>(
      args: SelectSubset<T, avaliadoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Avaliados and returns the data updated in the database.
     * @param {avaliadoUpdateManyAndReturnArgs} args - Arguments to update many Avaliados.
     * @example
     * // Update many Avaliados
     * const avaliado = await prisma.avaliado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Avaliados and only return the `codaval_avaliado`
     * const avaliadoWithCodaval_avaliadoOnly = await prisma.avaliado.updateManyAndReturn({
     *   select: { codaval_avaliado: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends avaliadoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, avaliadoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Avaliado.
     * @param {avaliadoUpsertArgs} args - Arguments to update or create a Avaliado.
     * @example
     * // Update or create a Avaliado
     * const avaliado = await prisma.avaliado.upsert({
     *   create: {
     *     // ... data to create a Avaliado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avaliado we want to update
     *   }
     * })
     */
    upsert<T extends avaliadoUpsertArgs>(
      args: SelectSubset<T, avaliadoUpsertArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      $Result.GetResult<
        Prisma.$avaliadoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Avaliados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliadoCountArgs} args - Arguments to filter Avaliados to count.
     * @example
     * // Count the number of Avaliados
     * const count = await prisma.avaliado.count({
     *   where: {
     *     // ... the filter for the Avaliados we want to count
     *   }
     * })
     **/
    count<T extends avaliadoCountArgs>(
      args?: Subset<T, avaliadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvaliadoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Avaliado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AvaliadoAggregateArgs>(
      args: Subset<T, AvaliadoAggregateArgs>,
    ): Prisma.PrismaPromise<GetAvaliadoAggregateType<T>>;

    /**
     * Group by Avaliado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {avaliadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends avaliadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: avaliadoGroupByArgs['orderBy'] }
        : { orderBy?: avaliadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, avaliadoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAvaliadoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the avaliado model
     */
    readonly fields: avaliadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for avaliado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__avaliadoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    avaliacao<T extends avaliacaoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, avaliacaoDefaultArgs<ExtArgs>>,
    ): Prisma__avaliacaoClient<
      | $Result.GetResult<
          Prisma.$avaliacaoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    recurso<T extends recursoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, recursoDefaultArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      | $Result.GetResult<
          Prisma.$recursoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    itavaliado<T extends avaliado$itavaliadoArgs<ExtArgs> = {}>(
      args?: Subset<T, avaliado$itavaliadoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$itavaliadoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the avaliado model
   */
  interface avaliadoFieldRefs {
    readonly codaval_avaliado: FieldRef<'avaliado', 'Int'>;
    readonly codrec_avaliado: FieldRef<'avaliado', 'Int'>;
    readonly status_avaliado: FieldRef<'avaliado', 'String'>;
    readonly data_avaliado: FieldRef<'avaliado', 'DateTime'>;
    readonly hora_avaliado: FieldRef<'avaliado', 'String'>;
    readonly usuario_avaliado: FieldRef<'avaliado', 'String'>;
  }

  // Custom InputTypes
  /**
   * avaliado findUnique
   */
  export type avaliadoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliado to fetch.
     */
    where: avaliadoWhereUniqueInput;
  };

  /**
   * avaliado findUniqueOrThrow
   */
  export type avaliadoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliado to fetch.
     */
    where: avaliadoWhereUniqueInput;
  };

  /**
   * avaliado findFirst
   */
  export type avaliadoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliado to fetch.
     */
    where?: avaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliados to fetch.
     */
    orderBy?:
      | avaliadoOrderByWithRelationInput
      | avaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for avaliados.
     */
    cursor?: avaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of avaliados.
     */
    distinct?: AvaliadoScalarFieldEnum | AvaliadoScalarFieldEnum[];
  };

  /**
   * avaliado findFirstOrThrow
   */
  export type avaliadoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliado to fetch.
     */
    where?: avaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliados to fetch.
     */
    orderBy?:
      | avaliadoOrderByWithRelationInput
      | avaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for avaliados.
     */
    cursor?: avaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of avaliados.
     */
    distinct?: AvaliadoScalarFieldEnum | AvaliadoScalarFieldEnum[];
  };

  /**
   * avaliado findMany
   */
  export type avaliadoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which avaliados to fetch.
     */
    where?: avaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of avaliados to fetch.
     */
    orderBy?:
      | avaliadoOrderByWithRelationInput
      | avaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing avaliados.
     */
    cursor?: avaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` avaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` avaliados.
     */
    skip?: number;
    distinct?: AvaliadoScalarFieldEnum | AvaliadoScalarFieldEnum[];
  };

  /**
   * avaliado create
   */
  export type avaliadoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * The data needed to create a avaliado.
     */
    data: XOR<avaliadoCreateInput, avaliadoUncheckedCreateInput>;
  };

  /**
   * avaliado createMany
   */
  export type avaliadoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many avaliados.
     */
    data: avaliadoCreateManyInput | avaliadoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * avaliado createManyAndReturn
   */
  export type avaliadoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * The data used to create many avaliados.
     */
    data: avaliadoCreateManyInput | avaliadoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * avaliado update
   */
  export type avaliadoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * The data needed to update a avaliado.
     */
    data: XOR<avaliadoUpdateInput, avaliadoUncheckedUpdateInput>;
    /**
     * Choose, which avaliado to update.
     */
    where: avaliadoWhereUniqueInput;
  };

  /**
   * avaliado updateMany
   */
  export type avaliadoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update avaliados.
     */
    data: XOR<
      avaliadoUpdateManyMutationInput,
      avaliadoUncheckedUpdateManyInput
    >;
    /**
     * Filter which avaliados to update
     */
    where?: avaliadoWhereInput;
    /**
     * Limit how many avaliados to update.
     */
    limit?: number;
  };

  /**
   * avaliado updateManyAndReturn
   */
  export type avaliadoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * The data used to update avaliados.
     */
    data: XOR<
      avaliadoUpdateManyMutationInput,
      avaliadoUncheckedUpdateManyInput
    >;
    /**
     * Filter which avaliados to update
     */
    where?: avaliadoWhereInput;
    /**
     * Limit how many avaliados to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * avaliado upsert
   */
  export type avaliadoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * The filter to search for the avaliado to update in case it exists.
     */
    where: avaliadoWhereUniqueInput;
    /**
     * In case the avaliado found by the `where` argument doesn't exist, create a new avaliado with this data.
     */
    create: XOR<avaliadoCreateInput, avaliadoUncheckedCreateInput>;
    /**
     * In case the avaliado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<avaliadoUpdateInput, avaliadoUncheckedUpdateInput>;
  };

  /**
   * avaliado delete
   */
  export type avaliadoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    /**
     * Filter which avaliado to delete.
     */
    where: avaliadoWhereUniqueInput;
  };

  /**
   * avaliado deleteMany
   */
  export type avaliadoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which avaliados to delete
     */
    where?: avaliadoWhereInput;
    /**
     * Limit how many avaliados to delete.
     */
    limit?: number;
  };

  /**
   * avaliado.itavaliado
   */
  export type avaliado$itavaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    where?: itavaliadoWhereInput;
    orderBy?:
      | itavaliadoOrderByWithRelationInput
      | itavaliadoOrderByWithRelationInput[];
    cursor?: itavaliadoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItavaliadoScalarFieldEnum | ItavaliadoScalarFieldEnum[];
  };

  /**
   * avaliado without action
   */
  export type avaliadoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
  };

  /**
   * Model chamado
   */

  export type AggregateChamado = {
    _count: ChamadoCountAggregateOutputType | null;
    _avg: ChamadoAvgAggregateOutputType | null;
    _sum: ChamadoSumAggregateOutputType | null;
    _min: ChamadoMinAggregateOutputType | null;
    _max: ChamadoMaxAggregateOutputType | null;
  };

  export type ChamadoAvgAggregateOutputType = {
    cod_chamado: number | null;
    cod_recurso: number | null;
    codtrf_chamado: number | null;
    cod_cliente: number | null;
    prior_chamado: number | null;
    cod_classificacao: number | null;
  };

  export type ChamadoSumAggregateOutputType = {
    cod_chamado: number | null;
    cod_recurso: number | null;
    codtrf_chamado: number | null;
    cod_cliente: number | null;
    prior_chamado: number | null;
    cod_classificacao: number | null;
  };

  export type ChamadoMinAggregateOutputType = {
    cod_chamado: number | null;
    data_chamado: Date | null;
    hora_chamado: string | null;
    solicitacao_chamado: Uint8Array | null;
    conclusao_chamado: Date | null;
    status_chamado: string | null;
    dtenvio_chamado: string | null;
    cod_recurso: number | null;
    cliente_chamado: string | null;
    codtrf_chamado: number | null;
    cod_cliente: number | null;
    solicitacao2_chamado: Uint8Array | null;
    assunto_chamado: string | null;
    email_chamado: string | null;
    prior_chamado: number | null;
    cod_classificacao: number | null;
  };

  export type ChamadoMaxAggregateOutputType = {
    cod_chamado: number | null;
    data_chamado: Date | null;
    hora_chamado: string | null;
    solicitacao_chamado: Uint8Array | null;
    conclusao_chamado: Date | null;
    status_chamado: string | null;
    dtenvio_chamado: string | null;
    cod_recurso: number | null;
    cliente_chamado: string | null;
    codtrf_chamado: number | null;
    cod_cliente: number | null;
    solicitacao2_chamado: Uint8Array | null;
    assunto_chamado: string | null;
    email_chamado: string | null;
    prior_chamado: number | null;
    cod_classificacao: number | null;
  };

  export type ChamadoCountAggregateOutputType = {
    cod_chamado: number;
    data_chamado: number;
    hora_chamado: number;
    solicitacao_chamado: number;
    conclusao_chamado: number;
    status_chamado: number;
    dtenvio_chamado: number;
    cod_recurso: number;
    cliente_chamado: number;
    codtrf_chamado: number;
    cod_cliente: number;
    solicitacao2_chamado: number;
    assunto_chamado: number;
    email_chamado: number;
    prior_chamado: number;
    cod_classificacao: number;
    _all: number;
  };

  export type ChamadoAvgAggregateInputType = {
    cod_chamado?: true;
    cod_recurso?: true;
    codtrf_chamado?: true;
    cod_cliente?: true;
    prior_chamado?: true;
    cod_classificacao?: true;
  };

  export type ChamadoSumAggregateInputType = {
    cod_chamado?: true;
    cod_recurso?: true;
    codtrf_chamado?: true;
    cod_cliente?: true;
    prior_chamado?: true;
    cod_classificacao?: true;
  };

  export type ChamadoMinAggregateInputType = {
    cod_chamado?: true;
    data_chamado?: true;
    hora_chamado?: true;
    solicitacao_chamado?: true;
    conclusao_chamado?: true;
    status_chamado?: true;
    dtenvio_chamado?: true;
    cod_recurso?: true;
    cliente_chamado?: true;
    codtrf_chamado?: true;
    cod_cliente?: true;
    solicitacao2_chamado?: true;
    assunto_chamado?: true;
    email_chamado?: true;
    prior_chamado?: true;
    cod_classificacao?: true;
  };

  export type ChamadoMaxAggregateInputType = {
    cod_chamado?: true;
    data_chamado?: true;
    hora_chamado?: true;
    solicitacao_chamado?: true;
    conclusao_chamado?: true;
    status_chamado?: true;
    dtenvio_chamado?: true;
    cod_recurso?: true;
    cliente_chamado?: true;
    codtrf_chamado?: true;
    cod_cliente?: true;
    solicitacao2_chamado?: true;
    assunto_chamado?: true;
    email_chamado?: true;
    prior_chamado?: true;
    cod_classificacao?: true;
  };

  export type ChamadoCountAggregateInputType = {
    cod_chamado?: true;
    data_chamado?: true;
    hora_chamado?: true;
    solicitacao_chamado?: true;
    conclusao_chamado?: true;
    status_chamado?: true;
    dtenvio_chamado?: true;
    cod_recurso?: true;
    cliente_chamado?: true;
    codtrf_chamado?: true;
    cod_cliente?: true;
    solicitacao2_chamado?: true;
    assunto_chamado?: true;
    email_chamado?: true;
    prior_chamado?: true;
    cod_classificacao?: true;
    _all?: true;
  };

  export type ChamadoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which chamado to aggregate.
     */
    where?: chamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of chamados to fetch.
     */
    orderBy?:
      | chamadoOrderByWithRelationInput
      | chamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: chamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` chamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` chamados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned chamados
     **/
    _count?: true | ChamadoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ChamadoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ChamadoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ChamadoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ChamadoMaxAggregateInputType;
  };

  export type GetChamadoAggregateType<T extends ChamadoAggregateArgs> = {
    [P in keyof T & keyof AggregateChamado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChamado[P]>
      : GetScalarType<T[P], AggregateChamado[P]>;
  };

  export type chamadoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: chamadoWhereInput;
    orderBy?:
      | chamadoOrderByWithAggregationInput
      | chamadoOrderByWithAggregationInput[];
    by: ChamadoScalarFieldEnum[] | ChamadoScalarFieldEnum;
    having?: chamadoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ChamadoCountAggregateInputType | true;
    _avg?: ChamadoAvgAggregateInputType;
    _sum?: ChamadoSumAggregateInputType;
    _min?: ChamadoMinAggregateInputType;
    _max?: ChamadoMaxAggregateInputType;
  };

  export type ChamadoGroupByOutputType = {
    cod_chamado: number;
    data_chamado: Date;
    hora_chamado: string;
    solicitacao_chamado: Uint8Array | null;
    conclusao_chamado: Date | null;
    status_chamado: string;
    dtenvio_chamado: string | null;
    cod_recurso: number | null;
    cliente_chamado: string | null;
    codtrf_chamado: number | null;
    cod_cliente: number | null;
    solicitacao2_chamado: Uint8Array | null;
    assunto_chamado: string | null;
    email_chamado: string | null;
    prior_chamado: number | null;
    cod_classificacao: number | null;
    _count: ChamadoCountAggregateOutputType | null;
    _avg: ChamadoAvgAggregateOutputType | null;
    _sum: ChamadoSumAggregateOutputType | null;
    _min: ChamadoMinAggregateOutputType | null;
    _max: ChamadoMaxAggregateOutputType | null;
  };

  type GetChamadoGroupByPayload<T extends chamadoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ChamadoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ChamadoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChamadoGroupByOutputType[P]>
            : GetScalarType<T[P], ChamadoGroupByOutputType[P]>;
        }
      >
    >;

  export type chamadoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_chamado?: boolean;
      data_chamado?: boolean;
      hora_chamado?: boolean;
      solicitacao_chamado?: boolean;
      conclusao_chamado?: boolean;
      status_chamado?: boolean;
      dtenvio_chamado?: boolean;
      cod_recurso?: boolean;
      cliente_chamado?: boolean;
      codtrf_chamado?: boolean;
      cod_cliente?: boolean;
      solicitacao2_chamado?: boolean;
      assunto_chamado?: boolean;
      email_chamado?: boolean;
      prior_chamado?: boolean;
      cod_classificacao?: boolean;
      cliente?: boolean | chamado$clienteArgs<ExtArgs>;
      recurso?: boolean | chamado$recursoArgs<ExtArgs>;
    },
    ExtArgs['result']['chamado']
  >;

  export type chamadoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_chamado?: boolean;
      data_chamado?: boolean;
      hora_chamado?: boolean;
      solicitacao_chamado?: boolean;
      conclusao_chamado?: boolean;
      status_chamado?: boolean;
      dtenvio_chamado?: boolean;
      cod_recurso?: boolean;
      cliente_chamado?: boolean;
      codtrf_chamado?: boolean;
      cod_cliente?: boolean;
      solicitacao2_chamado?: boolean;
      assunto_chamado?: boolean;
      email_chamado?: boolean;
      prior_chamado?: boolean;
      cod_classificacao?: boolean;
      cliente?: boolean | chamado$clienteArgs<ExtArgs>;
      recurso?: boolean | chamado$recursoArgs<ExtArgs>;
    },
    ExtArgs['result']['chamado']
  >;

  export type chamadoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_chamado?: boolean;
      data_chamado?: boolean;
      hora_chamado?: boolean;
      solicitacao_chamado?: boolean;
      conclusao_chamado?: boolean;
      status_chamado?: boolean;
      dtenvio_chamado?: boolean;
      cod_recurso?: boolean;
      cliente_chamado?: boolean;
      codtrf_chamado?: boolean;
      cod_cliente?: boolean;
      solicitacao2_chamado?: boolean;
      assunto_chamado?: boolean;
      email_chamado?: boolean;
      prior_chamado?: boolean;
      cod_classificacao?: boolean;
      cliente?: boolean | chamado$clienteArgs<ExtArgs>;
      recurso?: boolean | chamado$recursoArgs<ExtArgs>;
    },
    ExtArgs['result']['chamado']
  >;

  export type chamadoSelectScalar = {
    cod_chamado?: boolean;
    data_chamado?: boolean;
    hora_chamado?: boolean;
    solicitacao_chamado?: boolean;
    conclusao_chamado?: boolean;
    status_chamado?: boolean;
    dtenvio_chamado?: boolean;
    cod_recurso?: boolean;
    cliente_chamado?: boolean;
    codtrf_chamado?: boolean;
    cod_cliente?: boolean;
    solicitacao2_chamado?: boolean;
    assunto_chamado?: boolean;
    email_chamado?: boolean;
    prior_chamado?: boolean;
    cod_classificacao?: boolean;
  };

  export type chamadoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_chamado'
    | 'data_chamado'
    | 'hora_chamado'
    | 'solicitacao_chamado'
    | 'conclusao_chamado'
    | 'status_chamado'
    | 'dtenvio_chamado'
    | 'cod_recurso'
    | 'cliente_chamado'
    | 'codtrf_chamado'
    | 'cod_cliente'
    | 'solicitacao2_chamado'
    | 'assunto_chamado'
    | 'email_chamado'
    | 'prior_chamado'
    | 'cod_classificacao',
    ExtArgs['result']['chamado']
  >;
  export type chamadoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | chamado$clienteArgs<ExtArgs>;
    recurso?: boolean | chamado$recursoArgs<ExtArgs>;
  };
  export type chamadoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | chamado$clienteArgs<ExtArgs>;
    recurso?: boolean | chamado$recursoArgs<ExtArgs>;
  };
  export type chamadoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | chamado$clienteArgs<ExtArgs>;
    recurso?: boolean | chamado$recursoArgs<ExtArgs>;
  };

  export type $chamadoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'chamado';
    objects: {
      cliente: Prisma.$clientePayload<ExtArgs> | null;
      recurso: Prisma.$recursoPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_chamado: number;
        data_chamado: Date;
        hora_chamado: string;
        solicitacao_chamado: Uint8Array | null;
        conclusao_chamado: Date | null;
        status_chamado: string;
        dtenvio_chamado: string | null;
        cod_recurso: number | null;
        cliente_chamado: string | null;
        codtrf_chamado: number | null;
        cod_cliente: number | null;
        solicitacao2_chamado: Uint8Array | null;
        assunto_chamado: string | null;
        email_chamado: string | null;
        prior_chamado: number | null;
        cod_classificacao: number | null;
      },
      ExtArgs['result']['chamado']
    >;
    composites: {};
  };

  type chamadoGetPayload<
    S extends boolean | null | undefined | chamadoDefaultArgs,
  > = $Result.GetResult<Prisma.$chamadoPayload, S>;

  type chamadoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<chamadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ChamadoCountAggregateInputType | true;
  };

  export interface chamadoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['chamado'];
      meta: { name: 'chamado' };
    };
    /**
     * Find zero or one Chamado that matches the filter.
     * @param {chamadoFindUniqueArgs} args - Arguments to find a Chamado
     * @example
     * // Get one Chamado
     * const chamado = await prisma.chamado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chamadoFindUniqueArgs>(
      args: SelectSubset<T, chamadoFindUniqueArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Chamado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chamadoFindUniqueOrThrowArgs} args - Arguments to find a Chamado
     * @example
     * // Get one Chamado
     * const chamado = await prisma.chamado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chamadoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, chamadoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Chamado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chamadoFindFirstArgs} args - Arguments to find a Chamado
     * @example
     * // Get one Chamado
     * const chamado = await prisma.chamado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chamadoFindFirstArgs>(
      args?: SelectSubset<T, chamadoFindFirstArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Chamado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chamadoFindFirstOrThrowArgs} args - Arguments to find a Chamado
     * @example
     * // Get one Chamado
     * const chamado = await prisma.chamado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chamadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, chamadoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Chamados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chamadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chamados
     * const chamados = await prisma.chamado.findMany()
     *
     * // Get first 10 Chamados
     * const chamados = await prisma.chamado.findMany({ take: 10 })
     *
     * // Only select the `cod_chamado`
     * const chamadoWithCod_chamadoOnly = await prisma.chamado.findMany({ select: { cod_chamado: true } })
     *
     */
    findMany<T extends chamadoFindManyArgs>(
      args?: SelectSubset<T, chamadoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Chamado.
     * @param {chamadoCreateArgs} args - Arguments to create a Chamado.
     * @example
     * // Create one Chamado
     * const Chamado = await prisma.chamado.create({
     *   data: {
     *     // ... data to create a Chamado
     *   }
     * })
     *
     */
    create<T extends chamadoCreateArgs>(
      args: SelectSubset<T, chamadoCreateArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Chamados.
     * @param {chamadoCreateManyArgs} args - Arguments to create many Chamados.
     * @example
     * // Create many Chamados
     * const chamado = await prisma.chamado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends chamadoCreateManyArgs>(
      args?: SelectSubset<T, chamadoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Chamados and returns the data saved in the database.
     * @param {chamadoCreateManyAndReturnArgs} args - Arguments to create many Chamados.
     * @example
     * // Create many Chamados
     * const chamado = await prisma.chamado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Chamados and only return the `cod_chamado`
     * const chamadoWithCod_chamadoOnly = await prisma.chamado.createManyAndReturn({
     *   select: { cod_chamado: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends chamadoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, chamadoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Chamado.
     * @param {chamadoDeleteArgs} args - Arguments to delete one Chamado.
     * @example
     * // Delete one Chamado
     * const Chamado = await prisma.chamado.delete({
     *   where: {
     *     // ... filter to delete one Chamado
     *   }
     * })
     *
     */
    delete<T extends chamadoDeleteArgs>(
      args: SelectSubset<T, chamadoDeleteArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Chamado.
     * @param {chamadoUpdateArgs} args - Arguments to update one Chamado.
     * @example
     * // Update one Chamado
     * const chamado = await prisma.chamado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends chamadoUpdateArgs>(
      args: SelectSubset<T, chamadoUpdateArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Chamados.
     * @param {chamadoDeleteManyArgs} args - Arguments to filter Chamados to delete.
     * @example
     * // Delete a few Chamados
     * const { count } = await prisma.chamado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends chamadoDeleteManyArgs>(
      args?: SelectSubset<T, chamadoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Chamados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chamadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chamados
     * const chamado = await prisma.chamado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends chamadoUpdateManyArgs>(
      args: SelectSubset<T, chamadoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Chamados and returns the data updated in the database.
     * @param {chamadoUpdateManyAndReturnArgs} args - Arguments to update many Chamados.
     * @example
     * // Update many Chamados
     * const chamado = await prisma.chamado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Chamados and only return the `cod_chamado`
     * const chamadoWithCod_chamadoOnly = await prisma.chamado.updateManyAndReturn({
     *   select: { cod_chamado: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends chamadoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, chamadoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Chamado.
     * @param {chamadoUpsertArgs} args - Arguments to update or create a Chamado.
     * @example
     * // Update or create a Chamado
     * const chamado = await prisma.chamado.upsert({
     *   create: {
     *     // ... data to create a Chamado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chamado we want to update
     *   }
     * })
     */
    upsert<T extends chamadoUpsertArgs>(
      args: SelectSubset<T, chamadoUpsertArgs<ExtArgs>>,
    ): Prisma__chamadoClient<
      $Result.GetResult<
        Prisma.$chamadoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Chamados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chamadoCountArgs} args - Arguments to filter Chamados to count.
     * @example
     * // Count the number of Chamados
     * const count = await prisma.chamado.count({
     *   where: {
     *     // ... the filter for the Chamados we want to count
     *   }
     * })
     **/
    count<T extends chamadoCountArgs>(
      args?: Subset<T, chamadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChamadoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Chamado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChamadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ChamadoAggregateArgs>(
      args: Subset<T, ChamadoAggregateArgs>,
    ): Prisma.PrismaPromise<GetChamadoAggregateType<T>>;

    /**
     * Group by Chamado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chamadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends chamadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chamadoGroupByArgs['orderBy'] }
        : { orderBy?: chamadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, chamadoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetChamadoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the chamado model
     */
    readonly fields: chamadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chamado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chamadoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    cliente<T extends chamado$clienteArgs<ExtArgs> = {}>(
      args?: Subset<T, chamado$clienteArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    recurso<T extends chamado$recursoArgs<ExtArgs> = {}>(
      args?: Subset<T, chamado$recursoArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the chamado model
   */
  interface chamadoFieldRefs {
    readonly cod_chamado: FieldRef<'chamado', 'Int'>;
    readonly data_chamado: FieldRef<'chamado', 'DateTime'>;
    readonly hora_chamado: FieldRef<'chamado', 'String'>;
    readonly solicitacao_chamado: FieldRef<'chamado', 'Bytes'>;
    readonly conclusao_chamado: FieldRef<'chamado', 'DateTime'>;
    readonly status_chamado: FieldRef<'chamado', 'String'>;
    readonly dtenvio_chamado: FieldRef<'chamado', 'String'>;
    readonly cod_recurso: FieldRef<'chamado', 'Int'>;
    readonly cliente_chamado: FieldRef<'chamado', 'String'>;
    readonly codtrf_chamado: FieldRef<'chamado', 'Int'>;
    readonly cod_cliente: FieldRef<'chamado', 'Int'>;
    readonly solicitacao2_chamado: FieldRef<'chamado', 'Bytes'>;
    readonly assunto_chamado: FieldRef<'chamado', 'String'>;
    readonly email_chamado: FieldRef<'chamado', 'String'>;
    readonly prior_chamado: FieldRef<'chamado', 'Int'>;
    readonly cod_classificacao: FieldRef<'chamado', 'Int'>;
  }

  // Custom InputTypes
  /**
   * chamado findUnique
   */
  export type chamadoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * Filter, which chamado to fetch.
     */
    where: chamadoWhereUniqueInput;
  };

  /**
   * chamado findUniqueOrThrow
   */
  export type chamadoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * Filter, which chamado to fetch.
     */
    where: chamadoWhereUniqueInput;
  };

  /**
   * chamado findFirst
   */
  export type chamadoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * Filter, which chamado to fetch.
     */
    where?: chamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of chamados to fetch.
     */
    orderBy?:
      | chamadoOrderByWithRelationInput
      | chamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for chamados.
     */
    cursor?: chamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` chamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` chamados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of chamados.
     */
    distinct?: ChamadoScalarFieldEnum | ChamadoScalarFieldEnum[];
  };

  /**
   * chamado findFirstOrThrow
   */
  export type chamadoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * Filter, which chamado to fetch.
     */
    where?: chamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of chamados to fetch.
     */
    orderBy?:
      | chamadoOrderByWithRelationInput
      | chamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for chamados.
     */
    cursor?: chamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` chamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` chamados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of chamados.
     */
    distinct?: ChamadoScalarFieldEnum | ChamadoScalarFieldEnum[];
  };

  /**
   * chamado findMany
   */
  export type chamadoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * Filter, which chamados to fetch.
     */
    where?: chamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of chamados to fetch.
     */
    orderBy?:
      | chamadoOrderByWithRelationInput
      | chamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing chamados.
     */
    cursor?: chamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` chamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` chamados.
     */
    skip?: number;
    distinct?: ChamadoScalarFieldEnum | ChamadoScalarFieldEnum[];
  };

  /**
   * chamado create
   */
  export type chamadoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * The data needed to create a chamado.
     */
    data: XOR<chamadoCreateInput, chamadoUncheckedCreateInput>;
  };

  /**
   * chamado createMany
   */
  export type chamadoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many chamados.
     */
    data: chamadoCreateManyInput | chamadoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * chamado createManyAndReturn
   */
  export type chamadoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * The data used to create many chamados.
     */
    data: chamadoCreateManyInput | chamadoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * chamado update
   */
  export type chamadoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * The data needed to update a chamado.
     */
    data: XOR<chamadoUpdateInput, chamadoUncheckedUpdateInput>;
    /**
     * Choose, which chamado to update.
     */
    where: chamadoWhereUniqueInput;
  };

  /**
   * chamado updateMany
   */
  export type chamadoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update chamados.
     */
    data: XOR<chamadoUpdateManyMutationInput, chamadoUncheckedUpdateManyInput>;
    /**
     * Filter which chamados to update
     */
    where?: chamadoWhereInput;
    /**
     * Limit how many chamados to update.
     */
    limit?: number;
  };

  /**
   * chamado updateManyAndReturn
   */
  export type chamadoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * The data used to update chamados.
     */
    data: XOR<chamadoUpdateManyMutationInput, chamadoUncheckedUpdateManyInput>;
    /**
     * Filter which chamados to update
     */
    where?: chamadoWhereInput;
    /**
     * Limit how many chamados to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * chamado upsert
   */
  export type chamadoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * The filter to search for the chamado to update in case it exists.
     */
    where: chamadoWhereUniqueInput;
    /**
     * In case the chamado found by the `where` argument doesn't exist, create a new chamado with this data.
     */
    create: XOR<chamadoCreateInput, chamadoUncheckedCreateInput>;
    /**
     * In case the chamado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chamadoUpdateInput, chamadoUncheckedUpdateInput>;
  };

  /**
   * chamado delete
   */
  export type chamadoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    /**
     * Filter which chamado to delete.
     */
    where: chamadoWhereUniqueInput;
  };

  /**
   * chamado deleteMany
   */
  export type chamadoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which chamados to delete
     */
    where?: chamadoWhereInput;
    /**
     * Limit how many chamados to delete.
     */
    limit?: number;
  };

  /**
   * chamado.cliente
   */
  export type chamado$clienteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    where?: clienteWhereInput;
  };

  /**
   * chamado.recurso
   */
  export type chamado$recursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    where?: recursoWhereInput;
  };

  /**
   * chamado without action
   */
  export type chamadoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
  };

  /**
   * Model cidade
   */

  export type AggregateCidade = {
    _count: CidadeCountAggregateOutputType | null;
    _avg: CidadeAvgAggregateOutputType | null;
    _sum: CidadeSumAggregateOutputType | null;
    _min: CidadeMinAggregateOutputType | null;
    _max: CidadeMaxAggregateOutputType | null;
  };

  export type CidadeAvgAggregateOutputType = {
    cod_cidade: number | null;
  };

  export type CidadeSumAggregateOutputType = {
    cod_cidade: number | null;
  };

  export type CidadeMinAggregateOutputType = {
    cod_cidade: number | null;
    nome_cidade: string | null;
    codibge_cidade: string | null;
    uf_cidade: string | null;
  };

  export type CidadeMaxAggregateOutputType = {
    cod_cidade: number | null;
    nome_cidade: string | null;
    codibge_cidade: string | null;
    uf_cidade: string | null;
  };

  export type CidadeCountAggregateOutputType = {
    cod_cidade: number;
    nome_cidade: number;
    codibge_cidade: number;
    uf_cidade: number;
    _all: number;
  };

  export type CidadeAvgAggregateInputType = {
    cod_cidade?: true;
  };

  export type CidadeSumAggregateInputType = {
    cod_cidade?: true;
  };

  export type CidadeMinAggregateInputType = {
    cod_cidade?: true;
    nome_cidade?: true;
    codibge_cidade?: true;
    uf_cidade?: true;
  };

  export type CidadeMaxAggregateInputType = {
    cod_cidade?: true;
    nome_cidade?: true;
    codibge_cidade?: true;
    uf_cidade?: true;
  };

  export type CidadeCountAggregateInputType = {
    cod_cidade?: true;
    nome_cidade?: true;
    codibge_cidade?: true;
    uf_cidade?: true;
    _all?: true;
  };

  export type CidadeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which cidade to aggregate.
     */
    where?: cidadeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: cidadeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` cidades.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned cidades
     **/
    _count?: true | CidadeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CidadeAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CidadeSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CidadeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CidadeMaxAggregateInputType;
  };

  export type GetCidadeAggregateType<T extends CidadeAggregateArgs> = {
    [P in keyof T & keyof AggregateCidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCidade[P]>
      : GetScalarType<T[P], AggregateCidade[P]>;
  };

  export type cidadeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: cidadeWhereInput;
    orderBy?:
      | cidadeOrderByWithAggregationInput
      | cidadeOrderByWithAggregationInput[];
    by: CidadeScalarFieldEnum[] | CidadeScalarFieldEnum;
    having?: cidadeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CidadeCountAggregateInputType | true;
    _avg?: CidadeAvgAggregateInputType;
    _sum?: CidadeSumAggregateInputType;
    _min?: CidadeMinAggregateInputType;
    _max?: CidadeMaxAggregateInputType;
  };

  export type CidadeGroupByOutputType = {
    cod_cidade: number;
    nome_cidade: string;
    codibge_cidade: string | null;
    uf_cidade: string | null;
    _count: CidadeCountAggregateOutputType | null;
    _avg: CidadeAvgAggregateOutputType | null;
    _sum: CidadeSumAggregateOutputType | null;
    _min: CidadeMinAggregateOutputType | null;
    _max: CidadeMaxAggregateOutputType | null;
  };

  type GetCidadeGroupByPayload<T extends cidadeGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CidadeGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CidadeGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CidadeGroupByOutputType[P]>
            : GetScalarType<T[P], CidadeGroupByOutputType[P]>;
        }
      >
    >;

  export type cidadeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_cidade?: boolean;
      nome_cidade?: boolean;
      codibge_cidade?: boolean;
      uf_cidade?: boolean;
    },
    ExtArgs['result']['cidade']
  >;

  export type cidadeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_cidade?: boolean;
      nome_cidade?: boolean;
      codibge_cidade?: boolean;
      uf_cidade?: boolean;
    },
    ExtArgs['result']['cidade']
  >;

  export type cidadeSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_cidade?: boolean;
      nome_cidade?: boolean;
      codibge_cidade?: boolean;
      uf_cidade?: boolean;
    },
    ExtArgs['result']['cidade']
  >;

  export type cidadeSelectScalar = {
    cod_cidade?: boolean;
    nome_cidade?: boolean;
    codibge_cidade?: boolean;
    uf_cidade?: boolean;
  };

  export type cidadeOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_cidade' | 'nome_cidade' | 'codibge_cidade' | 'uf_cidade',
    ExtArgs['result']['cidade']
  >;

  export type $cidadePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'cidade';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_cidade: number;
        nome_cidade: string;
        codibge_cidade: string | null;
        uf_cidade: string | null;
      },
      ExtArgs['result']['cidade']
    >;
    composites: {};
  };

  type cidadeGetPayload<
    S extends boolean | null | undefined | cidadeDefaultArgs,
  > = $Result.GetResult<Prisma.$cidadePayload, S>;

  type cidadeCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<cidadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CidadeCountAggregateInputType | true;
  };

  export interface cidadeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['cidade'];
      meta: { name: 'cidade' };
    };
    /**
     * Find zero or one Cidade that matches the filter.
     * @param {cidadeFindUniqueArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cidadeFindUniqueArgs>(
      args: SelectSubset<T, cidadeFindUniqueArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Cidade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cidadeFindUniqueOrThrowArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cidadeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, cidadeFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeFindFirstArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cidadeFindFirstArgs>(
      args?: SelectSubset<T, cidadeFindFirstArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeFindFirstOrThrowArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cidadeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cidadeFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Cidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cidades
     * const cidades = await prisma.cidade.findMany()
     *
     * // Get first 10 Cidades
     * const cidades = await prisma.cidade.findMany({ take: 10 })
     *
     * // Only select the `cod_cidade`
     * const cidadeWithCod_cidadeOnly = await prisma.cidade.findMany({ select: { cod_cidade: true } })
     *
     */
    findMany<T extends cidadeFindManyArgs>(
      args?: SelectSubset<T, cidadeFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Cidade.
     * @param {cidadeCreateArgs} args - Arguments to create a Cidade.
     * @example
     * // Create one Cidade
     * const Cidade = await prisma.cidade.create({
     *   data: {
     *     // ... data to create a Cidade
     *   }
     * })
     *
     */
    create<T extends cidadeCreateArgs>(
      args: SelectSubset<T, cidadeCreateArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Cidades.
     * @param {cidadeCreateManyArgs} args - Arguments to create many Cidades.
     * @example
     * // Create many Cidades
     * const cidade = await prisma.cidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends cidadeCreateManyArgs>(
      args?: SelectSubset<T, cidadeCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Cidades and returns the data saved in the database.
     * @param {cidadeCreateManyAndReturnArgs} args - Arguments to create many Cidades.
     * @example
     * // Create many Cidades
     * const cidade = await prisma.cidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Cidades and only return the `cod_cidade`
     * const cidadeWithCod_cidadeOnly = await prisma.cidade.createManyAndReturn({
     *   select: { cod_cidade: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends cidadeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, cidadeCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Cidade.
     * @param {cidadeDeleteArgs} args - Arguments to delete one Cidade.
     * @example
     * // Delete one Cidade
     * const Cidade = await prisma.cidade.delete({
     *   where: {
     *     // ... filter to delete one Cidade
     *   }
     * })
     *
     */
    delete<T extends cidadeDeleteArgs>(
      args: SelectSubset<T, cidadeDeleteArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Cidade.
     * @param {cidadeUpdateArgs} args - Arguments to update one Cidade.
     * @example
     * // Update one Cidade
     * const cidade = await prisma.cidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends cidadeUpdateArgs>(
      args: SelectSubset<T, cidadeUpdateArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Cidades.
     * @param {cidadeDeleteManyArgs} args - Arguments to filter Cidades to delete.
     * @example
     * // Delete a few Cidades
     * const { count } = await prisma.cidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends cidadeDeleteManyArgs>(
      args?: SelectSubset<T, cidadeDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Cidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cidades
     * const cidade = await prisma.cidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends cidadeUpdateManyArgs>(
      args: SelectSubset<T, cidadeUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Cidades and returns the data updated in the database.
     * @param {cidadeUpdateManyAndReturnArgs} args - Arguments to update many Cidades.
     * @example
     * // Update many Cidades
     * const cidade = await prisma.cidade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Cidades and only return the `cod_cidade`
     * const cidadeWithCod_cidadeOnly = await prisma.cidade.updateManyAndReturn({
     *   select: { cod_cidade: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends cidadeUpdateManyAndReturnArgs>(
      args: SelectSubset<T, cidadeUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Cidade.
     * @param {cidadeUpsertArgs} args - Arguments to update or create a Cidade.
     * @example
     * // Update or create a Cidade
     * const cidade = await prisma.cidade.upsert({
     *   create: {
     *     // ... data to create a Cidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cidade we want to update
     *   }
     * })
     */
    upsert<T extends cidadeUpsertArgs>(
      args: SelectSubset<T, cidadeUpsertArgs<ExtArgs>>,
    ): Prisma__cidadeClient<
      $Result.GetResult<
        Prisma.$cidadePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Cidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeCountArgs} args - Arguments to filter Cidades to count.
     * @example
     * // Count the number of Cidades
     * const count = await prisma.cidade.count({
     *   where: {
     *     // ... the filter for the Cidades we want to count
     *   }
     * })
     **/
    count<T extends cidadeCountArgs>(
      args?: Subset<T, cidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CidadeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Cidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CidadeAggregateArgs>(
      args: Subset<T, CidadeAggregateArgs>,
    ): Prisma.PrismaPromise<GetCidadeAggregateType<T>>;

    /**
     * Group by Cidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends cidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cidadeGroupByArgs['orderBy'] }
        : { orderBy?: cidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, cidadeGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCidadeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the cidade model
     */
    readonly fields: cidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cidadeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the cidade model
   */
  interface cidadeFieldRefs {
    readonly cod_cidade: FieldRef<'cidade', 'Int'>;
    readonly nome_cidade: FieldRef<'cidade', 'String'>;
    readonly codibge_cidade: FieldRef<'cidade', 'String'>;
    readonly uf_cidade: FieldRef<'cidade', 'String'>;
  }

  // Custom InputTypes
  /**
   * cidade findUnique
   */
  export type cidadeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * Filter, which cidade to fetch.
     */
    where: cidadeWhereUniqueInput;
  };

  /**
   * cidade findUniqueOrThrow
   */
  export type cidadeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * Filter, which cidade to fetch.
     */
    where: cidadeWhereUniqueInput;
  };

  /**
   * cidade findFirst
   */
  export type cidadeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * Filter, which cidade to fetch.
     */
    where?: cidadeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for cidades.
     */
    cursor?: cidadeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` cidades.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of cidades.
     */
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[];
  };

  /**
   * cidade findFirstOrThrow
   */
  export type cidadeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * Filter, which cidade to fetch.
     */
    where?: cidadeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for cidades.
     */
    cursor?: cidadeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` cidades.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of cidades.
     */
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[];
  };

  /**
   * cidade findMany
   */
  export type cidadeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * Filter, which cidades to fetch.
     */
    where?: cidadeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing cidades.
     */
    cursor?: cidadeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` cidades.
     */
    skip?: number;
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[];
  };

  /**
   * cidade create
   */
  export type cidadeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * The data needed to create a cidade.
     */
    data: XOR<cidadeCreateInput, cidadeUncheckedCreateInput>;
  };

  /**
   * cidade createMany
   */
  export type cidadeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many cidades.
     */
    data: cidadeCreateManyInput | cidadeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * cidade createManyAndReturn
   */
  export type cidadeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * The data used to create many cidades.
     */
    data: cidadeCreateManyInput | cidadeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * cidade update
   */
  export type cidadeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * The data needed to update a cidade.
     */
    data: XOR<cidadeUpdateInput, cidadeUncheckedUpdateInput>;
    /**
     * Choose, which cidade to update.
     */
    where: cidadeWhereUniqueInput;
  };

  /**
   * cidade updateMany
   */
  export type cidadeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update cidades.
     */
    data: XOR<cidadeUpdateManyMutationInput, cidadeUncheckedUpdateManyInput>;
    /**
     * Filter which cidades to update
     */
    where?: cidadeWhereInput;
    /**
     * Limit how many cidades to update.
     */
    limit?: number;
  };

  /**
   * cidade updateManyAndReturn
   */
  export type cidadeUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * The data used to update cidades.
     */
    data: XOR<cidadeUpdateManyMutationInput, cidadeUncheckedUpdateManyInput>;
    /**
     * Filter which cidades to update
     */
    where?: cidadeWhereInput;
    /**
     * Limit how many cidades to update.
     */
    limit?: number;
  };

  /**
   * cidade upsert
   */
  export type cidadeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * The filter to search for the cidade to update in case it exists.
     */
    where: cidadeWhereUniqueInput;
    /**
     * In case the cidade found by the `where` argument doesn't exist, create a new cidade with this data.
     */
    create: XOR<cidadeCreateInput, cidadeUncheckedCreateInput>;
    /**
     * In case the cidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cidadeUpdateInput, cidadeUncheckedUpdateInput>;
  };

  /**
   * cidade delete
   */
  export type cidadeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
    /**
     * Filter which cidade to delete.
     */
    where: cidadeWhereUniqueInput;
  };

  /**
   * cidade deleteMany
   */
  export type cidadeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which cidades to delete
     */
    where?: cidadeWhereInput;
    /**
     * Limit how many cidades to delete.
     */
    limit?: number;
  };

  /**
   * cidade without action
   */
  export type cidadeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null;
  };

  /**
   * Model classificacao
   */

  export type AggregateClassificacao = {
    _count: ClassificacaoCountAggregateOutputType | null;
    _avg: ClassificacaoAvgAggregateOutputType | null;
    _sum: ClassificacaoSumAggregateOutputType | null;
    _min: ClassificacaoMinAggregateOutputType | null;
    _max: ClassificacaoMaxAggregateOutputType | null;
  };

  export type ClassificacaoAvgAggregateOutputType = {
    cod_classificacao: number | null;
  };

  export type ClassificacaoSumAggregateOutputType = {
    cod_classificacao: number | null;
  };

  export type ClassificacaoMinAggregateOutputType = {
    cod_classificacao: number | null;
    nome_classificacao: string | null;
    ativo_classificacao: string | null;
  };

  export type ClassificacaoMaxAggregateOutputType = {
    cod_classificacao: number | null;
    nome_classificacao: string | null;
    ativo_classificacao: string | null;
  };

  export type ClassificacaoCountAggregateOutputType = {
    cod_classificacao: number;
    nome_classificacao: number;
    ativo_classificacao: number;
    _all: number;
  };

  export type ClassificacaoAvgAggregateInputType = {
    cod_classificacao?: true;
  };

  export type ClassificacaoSumAggregateInputType = {
    cod_classificacao?: true;
  };

  export type ClassificacaoMinAggregateInputType = {
    cod_classificacao?: true;
    nome_classificacao?: true;
    ativo_classificacao?: true;
  };

  export type ClassificacaoMaxAggregateInputType = {
    cod_classificacao?: true;
    nome_classificacao?: true;
    ativo_classificacao?: true;
  };

  export type ClassificacaoCountAggregateInputType = {
    cod_classificacao?: true;
    nome_classificacao?: true;
    ativo_classificacao?: true;
    _all?: true;
  };

  export type ClassificacaoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which classificacao to aggregate.
     */
    where?: classificacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classificacaos to fetch.
     */
    orderBy?:
      | classificacaoOrderByWithRelationInput
      | classificacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: classificacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classificacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classificacaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned classificacaos
     **/
    _count?: true | ClassificacaoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ClassificacaoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ClassificacaoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClassificacaoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClassificacaoMaxAggregateInputType;
  };

  export type GetClassificacaoAggregateType<
    T extends ClassificacaoAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateClassificacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassificacao[P]>
      : GetScalarType<T[P], AggregateClassificacao[P]>;
  };

  export type classificacaoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: classificacaoWhereInput;
    orderBy?:
      | classificacaoOrderByWithAggregationInput
      | classificacaoOrderByWithAggregationInput[];
    by: ClassificacaoScalarFieldEnum[] | ClassificacaoScalarFieldEnum;
    having?: classificacaoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClassificacaoCountAggregateInputType | true;
    _avg?: ClassificacaoAvgAggregateInputType;
    _sum?: ClassificacaoSumAggregateInputType;
    _min?: ClassificacaoMinAggregateInputType;
    _max?: ClassificacaoMaxAggregateInputType;
  };

  export type ClassificacaoGroupByOutputType = {
    cod_classificacao: number;
    nome_classificacao: string;
    ativo_classificacao: string | null;
    _count: ClassificacaoCountAggregateOutputType | null;
    _avg: ClassificacaoAvgAggregateOutputType | null;
    _sum: ClassificacaoSumAggregateOutputType | null;
    _min: ClassificacaoMinAggregateOutputType | null;
    _max: ClassificacaoMaxAggregateOutputType | null;
  };

  type GetClassificacaoGroupByPayload<T extends classificacaoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ClassificacaoGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ClassificacaoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassificacaoGroupByOutputType[P]>
            : GetScalarType<T[P], ClassificacaoGroupByOutputType[P]>;
        }
      >
    >;

  export type classificacaoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_classificacao?: boolean;
      nome_classificacao?: boolean;
      ativo_classificacao?: boolean;
    },
    ExtArgs['result']['classificacao']
  >;

  export type classificacaoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_classificacao?: boolean;
      nome_classificacao?: boolean;
      ativo_classificacao?: boolean;
    },
    ExtArgs['result']['classificacao']
  >;

  export type classificacaoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_classificacao?: boolean;
      nome_classificacao?: boolean;
      ativo_classificacao?: boolean;
    },
    ExtArgs['result']['classificacao']
  >;

  export type classificacaoSelectScalar = {
    cod_classificacao?: boolean;
    nome_classificacao?: boolean;
    ativo_classificacao?: boolean;
  };

  export type classificacaoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_classificacao' | 'nome_classificacao' | 'ativo_classificacao',
    ExtArgs['result']['classificacao']
  >;

  export type $classificacaoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'classificacao';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_classificacao: number;
        nome_classificacao: string;
        ativo_classificacao: string | null;
      },
      ExtArgs['result']['classificacao']
    >;
    composites: {};
  };

  type classificacaoGetPayload<
    S extends boolean | null | undefined | classificacaoDefaultArgs,
  > = $Result.GetResult<Prisma.$classificacaoPayload, S>;

  type classificacaoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    classificacaoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ClassificacaoCountAggregateInputType | true;
  };

  export interface classificacaoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['classificacao'];
      meta: { name: 'classificacao' };
    };
    /**
     * Find zero or one Classificacao that matches the filter.
     * @param {classificacaoFindUniqueArgs} args - Arguments to find a Classificacao
     * @example
     * // Get one Classificacao
     * const classificacao = await prisma.classificacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends classificacaoFindUniqueArgs>(
      args: SelectSubset<T, classificacaoFindUniqueArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Classificacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {classificacaoFindUniqueOrThrowArgs} args - Arguments to find a Classificacao
     * @example
     * // Get one Classificacao
     * const classificacao = await prisma.classificacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends classificacaoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, classificacaoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Classificacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classificacaoFindFirstArgs} args - Arguments to find a Classificacao
     * @example
     * // Get one Classificacao
     * const classificacao = await prisma.classificacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends classificacaoFindFirstArgs>(
      args?: SelectSubset<T, classificacaoFindFirstArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Classificacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classificacaoFindFirstOrThrowArgs} args - Arguments to find a Classificacao
     * @example
     * // Get one Classificacao
     * const classificacao = await prisma.classificacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends classificacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, classificacaoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Classificacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classificacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classificacaos
     * const classificacaos = await prisma.classificacao.findMany()
     *
     * // Get first 10 Classificacaos
     * const classificacaos = await prisma.classificacao.findMany({ take: 10 })
     *
     * // Only select the `cod_classificacao`
     * const classificacaoWithCod_classificacaoOnly = await prisma.classificacao.findMany({ select: { cod_classificacao: true } })
     *
     */
    findMany<T extends classificacaoFindManyArgs>(
      args?: SelectSubset<T, classificacaoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Classificacao.
     * @param {classificacaoCreateArgs} args - Arguments to create a Classificacao.
     * @example
     * // Create one Classificacao
     * const Classificacao = await prisma.classificacao.create({
     *   data: {
     *     // ... data to create a Classificacao
     *   }
     * })
     *
     */
    create<T extends classificacaoCreateArgs>(
      args: SelectSubset<T, classificacaoCreateArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Classificacaos.
     * @param {classificacaoCreateManyArgs} args - Arguments to create many Classificacaos.
     * @example
     * // Create many Classificacaos
     * const classificacao = await prisma.classificacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends classificacaoCreateManyArgs>(
      args?: SelectSubset<T, classificacaoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Classificacaos and returns the data saved in the database.
     * @param {classificacaoCreateManyAndReturnArgs} args - Arguments to create many Classificacaos.
     * @example
     * // Create many Classificacaos
     * const classificacao = await prisma.classificacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Classificacaos and only return the `cod_classificacao`
     * const classificacaoWithCod_classificacaoOnly = await prisma.classificacao.createManyAndReturn({
     *   select: { cod_classificacao: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends classificacaoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, classificacaoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Classificacao.
     * @param {classificacaoDeleteArgs} args - Arguments to delete one Classificacao.
     * @example
     * // Delete one Classificacao
     * const Classificacao = await prisma.classificacao.delete({
     *   where: {
     *     // ... filter to delete one Classificacao
     *   }
     * })
     *
     */
    delete<T extends classificacaoDeleteArgs>(
      args: SelectSubset<T, classificacaoDeleteArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Classificacao.
     * @param {classificacaoUpdateArgs} args - Arguments to update one Classificacao.
     * @example
     * // Update one Classificacao
     * const classificacao = await prisma.classificacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends classificacaoUpdateArgs>(
      args: SelectSubset<T, classificacaoUpdateArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Classificacaos.
     * @param {classificacaoDeleteManyArgs} args - Arguments to filter Classificacaos to delete.
     * @example
     * // Delete a few Classificacaos
     * const { count } = await prisma.classificacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends classificacaoDeleteManyArgs>(
      args?: SelectSubset<T, classificacaoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Classificacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classificacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classificacaos
     * const classificacao = await prisma.classificacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends classificacaoUpdateManyArgs>(
      args: SelectSubset<T, classificacaoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Classificacaos and returns the data updated in the database.
     * @param {classificacaoUpdateManyAndReturnArgs} args - Arguments to update many Classificacaos.
     * @example
     * // Update many Classificacaos
     * const classificacao = await prisma.classificacao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Classificacaos and only return the `cod_classificacao`
     * const classificacaoWithCod_classificacaoOnly = await prisma.classificacao.updateManyAndReturn({
     *   select: { cod_classificacao: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends classificacaoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, classificacaoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Classificacao.
     * @param {classificacaoUpsertArgs} args - Arguments to update or create a Classificacao.
     * @example
     * // Update or create a Classificacao
     * const classificacao = await prisma.classificacao.upsert({
     *   create: {
     *     // ... data to create a Classificacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classificacao we want to update
     *   }
     * })
     */
    upsert<T extends classificacaoUpsertArgs>(
      args: SelectSubset<T, classificacaoUpsertArgs<ExtArgs>>,
    ): Prisma__classificacaoClient<
      $Result.GetResult<
        Prisma.$classificacaoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Classificacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classificacaoCountArgs} args - Arguments to filter Classificacaos to count.
     * @example
     * // Count the number of Classificacaos
     * const count = await prisma.classificacao.count({
     *   where: {
     *     // ... the filter for the Classificacaos we want to count
     *   }
     * })
     **/
    count<T extends classificacaoCountArgs>(
      args?: Subset<T, classificacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassificacaoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Classificacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClassificacaoAggregateArgs>(
      args: Subset<T, ClassificacaoAggregateArgs>,
    ): Prisma.PrismaPromise<GetClassificacaoAggregateType<T>>;

    /**
     * Group by Classificacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classificacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends classificacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: classificacaoGroupByArgs['orderBy'] }
        : { orderBy?: classificacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, classificacaoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetClassificacaoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the classificacao model
     */
    readonly fields: classificacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for classificacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__classificacaoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the classificacao model
   */
  interface classificacaoFieldRefs {
    readonly cod_classificacao: FieldRef<'classificacao', 'Int'>;
    readonly nome_classificacao: FieldRef<'classificacao', 'String'>;
    readonly ativo_classificacao: FieldRef<'classificacao', 'String'>;
  }

  // Custom InputTypes
  /**
   * classificacao findUnique
   */
  export type classificacaoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * Filter, which classificacao to fetch.
     */
    where: classificacaoWhereUniqueInput;
  };

  /**
   * classificacao findUniqueOrThrow
   */
  export type classificacaoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * Filter, which classificacao to fetch.
     */
    where: classificacaoWhereUniqueInput;
  };

  /**
   * classificacao findFirst
   */
  export type classificacaoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * Filter, which classificacao to fetch.
     */
    where?: classificacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classificacaos to fetch.
     */
    orderBy?:
      | classificacaoOrderByWithRelationInput
      | classificacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for classificacaos.
     */
    cursor?: classificacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classificacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classificacaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of classificacaos.
     */
    distinct?: ClassificacaoScalarFieldEnum | ClassificacaoScalarFieldEnum[];
  };

  /**
   * classificacao findFirstOrThrow
   */
  export type classificacaoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * Filter, which classificacao to fetch.
     */
    where?: classificacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classificacaos to fetch.
     */
    orderBy?:
      | classificacaoOrderByWithRelationInput
      | classificacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for classificacaos.
     */
    cursor?: classificacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classificacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classificacaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of classificacaos.
     */
    distinct?: ClassificacaoScalarFieldEnum | ClassificacaoScalarFieldEnum[];
  };

  /**
   * classificacao findMany
   */
  export type classificacaoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * Filter, which classificacaos to fetch.
     */
    where?: classificacaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of classificacaos to fetch.
     */
    orderBy?:
      | classificacaoOrderByWithRelationInput
      | classificacaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing classificacaos.
     */
    cursor?: classificacaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` classificacaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` classificacaos.
     */
    skip?: number;
    distinct?: ClassificacaoScalarFieldEnum | ClassificacaoScalarFieldEnum[];
  };

  /**
   * classificacao create
   */
  export type classificacaoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * The data needed to create a classificacao.
     */
    data: XOR<classificacaoCreateInput, classificacaoUncheckedCreateInput>;
  };

  /**
   * classificacao createMany
   */
  export type classificacaoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many classificacaos.
     */
    data: classificacaoCreateManyInput | classificacaoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * classificacao createManyAndReturn
   */
  export type classificacaoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * The data used to create many classificacaos.
     */
    data: classificacaoCreateManyInput | classificacaoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * classificacao update
   */
  export type classificacaoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * The data needed to update a classificacao.
     */
    data: XOR<classificacaoUpdateInput, classificacaoUncheckedUpdateInput>;
    /**
     * Choose, which classificacao to update.
     */
    where: classificacaoWhereUniqueInput;
  };

  /**
   * classificacao updateMany
   */
  export type classificacaoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update classificacaos.
     */
    data: XOR<
      classificacaoUpdateManyMutationInput,
      classificacaoUncheckedUpdateManyInput
    >;
    /**
     * Filter which classificacaos to update
     */
    where?: classificacaoWhereInput;
    /**
     * Limit how many classificacaos to update.
     */
    limit?: number;
  };

  /**
   * classificacao updateManyAndReturn
   */
  export type classificacaoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * The data used to update classificacaos.
     */
    data: XOR<
      classificacaoUpdateManyMutationInput,
      classificacaoUncheckedUpdateManyInput
    >;
    /**
     * Filter which classificacaos to update
     */
    where?: classificacaoWhereInput;
    /**
     * Limit how many classificacaos to update.
     */
    limit?: number;
  };

  /**
   * classificacao upsert
   */
  export type classificacaoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * The filter to search for the classificacao to update in case it exists.
     */
    where: classificacaoWhereUniqueInput;
    /**
     * In case the classificacao found by the `where` argument doesn't exist, create a new classificacao with this data.
     */
    create: XOR<classificacaoCreateInput, classificacaoUncheckedCreateInput>;
    /**
     * In case the classificacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<classificacaoUpdateInput, classificacaoUncheckedUpdateInput>;
  };

  /**
   * classificacao delete
   */
  export type classificacaoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
    /**
     * Filter which classificacao to delete.
     */
    where: classificacaoWhereUniqueInput;
  };

  /**
   * classificacao deleteMany
   */
  export type classificacaoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which classificacaos to delete
     */
    where?: classificacaoWhereInput;
    /**
     * Limit how many classificacaos to delete.
     */
    limit?: number;
  };

  /**
   * classificacao without action
   */
  export type classificacaoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the classificacao
     */
    select?: classificacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the classificacao
     */
    omit?: classificacaoOmit<ExtArgs> | null;
  };

  /**
   * Model cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null;
    _avg: ClienteAvgAggregateOutputType | null;
    _sum: ClienteSumAggregateOutputType | null;
    _min: ClienteMinAggregateOutputType | null;
    _max: ClienteMaxAggregateOutputType | null;
  };

  export type ClienteAvgAggregateOutputType = {
    cod_cliente: number | null;
    ativo_cliente: number | null;
    cod_cidade: number | null;
    sla_cliente: number | null;
  };

  export type ClienteSumAggregateOutputType = {
    cod_cliente: number | null;
    ativo_cliente: number | null;
    cod_cidade: number | null;
    sla_cliente: number | null;
  };

  export type ClienteMinAggregateOutputType = {
    cod_cliente: number | null;
    nome_cliente: string | null;
    razao_cliente: string | null;
    end_cliente: string | null;
    bairro_cliente: string | null;
    cep_cliente: string | null;
    fone_cliente: string | null;
    cnpj_cliente: string | null;
    ie_cliente: string | null;
    uf_cliente: string | null;
    fax_cliente: string | null;
    contato_cliente: string | null;
    funccontato_cliente: string | null;
    endcob_cliente: string | null;
    bairrocob_cliente: string | null;
    cepcob_cliente: string | null;
    cidadecob_cliente: string | null;
    ufcob_cliente: string | null;
    ativo_cliente: number | null;
    obs_cliente: Uint8Array | null;
    im_cliente: string | null;
    cod_cidade: number | null;
    numend_cliente: string | null;
    comend_cliente: string | null;
    email_cliente: string | null;
    codbanco_cliente: string | null;
    sla_cliente: number | null;
  };

  export type ClienteMaxAggregateOutputType = {
    cod_cliente: number | null;
    nome_cliente: string | null;
    razao_cliente: string | null;
    end_cliente: string | null;
    bairro_cliente: string | null;
    cep_cliente: string | null;
    fone_cliente: string | null;
    cnpj_cliente: string | null;
    ie_cliente: string | null;
    uf_cliente: string | null;
    fax_cliente: string | null;
    contato_cliente: string | null;
    funccontato_cliente: string | null;
    endcob_cliente: string | null;
    bairrocob_cliente: string | null;
    cepcob_cliente: string | null;
    cidadecob_cliente: string | null;
    ufcob_cliente: string | null;
    ativo_cliente: number | null;
    obs_cliente: Uint8Array | null;
    im_cliente: string | null;
    cod_cidade: number | null;
    numend_cliente: string | null;
    comend_cliente: string | null;
    email_cliente: string | null;
    codbanco_cliente: string | null;
    sla_cliente: number | null;
  };

  export type ClienteCountAggregateOutputType = {
    cod_cliente: number;
    nome_cliente: number;
    razao_cliente: number;
    end_cliente: number;
    bairro_cliente: number;
    cep_cliente: number;
    fone_cliente: number;
    cnpj_cliente: number;
    ie_cliente: number;
    uf_cliente: number;
    fax_cliente: number;
    contato_cliente: number;
    funccontato_cliente: number;
    endcob_cliente: number;
    bairrocob_cliente: number;
    cepcob_cliente: number;
    cidadecob_cliente: number;
    ufcob_cliente: number;
    ativo_cliente: number;
    obs_cliente: number;
    im_cliente: number;
    cod_cidade: number;
    numend_cliente: number;
    comend_cliente: number;
    email_cliente: number;
    codbanco_cliente: number;
    sla_cliente: number;
    _all: number;
  };

  export type ClienteAvgAggregateInputType = {
    cod_cliente?: true;
    ativo_cliente?: true;
    cod_cidade?: true;
    sla_cliente?: true;
  };

  export type ClienteSumAggregateInputType = {
    cod_cliente?: true;
    ativo_cliente?: true;
    cod_cidade?: true;
    sla_cliente?: true;
  };

  export type ClienteMinAggregateInputType = {
    cod_cliente?: true;
    nome_cliente?: true;
    razao_cliente?: true;
    end_cliente?: true;
    bairro_cliente?: true;
    cep_cliente?: true;
    fone_cliente?: true;
    cnpj_cliente?: true;
    ie_cliente?: true;
    uf_cliente?: true;
    fax_cliente?: true;
    contato_cliente?: true;
    funccontato_cliente?: true;
    endcob_cliente?: true;
    bairrocob_cliente?: true;
    cepcob_cliente?: true;
    cidadecob_cliente?: true;
    ufcob_cliente?: true;
    ativo_cliente?: true;
    obs_cliente?: true;
    im_cliente?: true;
    cod_cidade?: true;
    numend_cliente?: true;
    comend_cliente?: true;
    email_cliente?: true;
    codbanco_cliente?: true;
    sla_cliente?: true;
  };

  export type ClienteMaxAggregateInputType = {
    cod_cliente?: true;
    nome_cliente?: true;
    razao_cliente?: true;
    end_cliente?: true;
    bairro_cliente?: true;
    cep_cliente?: true;
    fone_cliente?: true;
    cnpj_cliente?: true;
    ie_cliente?: true;
    uf_cliente?: true;
    fax_cliente?: true;
    contato_cliente?: true;
    funccontato_cliente?: true;
    endcob_cliente?: true;
    bairrocob_cliente?: true;
    cepcob_cliente?: true;
    cidadecob_cliente?: true;
    ufcob_cliente?: true;
    ativo_cliente?: true;
    obs_cliente?: true;
    im_cliente?: true;
    cod_cidade?: true;
    numend_cliente?: true;
    comend_cliente?: true;
    email_cliente?: true;
    codbanco_cliente?: true;
    sla_cliente?: true;
  };

  export type ClienteCountAggregateInputType = {
    cod_cliente?: true;
    nome_cliente?: true;
    razao_cliente?: true;
    end_cliente?: true;
    bairro_cliente?: true;
    cep_cliente?: true;
    fone_cliente?: true;
    cnpj_cliente?: true;
    ie_cliente?: true;
    uf_cliente?: true;
    fax_cliente?: true;
    contato_cliente?: true;
    funccontato_cliente?: true;
    endcob_cliente?: true;
    bairrocob_cliente?: true;
    cepcob_cliente?: true;
    cidadecob_cliente?: true;
    ufcob_cliente?: true;
    ativo_cliente?: true;
    obs_cliente?: true;
    im_cliente?: true;
    cod_cidade?: true;
    numend_cliente?: true;
    comend_cliente?: true;
    email_cliente?: true;
    codbanco_cliente?: true;
    sla_cliente?: true;
    _all?: true;
  };

  export type ClienteAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which cliente to aggregate.
     */
    where?: clienteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of clientes to fetch.
     */
    orderBy?:
      | clienteOrderByWithRelationInput
      | clienteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: clienteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` clientes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned clientes
     **/
    _count?: true | ClienteCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ClienteAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ClienteSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClienteMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClienteMaxAggregateInputType;
  };

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
    [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>;
  };

  export type clienteGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: clienteWhereInput;
    orderBy?:
      | clienteOrderByWithAggregationInput
      | clienteOrderByWithAggregationInput[];
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum;
    having?: clienteScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClienteCountAggregateInputType | true;
    _avg?: ClienteAvgAggregateInputType;
    _sum?: ClienteSumAggregateInputType;
    _min?: ClienteMinAggregateInputType;
    _max?: ClienteMaxAggregateInputType;
  };

  export type ClienteGroupByOutputType = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente: string | null;
    end_cliente: string | null;
    bairro_cliente: string | null;
    cep_cliente: string | null;
    fone_cliente: string | null;
    cnpj_cliente: string | null;
    ie_cliente: string | null;
    uf_cliente: string | null;
    fax_cliente: string | null;
    contato_cliente: string | null;
    funccontato_cliente: string | null;
    endcob_cliente: string | null;
    bairrocob_cliente: string | null;
    cepcob_cliente: string | null;
    cidadecob_cliente: string | null;
    ufcob_cliente: string | null;
    ativo_cliente: number;
    obs_cliente: Uint8Array | null;
    im_cliente: string | null;
    cod_cidade: number | null;
    numend_cliente: string | null;
    comend_cliente: string | null;
    email_cliente: string | null;
    codbanco_cliente: string | null;
    sla_cliente: number;
    _count: ClienteCountAggregateOutputType | null;
    _avg: ClienteAvgAggregateOutputType | null;
    _sum: ClienteSumAggregateOutputType | null;
    _min: ClienteMinAggregateOutputType | null;
    _max: ClienteMaxAggregateOutputType | null;
  };

  type GetClienteGroupByPayload<T extends clienteGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ClienteGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ClienteGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>;
        }
      >
    >;

  export type clienteSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_cliente?: boolean;
      nome_cliente?: boolean;
      razao_cliente?: boolean;
      end_cliente?: boolean;
      bairro_cliente?: boolean;
      cep_cliente?: boolean;
      fone_cliente?: boolean;
      cnpj_cliente?: boolean;
      ie_cliente?: boolean;
      uf_cliente?: boolean;
      fax_cliente?: boolean;
      contato_cliente?: boolean;
      funccontato_cliente?: boolean;
      endcob_cliente?: boolean;
      bairrocob_cliente?: boolean;
      cepcob_cliente?: boolean;
      cidadecob_cliente?: boolean;
      ufcob_cliente?: boolean;
      ativo_cliente?: boolean;
      obs_cliente?: boolean;
      im_cliente?: boolean;
      cod_cidade?: boolean;
      numend_cliente?: boolean;
      comend_cliente?: boolean;
      email_cliente?: boolean;
      codbanco_cliente?: boolean;
      sla_cliente?: boolean;
      chamados?: boolean | cliente$chamadosArgs<ExtArgs>;
      fatrec?: boolean | cliente$fatrecArgs<ExtArgs>;
      projeto?: boolean | cliente$projetoArgs<ExtArgs>;
      _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['cliente']
  >;

  export type clienteSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_cliente?: boolean;
      nome_cliente?: boolean;
      razao_cliente?: boolean;
      end_cliente?: boolean;
      bairro_cliente?: boolean;
      cep_cliente?: boolean;
      fone_cliente?: boolean;
      cnpj_cliente?: boolean;
      ie_cliente?: boolean;
      uf_cliente?: boolean;
      fax_cliente?: boolean;
      contato_cliente?: boolean;
      funccontato_cliente?: boolean;
      endcob_cliente?: boolean;
      bairrocob_cliente?: boolean;
      cepcob_cliente?: boolean;
      cidadecob_cliente?: boolean;
      ufcob_cliente?: boolean;
      ativo_cliente?: boolean;
      obs_cliente?: boolean;
      im_cliente?: boolean;
      cod_cidade?: boolean;
      numend_cliente?: boolean;
      comend_cliente?: boolean;
      email_cliente?: boolean;
      codbanco_cliente?: boolean;
      sla_cliente?: boolean;
    },
    ExtArgs['result']['cliente']
  >;

  export type clienteSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_cliente?: boolean;
      nome_cliente?: boolean;
      razao_cliente?: boolean;
      end_cliente?: boolean;
      bairro_cliente?: boolean;
      cep_cliente?: boolean;
      fone_cliente?: boolean;
      cnpj_cliente?: boolean;
      ie_cliente?: boolean;
      uf_cliente?: boolean;
      fax_cliente?: boolean;
      contato_cliente?: boolean;
      funccontato_cliente?: boolean;
      endcob_cliente?: boolean;
      bairrocob_cliente?: boolean;
      cepcob_cliente?: boolean;
      cidadecob_cliente?: boolean;
      ufcob_cliente?: boolean;
      ativo_cliente?: boolean;
      obs_cliente?: boolean;
      im_cliente?: boolean;
      cod_cidade?: boolean;
      numend_cliente?: boolean;
      comend_cliente?: boolean;
      email_cliente?: boolean;
      codbanco_cliente?: boolean;
      sla_cliente?: boolean;
    },
    ExtArgs['result']['cliente']
  >;

  export type clienteSelectScalar = {
    cod_cliente?: boolean;
    nome_cliente?: boolean;
    razao_cliente?: boolean;
    end_cliente?: boolean;
    bairro_cliente?: boolean;
    cep_cliente?: boolean;
    fone_cliente?: boolean;
    cnpj_cliente?: boolean;
    ie_cliente?: boolean;
    uf_cliente?: boolean;
    fax_cliente?: boolean;
    contato_cliente?: boolean;
    funccontato_cliente?: boolean;
    endcob_cliente?: boolean;
    bairrocob_cliente?: boolean;
    cepcob_cliente?: boolean;
    cidadecob_cliente?: boolean;
    ufcob_cliente?: boolean;
    ativo_cliente?: boolean;
    obs_cliente?: boolean;
    im_cliente?: boolean;
    cod_cidade?: boolean;
    numend_cliente?: boolean;
    comend_cliente?: boolean;
    email_cliente?: boolean;
    codbanco_cliente?: boolean;
    sla_cliente?: boolean;
  };

  export type clienteOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_cliente'
    | 'nome_cliente'
    | 'razao_cliente'
    | 'end_cliente'
    | 'bairro_cliente'
    | 'cep_cliente'
    | 'fone_cliente'
    | 'cnpj_cliente'
    | 'ie_cliente'
    | 'uf_cliente'
    | 'fax_cliente'
    | 'contato_cliente'
    | 'funccontato_cliente'
    | 'endcob_cliente'
    | 'bairrocob_cliente'
    | 'cepcob_cliente'
    | 'cidadecob_cliente'
    | 'ufcob_cliente'
    | 'ativo_cliente'
    | 'obs_cliente'
    | 'im_cliente'
    | 'cod_cidade'
    | 'numend_cliente'
    | 'comend_cliente'
    | 'email_cliente'
    | 'codbanco_cliente'
    | 'sla_cliente',
    ExtArgs['result']['cliente']
  >;
  export type clienteInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    chamados?: boolean | cliente$chamadosArgs<ExtArgs>;
    fatrec?: boolean | cliente$fatrecArgs<ExtArgs>;
    projeto?: boolean | cliente$projetoArgs<ExtArgs>;
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type clienteIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type clienteIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $clientePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'cliente';
    objects: {
      chamados: Prisma.$chamadoPayload<ExtArgs>[];
      fatrec: Prisma.$fatrecPayload<ExtArgs>[];
      projeto: Prisma.$projetoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_cliente: number;
        nome_cliente: string;
        razao_cliente: string | null;
        end_cliente: string | null;
        bairro_cliente: string | null;
        cep_cliente: string | null;
        fone_cliente: string | null;
        cnpj_cliente: string | null;
        ie_cliente: string | null;
        uf_cliente: string | null;
        fax_cliente: string | null;
        contato_cliente: string | null;
        funccontato_cliente: string | null;
        endcob_cliente: string | null;
        bairrocob_cliente: string | null;
        cepcob_cliente: string | null;
        cidadecob_cliente: string | null;
        ufcob_cliente: string | null;
        ativo_cliente: number;
        obs_cliente: Uint8Array | null;
        im_cliente: string | null;
        cod_cidade: number | null;
        numend_cliente: string | null;
        comend_cliente: string | null;
        email_cliente: string | null;
        codbanco_cliente: string | null;
        sla_cliente: number;
      },
      ExtArgs['result']['cliente']
    >;
    composites: {};
  };

  type clienteGetPayload<
    S extends boolean | null | undefined | clienteDefaultArgs,
  > = $Result.GetResult<Prisma.$clientePayload, S>;

  type clienteCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<clienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ClienteCountAggregateInputType | true;
  };

  export interface clienteDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['cliente'];
      meta: { name: 'cliente' };
    };
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {clienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clienteFindUniqueArgs>(
      args: SelectSubset<T, clienteFindUniqueArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clienteFindUniqueOrThrowArgs>(
      args: SelectSubset<T, clienteFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clienteFindFirstArgs>(
      args?: SelectSubset<T, clienteFindFirstArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clienteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, clienteFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     *
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     *
     * // Only select the `cod_cliente`
     * const clienteWithCod_clienteOnly = await prisma.cliente.findMany({ select: { cod_cliente: true } })
     *
     */
    findMany<T extends clienteFindManyArgs>(
      args?: SelectSubset<T, clienteFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Cliente.
     * @param {clienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     *
     */
    create<T extends clienteCreateArgs>(
      args: SelectSubset<T, clienteCreateArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Clientes.
     * @param {clienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends clienteCreateManyArgs>(
      args?: SelectSubset<T, clienteCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {clienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Clientes and only return the `cod_cliente`
     * const clienteWithCod_clienteOnly = await prisma.cliente.createManyAndReturn({
     *   select: { cod_cliente: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends clienteCreateManyAndReturnArgs>(
      args?: SelectSubset<T, clienteCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Cliente.
     * @param {clienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     *
     */
    delete<T extends clienteDeleteArgs>(
      args: SelectSubset<T, clienteDeleteArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Cliente.
     * @param {clienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends clienteUpdateArgs>(
      args: SelectSubset<T, clienteUpdateArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Clientes.
     * @param {clienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends clienteDeleteManyArgs>(
      args?: SelectSubset<T, clienteDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends clienteUpdateManyArgs>(
      args: SelectSubset<T, clienteUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Clientes and returns the data updated in the database.
     * @param {clienteUpdateManyAndReturnArgs} args - Arguments to update many Clientes.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Clientes and only return the `cod_cliente`
     * const clienteWithCod_clienteOnly = await prisma.cliente.updateManyAndReturn({
     *   select: { cod_cliente: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends clienteUpdateManyAndReturnArgs>(
      args: SelectSubset<T, clienteUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Cliente.
     * @param {clienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends clienteUpsertArgs>(
      args: SelectSubset<T, clienteUpsertArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      $Result.GetResult<
        Prisma.$clientePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
     **/
    count<T extends clienteCountArgs>(
      args?: Subset<T, clienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClienteAggregateArgs>(
      args: Subset<T, ClienteAggregateArgs>,
    ): Prisma.PrismaPromise<GetClienteAggregateType<T>>;

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends clienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clienteGroupByArgs['orderBy'] }
        : { orderBy?: clienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, clienteGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetClienteGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the cliente model
     */
    readonly fields: clienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clienteClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    chamados<T extends cliente$chamadosArgs<ExtArgs> = {}>(
      args?: Subset<T, cliente$chamadosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$chamadoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    fatrec<T extends cliente$fatrecArgs<ExtArgs> = {}>(
      args?: Subset<T, cliente$fatrecArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$fatrecPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    projeto<T extends cliente$projetoArgs<ExtArgs> = {}>(
      args?: Subset<T, cliente$projetoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$projetoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the cliente model
   */
  interface clienteFieldRefs {
    readonly cod_cliente: FieldRef<'cliente', 'Int'>;
    readonly nome_cliente: FieldRef<'cliente', 'String'>;
    readonly razao_cliente: FieldRef<'cliente', 'String'>;
    readonly end_cliente: FieldRef<'cliente', 'String'>;
    readonly bairro_cliente: FieldRef<'cliente', 'String'>;
    readonly cep_cliente: FieldRef<'cliente', 'String'>;
    readonly fone_cliente: FieldRef<'cliente', 'String'>;
    readonly cnpj_cliente: FieldRef<'cliente', 'String'>;
    readonly ie_cliente: FieldRef<'cliente', 'String'>;
    readonly uf_cliente: FieldRef<'cliente', 'String'>;
    readonly fax_cliente: FieldRef<'cliente', 'String'>;
    readonly contato_cliente: FieldRef<'cliente', 'String'>;
    readonly funccontato_cliente: FieldRef<'cliente', 'String'>;
    readonly endcob_cliente: FieldRef<'cliente', 'String'>;
    readonly bairrocob_cliente: FieldRef<'cliente', 'String'>;
    readonly cepcob_cliente: FieldRef<'cliente', 'String'>;
    readonly cidadecob_cliente: FieldRef<'cliente', 'String'>;
    readonly ufcob_cliente: FieldRef<'cliente', 'String'>;
    readonly ativo_cliente: FieldRef<'cliente', 'Int'>;
    readonly obs_cliente: FieldRef<'cliente', 'Bytes'>;
    readonly im_cliente: FieldRef<'cliente', 'String'>;
    readonly cod_cidade: FieldRef<'cliente', 'Int'>;
    readonly numend_cliente: FieldRef<'cliente', 'String'>;
    readonly comend_cliente: FieldRef<'cliente', 'String'>;
    readonly email_cliente: FieldRef<'cliente', 'String'>;
    readonly codbanco_cliente: FieldRef<'cliente', 'String'>;
    readonly sla_cliente: FieldRef<'cliente', 'Int'>;
  }

  // Custom InputTypes
  /**
   * cliente findUnique
   */
  export type clienteFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput;
  };

  /**
   * cliente findUniqueOrThrow
   */
  export type clienteFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput;
  };

  /**
   * cliente findFirst
   */
  export type clienteFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of clientes to fetch.
     */
    orderBy?:
      | clienteOrderByWithRelationInput
      | clienteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` clientes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[];
  };

  /**
   * cliente findFirstOrThrow
   */
  export type clienteFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of clientes to fetch.
     */
    orderBy?:
      | clienteOrderByWithRelationInput
      | clienteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` clientes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[];
  };

  /**
   * cliente findMany
   */
  export type clienteFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * Filter, which clientes to fetch.
     */
    where?: clienteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of clientes to fetch.
     */
    orderBy?:
      | clienteOrderByWithRelationInput
      | clienteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing clientes.
     */
    cursor?: clienteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` clientes.
     */
    skip?: number;
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[];
  };

  /**
   * cliente create
   */
  export type clienteCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * The data needed to create a cliente.
     */
    data: XOR<clienteCreateInput, clienteUncheckedCreateInput>;
  };

  /**
   * cliente createMany
   */
  export type clienteCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many clientes.
     */
    data: clienteCreateManyInput | clienteCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * cliente createManyAndReturn
   */
  export type clienteCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * The data used to create many clientes.
     */
    data: clienteCreateManyInput | clienteCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * cliente update
   */
  export type clienteUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * The data needed to update a cliente.
     */
    data: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>;
    /**
     * Choose, which cliente to update.
     */
    where: clienteWhereUniqueInput;
  };

  /**
   * cliente updateMany
   */
  export type clienteUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update clientes.
     */
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyInput>;
    /**
     * Filter which clientes to update
     */
    where?: clienteWhereInput;
    /**
     * Limit how many clientes to update.
     */
    limit?: number;
  };

  /**
   * cliente updateManyAndReturn
   */
  export type clienteUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * The data used to update clientes.
     */
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyInput>;
    /**
     * Filter which clientes to update
     */
    where?: clienteWhereInput;
    /**
     * Limit how many clientes to update.
     */
    limit?: number;
  };

  /**
   * cliente upsert
   */
  export type clienteUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * The filter to search for the cliente to update in case it exists.
     */
    where: clienteWhereUniqueInput;
    /**
     * In case the cliente found by the `where` argument doesn't exist, create a new cliente with this data.
     */
    create: XOR<clienteCreateInput, clienteUncheckedCreateInput>;
    /**
     * In case the cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>;
  };

  /**
   * cliente delete
   */
  export type clienteDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
    /**
     * Filter which cliente to delete.
     */
    where: clienteWhereUniqueInput;
  };

  /**
   * cliente deleteMany
   */
  export type clienteDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which clientes to delete
     */
    where?: clienteWhereInput;
    /**
     * Limit how many clientes to delete.
     */
    limit?: number;
  };

  /**
   * cliente.chamados
   */
  export type cliente$chamadosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    where?: chamadoWhereInput;
    orderBy?:
      | chamadoOrderByWithRelationInput
      | chamadoOrderByWithRelationInput[];
    cursor?: chamadoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ChamadoScalarFieldEnum | ChamadoScalarFieldEnum[];
  };

  /**
   * cliente.fatrec
   */
  export type cliente$fatrecArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    where?: fatrecWhereInput;
    orderBy?: fatrecOrderByWithRelationInput | fatrecOrderByWithRelationInput[];
    cursor?: fatrecWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FatrecScalarFieldEnum | FatrecScalarFieldEnum[];
  };

  /**
   * cliente.projeto
   */
  export type cliente$projetoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    where?: projetoWhereInput;
    orderBy?:
      | projetoOrderByWithRelationInput
      | projetoOrderByWithRelationInput[];
    cursor?: projetoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[];
  };

  /**
   * cliente without action
   */
  export type clienteDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null;
  };

  /**
   * Model composicao
   */

  export type AggregateComposicao = {
    _count: ComposicaoCountAggregateOutputType | null;
    _avg: ComposicaoAvgAggregateOutputType | null;
    _sum: ComposicaoSumAggregateOutputType | null;
    _min: ComposicaoMinAggregateOutputType | null;
    _max: ComposicaoMaxAggregateOutputType | null;
  };

  export type ComposicaoAvgAggregateOutputType = {
    cod_composicao: number | null;
    cod_fatura: number | null;
    cod_cliente: number | null;
    cod_projeto: number | null;
    cod_tarefa: number | null;
    cod_recurso: number | null;
    hrfat_composicao: Decimal | null;
    hrnfat_composicao: Decimal | null;
    vrhr_composicao: Decimal | null;
    vrfat_composicao: Decimal | null;
  };

  export type ComposicaoSumAggregateOutputType = {
    cod_composicao: number | null;
    cod_fatura: number | null;
    cod_cliente: number | null;
    cod_projeto: number | null;
    cod_tarefa: number | null;
    cod_recurso: number | null;
    hrfat_composicao: Decimal | null;
    hrnfat_composicao: Decimal | null;
    vrhr_composicao: Decimal | null;
    vrfat_composicao: Decimal | null;
  };

  export type ComposicaoMinAggregateOutputType = {
    cod_composicao: number | null;
    cod_fatura: number | null;
    cod_cliente: number | null;
    cod_projeto: number | null;
    cod_tarefa: number | null;
    cod_recurso: number | null;
    hrfat_composicao: Decimal | null;
    hrnfat_composicao: Decimal | null;
    vrhr_composicao: Decimal | null;
    vrfat_composicao: Decimal | null;
  };

  export type ComposicaoMaxAggregateOutputType = {
    cod_composicao: number | null;
    cod_fatura: number | null;
    cod_cliente: number | null;
    cod_projeto: number | null;
    cod_tarefa: number | null;
    cod_recurso: number | null;
    hrfat_composicao: Decimal | null;
    hrnfat_composicao: Decimal | null;
    vrhr_composicao: Decimal | null;
    vrfat_composicao: Decimal | null;
  };

  export type ComposicaoCountAggregateOutputType = {
    cod_composicao: number;
    cod_fatura: number;
    cod_cliente: number;
    cod_projeto: number;
    cod_tarefa: number;
    cod_recurso: number;
    hrfat_composicao: number;
    hrnfat_composicao: number;
    vrhr_composicao: number;
    vrfat_composicao: number;
    _all: number;
  };

  export type ComposicaoAvgAggregateInputType = {
    cod_composicao?: true;
    cod_fatura?: true;
    cod_cliente?: true;
    cod_projeto?: true;
    cod_tarefa?: true;
    cod_recurso?: true;
    hrfat_composicao?: true;
    hrnfat_composicao?: true;
    vrhr_composicao?: true;
    vrfat_composicao?: true;
  };

  export type ComposicaoSumAggregateInputType = {
    cod_composicao?: true;
    cod_fatura?: true;
    cod_cliente?: true;
    cod_projeto?: true;
    cod_tarefa?: true;
    cod_recurso?: true;
    hrfat_composicao?: true;
    hrnfat_composicao?: true;
    vrhr_composicao?: true;
    vrfat_composicao?: true;
  };

  export type ComposicaoMinAggregateInputType = {
    cod_composicao?: true;
    cod_fatura?: true;
    cod_cliente?: true;
    cod_projeto?: true;
    cod_tarefa?: true;
    cod_recurso?: true;
    hrfat_composicao?: true;
    hrnfat_composicao?: true;
    vrhr_composicao?: true;
    vrfat_composicao?: true;
  };

  export type ComposicaoMaxAggregateInputType = {
    cod_composicao?: true;
    cod_fatura?: true;
    cod_cliente?: true;
    cod_projeto?: true;
    cod_tarefa?: true;
    cod_recurso?: true;
    hrfat_composicao?: true;
    hrnfat_composicao?: true;
    vrhr_composicao?: true;
    vrfat_composicao?: true;
  };

  export type ComposicaoCountAggregateInputType = {
    cod_composicao?: true;
    cod_fatura?: true;
    cod_cliente?: true;
    cod_projeto?: true;
    cod_tarefa?: true;
    cod_recurso?: true;
    hrfat_composicao?: true;
    hrnfat_composicao?: true;
    vrhr_composicao?: true;
    vrfat_composicao?: true;
    _all?: true;
  };

  export type ComposicaoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which composicao to aggregate.
     */
    where?: composicaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of composicaos to fetch.
     */
    orderBy?:
      | composicaoOrderByWithRelationInput
      | composicaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: composicaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` composicaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` composicaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned composicaos
     **/
    _count?: true | ComposicaoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ComposicaoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ComposicaoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ComposicaoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ComposicaoMaxAggregateInputType;
  };

  export type GetComposicaoAggregateType<T extends ComposicaoAggregateArgs> = {
    [P in keyof T & keyof AggregateComposicao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComposicao[P]>
      : GetScalarType<T[P], AggregateComposicao[P]>;
  };

  export type composicaoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: composicaoWhereInput;
    orderBy?:
      | composicaoOrderByWithAggregationInput
      | composicaoOrderByWithAggregationInput[];
    by: ComposicaoScalarFieldEnum[] | ComposicaoScalarFieldEnum;
    having?: composicaoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ComposicaoCountAggregateInputType | true;
    _avg?: ComposicaoAvgAggregateInputType;
    _sum?: ComposicaoSumAggregateInputType;
    _min?: ComposicaoMinAggregateInputType;
    _max?: ComposicaoMaxAggregateInputType;
  };

  export type ComposicaoGroupByOutputType = {
    cod_composicao: number;
    cod_fatura: number;
    cod_cliente: number;
    cod_projeto: number;
    cod_tarefa: number;
    cod_recurso: number;
    hrfat_composicao: Decimal | null;
    hrnfat_composicao: Decimal | null;
    vrhr_composicao: Decimal | null;
    vrfat_composicao: Decimal | null;
    _count: ComposicaoCountAggregateOutputType | null;
    _avg: ComposicaoAvgAggregateOutputType | null;
    _sum: ComposicaoSumAggregateOutputType | null;
    _min: ComposicaoMinAggregateOutputType | null;
    _max: ComposicaoMaxAggregateOutputType | null;
  };

  type GetComposicaoGroupByPayload<T extends composicaoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ComposicaoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ComposicaoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComposicaoGroupByOutputType[P]>
            : GetScalarType<T[P], ComposicaoGroupByOutputType[P]>;
        }
      >
    >;

  export type composicaoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_composicao?: boolean;
      cod_fatura?: boolean;
      cod_cliente?: boolean;
      cod_projeto?: boolean;
      cod_tarefa?: boolean;
      cod_recurso?: boolean;
      hrfat_composicao?: boolean;
      hrnfat_composicao?: boolean;
      vrhr_composicao?: boolean;
      vrfat_composicao?: boolean;
    },
    ExtArgs['result']['composicao']
  >;

  export type composicaoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_composicao?: boolean;
      cod_fatura?: boolean;
      cod_cliente?: boolean;
      cod_projeto?: boolean;
      cod_tarefa?: boolean;
      cod_recurso?: boolean;
      hrfat_composicao?: boolean;
      hrnfat_composicao?: boolean;
      vrhr_composicao?: boolean;
      vrfat_composicao?: boolean;
    },
    ExtArgs['result']['composicao']
  >;

  export type composicaoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_composicao?: boolean;
      cod_fatura?: boolean;
      cod_cliente?: boolean;
      cod_projeto?: boolean;
      cod_tarefa?: boolean;
      cod_recurso?: boolean;
      hrfat_composicao?: boolean;
      hrnfat_composicao?: boolean;
      vrhr_composicao?: boolean;
      vrfat_composicao?: boolean;
    },
    ExtArgs['result']['composicao']
  >;

  export type composicaoSelectScalar = {
    cod_composicao?: boolean;
    cod_fatura?: boolean;
    cod_cliente?: boolean;
    cod_projeto?: boolean;
    cod_tarefa?: boolean;
    cod_recurso?: boolean;
    hrfat_composicao?: boolean;
    hrnfat_composicao?: boolean;
    vrhr_composicao?: boolean;
    vrfat_composicao?: boolean;
  };

  export type composicaoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_composicao'
    | 'cod_fatura'
    | 'cod_cliente'
    | 'cod_projeto'
    | 'cod_tarefa'
    | 'cod_recurso'
    | 'hrfat_composicao'
    | 'hrnfat_composicao'
    | 'vrhr_composicao'
    | 'vrfat_composicao',
    ExtArgs['result']['composicao']
  >;

  export type $composicaoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'composicao';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_composicao: number;
        cod_fatura: number;
        cod_cliente: number;
        cod_projeto: number;
        cod_tarefa: number;
        cod_recurso: number;
        hrfat_composicao: Prisma.Decimal | null;
        hrnfat_composicao: Prisma.Decimal | null;
        vrhr_composicao: Prisma.Decimal | null;
        vrfat_composicao: Prisma.Decimal | null;
      },
      ExtArgs['result']['composicao']
    >;
    composites: {};
  };

  type composicaoGetPayload<
    S extends boolean | null | undefined | composicaoDefaultArgs,
  > = $Result.GetResult<Prisma.$composicaoPayload, S>;

  type composicaoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    composicaoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ComposicaoCountAggregateInputType | true;
  };

  export interface composicaoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['composicao'];
      meta: { name: 'composicao' };
    };
    /**
     * Find zero or one Composicao that matches the filter.
     * @param {composicaoFindUniqueArgs} args - Arguments to find a Composicao
     * @example
     * // Get one Composicao
     * const composicao = await prisma.composicao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends composicaoFindUniqueArgs>(
      args: SelectSubset<T, composicaoFindUniqueArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Composicao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {composicaoFindUniqueOrThrowArgs} args - Arguments to find a Composicao
     * @example
     * // Get one Composicao
     * const composicao = await prisma.composicao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends composicaoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, composicaoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Composicao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {composicaoFindFirstArgs} args - Arguments to find a Composicao
     * @example
     * // Get one Composicao
     * const composicao = await prisma.composicao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends composicaoFindFirstArgs>(
      args?: SelectSubset<T, composicaoFindFirstArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Composicao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {composicaoFindFirstOrThrowArgs} args - Arguments to find a Composicao
     * @example
     * // Get one Composicao
     * const composicao = await prisma.composicao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends composicaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, composicaoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Composicaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {composicaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Composicaos
     * const composicaos = await prisma.composicao.findMany()
     *
     * // Get first 10 Composicaos
     * const composicaos = await prisma.composicao.findMany({ take: 10 })
     *
     * // Only select the `cod_composicao`
     * const composicaoWithCod_composicaoOnly = await prisma.composicao.findMany({ select: { cod_composicao: true } })
     *
     */
    findMany<T extends composicaoFindManyArgs>(
      args?: SelectSubset<T, composicaoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Composicao.
     * @param {composicaoCreateArgs} args - Arguments to create a Composicao.
     * @example
     * // Create one Composicao
     * const Composicao = await prisma.composicao.create({
     *   data: {
     *     // ... data to create a Composicao
     *   }
     * })
     *
     */
    create<T extends composicaoCreateArgs>(
      args: SelectSubset<T, composicaoCreateArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Composicaos.
     * @param {composicaoCreateManyArgs} args - Arguments to create many Composicaos.
     * @example
     * // Create many Composicaos
     * const composicao = await prisma.composicao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends composicaoCreateManyArgs>(
      args?: SelectSubset<T, composicaoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Composicaos and returns the data saved in the database.
     * @param {composicaoCreateManyAndReturnArgs} args - Arguments to create many Composicaos.
     * @example
     * // Create many Composicaos
     * const composicao = await prisma.composicao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Composicaos and only return the `cod_composicao`
     * const composicaoWithCod_composicaoOnly = await prisma.composicao.createManyAndReturn({
     *   select: { cod_composicao: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends composicaoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, composicaoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Composicao.
     * @param {composicaoDeleteArgs} args - Arguments to delete one Composicao.
     * @example
     * // Delete one Composicao
     * const Composicao = await prisma.composicao.delete({
     *   where: {
     *     // ... filter to delete one Composicao
     *   }
     * })
     *
     */
    delete<T extends composicaoDeleteArgs>(
      args: SelectSubset<T, composicaoDeleteArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Composicao.
     * @param {composicaoUpdateArgs} args - Arguments to update one Composicao.
     * @example
     * // Update one Composicao
     * const composicao = await prisma.composicao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends composicaoUpdateArgs>(
      args: SelectSubset<T, composicaoUpdateArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Composicaos.
     * @param {composicaoDeleteManyArgs} args - Arguments to filter Composicaos to delete.
     * @example
     * // Delete a few Composicaos
     * const { count } = await prisma.composicao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends composicaoDeleteManyArgs>(
      args?: SelectSubset<T, composicaoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Composicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {composicaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Composicaos
     * const composicao = await prisma.composicao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends composicaoUpdateManyArgs>(
      args: SelectSubset<T, composicaoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Composicaos and returns the data updated in the database.
     * @param {composicaoUpdateManyAndReturnArgs} args - Arguments to update many Composicaos.
     * @example
     * // Update many Composicaos
     * const composicao = await prisma.composicao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Composicaos and only return the `cod_composicao`
     * const composicaoWithCod_composicaoOnly = await prisma.composicao.updateManyAndReturn({
     *   select: { cod_composicao: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends composicaoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, composicaoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Composicao.
     * @param {composicaoUpsertArgs} args - Arguments to update or create a Composicao.
     * @example
     * // Update or create a Composicao
     * const composicao = await prisma.composicao.upsert({
     *   create: {
     *     // ... data to create a Composicao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Composicao we want to update
     *   }
     * })
     */
    upsert<T extends composicaoUpsertArgs>(
      args: SelectSubset<T, composicaoUpsertArgs<ExtArgs>>,
    ): Prisma__composicaoClient<
      $Result.GetResult<
        Prisma.$composicaoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Composicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {composicaoCountArgs} args - Arguments to filter Composicaos to count.
     * @example
     * // Count the number of Composicaos
     * const count = await prisma.composicao.count({
     *   where: {
     *     // ... the filter for the Composicaos we want to count
     *   }
     * })
     **/
    count<T extends composicaoCountArgs>(
      args?: Subset<T, composicaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComposicaoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Composicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComposicaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ComposicaoAggregateArgs>(
      args: Subset<T, ComposicaoAggregateArgs>,
    ): Prisma.PrismaPromise<GetComposicaoAggregateType<T>>;

    /**
     * Group by Composicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {composicaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends composicaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: composicaoGroupByArgs['orderBy'] }
        : { orderBy?: composicaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, composicaoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetComposicaoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the composicao model
     */
    readonly fields: composicaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for composicao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__composicaoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the composicao model
   */
  interface composicaoFieldRefs {
    readonly cod_composicao: FieldRef<'composicao', 'Int'>;
    readonly cod_fatura: FieldRef<'composicao', 'Int'>;
    readonly cod_cliente: FieldRef<'composicao', 'Int'>;
    readonly cod_projeto: FieldRef<'composicao', 'Int'>;
    readonly cod_tarefa: FieldRef<'composicao', 'Int'>;
    readonly cod_recurso: FieldRef<'composicao', 'Int'>;
    readonly hrfat_composicao: FieldRef<'composicao', 'Decimal'>;
    readonly hrnfat_composicao: FieldRef<'composicao', 'Decimal'>;
    readonly vrhr_composicao: FieldRef<'composicao', 'Decimal'>;
    readonly vrfat_composicao: FieldRef<'composicao', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * composicao findUnique
   */
  export type composicaoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * Filter, which composicao to fetch.
     */
    where: composicaoWhereUniqueInput;
  };

  /**
   * composicao findUniqueOrThrow
   */
  export type composicaoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * Filter, which composicao to fetch.
     */
    where: composicaoWhereUniqueInput;
  };

  /**
   * composicao findFirst
   */
  export type composicaoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * Filter, which composicao to fetch.
     */
    where?: composicaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of composicaos to fetch.
     */
    orderBy?:
      | composicaoOrderByWithRelationInput
      | composicaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for composicaos.
     */
    cursor?: composicaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` composicaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` composicaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of composicaos.
     */
    distinct?: ComposicaoScalarFieldEnum | ComposicaoScalarFieldEnum[];
  };

  /**
   * composicao findFirstOrThrow
   */
  export type composicaoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * Filter, which composicao to fetch.
     */
    where?: composicaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of composicaos to fetch.
     */
    orderBy?:
      | composicaoOrderByWithRelationInput
      | composicaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for composicaos.
     */
    cursor?: composicaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` composicaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` composicaos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of composicaos.
     */
    distinct?: ComposicaoScalarFieldEnum | ComposicaoScalarFieldEnum[];
  };

  /**
   * composicao findMany
   */
  export type composicaoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * Filter, which composicaos to fetch.
     */
    where?: composicaoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of composicaos to fetch.
     */
    orderBy?:
      | composicaoOrderByWithRelationInput
      | composicaoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing composicaos.
     */
    cursor?: composicaoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` composicaos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` composicaos.
     */
    skip?: number;
    distinct?: ComposicaoScalarFieldEnum | ComposicaoScalarFieldEnum[];
  };

  /**
   * composicao create
   */
  export type composicaoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * The data needed to create a composicao.
     */
    data: XOR<composicaoCreateInput, composicaoUncheckedCreateInput>;
  };

  /**
   * composicao createMany
   */
  export type composicaoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many composicaos.
     */
    data: composicaoCreateManyInput | composicaoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * composicao createManyAndReturn
   */
  export type composicaoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * The data used to create many composicaos.
     */
    data: composicaoCreateManyInput | composicaoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * composicao update
   */
  export type composicaoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * The data needed to update a composicao.
     */
    data: XOR<composicaoUpdateInput, composicaoUncheckedUpdateInput>;
    /**
     * Choose, which composicao to update.
     */
    where: composicaoWhereUniqueInput;
  };

  /**
   * composicao updateMany
   */
  export type composicaoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update composicaos.
     */
    data: XOR<
      composicaoUpdateManyMutationInput,
      composicaoUncheckedUpdateManyInput
    >;
    /**
     * Filter which composicaos to update
     */
    where?: composicaoWhereInput;
    /**
     * Limit how many composicaos to update.
     */
    limit?: number;
  };

  /**
   * composicao updateManyAndReturn
   */
  export type composicaoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * The data used to update composicaos.
     */
    data: XOR<
      composicaoUpdateManyMutationInput,
      composicaoUncheckedUpdateManyInput
    >;
    /**
     * Filter which composicaos to update
     */
    where?: composicaoWhereInput;
    /**
     * Limit how many composicaos to update.
     */
    limit?: number;
  };

  /**
   * composicao upsert
   */
  export type composicaoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * The filter to search for the composicao to update in case it exists.
     */
    where: composicaoWhereUniqueInput;
    /**
     * In case the composicao found by the `where` argument doesn't exist, create a new composicao with this data.
     */
    create: XOR<composicaoCreateInput, composicaoUncheckedCreateInput>;
    /**
     * In case the composicao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<composicaoUpdateInput, composicaoUncheckedUpdateInput>;
  };

  /**
   * composicao delete
   */
  export type composicaoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
    /**
     * Filter which composicao to delete.
     */
    where: composicaoWhereUniqueInput;
  };

  /**
   * composicao deleteMany
   */
  export type composicaoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which composicaos to delete
     */
    where?: composicaoWhereInput;
    /**
     * Limit how many composicaos to delete.
     */
    limit?: number;
  };

  /**
   * composicao without action
   */
  export type composicaoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the composicao
     */
    select?: composicaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the composicao
     */
    omit?: composicaoOmit<ExtArgs> | null;
  };

  /**
   * Model contato
   */

  export type AggregateContato = {
    _count: ContatoCountAggregateOutputType | null;
    _avg: ContatoAvgAggregateOutputType | null;
    _sum: ContatoSumAggregateOutputType | null;
    _min: ContatoMinAggregateOutputType | null;
    _max: ContatoMaxAggregateOutputType | null;
  };

  export type ContatoAvgAggregateOutputType = {
    cod_contato: number | null;
    cod_lista: number | null;
  };

  export type ContatoSumAggregateOutputType = {
    cod_contato: number | null;
    cod_lista: number | null;
  };

  export type ContatoMinAggregateOutputType = {
    cod_contato: number | null;
    data_contato: Date | null;
    hora_contato: string | null;
    nomeusuario_contato: string | null;
    desc_contato: string | null;
    cod_lista: number | null;
  };

  export type ContatoMaxAggregateOutputType = {
    cod_contato: number | null;
    data_contato: Date | null;
    hora_contato: string | null;
    nomeusuario_contato: string | null;
    desc_contato: string | null;
    cod_lista: number | null;
  };

  export type ContatoCountAggregateOutputType = {
    cod_contato: number;
    data_contato: number;
    hora_contato: number;
    nomeusuario_contato: number;
    desc_contato: number;
    cod_lista: number;
    _all: number;
  };

  export type ContatoAvgAggregateInputType = {
    cod_contato?: true;
    cod_lista?: true;
  };

  export type ContatoSumAggregateInputType = {
    cod_contato?: true;
    cod_lista?: true;
  };

  export type ContatoMinAggregateInputType = {
    cod_contato?: true;
    data_contato?: true;
    hora_contato?: true;
    nomeusuario_contato?: true;
    desc_contato?: true;
    cod_lista?: true;
  };

  export type ContatoMaxAggregateInputType = {
    cod_contato?: true;
    data_contato?: true;
    hora_contato?: true;
    nomeusuario_contato?: true;
    desc_contato?: true;
    cod_lista?: true;
  };

  export type ContatoCountAggregateInputType = {
    cod_contato?: true;
    data_contato?: true;
    hora_contato?: true;
    nomeusuario_contato?: true;
    desc_contato?: true;
    cod_lista?: true;
    _all?: true;
  };

  export type ContatoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which contato to aggregate.
     */
    where?: contatoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of contatoes to fetch.
     */
    orderBy?:
      | contatoOrderByWithRelationInput
      | contatoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: contatoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` contatoes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` contatoes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned contatoes
     **/
    _count?: true | ContatoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ContatoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ContatoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ContatoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ContatoMaxAggregateInputType;
  };

  export type GetContatoAggregateType<T extends ContatoAggregateArgs> = {
    [P in keyof T & keyof AggregateContato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContato[P]>
      : GetScalarType<T[P], AggregateContato[P]>;
  };

  export type contatoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: contatoWhereInput;
    orderBy?:
      | contatoOrderByWithAggregationInput
      | contatoOrderByWithAggregationInput[];
    by: ContatoScalarFieldEnum[] | ContatoScalarFieldEnum;
    having?: contatoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ContatoCountAggregateInputType | true;
    _avg?: ContatoAvgAggregateInputType;
    _sum?: ContatoSumAggregateInputType;
    _min?: ContatoMinAggregateInputType;
    _max?: ContatoMaxAggregateInputType;
  };

  export type ContatoGroupByOutputType = {
    cod_contato: number;
    data_contato: Date;
    hora_contato: string;
    nomeusuario_contato: string;
    desc_contato: string | null;
    cod_lista: number;
    _count: ContatoCountAggregateOutputType | null;
    _avg: ContatoAvgAggregateOutputType | null;
    _sum: ContatoSumAggregateOutputType | null;
    _min: ContatoMinAggregateOutputType | null;
    _max: ContatoMaxAggregateOutputType | null;
  };

  type GetContatoGroupByPayload<T extends contatoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ContatoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ContatoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContatoGroupByOutputType[P]>
            : GetScalarType<T[P], ContatoGroupByOutputType[P]>;
        }
      >
    >;

  export type contatoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_contato?: boolean;
      data_contato?: boolean;
      hora_contato?: boolean;
      nomeusuario_contato?: boolean;
      desc_contato?: boolean;
      cod_lista?: boolean;
    },
    ExtArgs['result']['contato']
  >;

  export type contatoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_contato?: boolean;
      data_contato?: boolean;
      hora_contato?: boolean;
      nomeusuario_contato?: boolean;
      desc_contato?: boolean;
      cod_lista?: boolean;
    },
    ExtArgs['result']['contato']
  >;

  export type contatoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_contato?: boolean;
      data_contato?: boolean;
      hora_contato?: boolean;
      nomeusuario_contato?: boolean;
      desc_contato?: boolean;
      cod_lista?: boolean;
    },
    ExtArgs['result']['contato']
  >;

  export type contatoSelectScalar = {
    cod_contato?: boolean;
    data_contato?: boolean;
    hora_contato?: boolean;
    nomeusuario_contato?: boolean;
    desc_contato?: boolean;
    cod_lista?: boolean;
  };

  export type contatoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_contato'
    | 'data_contato'
    | 'hora_contato'
    | 'nomeusuario_contato'
    | 'desc_contato'
    | 'cod_lista',
    ExtArgs['result']['contato']
  >;

  export type $contatoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'contato';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_contato: number;
        data_contato: Date;
        hora_contato: string;
        nomeusuario_contato: string;
        desc_contato: string | null;
        cod_lista: number;
      },
      ExtArgs['result']['contato']
    >;
    composites: {};
  };

  type contatoGetPayload<
    S extends boolean | null | undefined | contatoDefaultArgs,
  > = $Result.GetResult<Prisma.$contatoPayload, S>;

  type contatoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<contatoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ContatoCountAggregateInputType | true;
  };

  export interface contatoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['contato'];
      meta: { name: 'contato' };
    };
    /**
     * Find zero or one Contato that matches the filter.
     * @param {contatoFindUniqueArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contatoFindUniqueArgs>(
      args: SelectSubset<T, contatoFindUniqueArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Contato that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contatoFindUniqueOrThrowArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contatoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, contatoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Contato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contatoFindFirstArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contatoFindFirstArgs>(
      args?: SelectSubset<T, contatoFindFirstArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Contato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contatoFindFirstOrThrowArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contatoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, contatoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Contatoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contatoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contatoes
     * const contatoes = await prisma.contato.findMany()
     *
     * // Get first 10 Contatoes
     * const contatoes = await prisma.contato.findMany({ take: 10 })
     *
     * // Only select the `cod_contato`
     * const contatoWithCod_contatoOnly = await prisma.contato.findMany({ select: { cod_contato: true } })
     *
     */
    findMany<T extends contatoFindManyArgs>(
      args?: SelectSubset<T, contatoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Contato.
     * @param {contatoCreateArgs} args - Arguments to create a Contato.
     * @example
     * // Create one Contato
     * const Contato = await prisma.contato.create({
     *   data: {
     *     // ... data to create a Contato
     *   }
     * })
     *
     */
    create<T extends contatoCreateArgs>(
      args: SelectSubset<T, contatoCreateArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Contatoes.
     * @param {contatoCreateManyArgs} args - Arguments to create many Contatoes.
     * @example
     * // Create many Contatoes
     * const contato = await prisma.contato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends contatoCreateManyArgs>(
      args?: SelectSubset<T, contatoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Contatoes and returns the data saved in the database.
     * @param {contatoCreateManyAndReturnArgs} args - Arguments to create many Contatoes.
     * @example
     * // Create many Contatoes
     * const contato = await prisma.contato.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Contatoes and only return the `cod_contato`
     * const contatoWithCod_contatoOnly = await prisma.contato.createManyAndReturn({
     *   select: { cod_contato: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends contatoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, contatoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Contato.
     * @param {contatoDeleteArgs} args - Arguments to delete one Contato.
     * @example
     * // Delete one Contato
     * const Contato = await prisma.contato.delete({
     *   where: {
     *     // ... filter to delete one Contato
     *   }
     * })
     *
     */
    delete<T extends contatoDeleteArgs>(
      args: SelectSubset<T, contatoDeleteArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Contato.
     * @param {contatoUpdateArgs} args - Arguments to update one Contato.
     * @example
     * // Update one Contato
     * const contato = await prisma.contato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends contatoUpdateArgs>(
      args: SelectSubset<T, contatoUpdateArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Contatoes.
     * @param {contatoDeleteManyArgs} args - Arguments to filter Contatoes to delete.
     * @example
     * // Delete a few Contatoes
     * const { count } = await prisma.contato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends contatoDeleteManyArgs>(
      args?: SelectSubset<T, contatoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Contatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contatoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contatoes
     * const contato = await prisma.contato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends contatoUpdateManyArgs>(
      args: SelectSubset<T, contatoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Contatoes and returns the data updated in the database.
     * @param {contatoUpdateManyAndReturnArgs} args - Arguments to update many Contatoes.
     * @example
     * // Update many Contatoes
     * const contato = await prisma.contato.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Contatoes and only return the `cod_contato`
     * const contatoWithCod_contatoOnly = await prisma.contato.updateManyAndReturn({
     *   select: { cod_contato: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends contatoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, contatoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Contato.
     * @param {contatoUpsertArgs} args - Arguments to update or create a Contato.
     * @example
     * // Update or create a Contato
     * const contato = await prisma.contato.upsert({
     *   create: {
     *     // ... data to create a Contato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contato we want to update
     *   }
     * })
     */
    upsert<T extends contatoUpsertArgs>(
      args: SelectSubset<T, contatoUpsertArgs<ExtArgs>>,
    ): Prisma__contatoClient<
      $Result.GetResult<
        Prisma.$contatoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Contatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contatoCountArgs} args - Arguments to filter Contatoes to count.
     * @example
     * // Count the number of Contatoes
     * const count = await prisma.contato.count({
     *   where: {
     *     // ... the filter for the Contatoes we want to count
     *   }
     * })
     **/
    count<T extends contatoCountArgs>(
      args?: Subset<T, contatoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContatoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Contato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ContatoAggregateArgs>(
      args: Subset<T, ContatoAggregateArgs>,
    ): Prisma.PrismaPromise<GetContatoAggregateType<T>>;

    /**
     * Group by Contato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contatoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends contatoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contatoGroupByArgs['orderBy'] }
        : { orderBy?: contatoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, contatoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetContatoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the contato model
     */
    readonly fields: contatoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contatoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the contato model
   */
  interface contatoFieldRefs {
    readonly cod_contato: FieldRef<'contato', 'Int'>;
    readonly data_contato: FieldRef<'contato', 'DateTime'>;
    readonly hora_contato: FieldRef<'contato', 'String'>;
    readonly nomeusuario_contato: FieldRef<'contato', 'String'>;
    readonly desc_contato: FieldRef<'contato', 'String'>;
    readonly cod_lista: FieldRef<'contato', 'Int'>;
  }

  // Custom InputTypes
  /**
   * contato findUnique
   */
  export type contatoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * Filter, which contato to fetch.
     */
    where: contatoWhereUniqueInput;
  };

  /**
   * contato findUniqueOrThrow
   */
  export type contatoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * Filter, which contato to fetch.
     */
    where: contatoWhereUniqueInput;
  };

  /**
   * contato findFirst
   */
  export type contatoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * Filter, which contato to fetch.
     */
    where?: contatoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of contatoes to fetch.
     */
    orderBy?:
      | contatoOrderByWithRelationInput
      | contatoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for contatoes.
     */
    cursor?: contatoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` contatoes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` contatoes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of contatoes.
     */
    distinct?: ContatoScalarFieldEnum | ContatoScalarFieldEnum[];
  };

  /**
   * contato findFirstOrThrow
   */
  export type contatoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * Filter, which contato to fetch.
     */
    where?: contatoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of contatoes to fetch.
     */
    orderBy?:
      | contatoOrderByWithRelationInput
      | contatoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for contatoes.
     */
    cursor?: contatoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` contatoes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` contatoes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of contatoes.
     */
    distinct?: ContatoScalarFieldEnum | ContatoScalarFieldEnum[];
  };

  /**
   * contato findMany
   */
  export type contatoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * Filter, which contatoes to fetch.
     */
    where?: contatoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of contatoes to fetch.
     */
    orderBy?:
      | contatoOrderByWithRelationInput
      | contatoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing contatoes.
     */
    cursor?: contatoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` contatoes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` contatoes.
     */
    skip?: number;
    distinct?: ContatoScalarFieldEnum | ContatoScalarFieldEnum[];
  };

  /**
   * contato create
   */
  export type contatoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * The data needed to create a contato.
     */
    data: XOR<contatoCreateInput, contatoUncheckedCreateInput>;
  };

  /**
   * contato createMany
   */
  export type contatoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many contatoes.
     */
    data: contatoCreateManyInput | contatoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * contato createManyAndReturn
   */
  export type contatoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * The data used to create many contatoes.
     */
    data: contatoCreateManyInput | contatoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * contato update
   */
  export type contatoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * The data needed to update a contato.
     */
    data: XOR<contatoUpdateInput, contatoUncheckedUpdateInput>;
    /**
     * Choose, which contato to update.
     */
    where: contatoWhereUniqueInput;
  };

  /**
   * contato updateMany
   */
  export type contatoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update contatoes.
     */
    data: XOR<contatoUpdateManyMutationInput, contatoUncheckedUpdateManyInput>;
    /**
     * Filter which contatoes to update
     */
    where?: contatoWhereInput;
    /**
     * Limit how many contatoes to update.
     */
    limit?: number;
  };

  /**
   * contato updateManyAndReturn
   */
  export type contatoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * The data used to update contatoes.
     */
    data: XOR<contatoUpdateManyMutationInput, contatoUncheckedUpdateManyInput>;
    /**
     * Filter which contatoes to update
     */
    where?: contatoWhereInput;
    /**
     * Limit how many contatoes to update.
     */
    limit?: number;
  };

  /**
   * contato upsert
   */
  export type contatoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * The filter to search for the contato to update in case it exists.
     */
    where: contatoWhereUniqueInput;
    /**
     * In case the contato found by the `where` argument doesn't exist, create a new contato with this data.
     */
    create: XOR<contatoCreateInput, contatoUncheckedCreateInput>;
    /**
     * In case the contato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contatoUpdateInput, contatoUncheckedUpdateInput>;
  };

  /**
   * contato delete
   */
  export type contatoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
    /**
     * Filter which contato to delete.
     */
    where: contatoWhereUniqueInput;
  };

  /**
   * contato deleteMany
   */
  export type contatoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which contatoes to delete
     */
    where?: contatoWhereInput;
    /**
     * Limit how many contatoes to delete.
     */
    limit?: number;
  };

  /**
   * contato without action
   */
  export type contatoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the contato
     */
    select?: contatoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the contato
     */
    omit?: contatoOmit<ExtArgs> | null;
  };

  /**
   * Model ctiss
   */

  export type AggregateCtiss = {
    _count: CtissCountAggregateOutputType | null;
    _avg: CtissAvgAggregateOutputType | null;
    _sum: CtissSumAggregateOutputType | null;
    _min: CtissMinAggregateOutputType | null;
    _max: CtissMaxAggregateOutputType | null;
  };

  export type CtissAvgAggregateOutputType = {
    cod_ctiss: number | null;
    csll_ctiss: Decimal | null;
    pis_ctiss: Decimal | null;
    cofins_ctiss: Decimal | null;
    irrf_ctiss: Decimal | null;
    aliq_ctiss: Decimal | null;
    aliqret_ctiss: Decimal | null;
  };

  export type CtissSumAggregateOutputType = {
    cod_ctiss: number | null;
    csll_ctiss: Decimal | null;
    pis_ctiss: Decimal | null;
    cofins_ctiss: Decimal | null;
    irrf_ctiss: Decimal | null;
    aliq_ctiss: Decimal | null;
    aliqret_ctiss: Decimal | null;
  };

  export type CtissMinAggregateOutputType = {
    cod_ctiss: number | null;
    num_ctiss: string | null;
    subitem_ctiss: string | null;
    descr_ctiss: string | null;
    csll_ctiss: Decimal | null;
    pis_ctiss: Decimal | null;
    cofins_ctiss: Decimal | null;
    irrf_ctiss: Decimal | null;
    aliq_ctiss: Decimal | null;
    aliqret_ctiss: Decimal | null;
  };

  export type CtissMaxAggregateOutputType = {
    cod_ctiss: number | null;
    num_ctiss: string | null;
    subitem_ctiss: string | null;
    descr_ctiss: string | null;
    csll_ctiss: Decimal | null;
    pis_ctiss: Decimal | null;
    cofins_ctiss: Decimal | null;
    irrf_ctiss: Decimal | null;
    aliq_ctiss: Decimal | null;
    aliqret_ctiss: Decimal | null;
  };

  export type CtissCountAggregateOutputType = {
    cod_ctiss: number;
    num_ctiss: number;
    subitem_ctiss: number;
    descr_ctiss: number;
    csll_ctiss: number;
    pis_ctiss: number;
    cofins_ctiss: number;
    irrf_ctiss: number;
    aliq_ctiss: number;
    aliqret_ctiss: number;
    _all: number;
  };

  export type CtissAvgAggregateInputType = {
    cod_ctiss?: true;
    csll_ctiss?: true;
    pis_ctiss?: true;
    cofins_ctiss?: true;
    irrf_ctiss?: true;
    aliq_ctiss?: true;
    aliqret_ctiss?: true;
  };

  export type CtissSumAggregateInputType = {
    cod_ctiss?: true;
    csll_ctiss?: true;
    pis_ctiss?: true;
    cofins_ctiss?: true;
    irrf_ctiss?: true;
    aliq_ctiss?: true;
    aliqret_ctiss?: true;
  };

  export type CtissMinAggregateInputType = {
    cod_ctiss?: true;
    num_ctiss?: true;
    subitem_ctiss?: true;
    descr_ctiss?: true;
    csll_ctiss?: true;
    pis_ctiss?: true;
    cofins_ctiss?: true;
    irrf_ctiss?: true;
    aliq_ctiss?: true;
    aliqret_ctiss?: true;
  };

  export type CtissMaxAggregateInputType = {
    cod_ctiss?: true;
    num_ctiss?: true;
    subitem_ctiss?: true;
    descr_ctiss?: true;
    csll_ctiss?: true;
    pis_ctiss?: true;
    cofins_ctiss?: true;
    irrf_ctiss?: true;
    aliq_ctiss?: true;
    aliqret_ctiss?: true;
  };

  export type CtissCountAggregateInputType = {
    cod_ctiss?: true;
    num_ctiss?: true;
    subitem_ctiss?: true;
    descr_ctiss?: true;
    csll_ctiss?: true;
    pis_ctiss?: true;
    cofins_ctiss?: true;
    irrf_ctiss?: true;
    aliq_ctiss?: true;
    aliqret_ctiss?: true;
    _all?: true;
  };

  export type CtissAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ctiss to aggregate.
     */
    where?: ctissWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ctisses to fetch.
     */
    orderBy?: ctissOrderByWithRelationInput | ctissOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ctissWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ctisses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ctisses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ctisses
     **/
    _count?: true | CtissCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CtissAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CtissSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CtissMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CtissMaxAggregateInputType;
  };

  export type GetCtissAggregateType<T extends CtissAggregateArgs> = {
    [P in keyof T & keyof AggregateCtiss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCtiss[P]>
      : GetScalarType<T[P], AggregateCtiss[P]>;
  };

  export type ctissGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ctissWhereInput;
    orderBy?:
      | ctissOrderByWithAggregationInput
      | ctissOrderByWithAggregationInput[];
    by: CtissScalarFieldEnum[] | CtissScalarFieldEnum;
    having?: ctissScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CtissCountAggregateInputType | true;
    _avg?: CtissAvgAggregateInputType;
    _sum?: CtissSumAggregateInputType;
    _min?: CtissMinAggregateInputType;
    _max?: CtissMaxAggregateInputType;
  };

  export type CtissGroupByOutputType = {
    cod_ctiss: number;
    num_ctiss: string;
    subitem_ctiss: string;
    descr_ctiss: string | null;
    csll_ctiss: Decimal;
    pis_ctiss: Decimal;
    cofins_ctiss: Decimal;
    irrf_ctiss: Decimal;
    aliq_ctiss: Decimal;
    aliqret_ctiss: Decimal;
    _count: CtissCountAggregateOutputType | null;
    _avg: CtissAvgAggregateOutputType | null;
    _sum: CtissSumAggregateOutputType | null;
    _min: CtissMinAggregateOutputType | null;
    _max: CtissMaxAggregateOutputType | null;
  };

  type GetCtissGroupByPayload<T extends ctissGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CtissGroupByOutputType, T['by']> & {
          [P in keyof T & keyof CtissGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CtissGroupByOutputType[P]>
            : GetScalarType<T[P], CtissGroupByOutputType[P]>;
        }
      >
    >;

  export type ctissSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_ctiss?: boolean;
      num_ctiss?: boolean;
      subitem_ctiss?: boolean;
      descr_ctiss?: boolean;
      csll_ctiss?: boolean;
      pis_ctiss?: boolean;
      cofins_ctiss?: boolean;
      irrf_ctiss?: boolean;
      aliq_ctiss?: boolean;
      aliqret_ctiss?: boolean;
    },
    ExtArgs['result']['ctiss']
  >;

  export type ctissSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_ctiss?: boolean;
      num_ctiss?: boolean;
      subitem_ctiss?: boolean;
      descr_ctiss?: boolean;
      csll_ctiss?: boolean;
      pis_ctiss?: boolean;
      cofins_ctiss?: boolean;
      irrf_ctiss?: boolean;
      aliq_ctiss?: boolean;
      aliqret_ctiss?: boolean;
    },
    ExtArgs['result']['ctiss']
  >;

  export type ctissSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_ctiss?: boolean;
      num_ctiss?: boolean;
      subitem_ctiss?: boolean;
      descr_ctiss?: boolean;
      csll_ctiss?: boolean;
      pis_ctiss?: boolean;
      cofins_ctiss?: boolean;
      irrf_ctiss?: boolean;
      aliq_ctiss?: boolean;
      aliqret_ctiss?: boolean;
    },
    ExtArgs['result']['ctiss']
  >;

  export type ctissSelectScalar = {
    cod_ctiss?: boolean;
    num_ctiss?: boolean;
    subitem_ctiss?: boolean;
    descr_ctiss?: boolean;
    csll_ctiss?: boolean;
    pis_ctiss?: boolean;
    cofins_ctiss?: boolean;
    irrf_ctiss?: boolean;
    aliq_ctiss?: boolean;
    aliqret_ctiss?: boolean;
  };

  export type ctissOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_ctiss'
    | 'num_ctiss'
    | 'subitem_ctiss'
    | 'descr_ctiss'
    | 'csll_ctiss'
    | 'pis_ctiss'
    | 'cofins_ctiss'
    | 'irrf_ctiss'
    | 'aliq_ctiss'
    | 'aliqret_ctiss',
    ExtArgs['result']['ctiss']
  >;

  export type $ctissPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ctiss';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_ctiss: number;
        num_ctiss: string;
        subitem_ctiss: string;
        descr_ctiss: string | null;
        csll_ctiss: Prisma.Decimal;
        pis_ctiss: Prisma.Decimal;
        cofins_ctiss: Prisma.Decimal;
        irrf_ctiss: Prisma.Decimal;
        aliq_ctiss: Prisma.Decimal;
        aliqret_ctiss: Prisma.Decimal;
      },
      ExtArgs['result']['ctiss']
    >;
    composites: {};
  };

  type ctissGetPayload<
    S extends boolean | null | undefined | ctissDefaultArgs,
  > = $Result.GetResult<Prisma.$ctissPayload, S>;

  type ctissCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ctissFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CtissCountAggregateInputType | true;
  };

  export interface ctissDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ctiss'];
      meta: { name: 'ctiss' };
    };
    /**
     * Find zero or one Ctiss that matches the filter.
     * @param {ctissFindUniqueArgs} args - Arguments to find a Ctiss
     * @example
     * // Get one Ctiss
     * const ctiss = await prisma.ctiss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ctissFindUniqueArgs>(
      args: SelectSubset<T, ctissFindUniqueArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Ctiss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ctissFindUniqueOrThrowArgs} args - Arguments to find a Ctiss
     * @example
     * // Get one Ctiss
     * const ctiss = await prisma.ctiss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ctissFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ctissFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Ctiss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ctissFindFirstArgs} args - Arguments to find a Ctiss
     * @example
     * // Get one Ctiss
     * const ctiss = await prisma.ctiss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ctissFindFirstArgs>(
      args?: SelectSubset<T, ctissFindFirstArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Ctiss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ctissFindFirstOrThrowArgs} args - Arguments to find a Ctiss
     * @example
     * // Get one Ctiss
     * const ctiss = await prisma.ctiss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ctissFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ctissFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Ctisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ctissFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ctisses
     * const ctisses = await prisma.ctiss.findMany()
     *
     * // Get first 10 Ctisses
     * const ctisses = await prisma.ctiss.findMany({ take: 10 })
     *
     * // Only select the `cod_ctiss`
     * const ctissWithCod_ctissOnly = await prisma.ctiss.findMany({ select: { cod_ctiss: true } })
     *
     */
    findMany<T extends ctissFindManyArgs>(
      args?: SelectSubset<T, ctissFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Ctiss.
     * @param {ctissCreateArgs} args - Arguments to create a Ctiss.
     * @example
     * // Create one Ctiss
     * const Ctiss = await prisma.ctiss.create({
     *   data: {
     *     // ... data to create a Ctiss
     *   }
     * })
     *
     */
    create<T extends ctissCreateArgs>(
      args: SelectSubset<T, ctissCreateArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Ctisses.
     * @param {ctissCreateManyArgs} args - Arguments to create many Ctisses.
     * @example
     * // Create many Ctisses
     * const ctiss = await prisma.ctiss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ctissCreateManyArgs>(
      args?: SelectSubset<T, ctissCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Ctisses and returns the data saved in the database.
     * @param {ctissCreateManyAndReturnArgs} args - Arguments to create many Ctisses.
     * @example
     * // Create many Ctisses
     * const ctiss = await prisma.ctiss.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Ctisses and only return the `cod_ctiss`
     * const ctissWithCod_ctissOnly = await prisma.ctiss.createManyAndReturn({
     *   select: { cod_ctiss: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ctissCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ctissCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Ctiss.
     * @param {ctissDeleteArgs} args - Arguments to delete one Ctiss.
     * @example
     * // Delete one Ctiss
     * const Ctiss = await prisma.ctiss.delete({
     *   where: {
     *     // ... filter to delete one Ctiss
     *   }
     * })
     *
     */
    delete<T extends ctissDeleteArgs>(
      args: SelectSubset<T, ctissDeleteArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Ctiss.
     * @param {ctissUpdateArgs} args - Arguments to update one Ctiss.
     * @example
     * // Update one Ctiss
     * const ctiss = await prisma.ctiss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ctissUpdateArgs>(
      args: SelectSubset<T, ctissUpdateArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Ctisses.
     * @param {ctissDeleteManyArgs} args - Arguments to filter Ctisses to delete.
     * @example
     * // Delete a few Ctisses
     * const { count } = await prisma.ctiss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ctissDeleteManyArgs>(
      args?: SelectSubset<T, ctissDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Ctisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ctissUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ctisses
     * const ctiss = await prisma.ctiss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ctissUpdateManyArgs>(
      args: SelectSubset<T, ctissUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Ctisses and returns the data updated in the database.
     * @param {ctissUpdateManyAndReturnArgs} args - Arguments to update many Ctisses.
     * @example
     * // Update many Ctisses
     * const ctiss = await prisma.ctiss.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Ctisses and only return the `cod_ctiss`
     * const ctissWithCod_ctissOnly = await prisma.ctiss.updateManyAndReturn({
     *   select: { cod_ctiss: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ctissUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ctissUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Ctiss.
     * @param {ctissUpsertArgs} args - Arguments to update or create a Ctiss.
     * @example
     * // Update or create a Ctiss
     * const ctiss = await prisma.ctiss.upsert({
     *   create: {
     *     // ... data to create a Ctiss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ctiss we want to update
     *   }
     * })
     */
    upsert<T extends ctissUpsertArgs>(
      args: SelectSubset<T, ctissUpsertArgs<ExtArgs>>,
    ): Prisma__ctissClient<
      $Result.GetResult<
        Prisma.$ctissPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Ctisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ctissCountArgs} args - Arguments to filter Ctisses to count.
     * @example
     * // Count the number of Ctisses
     * const count = await prisma.ctiss.count({
     *   where: {
     *     // ... the filter for the Ctisses we want to count
     *   }
     * })
     **/
    count<T extends ctissCountArgs>(
      args?: Subset<T, ctissCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CtissCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Ctiss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CtissAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CtissAggregateArgs>(
      args: Subset<T, CtissAggregateArgs>,
    ): Prisma.PrismaPromise<GetCtissAggregateType<T>>;

    /**
     * Group by Ctiss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ctissGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ctissGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ctissGroupByArgs['orderBy'] }
        : { orderBy?: ctissGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ctissGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetCtissGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ctiss model
     */
    readonly fields: ctissFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ctiss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ctissClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ctiss model
   */
  interface ctissFieldRefs {
    readonly cod_ctiss: FieldRef<'ctiss', 'Int'>;
    readonly num_ctiss: FieldRef<'ctiss', 'String'>;
    readonly subitem_ctiss: FieldRef<'ctiss', 'String'>;
    readonly descr_ctiss: FieldRef<'ctiss', 'String'>;
    readonly csll_ctiss: FieldRef<'ctiss', 'Decimal'>;
    readonly pis_ctiss: FieldRef<'ctiss', 'Decimal'>;
    readonly cofins_ctiss: FieldRef<'ctiss', 'Decimal'>;
    readonly irrf_ctiss: FieldRef<'ctiss', 'Decimal'>;
    readonly aliq_ctiss: FieldRef<'ctiss', 'Decimal'>;
    readonly aliqret_ctiss: FieldRef<'ctiss', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * ctiss findUnique
   */
  export type ctissFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * Filter, which ctiss to fetch.
     */
    where: ctissWhereUniqueInput;
  };

  /**
   * ctiss findUniqueOrThrow
   */
  export type ctissFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * Filter, which ctiss to fetch.
     */
    where: ctissWhereUniqueInput;
  };

  /**
   * ctiss findFirst
   */
  export type ctissFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * Filter, which ctiss to fetch.
     */
    where?: ctissWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ctisses to fetch.
     */
    orderBy?: ctissOrderByWithRelationInput | ctissOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ctisses.
     */
    cursor?: ctissWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ctisses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ctisses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ctisses.
     */
    distinct?: CtissScalarFieldEnum | CtissScalarFieldEnum[];
  };

  /**
   * ctiss findFirstOrThrow
   */
  export type ctissFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * Filter, which ctiss to fetch.
     */
    where?: ctissWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ctisses to fetch.
     */
    orderBy?: ctissOrderByWithRelationInput | ctissOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ctisses.
     */
    cursor?: ctissWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ctisses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ctisses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ctisses.
     */
    distinct?: CtissScalarFieldEnum | CtissScalarFieldEnum[];
  };

  /**
   * ctiss findMany
   */
  export type ctissFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * Filter, which ctisses to fetch.
     */
    where?: ctissWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ctisses to fetch.
     */
    orderBy?: ctissOrderByWithRelationInput | ctissOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ctisses.
     */
    cursor?: ctissWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ctisses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ctisses.
     */
    skip?: number;
    distinct?: CtissScalarFieldEnum | CtissScalarFieldEnum[];
  };

  /**
   * ctiss create
   */
  export type ctissCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * The data needed to create a ctiss.
     */
    data: XOR<ctissCreateInput, ctissUncheckedCreateInput>;
  };

  /**
   * ctiss createMany
   */
  export type ctissCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ctisses.
     */
    data: ctissCreateManyInput | ctissCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ctiss createManyAndReturn
   */
  export type ctissCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * The data used to create many ctisses.
     */
    data: ctissCreateManyInput | ctissCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ctiss update
   */
  export type ctissUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * The data needed to update a ctiss.
     */
    data: XOR<ctissUpdateInput, ctissUncheckedUpdateInput>;
    /**
     * Choose, which ctiss to update.
     */
    where: ctissWhereUniqueInput;
  };

  /**
   * ctiss updateMany
   */
  export type ctissUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ctisses.
     */
    data: XOR<ctissUpdateManyMutationInput, ctissUncheckedUpdateManyInput>;
    /**
     * Filter which ctisses to update
     */
    where?: ctissWhereInput;
    /**
     * Limit how many ctisses to update.
     */
    limit?: number;
  };

  /**
   * ctiss updateManyAndReturn
   */
  export type ctissUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * The data used to update ctisses.
     */
    data: XOR<ctissUpdateManyMutationInput, ctissUncheckedUpdateManyInput>;
    /**
     * Filter which ctisses to update
     */
    where?: ctissWhereInput;
    /**
     * Limit how many ctisses to update.
     */
    limit?: number;
  };

  /**
   * ctiss upsert
   */
  export type ctissUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * The filter to search for the ctiss to update in case it exists.
     */
    where: ctissWhereUniqueInput;
    /**
     * In case the ctiss found by the `where` argument doesn't exist, create a new ctiss with this data.
     */
    create: XOR<ctissCreateInput, ctissUncheckedCreateInput>;
    /**
     * In case the ctiss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ctissUpdateInput, ctissUncheckedUpdateInput>;
  };

  /**
   * ctiss delete
   */
  export type ctissDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
    /**
     * Filter which ctiss to delete.
     */
    where: ctissWhereUniqueInput;
  };

  /**
   * ctiss deleteMany
   */
  export type ctissDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ctisses to delete
     */
    where?: ctissWhereInput;
    /**
     * Limit how many ctisses to delete.
     */
    limit?: number;
  };

  /**
   * ctiss without action
   */
  export type ctissDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ctiss
     */
    select?: ctissSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ctiss
     */
    omit?: ctissOmit<ExtArgs> | null;
  };

  /**
   * Model despesa
   */

  export type AggregateDespesa = {
    _count: DespesaCountAggregateOutputType | null;
    _avg: DespesaAvgAggregateOutputType | null;
    _sum: DespesaSumAggregateOutputType | null;
    _min: DespesaMinAggregateOutputType | null;
    _max: DespesaMaxAggregateOutputType | null;
  };

  export type DespesaAvgAggregateOutputType = {
    cod_despesa: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_despesa: Decimal | null;
  };

  export type DespesaSumAggregateOutputType = {
    cod_despesa: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_despesa: Decimal | null;
  };

  export type DespesaMinAggregateOutputType = {
    cod_despesa: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_despesa: Decimal | null;
    mesano_despesa: string | null;
  };

  export type DespesaMaxAggregateOutputType = {
    cod_despesa: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_despesa: Decimal | null;
    mesano_despesa: string | null;
  };

  export type DespesaCountAggregateOutputType = {
    cod_despesa: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_despesa: number;
    mesano_despesa: number;
    _all: number;
  };

  export type DespesaAvgAggregateInputType = {
    cod_despesa?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_despesa?: true;
  };

  export type DespesaSumAggregateInputType = {
    cod_despesa?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_despesa?: true;
  };

  export type DespesaMinAggregateInputType = {
    cod_despesa?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_despesa?: true;
    mesano_despesa?: true;
  };

  export type DespesaMaxAggregateInputType = {
    cod_despesa?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_despesa?: true;
    mesano_despesa?: true;
  };

  export type DespesaCountAggregateInputType = {
    cod_despesa?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_despesa?: true;
    mesano_despesa?: true;
    _all?: true;
  };

  export type DespesaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which despesa to aggregate.
     */
    where?: despesaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of despesas to fetch.
     */
    orderBy?:
      | despesaOrderByWithRelationInput
      | despesaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: despesaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` despesas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` despesas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned despesas
     **/
    _count?: true | DespesaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DespesaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DespesaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DespesaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DespesaMaxAggregateInputType;
  };

  export type GetDespesaAggregateType<T extends DespesaAggregateArgs> = {
    [P in keyof T & keyof AggregateDespesa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDespesa[P]>
      : GetScalarType<T[P], AggregateDespesa[P]>;
  };

  export type despesaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: despesaWhereInput;
    orderBy?:
      | despesaOrderByWithAggregationInput
      | despesaOrderByWithAggregationInput[];
    by: DespesaScalarFieldEnum[] | DespesaScalarFieldEnum;
    having?: despesaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DespesaCountAggregateInputType | true;
    _avg?: DespesaAvgAggregateInputType;
    _sum?: DespesaSumAggregateInputType;
    _min?: DespesaMinAggregateInputType;
    _max?: DespesaMaxAggregateInputType;
  };

  export type DespesaGroupByOutputType = {
    cod_despesa: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_despesa: Decimal;
    mesano_despesa: string;
    _count: DespesaCountAggregateOutputType | null;
    _avg: DespesaAvgAggregateOutputType | null;
    _sum: DespesaSumAggregateOutputType | null;
    _min: DespesaMinAggregateOutputType | null;
    _max: DespesaMaxAggregateOutputType | null;
  };

  type GetDespesaGroupByPayload<T extends despesaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DespesaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DespesaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DespesaGroupByOutputType[P]>
            : GetScalarType<T[P], DespesaGroupByOutputType[P]>;
        }
      >
    >;

  export type despesaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_despesa?: boolean;
      cod_recurso?: boolean;
      cod_tpdesp?: boolean;
      valor_despesa?: boolean;
      mesano_despesa?: boolean;
    },
    ExtArgs['result']['despesa']
  >;

  export type despesaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_despesa?: boolean;
      cod_recurso?: boolean;
      cod_tpdesp?: boolean;
      valor_despesa?: boolean;
      mesano_despesa?: boolean;
    },
    ExtArgs['result']['despesa']
  >;

  export type despesaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_despesa?: boolean;
      cod_recurso?: boolean;
      cod_tpdesp?: boolean;
      valor_despesa?: boolean;
      mesano_despesa?: boolean;
    },
    ExtArgs['result']['despesa']
  >;

  export type despesaSelectScalar = {
    cod_despesa?: boolean;
    cod_recurso?: boolean;
    cod_tpdesp?: boolean;
    valor_despesa?: boolean;
    mesano_despesa?: boolean;
  };

  export type despesaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_despesa'
    | 'cod_recurso'
    | 'cod_tpdesp'
    | 'valor_despesa'
    | 'mesano_despesa',
    ExtArgs['result']['despesa']
  >;

  export type $despesaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'despesa';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_despesa: number;
        cod_recurso: number;
        cod_tpdesp: number;
        valor_despesa: Prisma.Decimal;
        mesano_despesa: string;
      },
      ExtArgs['result']['despesa']
    >;
    composites: {};
  };

  type despesaGetPayload<
    S extends boolean | null | undefined | despesaDefaultArgs,
  > = $Result.GetResult<Prisma.$despesaPayload, S>;

  type despesaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<despesaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DespesaCountAggregateInputType | true;
  };

  export interface despesaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['despesa'];
      meta: { name: 'despesa' };
    };
    /**
     * Find zero or one Despesa that matches the filter.
     * @param {despesaFindUniqueArgs} args - Arguments to find a Despesa
     * @example
     * // Get one Despesa
     * const despesa = await prisma.despesa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends despesaFindUniqueArgs>(
      args: SelectSubset<T, despesaFindUniqueArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Despesa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {despesaFindUniqueOrThrowArgs} args - Arguments to find a Despesa
     * @example
     * // Get one Despesa
     * const despesa = await prisma.despesa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends despesaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, despesaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Despesa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {despesaFindFirstArgs} args - Arguments to find a Despesa
     * @example
     * // Get one Despesa
     * const despesa = await prisma.despesa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends despesaFindFirstArgs>(
      args?: SelectSubset<T, despesaFindFirstArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Despesa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {despesaFindFirstOrThrowArgs} args - Arguments to find a Despesa
     * @example
     * // Get one Despesa
     * const despesa = await prisma.despesa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends despesaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, despesaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Despesas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {despesaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Despesas
     * const despesas = await prisma.despesa.findMany()
     *
     * // Get first 10 Despesas
     * const despesas = await prisma.despesa.findMany({ take: 10 })
     *
     * // Only select the `cod_despesa`
     * const despesaWithCod_despesaOnly = await prisma.despesa.findMany({ select: { cod_despesa: true } })
     *
     */
    findMany<T extends despesaFindManyArgs>(
      args?: SelectSubset<T, despesaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Despesa.
     * @param {despesaCreateArgs} args - Arguments to create a Despesa.
     * @example
     * // Create one Despesa
     * const Despesa = await prisma.despesa.create({
     *   data: {
     *     // ... data to create a Despesa
     *   }
     * })
     *
     */
    create<T extends despesaCreateArgs>(
      args: SelectSubset<T, despesaCreateArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Despesas.
     * @param {despesaCreateManyArgs} args - Arguments to create many Despesas.
     * @example
     * // Create many Despesas
     * const despesa = await prisma.despesa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends despesaCreateManyArgs>(
      args?: SelectSubset<T, despesaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Despesas and returns the data saved in the database.
     * @param {despesaCreateManyAndReturnArgs} args - Arguments to create many Despesas.
     * @example
     * // Create many Despesas
     * const despesa = await prisma.despesa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Despesas and only return the `cod_despesa`
     * const despesaWithCod_despesaOnly = await prisma.despesa.createManyAndReturn({
     *   select: { cod_despesa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends despesaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, despesaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Despesa.
     * @param {despesaDeleteArgs} args - Arguments to delete one Despesa.
     * @example
     * // Delete one Despesa
     * const Despesa = await prisma.despesa.delete({
     *   where: {
     *     // ... filter to delete one Despesa
     *   }
     * })
     *
     */
    delete<T extends despesaDeleteArgs>(
      args: SelectSubset<T, despesaDeleteArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Despesa.
     * @param {despesaUpdateArgs} args - Arguments to update one Despesa.
     * @example
     * // Update one Despesa
     * const despesa = await prisma.despesa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends despesaUpdateArgs>(
      args: SelectSubset<T, despesaUpdateArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Despesas.
     * @param {despesaDeleteManyArgs} args - Arguments to filter Despesas to delete.
     * @example
     * // Delete a few Despesas
     * const { count } = await prisma.despesa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends despesaDeleteManyArgs>(
      args?: SelectSubset<T, despesaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Despesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {despesaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Despesas
     * const despesa = await prisma.despesa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends despesaUpdateManyArgs>(
      args: SelectSubset<T, despesaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Despesas and returns the data updated in the database.
     * @param {despesaUpdateManyAndReturnArgs} args - Arguments to update many Despesas.
     * @example
     * // Update many Despesas
     * const despesa = await prisma.despesa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Despesas and only return the `cod_despesa`
     * const despesaWithCod_despesaOnly = await prisma.despesa.updateManyAndReturn({
     *   select: { cod_despesa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends despesaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, despesaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Despesa.
     * @param {despesaUpsertArgs} args - Arguments to update or create a Despesa.
     * @example
     * // Update or create a Despesa
     * const despesa = await prisma.despesa.upsert({
     *   create: {
     *     // ... data to create a Despesa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Despesa we want to update
     *   }
     * })
     */
    upsert<T extends despesaUpsertArgs>(
      args: SelectSubset<T, despesaUpsertArgs<ExtArgs>>,
    ): Prisma__despesaClient<
      $Result.GetResult<
        Prisma.$despesaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Despesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {despesaCountArgs} args - Arguments to filter Despesas to count.
     * @example
     * // Count the number of Despesas
     * const count = await prisma.despesa.count({
     *   where: {
     *     // ... the filter for the Despesas we want to count
     *   }
     * })
     **/
    count<T extends despesaCountArgs>(
      args?: Subset<T, despesaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DespesaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Despesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DespesaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DespesaAggregateArgs>(
      args: Subset<T, DespesaAggregateArgs>,
    ): Prisma.PrismaPromise<GetDespesaAggregateType<T>>;

    /**
     * Group by Despesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {despesaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends despesaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: despesaGroupByArgs['orderBy'] }
        : { orderBy?: despesaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, despesaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetDespesaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the despesa model
     */
    readonly fields: despesaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for despesa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__despesaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the despesa model
   */
  interface despesaFieldRefs {
    readonly cod_despesa: FieldRef<'despesa', 'Int'>;
    readonly cod_recurso: FieldRef<'despesa', 'Int'>;
    readonly cod_tpdesp: FieldRef<'despesa', 'Int'>;
    readonly valor_despesa: FieldRef<'despesa', 'Decimal'>;
    readonly mesano_despesa: FieldRef<'despesa', 'String'>;
  }

  // Custom InputTypes
  /**
   * despesa findUnique
   */
  export type despesaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * Filter, which despesa to fetch.
     */
    where: despesaWhereUniqueInput;
  };

  /**
   * despesa findUniqueOrThrow
   */
  export type despesaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * Filter, which despesa to fetch.
     */
    where: despesaWhereUniqueInput;
  };

  /**
   * despesa findFirst
   */
  export type despesaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * Filter, which despesa to fetch.
     */
    where?: despesaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of despesas to fetch.
     */
    orderBy?:
      | despesaOrderByWithRelationInput
      | despesaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for despesas.
     */
    cursor?: despesaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` despesas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` despesas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of despesas.
     */
    distinct?: DespesaScalarFieldEnum | DespesaScalarFieldEnum[];
  };

  /**
   * despesa findFirstOrThrow
   */
  export type despesaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * Filter, which despesa to fetch.
     */
    where?: despesaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of despesas to fetch.
     */
    orderBy?:
      | despesaOrderByWithRelationInput
      | despesaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for despesas.
     */
    cursor?: despesaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` despesas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` despesas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of despesas.
     */
    distinct?: DespesaScalarFieldEnum | DespesaScalarFieldEnum[];
  };

  /**
   * despesa findMany
   */
  export type despesaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * Filter, which despesas to fetch.
     */
    where?: despesaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of despesas to fetch.
     */
    orderBy?:
      | despesaOrderByWithRelationInput
      | despesaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing despesas.
     */
    cursor?: despesaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` despesas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` despesas.
     */
    skip?: number;
    distinct?: DespesaScalarFieldEnum | DespesaScalarFieldEnum[];
  };

  /**
   * despesa create
   */
  export type despesaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * The data needed to create a despesa.
     */
    data: XOR<despesaCreateInput, despesaUncheckedCreateInput>;
  };

  /**
   * despesa createMany
   */
  export type despesaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many despesas.
     */
    data: despesaCreateManyInput | despesaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * despesa createManyAndReturn
   */
  export type despesaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * The data used to create many despesas.
     */
    data: despesaCreateManyInput | despesaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * despesa update
   */
  export type despesaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * The data needed to update a despesa.
     */
    data: XOR<despesaUpdateInput, despesaUncheckedUpdateInput>;
    /**
     * Choose, which despesa to update.
     */
    where: despesaWhereUniqueInput;
  };

  /**
   * despesa updateMany
   */
  export type despesaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update despesas.
     */
    data: XOR<despesaUpdateManyMutationInput, despesaUncheckedUpdateManyInput>;
    /**
     * Filter which despesas to update
     */
    where?: despesaWhereInput;
    /**
     * Limit how many despesas to update.
     */
    limit?: number;
  };

  /**
   * despesa updateManyAndReturn
   */
  export type despesaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * The data used to update despesas.
     */
    data: XOR<despesaUpdateManyMutationInput, despesaUncheckedUpdateManyInput>;
    /**
     * Filter which despesas to update
     */
    where?: despesaWhereInput;
    /**
     * Limit how many despesas to update.
     */
    limit?: number;
  };

  /**
   * despesa upsert
   */
  export type despesaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * The filter to search for the despesa to update in case it exists.
     */
    where: despesaWhereUniqueInput;
    /**
     * In case the despesa found by the `where` argument doesn't exist, create a new despesa with this data.
     */
    create: XOR<despesaCreateInput, despesaUncheckedCreateInput>;
    /**
     * In case the despesa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<despesaUpdateInput, despesaUncheckedUpdateInput>;
  };

  /**
   * despesa delete
   */
  export type despesaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
    /**
     * Filter which despesa to delete.
     */
    where: despesaWhereUniqueInput;
  };

  /**
   * despesa deleteMany
   */
  export type despesaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which despesas to delete
     */
    where?: despesaWhereInput;
    /**
     * Limit how many despesas to delete.
     */
    limit?: number;
  };

  /**
   * despesa without action
   */
  export type despesaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the despesa
     */
    select?: despesaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the despesa
     */
    omit?: despesaOmit<ExtArgs> | null;
  };

  /**
   * Model desprec
   */

  export type AggregateDesprec = {
    _count: DesprecCountAggregateOutputType | null;
    _avg: DesprecAvgAggregateOutputType | null;
    _sum: DesprecSumAggregateOutputType | null;
    _min: DesprecMinAggregateOutputType | null;
    _max: DesprecMaxAggregateOutputType | null;
  };

  export type DesprecAvgAggregateOutputType = {
    cod_desprec: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_desprec: Decimal | null;
  };

  export type DesprecSumAggregateOutputType = {
    cod_desprec: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_desprec: Decimal | null;
  };

  export type DesprecMinAggregateOutputType = {
    cod_desprec: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_desprec: Decimal | null;
  };

  export type DesprecMaxAggregateOutputType = {
    cod_desprec: number | null;
    cod_recurso: number | null;
    cod_tpdesp: number | null;
    valor_desprec: Decimal | null;
  };

  export type DesprecCountAggregateOutputType = {
    cod_desprec: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_desprec: number;
    _all: number;
  };

  export type DesprecAvgAggregateInputType = {
    cod_desprec?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_desprec?: true;
  };

  export type DesprecSumAggregateInputType = {
    cod_desprec?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_desprec?: true;
  };

  export type DesprecMinAggregateInputType = {
    cod_desprec?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_desprec?: true;
  };

  export type DesprecMaxAggregateInputType = {
    cod_desprec?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_desprec?: true;
  };

  export type DesprecCountAggregateInputType = {
    cod_desprec?: true;
    cod_recurso?: true;
    cod_tpdesp?: true;
    valor_desprec?: true;
    _all?: true;
  };

  export type DesprecAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which desprec to aggregate.
     */
    where?: desprecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of desprecs to fetch.
     */
    orderBy?:
      | desprecOrderByWithRelationInput
      | desprecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: desprecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` desprecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` desprecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned desprecs
     **/
    _count?: true | DesprecCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DesprecAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DesprecSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DesprecMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DesprecMaxAggregateInputType;
  };

  export type GetDesprecAggregateType<T extends DesprecAggregateArgs> = {
    [P in keyof T & keyof AggregateDesprec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesprec[P]>
      : GetScalarType<T[P], AggregateDesprec[P]>;
  };

  export type desprecGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: desprecWhereInput;
    orderBy?:
      | desprecOrderByWithAggregationInput
      | desprecOrderByWithAggregationInput[];
    by: DesprecScalarFieldEnum[] | DesprecScalarFieldEnum;
    having?: desprecScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DesprecCountAggregateInputType | true;
    _avg?: DesprecAvgAggregateInputType;
    _sum?: DesprecSumAggregateInputType;
    _min?: DesprecMinAggregateInputType;
    _max?: DesprecMaxAggregateInputType;
  };

  export type DesprecGroupByOutputType = {
    cod_desprec: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_desprec: Decimal;
    _count: DesprecCountAggregateOutputType | null;
    _avg: DesprecAvgAggregateOutputType | null;
    _sum: DesprecSumAggregateOutputType | null;
    _min: DesprecMinAggregateOutputType | null;
    _max: DesprecMaxAggregateOutputType | null;
  };

  type GetDesprecGroupByPayload<T extends desprecGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DesprecGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DesprecGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesprecGroupByOutputType[P]>
            : GetScalarType<T[P], DesprecGroupByOutputType[P]>;
        }
      >
    >;

  export type desprecSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_desprec?: boolean;
      cod_recurso?: boolean;
      cod_tpdesp?: boolean;
      valor_desprec?: boolean;
    },
    ExtArgs['result']['desprec']
  >;

  export type desprecSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_desprec?: boolean;
      cod_recurso?: boolean;
      cod_tpdesp?: boolean;
      valor_desprec?: boolean;
    },
    ExtArgs['result']['desprec']
  >;

  export type desprecSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_desprec?: boolean;
      cod_recurso?: boolean;
      cod_tpdesp?: boolean;
      valor_desprec?: boolean;
    },
    ExtArgs['result']['desprec']
  >;

  export type desprecSelectScalar = {
    cod_desprec?: boolean;
    cod_recurso?: boolean;
    cod_tpdesp?: boolean;
    valor_desprec?: boolean;
  };

  export type desprecOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_desprec' | 'cod_recurso' | 'cod_tpdesp' | 'valor_desprec',
    ExtArgs['result']['desprec']
  >;

  export type $desprecPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'desprec';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_desprec: number;
        cod_recurso: number;
        cod_tpdesp: number;
        valor_desprec: Prisma.Decimal;
      },
      ExtArgs['result']['desprec']
    >;
    composites: {};
  };

  type desprecGetPayload<
    S extends boolean | null | undefined | desprecDefaultArgs,
  > = $Result.GetResult<Prisma.$desprecPayload, S>;

  type desprecCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<desprecFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DesprecCountAggregateInputType | true;
  };

  export interface desprecDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['desprec'];
      meta: { name: 'desprec' };
    };
    /**
     * Find zero or one Desprec that matches the filter.
     * @param {desprecFindUniqueArgs} args - Arguments to find a Desprec
     * @example
     * // Get one Desprec
     * const desprec = await prisma.desprec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends desprecFindUniqueArgs>(
      args: SelectSubset<T, desprecFindUniqueArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Desprec that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {desprecFindUniqueOrThrowArgs} args - Arguments to find a Desprec
     * @example
     * // Get one Desprec
     * const desprec = await prisma.desprec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends desprecFindUniqueOrThrowArgs>(
      args: SelectSubset<T, desprecFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Desprec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desprecFindFirstArgs} args - Arguments to find a Desprec
     * @example
     * // Get one Desprec
     * const desprec = await prisma.desprec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends desprecFindFirstArgs>(
      args?: SelectSubset<T, desprecFindFirstArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Desprec that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desprecFindFirstOrThrowArgs} args - Arguments to find a Desprec
     * @example
     * // Get one Desprec
     * const desprec = await prisma.desprec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends desprecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, desprecFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Desprecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desprecFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Desprecs
     * const desprecs = await prisma.desprec.findMany()
     *
     * // Get first 10 Desprecs
     * const desprecs = await prisma.desprec.findMany({ take: 10 })
     *
     * // Only select the `cod_desprec`
     * const desprecWithCod_desprecOnly = await prisma.desprec.findMany({ select: { cod_desprec: true } })
     *
     */
    findMany<T extends desprecFindManyArgs>(
      args?: SelectSubset<T, desprecFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Desprec.
     * @param {desprecCreateArgs} args - Arguments to create a Desprec.
     * @example
     * // Create one Desprec
     * const Desprec = await prisma.desprec.create({
     *   data: {
     *     // ... data to create a Desprec
     *   }
     * })
     *
     */
    create<T extends desprecCreateArgs>(
      args: SelectSubset<T, desprecCreateArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Desprecs.
     * @param {desprecCreateManyArgs} args - Arguments to create many Desprecs.
     * @example
     * // Create many Desprecs
     * const desprec = await prisma.desprec.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends desprecCreateManyArgs>(
      args?: SelectSubset<T, desprecCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Desprecs and returns the data saved in the database.
     * @param {desprecCreateManyAndReturnArgs} args - Arguments to create many Desprecs.
     * @example
     * // Create many Desprecs
     * const desprec = await prisma.desprec.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Desprecs and only return the `cod_desprec`
     * const desprecWithCod_desprecOnly = await prisma.desprec.createManyAndReturn({
     *   select: { cod_desprec: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends desprecCreateManyAndReturnArgs>(
      args?: SelectSubset<T, desprecCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Desprec.
     * @param {desprecDeleteArgs} args - Arguments to delete one Desprec.
     * @example
     * // Delete one Desprec
     * const Desprec = await prisma.desprec.delete({
     *   where: {
     *     // ... filter to delete one Desprec
     *   }
     * })
     *
     */
    delete<T extends desprecDeleteArgs>(
      args: SelectSubset<T, desprecDeleteArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Desprec.
     * @param {desprecUpdateArgs} args - Arguments to update one Desprec.
     * @example
     * // Update one Desprec
     * const desprec = await prisma.desprec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends desprecUpdateArgs>(
      args: SelectSubset<T, desprecUpdateArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Desprecs.
     * @param {desprecDeleteManyArgs} args - Arguments to filter Desprecs to delete.
     * @example
     * // Delete a few Desprecs
     * const { count } = await prisma.desprec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends desprecDeleteManyArgs>(
      args?: SelectSubset<T, desprecDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Desprecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desprecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Desprecs
     * const desprec = await prisma.desprec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends desprecUpdateManyArgs>(
      args: SelectSubset<T, desprecUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Desprecs and returns the data updated in the database.
     * @param {desprecUpdateManyAndReturnArgs} args - Arguments to update many Desprecs.
     * @example
     * // Update many Desprecs
     * const desprec = await prisma.desprec.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Desprecs and only return the `cod_desprec`
     * const desprecWithCod_desprecOnly = await prisma.desprec.updateManyAndReturn({
     *   select: { cod_desprec: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends desprecUpdateManyAndReturnArgs>(
      args: SelectSubset<T, desprecUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Desprec.
     * @param {desprecUpsertArgs} args - Arguments to update or create a Desprec.
     * @example
     * // Update or create a Desprec
     * const desprec = await prisma.desprec.upsert({
     *   create: {
     *     // ... data to create a Desprec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Desprec we want to update
     *   }
     * })
     */
    upsert<T extends desprecUpsertArgs>(
      args: SelectSubset<T, desprecUpsertArgs<ExtArgs>>,
    ): Prisma__desprecClient<
      $Result.GetResult<
        Prisma.$desprecPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Desprecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desprecCountArgs} args - Arguments to filter Desprecs to count.
     * @example
     * // Count the number of Desprecs
     * const count = await prisma.desprec.count({
     *   where: {
     *     // ... the filter for the Desprecs we want to count
     *   }
     * })
     **/
    count<T extends desprecCountArgs>(
      args?: Subset<T, desprecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesprecCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Desprec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesprecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DesprecAggregateArgs>(
      args: Subset<T, DesprecAggregateArgs>,
    ): Prisma.PrismaPromise<GetDesprecAggregateType<T>>;

    /**
     * Group by Desprec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desprecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends desprecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: desprecGroupByArgs['orderBy'] }
        : { orderBy?: desprecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, desprecGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetDesprecGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the desprec model
     */
    readonly fields: desprecFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for desprec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__desprecClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the desprec model
   */
  interface desprecFieldRefs {
    readonly cod_desprec: FieldRef<'desprec', 'Int'>;
    readonly cod_recurso: FieldRef<'desprec', 'Int'>;
    readonly cod_tpdesp: FieldRef<'desprec', 'Int'>;
    readonly valor_desprec: FieldRef<'desprec', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * desprec findUnique
   */
  export type desprecFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * Filter, which desprec to fetch.
     */
    where: desprecWhereUniqueInput;
  };

  /**
   * desprec findUniqueOrThrow
   */
  export type desprecFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * Filter, which desprec to fetch.
     */
    where: desprecWhereUniqueInput;
  };

  /**
   * desprec findFirst
   */
  export type desprecFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * Filter, which desprec to fetch.
     */
    where?: desprecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of desprecs to fetch.
     */
    orderBy?:
      | desprecOrderByWithRelationInput
      | desprecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for desprecs.
     */
    cursor?: desprecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` desprecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` desprecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of desprecs.
     */
    distinct?: DesprecScalarFieldEnum | DesprecScalarFieldEnum[];
  };

  /**
   * desprec findFirstOrThrow
   */
  export type desprecFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * Filter, which desprec to fetch.
     */
    where?: desprecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of desprecs to fetch.
     */
    orderBy?:
      | desprecOrderByWithRelationInput
      | desprecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for desprecs.
     */
    cursor?: desprecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` desprecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` desprecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of desprecs.
     */
    distinct?: DesprecScalarFieldEnum | DesprecScalarFieldEnum[];
  };

  /**
   * desprec findMany
   */
  export type desprecFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * Filter, which desprecs to fetch.
     */
    where?: desprecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of desprecs to fetch.
     */
    orderBy?:
      | desprecOrderByWithRelationInput
      | desprecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing desprecs.
     */
    cursor?: desprecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` desprecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` desprecs.
     */
    skip?: number;
    distinct?: DesprecScalarFieldEnum | DesprecScalarFieldEnum[];
  };

  /**
   * desprec create
   */
  export type desprecCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * The data needed to create a desprec.
     */
    data: XOR<desprecCreateInput, desprecUncheckedCreateInput>;
  };

  /**
   * desprec createMany
   */
  export type desprecCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many desprecs.
     */
    data: desprecCreateManyInput | desprecCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * desprec createManyAndReturn
   */
  export type desprecCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * The data used to create many desprecs.
     */
    data: desprecCreateManyInput | desprecCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * desprec update
   */
  export type desprecUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * The data needed to update a desprec.
     */
    data: XOR<desprecUpdateInput, desprecUncheckedUpdateInput>;
    /**
     * Choose, which desprec to update.
     */
    where: desprecWhereUniqueInput;
  };

  /**
   * desprec updateMany
   */
  export type desprecUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update desprecs.
     */
    data: XOR<desprecUpdateManyMutationInput, desprecUncheckedUpdateManyInput>;
    /**
     * Filter which desprecs to update
     */
    where?: desprecWhereInput;
    /**
     * Limit how many desprecs to update.
     */
    limit?: number;
  };

  /**
   * desprec updateManyAndReturn
   */
  export type desprecUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * The data used to update desprecs.
     */
    data: XOR<desprecUpdateManyMutationInput, desprecUncheckedUpdateManyInput>;
    /**
     * Filter which desprecs to update
     */
    where?: desprecWhereInput;
    /**
     * Limit how many desprecs to update.
     */
    limit?: number;
  };

  /**
   * desprec upsert
   */
  export type desprecUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * The filter to search for the desprec to update in case it exists.
     */
    where: desprecWhereUniqueInput;
    /**
     * In case the desprec found by the `where` argument doesn't exist, create a new desprec with this data.
     */
    create: XOR<desprecCreateInput, desprecUncheckedCreateInput>;
    /**
     * In case the desprec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<desprecUpdateInput, desprecUncheckedUpdateInput>;
  };

  /**
   * desprec delete
   */
  export type desprecDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
    /**
     * Filter which desprec to delete.
     */
    where: desprecWhereUniqueInput;
  };

  /**
   * desprec deleteMany
   */
  export type desprecDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which desprecs to delete
     */
    where?: desprecWhereInput;
    /**
     * Limit how many desprecs to delete.
     */
    limit?: number;
  };

  /**
   * desprec without action
   */
  export type desprecDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the desprec
     */
    select?: desprecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the desprec
     */
    omit?: desprecOmit<ExtArgs> | null;
  };

  /**
   * Model empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null;
    _avg: EmpresaAvgAggregateOutputType | null;
    _sum: EmpresaSumAggregateOutputType | null;
    _min: EmpresaMinAggregateOutputType | null;
    _max: EmpresaMaxAggregateOutputType | null;
  };

  export type EmpresaAvgAggregateOutputType = {
    cod_empresa: number | null;
    cod_cidade: number | null;
  };

  export type EmpresaSumAggregateOutputType = {
    cod_empresa: number | null;
    cod_cidade: number | null;
  };

  export type EmpresaMinAggregateOutputType = {
    cod_empresa: number | null;
    nome_empresa: string | null;
    razao_empresa: string | null;
    end_empresa: string | null;
    bairro_empresa: string | null;
    cep_empresa: string | null;
    ddd_empresa: string | null;
    fone_empresa: string | null;
    cnpj_empresa: string | null;
    ie_empresa: string | null;
    im_empresa: string | null;
    cod_cidade: number | null;
    certificado_empresa: string | null;
    email_empresa: string | null;
  };

  export type EmpresaMaxAggregateOutputType = {
    cod_empresa: number | null;
    nome_empresa: string | null;
    razao_empresa: string | null;
    end_empresa: string | null;
    bairro_empresa: string | null;
    cep_empresa: string | null;
    ddd_empresa: string | null;
    fone_empresa: string | null;
    cnpj_empresa: string | null;
    ie_empresa: string | null;
    im_empresa: string | null;
    cod_cidade: number | null;
    certificado_empresa: string | null;
    email_empresa: string | null;
  };

  export type EmpresaCountAggregateOutputType = {
    cod_empresa: number;
    nome_empresa: number;
    razao_empresa: number;
    end_empresa: number;
    bairro_empresa: number;
    cep_empresa: number;
    ddd_empresa: number;
    fone_empresa: number;
    cnpj_empresa: number;
    ie_empresa: number;
    im_empresa: number;
    cod_cidade: number;
    certificado_empresa: number;
    email_empresa: number;
    _all: number;
  };

  export type EmpresaAvgAggregateInputType = {
    cod_empresa?: true;
    cod_cidade?: true;
  };

  export type EmpresaSumAggregateInputType = {
    cod_empresa?: true;
    cod_cidade?: true;
  };

  export type EmpresaMinAggregateInputType = {
    cod_empresa?: true;
    nome_empresa?: true;
    razao_empresa?: true;
    end_empresa?: true;
    bairro_empresa?: true;
    cep_empresa?: true;
    ddd_empresa?: true;
    fone_empresa?: true;
    cnpj_empresa?: true;
    ie_empresa?: true;
    im_empresa?: true;
    cod_cidade?: true;
    certificado_empresa?: true;
    email_empresa?: true;
  };

  export type EmpresaMaxAggregateInputType = {
    cod_empresa?: true;
    nome_empresa?: true;
    razao_empresa?: true;
    end_empresa?: true;
    bairro_empresa?: true;
    cep_empresa?: true;
    ddd_empresa?: true;
    fone_empresa?: true;
    cnpj_empresa?: true;
    ie_empresa?: true;
    im_empresa?: true;
    cod_cidade?: true;
    certificado_empresa?: true;
    email_empresa?: true;
  };

  export type EmpresaCountAggregateInputType = {
    cod_empresa?: true;
    nome_empresa?: true;
    razao_empresa?: true;
    end_empresa?: true;
    bairro_empresa?: true;
    cep_empresa?: true;
    ddd_empresa?: true;
    fone_empresa?: true;
    cnpj_empresa?: true;
    ie_empresa?: true;
    im_empresa?: true;
    cod_cidade?: true;
    certificado_empresa?: true;
    email_empresa?: true;
    _all?: true;
  };

  export type EmpresaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which empresa to aggregate.
     */
    where?: empresaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of empresas to fetch.
     */
    orderBy?:
      | empresaOrderByWithRelationInput
      | empresaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: empresaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` empresas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned empresas
     **/
    _count?: true | EmpresaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EmpresaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EmpresaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EmpresaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EmpresaMaxAggregateInputType;
  };

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
    [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>;
  };

  export type empresaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: empresaWhereInput;
    orderBy?:
      | empresaOrderByWithAggregationInput
      | empresaOrderByWithAggregationInput[];
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum;
    having?: empresaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EmpresaCountAggregateInputType | true;
    _avg?: EmpresaAvgAggregateInputType;
    _sum?: EmpresaSumAggregateInputType;
    _min?: EmpresaMinAggregateInputType;
    _max?: EmpresaMaxAggregateInputType;
  };

  export type EmpresaGroupByOutputType = {
    cod_empresa: number;
    nome_empresa: string;
    razao_empresa: string | null;
    end_empresa: string | null;
    bairro_empresa: string | null;
    cep_empresa: string | null;
    ddd_empresa: string | null;
    fone_empresa: string | null;
    cnpj_empresa: string | null;
    ie_empresa: string | null;
    im_empresa: string | null;
    cod_cidade: number | null;
    certificado_empresa: string | null;
    email_empresa: string | null;
    _count: EmpresaCountAggregateOutputType | null;
    _avg: EmpresaAvgAggregateOutputType | null;
    _sum: EmpresaSumAggregateOutputType | null;
    _min: EmpresaMinAggregateOutputType | null;
    _max: EmpresaMaxAggregateOutputType | null;
  };

  type GetEmpresaGroupByPayload<T extends empresaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EmpresaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof EmpresaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>;
        }
      >
    >;

  export type empresaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_empresa?: boolean;
      nome_empresa?: boolean;
      razao_empresa?: boolean;
      end_empresa?: boolean;
      bairro_empresa?: boolean;
      cep_empresa?: boolean;
      ddd_empresa?: boolean;
      fone_empresa?: boolean;
      cnpj_empresa?: boolean;
      ie_empresa?: boolean;
      im_empresa?: boolean;
      cod_cidade?: boolean;
      certificado_empresa?: boolean;
      email_empresa?: boolean;
    },
    ExtArgs['result']['empresa']
  >;

  export type empresaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_empresa?: boolean;
      nome_empresa?: boolean;
      razao_empresa?: boolean;
      end_empresa?: boolean;
      bairro_empresa?: boolean;
      cep_empresa?: boolean;
      ddd_empresa?: boolean;
      fone_empresa?: boolean;
      cnpj_empresa?: boolean;
      ie_empresa?: boolean;
      im_empresa?: boolean;
      cod_cidade?: boolean;
      certificado_empresa?: boolean;
      email_empresa?: boolean;
    },
    ExtArgs['result']['empresa']
  >;

  export type empresaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_empresa?: boolean;
      nome_empresa?: boolean;
      razao_empresa?: boolean;
      end_empresa?: boolean;
      bairro_empresa?: boolean;
      cep_empresa?: boolean;
      ddd_empresa?: boolean;
      fone_empresa?: boolean;
      cnpj_empresa?: boolean;
      ie_empresa?: boolean;
      im_empresa?: boolean;
      cod_cidade?: boolean;
      certificado_empresa?: boolean;
      email_empresa?: boolean;
    },
    ExtArgs['result']['empresa']
  >;

  export type empresaSelectScalar = {
    cod_empresa?: boolean;
    nome_empresa?: boolean;
    razao_empresa?: boolean;
    end_empresa?: boolean;
    bairro_empresa?: boolean;
    cep_empresa?: boolean;
    ddd_empresa?: boolean;
    fone_empresa?: boolean;
    cnpj_empresa?: boolean;
    ie_empresa?: boolean;
    im_empresa?: boolean;
    cod_cidade?: boolean;
    certificado_empresa?: boolean;
    email_empresa?: boolean;
  };

  export type empresaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_empresa'
    | 'nome_empresa'
    | 'razao_empresa'
    | 'end_empresa'
    | 'bairro_empresa'
    | 'cep_empresa'
    | 'ddd_empresa'
    | 'fone_empresa'
    | 'cnpj_empresa'
    | 'ie_empresa'
    | 'im_empresa'
    | 'cod_cidade'
    | 'certificado_empresa'
    | 'email_empresa',
    ExtArgs['result']['empresa']
  >;

  export type $empresaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'empresa';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_empresa: number;
        nome_empresa: string;
        razao_empresa: string | null;
        end_empresa: string | null;
        bairro_empresa: string | null;
        cep_empresa: string | null;
        ddd_empresa: string | null;
        fone_empresa: string | null;
        cnpj_empresa: string | null;
        ie_empresa: string | null;
        im_empresa: string | null;
        cod_cidade: number | null;
        certificado_empresa: string | null;
        email_empresa: string | null;
      },
      ExtArgs['result']['empresa']
    >;
    composites: {};
  };

  type empresaGetPayload<
    S extends boolean | null | undefined | empresaDefaultArgs,
  > = $Result.GetResult<Prisma.$empresaPayload, S>;

  type empresaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<empresaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: EmpresaCountAggregateInputType | true;
  };

  export interface empresaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['empresa'];
      meta: { name: 'empresa' };
    };
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {empresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends empresaFindUniqueArgs>(
      args: SelectSubset<T, empresaFindUniqueArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {empresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends empresaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, empresaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends empresaFindFirstArgs>(
      args?: SelectSubset<T, empresaFindFirstArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends empresaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, empresaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     *
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     *
     * // Only select the `cod_empresa`
     * const empresaWithCod_empresaOnly = await prisma.empresa.findMany({ select: { cod_empresa: true } })
     *
     */
    findMany<T extends empresaFindManyArgs>(
      args?: SelectSubset<T, empresaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Empresa.
     * @param {empresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     *
     */
    create<T extends empresaCreateArgs>(
      args: SelectSubset<T, empresaCreateArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Empresas.
     * @param {empresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends empresaCreateManyArgs>(
      args?: SelectSubset<T, empresaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Empresas and returns the data saved in the database.
     * @param {empresaCreateManyAndReturnArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Empresas and only return the `cod_empresa`
     * const empresaWithCod_empresaOnly = await prisma.empresa.createManyAndReturn({
     *   select: { cod_empresa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends empresaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, empresaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Empresa.
     * @param {empresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     *
     */
    delete<T extends empresaDeleteArgs>(
      args: SelectSubset<T, empresaDeleteArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Empresa.
     * @param {empresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends empresaUpdateArgs>(
      args: SelectSubset<T, empresaUpdateArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Empresas.
     * @param {empresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends empresaDeleteManyArgs>(
      args?: SelectSubset<T, empresaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends empresaUpdateManyArgs>(
      args: SelectSubset<T, empresaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Empresas and returns the data updated in the database.
     * @param {empresaUpdateManyAndReturnArgs} args - Arguments to update many Empresas.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Empresas and only return the `cod_empresa`
     * const empresaWithCod_empresaOnly = await prisma.empresa.updateManyAndReturn({
     *   select: { cod_empresa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends empresaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, empresaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Empresa.
     * @param {empresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends empresaUpsertArgs>(
      args: SelectSubset<T, empresaUpsertArgs<ExtArgs>>,
    ): Prisma__empresaClient<
      $Result.GetResult<
        Prisma.$empresaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
     **/
    count<T extends empresaCountArgs>(
      args?: Subset<T, empresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EmpresaAggregateArgs>(
      args: Subset<T, EmpresaAggregateArgs>,
    ): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>;

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends empresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empresaGroupByArgs['orderBy'] }
        : { orderBy?: empresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, empresaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetEmpresaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the empresa model
     */
    readonly fields: empresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empresaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the empresa model
   */
  interface empresaFieldRefs {
    readonly cod_empresa: FieldRef<'empresa', 'Int'>;
    readonly nome_empresa: FieldRef<'empresa', 'String'>;
    readonly razao_empresa: FieldRef<'empresa', 'String'>;
    readonly end_empresa: FieldRef<'empresa', 'String'>;
    readonly bairro_empresa: FieldRef<'empresa', 'String'>;
    readonly cep_empresa: FieldRef<'empresa', 'String'>;
    readonly ddd_empresa: FieldRef<'empresa', 'String'>;
    readonly fone_empresa: FieldRef<'empresa', 'String'>;
    readonly cnpj_empresa: FieldRef<'empresa', 'String'>;
    readonly ie_empresa: FieldRef<'empresa', 'String'>;
    readonly im_empresa: FieldRef<'empresa', 'String'>;
    readonly cod_cidade: FieldRef<'empresa', 'Int'>;
    readonly certificado_empresa: FieldRef<'empresa', 'String'>;
    readonly email_empresa: FieldRef<'empresa', 'String'>;
  }

  // Custom InputTypes
  /**
   * empresa findUnique
   */
  export type empresaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * Filter, which empresa to fetch.
     */
    where: empresaWhereUniqueInput;
  };

  /**
   * empresa findUniqueOrThrow
   */
  export type empresaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * Filter, which empresa to fetch.
     */
    where: empresaWhereUniqueInput;
  };

  /**
   * empresa findFirst
   */
  export type empresaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * Filter, which empresa to fetch.
     */
    where?: empresaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of empresas to fetch.
     */
    orderBy?:
      | empresaOrderByWithRelationInput
      | empresaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for empresas.
     */
    cursor?: empresaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` empresas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[];
  };

  /**
   * empresa findFirstOrThrow
   */
  export type empresaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * Filter, which empresa to fetch.
     */
    where?: empresaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of empresas to fetch.
     */
    orderBy?:
      | empresaOrderByWithRelationInput
      | empresaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for empresas.
     */
    cursor?: empresaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` empresas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[];
  };

  /**
   * empresa findMany
   */
  export type empresaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * Filter, which empresas to fetch.
     */
    where?: empresaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of empresas to fetch.
     */
    orderBy?:
      | empresaOrderByWithRelationInput
      | empresaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing empresas.
     */
    cursor?: empresaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` empresas.
     */
    skip?: number;
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[];
  };

  /**
   * empresa create
   */
  export type empresaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * The data needed to create a empresa.
     */
    data: XOR<empresaCreateInput, empresaUncheckedCreateInput>;
  };

  /**
   * empresa createMany
   */
  export type empresaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many empresas.
     */
    data: empresaCreateManyInput | empresaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * empresa createManyAndReturn
   */
  export type empresaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * The data used to create many empresas.
     */
    data: empresaCreateManyInput | empresaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * empresa update
   */
  export type empresaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * The data needed to update a empresa.
     */
    data: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>;
    /**
     * Choose, which empresa to update.
     */
    where: empresaWhereUniqueInput;
  };

  /**
   * empresa updateMany
   */
  export type empresaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update empresas.
     */
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyInput>;
    /**
     * Filter which empresas to update
     */
    where?: empresaWhereInput;
    /**
     * Limit how many empresas to update.
     */
    limit?: number;
  };

  /**
   * empresa updateManyAndReturn
   */
  export type empresaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * The data used to update empresas.
     */
    data: XOR<empresaUpdateManyMutationInput, empresaUncheckedUpdateManyInput>;
    /**
     * Filter which empresas to update
     */
    where?: empresaWhereInput;
    /**
     * Limit how many empresas to update.
     */
    limit?: number;
  };

  /**
   * empresa upsert
   */
  export type empresaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * The filter to search for the empresa to update in case it exists.
     */
    where: empresaWhereUniqueInput;
    /**
     * In case the empresa found by the `where` argument doesn't exist, create a new empresa with this data.
     */
    create: XOR<empresaCreateInput, empresaUncheckedCreateInput>;
    /**
     * In case the empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empresaUpdateInput, empresaUncheckedUpdateInput>;
  };

  /**
   * empresa delete
   */
  export type empresaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
    /**
     * Filter which empresa to delete.
     */
    where: empresaWhereUniqueInput;
  };

  /**
   * empresa deleteMany
   */
  export type empresaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which empresas to delete
     */
    where?: empresaWhereInput;
    /**
     * Limit how many empresas to delete.
     */
    limit?: number;
  };

  /**
   * empresa without action
   */
  export type empresaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the empresa
     */
    select?: empresaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the empresa
     */
    omit?: empresaOmit<ExtArgs> | null;
  };

  /**
   * Model fase
   */

  export type AggregateFase = {
    _count: FaseCountAggregateOutputType | null;
    _avg: FaseAvgAggregateOutputType | null;
    _sum: FaseSumAggregateOutputType | null;
    _min: FaseMinAggregateOutputType | null;
    _max: FaseMaxAggregateOutputType | null;
  };

  export type FaseAvgAggregateOutputType = {
    cod_fase: number | null;
  };

  export type FaseSumAggregateOutputType = {
    cod_fase: number | null;
  };

  export type FaseMinAggregateOutputType = {
    cod_fase: number | null;
    nome_fase: string | null;
  };

  export type FaseMaxAggregateOutputType = {
    cod_fase: number | null;
    nome_fase: string | null;
  };

  export type FaseCountAggregateOutputType = {
    cod_fase: number;
    nome_fase: number;
    _all: number;
  };

  export type FaseAvgAggregateInputType = {
    cod_fase?: true;
  };

  export type FaseSumAggregateInputType = {
    cod_fase?: true;
  };

  export type FaseMinAggregateInputType = {
    cod_fase?: true;
    nome_fase?: true;
  };

  export type FaseMaxAggregateInputType = {
    cod_fase?: true;
    nome_fase?: true;
  };

  export type FaseCountAggregateInputType = {
    cod_fase?: true;
    nome_fase?: true;
    _all?: true;
  };

  export type FaseAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fase to aggregate.
     */
    where?: faseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fases to fetch.
     */
    orderBy?: faseOrderByWithRelationInput | faseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: faseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fases from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fases.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned fases
     **/
    _count?: true | FaseCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FaseAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FaseSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FaseMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FaseMaxAggregateInputType;
  };

  export type GetFaseAggregateType<T extends FaseAggregateArgs> = {
    [P in keyof T & keyof AggregateFase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFase[P]>
      : GetScalarType<T[P], AggregateFase[P]>;
  };

  export type faseGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: faseWhereInput;
    orderBy?:
      | faseOrderByWithAggregationInput
      | faseOrderByWithAggregationInput[];
    by: FaseScalarFieldEnum[] | FaseScalarFieldEnum;
    having?: faseScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FaseCountAggregateInputType | true;
    _avg?: FaseAvgAggregateInputType;
    _sum?: FaseSumAggregateInputType;
    _min?: FaseMinAggregateInputType;
    _max?: FaseMaxAggregateInputType;
  };

  export type FaseGroupByOutputType = {
    cod_fase: number;
    nome_fase: string;
    _count: FaseCountAggregateOutputType | null;
    _avg: FaseAvgAggregateOutputType | null;
    _sum: FaseSumAggregateOutputType | null;
    _min: FaseMinAggregateOutputType | null;
    _max: FaseMaxAggregateOutputType | null;
  };

  type GetFaseGroupByPayload<T extends faseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaseGroupByOutputType, T['by']> & {
        [P in keyof T & keyof FaseGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FaseGroupByOutputType[P]>
          : GetScalarType<T[P], FaseGroupByOutputType[P]>;
      }
    >
  >;

  export type faseSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fase?: boolean;
      nome_fase?: boolean;
      meta?: boolean | fase$metaArgs<ExtArgs>;
      tarefa?: boolean | fase$tarefaArgs<ExtArgs>;
      _count?: boolean | FaseCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['fase']
  >;

  export type faseSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fase?: boolean;
      nome_fase?: boolean;
    },
    ExtArgs['result']['fase']
  >;

  export type faseSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fase?: boolean;
      nome_fase?: boolean;
    },
    ExtArgs['result']['fase']
  >;

  export type faseSelectScalar = {
    cod_fase?: boolean;
    nome_fase?: boolean;
  };

  export type faseOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<'cod_fase' | 'nome_fase', ExtArgs['result']['fase']>;
  export type faseInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    meta?: boolean | fase$metaArgs<ExtArgs>;
    tarefa?: boolean | fase$tarefaArgs<ExtArgs>;
    _count?: boolean | FaseCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type faseIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type faseIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $fasePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'fase';
    objects: {
      meta: Prisma.$metaPayload<ExtArgs>[];
      tarefa: Prisma.$tarefaPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_fase: number;
        nome_fase: string;
      },
      ExtArgs['result']['fase']
    >;
    composites: {};
  };

  type faseGetPayload<S extends boolean | null | undefined | faseDefaultArgs> =
    $Result.GetResult<Prisma.$fasePayload, S>;

  type faseCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<faseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FaseCountAggregateInputType | true;
  };

  export interface faseDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['fase'];
      meta: { name: 'fase' };
    };
    /**
     * Find zero or one Fase that matches the filter.
     * @param {faseFindUniqueArgs} args - Arguments to find a Fase
     * @example
     * // Get one Fase
     * const fase = await prisma.fase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faseFindUniqueArgs>(
      args: SelectSubset<T, faseFindUniqueArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Fase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faseFindUniqueOrThrowArgs} args - Arguments to find a Fase
     * @example
     * // Get one Fase
     * const fase = await prisma.fase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faseFindUniqueOrThrowArgs>(
      args: SelectSubset<T, faseFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faseFindFirstArgs} args - Arguments to find a Fase
     * @example
     * // Get one Fase
     * const fase = await prisma.fase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faseFindFirstArgs>(
      args?: SelectSubset<T, faseFindFirstArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faseFindFirstOrThrowArgs} args - Arguments to find a Fase
     * @example
     * // Get one Fase
     * const fase = await prisma.fase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, faseFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Fases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fases
     * const fases = await prisma.fase.findMany()
     *
     * // Get first 10 Fases
     * const fases = await prisma.fase.findMany({ take: 10 })
     *
     * // Only select the `cod_fase`
     * const faseWithCod_faseOnly = await prisma.fase.findMany({ select: { cod_fase: true } })
     *
     */
    findMany<T extends faseFindManyArgs>(
      args?: SelectSubset<T, faseFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Fase.
     * @param {faseCreateArgs} args - Arguments to create a Fase.
     * @example
     * // Create one Fase
     * const Fase = await prisma.fase.create({
     *   data: {
     *     // ... data to create a Fase
     *   }
     * })
     *
     */
    create<T extends faseCreateArgs>(
      args: SelectSubset<T, faseCreateArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Fases.
     * @param {faseCreateManyArgs} args - Arguments to create many Fases.
     * @example
     * // Create many Fases
     * const fase = await prisma.fase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends faseCreateManyArgs>(
      args?: SelectSubset<T, faseCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Fases and returns the data saved in the database.
     * @param {faseCreateManyAndReturnArgs} args - Arguments to create many Fases.
     * @example
     * // Create many Fases
     * const fase = await prisma.fase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Fases and only return the `cod_fase`
     * const faseWithCod_faseOnly = await prisma.fase.createManyAndReturn({
     *   select: { cod_fase: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends faseCreateManyAndReturnArgs>(
      args?: SelectSubset<T, faseCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Fase.
     * @param {faseDeleteArgs} args - Arguments to delete one Fase.
     * @example
     * // Delete one Fase
     * const Fase = await prisma.fase.delete({
     *   where: {
     *     // ... filter to delete one Fase
     *   }
     * })
     *
     */
    delete<T extends faseDeleteArgs>(
      args: SelectSubset<T, faseDeleteArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Fase.
     * @param {faseUpdateArgs} args - Arguments to update one Fase.
     * @example
     * // Update one Fase
     * const fase = await prisma.fase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends faseUpdateArgs>(
      args: SelectSubset<T, faseUpdateArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Fases.
     * @param {faseDeleteManyArgs} args - Arguments to filter Fases to delete.
     * @example
     * // Delete a few Fases
     * const { count } = await prisma.fase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends faseDeleteManyArgs>(
      args?: SelectSubset<T, faseDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fases
     * const fase = await prisma.fase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends faseUpdateManyArgs>(
      args: SelectSubset<T, faseUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fases and returns the data updated in the database.
     * @param {faseUpdateManyAndReturnArgs} args - Arguments to update many Fases.
     * @example
     * // Update many Fases
     * const fase = await prisma.fase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Fases and only return the `cod_fase`
     * const faseWithCod_faseOnly = await prisma.fase.updateManyAndReturn({
     *   select: { cod_fase: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends faseUpdateManyAndReturnArgs>(
      args: SelectSubset<T, faseUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Fase.
     * @param {faseUpsertArgs} args - Arguments to update or create a Fase.
     * @example
     * // Update or create a Fase
     * const fase = await prisma.fase.upsert({
     *   create: {
     *     // ... data to create a Fase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fase we want to update
     *   }
     * })
     */
    upsert<T extends faseUpsertArgs>(
      args: SelectSubset<T, faseUpsertArgs<ExtArgs>>,
    ): Prisma__faseClient<
      $Result.GetResult<
        Prisma.$fasePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Fases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faseCountArgs} args - Arguments to filter Fases to count.
     * @example
     * // Count the number of Fases
     * const count = await prisma.fase.count({
     *   where: {
     *     // ... the filter for the Fases we want to count
     *   }
     * })
     **/
    count<T extends faseCountArgs>(
      args?: Subset<T, faseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaseCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Fase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FaseAggregateArgs>(
      args: Subset<T, FaseAggregateArgs>,
    ): Prisma.PrismaPromise<GetFaseAggregateType<T>>;

    /**
     * Group by Fase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends faseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faseGroupByArgs['orderBy'] }
        : { orderBy?: faseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, faseGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFaseGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the fase model
     */
    readonly fields: faseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faseClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    meta<T extends fase$metaArgs<ExtArgs> = {}>(
      args?: Subset<T, fase$metaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$metaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    tarefa<T extends fase$tarefaArgs<ExtArgs> = {}>(
      args?: Subset<T, fase$tarefaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$tarefaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the fase model
   */
  interface faseFieldRefs {
    readonly cod_fase: FieldRef<'fase', 'Int'>;
    readonly nome_fase: FieldRef<'fase', 'String'>;
  }

  // Custom InputTypes
  /**
   * fase findUnique
   */
  export type faseFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * Filter, which fase to fetch.
     */
    where: faseWhereUniqueInput;
  };

  /**
   * fase findUniqueOrThrow
   */
  export type faseFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * Filter, which fase to fetch.
     */
    where: faseWhereUniqueInput;
  };

  /**
   * fase findFirst
   */
  export type faseFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * Filter, which fase to fetch.
     */
    where?: faseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fases to fetch.
     */
    orderBy?: faseOrderByWithRelationInput | faseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fases.
     */
    cursor?: faseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fases from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fases.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fases.
     */
    distinct?: FaseScalarFieldEnum | FaseScalarFieldEnum[];
  };

  /**
   * fase findFirstOrThrow
   */
  export type faseFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * Filter, which fase to fetch.
     */
    where?: faseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fases to fetch.
     */
    orderBy?: faseOrderByWithRelationInput | faseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fases.
     */
    cursor?: faseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fases from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fases.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fases.
     */
    distinct?: FaseScalarFieldEnum | FaseScalarFieldEnum[];
  };

  /**
   * fase findMany
   */
  export type faseFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * Filter, which fases to fetch.
     */
    where?: faseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fases to fetch.
     */
    orderBy?: faseOrderByWithRelationInput | faseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing fases.
     */
    cursor?: faseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fases from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fases.
     */
    skip?: number;
    distinct?: FaseScalarFieldEnum | FaseScalarFieldEnum[];
  };

  /**
   * fase create
   */
  export type faseCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * The data needed to create a fase.
     */
    data: XOR<faseCreateInput, faseUncheckedCreateInput>;
  };

  /**
   * fase createMany
   */
  export type faseCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many fases.
     */
    data: faseCreateManyInput | faseCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fase createManyAndReturn
   */
  export type faseCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * The data used to create many fases.
     */
    data: faseCreateManyInput | faseCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fase update
   */
  export type faseUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * The data needed to update a fase.
     */
    data: XOR<faseUpdateInput, faseUncheckedUpdateInput>;
    /**
     * Choose, which fase to update.
     */
    where: faseWhereUniqueInput;
  };

  /**
   * fase updateMany
   */
  export type faseUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update fases.
     */
    data: XOR<faseUpdateManyMutationInput, faseUncheckedUpdateManyInput>;
    /**
     * Filter which fases to update
     */
    where?: faseWhereInput;
    /**
     * Limit how many fases to update.
     */
    limit?: number;
  };

  /**
   * fase updateManyAndReturn
   */
  export type faseUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * The data used to update fases.
     */
    data: XOR<faseUpdateManyMutationInput, faseUncheckedUpdateManyInput>;
    /**
     * Filter which fases to update
     */
    where?: faseWhereInput;
    /**
     * Limit how many fases to update.
     */
    limit?: number;
  };

  /**
   * fase upsert
   */
  export type faseUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * The filter to search for the fase to update in case it exists.
     */
    where: faseWhereUniqueInput;
    /**
     * In case the fase found by the `where` argument doesn't exist, create a new fase with this data.
     */
    create: XOR<faseCreateInput, faseUncheckedCreateInput>;
    /**
     * In case the fase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faseUpdateInput, faseUncheckedUpdateInput>;
  };

  /**
   * fase delete
   */
  export type faseDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
    /**
     * Filter which fase to delete.
     */
    where: faseWhereUniqueInput;
  };

  /**
   * fase deleteMany
   */
  export type faseDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fases to delete
     */
    where?: faseWhereInput;
    /**
     * Limit how many fases to delete.
     */
    limit?: number;
  };

  /**
   * fase.meta
   */
  export type fase$metaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    where?: metaWhereInput;
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[];
    cursor?: metaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[];
  };

  /**
   * fase.tarefa
   */
  export type fase$tarefaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    where?: tarefaWhereInput;
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    cursor?: tarefaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * fase without action
   */
  export type faseDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fase
     */
    select?: faseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fase
     */
    omit?: faseOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: faseInclude<ExtArgs> | null;
  };

  /**
   * Model fatdes
   */

  export type AggregateFatdes = {
    _count: FatdesCountAggregateOutputType | null;
    _avg: FatdesAvgAggregateOutputType | null;
    _sum: FatdesSumAggregateOutputType | null;
    _min: FatdesMinAggregateOutputType | null;
    _max: FatdesMaxAggregateOutputType | null;
  };

  export type FatdesAvgAggregateOutputType = {
    cod_fatdes: number | null;
    vrdesp_fatdes: Decimal | null;
  };

  export type FatdesSumAggregateOutputType = {
    cod_fatdes: number | null;
    vrdesp_fatdes: Decimal | null;
  };

  export type FatdesMinAggregateOutputType = {
    cod_fatdes: number | null;
    mesano_fatdes: string | null;
    desc_fatdes: string | null;
    vrdesp_fatdes: Decimal | null;
    dtpag_fatdes: Date | null;
    obs_fatdes: Uint8Array | null;
    dtven_fatdes: Date | null;
  };

  export type FatdesMaxAggregateOutputType = {
    cod_fatdes: number | null;
    mesano_fatdes: string | null;
    desc_fatdes: string | null;
    vrdesp_fatdes: Decimal | null;
    dtpag_fatdes: Date | null;
    obs_fatdes: Uint8Array | null;
    dtven_fatdes: Date | null;
  };

  export type FatdesCountAggregateOutputType = {
    cod_fatdes: number;
    mesano_fatdes: number;
    desc_fatdes: number;
    vrdesp_fatdes: number;
    dtpag_fatdes: number;
    obs_fatdes: number;
    dtven_fatdes: number;
    _all: number;
  };

  export type FatdesAvgAggregateInputType = {
    cod_fatdes?: true;
    vrdesp_fatdes?: true;
  };

  export type FatdesSumAggregateInputType = {
    cod_fatdes?: true;
    vrdesp_fatdes?: true;
  };

  export type FatdesMinAggregateInputType = {
    cod_fatdes?: true;
    mesano_fatdes?: true;
    desc_fatdes?: true;
    vrdesp_fatdes?: true;
    dtpag_fatdes?: true;
    obs_fatdes?: true;
    dtven_fatdes?: true;
  };

  export type FatdesMaxAggregateInputType = {
    cod_fatdes?: true;
    mesano_fatdes?: true;
    desc_fatdes?: true;
    vrdesp_fatdes?: true;
    dtpag_fatdes?: true;
    obs_fatdes?: true;
    dtven_fatdes?: true;
  };

  export type FatdesCountAggregateInputType = {
    cod_fatdes?: true;
    mesano_fatdes?: true;
    desc_fatdes?: true;
    vrdesp_fatdes?: true;
    dtpag_fatdes?: true;
    obs_fatdes?: true;
    dtven_fatdes?: true;
    _all?: true;
  };

  export type FatdesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fatdes to aggregate.
     */
    where?: fatdesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatdes to fetch.
     */
    orderBy?: fatdesOrderByWithRelationInput | fatdesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: fatdesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatdes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatdes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned fatdes
     **/
    _count?: true | FatdesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FatdesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FatdesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FatdesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FatdesMaxAggregateInputType;
  };

  export type GetFatdesAggregateType<T extends FatdesAggregateArgs> = {
    [P in keyof T & keyof AggregateFatdes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFatdes[P]>
      : GetScalarType<T[P], AggregateFatdes[P]>;
  };

  export type fatdesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: fatdesWhereInput;
    orderBy?:
      | fatdesOrderByWithAggregationInput
      | fatdesOrderByWithAggregationInput[];
    by: FatdesScalarFieldEnum[] | FatdesScalarFieldEnum;
    having?: fatdesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FatdesCountAggregateInputType | true;
    _avg?: FatdesAvgAggregateInputType;
    _sum?: FatdesSumAggregateInputType;
    _min?: FatdesMinAggregateInputType;
    _max?: FatdesMaxAggregateInputType;
  };

  export type FatdesGroupByOutputType = {
    cod_fatdes: number;
    mesano_fatdes: string | null;
    desc_fatdes: string;
    vrdesp_fatdes: Decimal;
    dtpag_fatdes: Date | null;
    obs_fatdes: Uint8Array | null;
    dtven_fatdes: Date | null;
    _count: FatdesCountAggregateOutputType | null;
    _avg: FatdesAvgAggregateOutputType | null;
    _sum: FatdesSumAggregateOutputType | null;
    _min: FatdesMinAggregateOutputType | null;
    _max: FatdesMaxAggregateOutputType | null;
  };

  type GetFatdesGroupByPayload<T extends fatdesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FatdesGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FatdesGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FatdesGroupByOutputType[P]>
            : GetScalarType<T[P], FatdesGroupByOutputType[P]>;
        }
      >
    >;

  export type fatdesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatdes?: boolean;
      mesano_fatdes?: boolean;
      desc_fatdes?: boolean;
      vrdesp_fatdes?: boolean;
      dtpag_fatdes?: boolean;
      obs_fatdes?: boolean;
      dtven_fatdes?: boolean;
    },
    ExtArgs['result']['fatdes']
  >;

  export type fatdesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatdes?: boolean;
      mesano_fatdes?: boolean;
      desc_fatdes?: boolean;
      vrdesp_fatdes?: boolean;
      dtpag_fatdes?: boolean;
      obs_fatdes?: boolean;
      dtven_fatdes?: boolean;
    },
    ExtArgs['result']['fatdes']
  >;

  export type fatdesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatdes?: boolean;
      mesano_fatdes?: boolean;
      desc_fatdes?: boolean;
      vrdesp_fatdes?: boolean;
      dtpag_fatdes?: boolean;
      obs_fatdes?: boolean;
      dtven_fatdes?: boolean;
    },
    ExtArgs['result']['fatdes']
  >;

  export type fatdesSelectScalar = {
    cod_fatdes?: boolean;
    mesano_fatdes?: boolean;
    desc_fatdes?: boolean;
    vrdesp_fatdes?: boolean;
    dtpag_fatdes?: boolean;
    obs_fatdes?: boolean;
    dtven_fatdes?: boolean;
  };

  export type fatdesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_fatdes'
    | 'mesano_fatdes'
    | 'desc_fatdes'
    | 'vrdesp_fatdes'
    | 'dtpag_fatdes'
    | 'obs_fatdes'
    | 'dtven_fatdes',
    ExtArgs['result']['fatdes']
  >;

  export type $fatdesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'fatdes';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_fatdes: number;
        mesano_fatdes: string | null;
        desc_fatdes: string;
        vrdesp_fatdes: Prisma.Decimal;
        dtpag_fatdes: Date | null;
        obs_fatdes: Uint8Array | null;
        dtven_fatdes: Date | null;
      },
      ExtArgs['result']['fatdes']
    >;
    composites: {};
  };

  type fatdesGetPayload<
    S extends boolean | null | undefined | fatdesDefaultArgs,
  > = $Result.GetResult<Prisma.$fatdesPayload, S>;

  type fatdesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<fatdesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FatdesCountAggregateInputType | true;
  };

  export interface fatdesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['fatdes'];
      meta: { name: 'fatdes' };
    };
    /**
     * Find zero or one Fatdes that matches the filter.
     * @param {fatdesFindUniqueArgs} args - Arguments to find a Fatdes
     * @example
     * // Get one Fatdes
     * const fatdes = await prisma.fatdes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fatdesFindUniqueArgs>(
      args: SelectSubset<T, fatdesFindUniqueArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Fatdes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fatdesFindUniqueOrThrowArgs} args - Arguments to find a Fatdes
     * @example
     * // Get one Fatdes
     * const fatdes = await prisma.fatdes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fatdesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, fatdesFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatdes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatdesFindFirstArgs} args - Arguments to find a Fatdes
     * @example
     * // Get one Fatdes
     * const fatdes = await prisma.fatdes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fatdesFindFirstArgs>(
      args?: SelectSubset<T, fatdesFindFirstArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatdes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatdesFindFirstOrThrowArgs} args - Arguments to find a Fatdes
     * @example
     * // Get one Fatdes
     * const fatdes = await prisma.fatdes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fatdesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fatdesFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Fatdes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatdesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fatdes
     * const fatdes = await prisma.fatdes.findMany()
     *
     * // Get first 10 Fatdes
     * const fatdes = await prisma.fatdes.findMany({ take: 10 })
     *
     * // Only select the `cod_fatdes`
     * const fatdesWithCod_fatdesOnly = await prisma.fatdes.findMany({ select: { cod_fatdes: true } })
     *
     */
    findMany<T extends fatdesFindManyArgs>(
      args?: SelectSubset<T, fatdesFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Fatdes.
     * @param {fatdesCreateArgs} args - Arguments to create a Fatdes.
     * @example
     * // Create one Fatdes
     * const Fatdes = await prisma.fatdes.create({
     *   data: {
     *     // ... data to create a Fatdes
     *   }
     * })
     *
     */
    create<T extends fatdesCreateArgs>(
      args: SelectSubset<T, fatdesCreateArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Fatdes.
     * @param {fatdesCreateManyArgs} args - Arguments to create many Fatdes.
     * @example
     * // Create many Fatdes
     * const fatdes = await prisma.fatdes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends fatdesCreateManyArgs>(
      args?: SelectSubset<T, fatdesCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Fatdes and returns the data saved in the database.
     * @param {fatdesCreateManyAndReturnArgs} args - Arguments to create many Fatdes.
     * @example
     * // Create many Fatdes
     * const fatdes = await prisma.fatdes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Fatdes and only return the `cod_fatdes`
     * const fatdesWithCod_fatdesOnly = await prisma.fatdes.createManyAndReturn({
     *   select: { cod_fatdes: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends fatdesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, fatdesCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Fatdes.
     * @param {fatdesDeleteArgs} args - Arguments to delete one Fatdes.
     * @example
     * // Delete one Fatdes
     * const Fatdes = await prisma.fatdes.delete({
     *   where: {
     *     // ... filter to delete one Fatdes
     *   }
     * })
     *
     */
    delete<T extends fatdesDeleteArgs>(
      args: SelectSubset<T, fatdesDeleteArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Fatdes.
     * @param {fatdesUpdateArgs} args - Arguments to update one Fatdes.
     * @example
     * // Update one Fatdes
     * const fatdes = await prisma.fatdes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends fatdesUpdateArgs>(
      args: SelectSubset<T, fatdesUpdateArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Fatdes.
     * @param {fatdesDeleteManyArgs} args - Arguments to filter Fatdes to delete.
     * @example
     * // Delete a few Fatdes
     * const { count } = await prisma.fatdes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends fatdesDeleteManyArgs>(
      args?: SelectSubset<T, fatdesDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fatdes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatdesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fatdes
     * const fatdes = await prisma.fatdes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends fatdesUpdateManyArgs>(
      args: SelectSubset<T, fatdesUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fatdes and returns the data updated in the database.
     * @param {fatdesUpdateManyAndReturnArgs} args - Arguments to update many Fatdes.
     * @example
     * // Update many Fatdes
     * const fatdes = await prisma.fatdes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Fatdes and only return the `cod_fatdes`
     * const fatdesWithCod_fatdesOnly = await prisma.fatdes.updateManyAndReturn({
     *   select: { cod_fatdes: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends fatdesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, fatdesUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Fatdes.
     * @param {fatdesUpsertArgs} args - Arguments to update or create a Fatdes.
     * @example
     * // Update or create a Fatdes
     * const fatdes = await prisma.fatdes.upsert({
     *   create: {
     *     // ... data to create a Fatdes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fatdes we want to update
     *   }
     * })
     */
    upsert<T extends fatdesUpsertArgs>(
      args: SelectSubset<T, fatdesUpsertArgs<ExtArgs>>,
    ): Prisma__fatdesClient<
      $Result.GetResult<
        Prisma.$fatdesPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Fatdes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatdesCountArgs} args - Arguments to filter Fatdes to count.
     * @example
     * // Count the number of Fatdes
     * const count = await prisma.fatdes.count({
     *   where: {
     *     // ... the filter for the Fatdes we want to count
     *   }
     * })
     **/
    count<T extends fatdesCountArgs>(
      args?: Subset<T, fatdesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FatdesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Fatdes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatdesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FatdesAggregateArgs>(
      args: Subset<T, FatdesAggregateArgs>,
    ): Prisma.PrismaPromise<GetFatdesAggregateType<T>>;

    /**
     * Group by Fatdes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatdesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends fatdesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fatdesGroupByArgs['orderBy'] }
        : { orderBy?: fatdesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, fatdesGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFatdesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the fatdes model
     */
    readonly fields: fatdesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fatdes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fatdesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the fatdes model
   */
  interface fatdesFieldRefs {
    readonly cod_fatdes: FieldRef<'fatdes', 'Int'>;
    readonly mesano_fatdes: FieldRef<'fatdes', 'String'>;
    readonly desc_fatdes: FieldRef<'fatdes', 'String'>;
    readonly vrdesp_fatdes: FieldRef<'fatdes', 'Decimal'>;
    readonly dtpag_fatdes: FieldRef<'fatdes', 'DateTime'>;
    readonly obs_fatdes: FieldRef<'fatdes', 'Bytes'>;
    readonly dtven_fatdes: FieldRef<'fatdes', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * fatdes findUnique
   */
  export type fatdesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * Filter, which fatdes to fetch.
     */
    where: fatdesWhereUniqueInput;
  };

  /**
   * fatdes findUniqueOrThrow
   */
  export type fatdesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * Filter, which fatdes to fetch.
     */
    where: fatdesWhereUniqueInput;
  };

  /**
   * fatdes findFirst
   */
  export type fatdesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * Filter, which fatdes to fetch.
     */
    where?: fatdesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatdes to fetch.
     */
    orderBy?: fatdesOrderByWithRelationInput | fatdesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fatdes.
     */
    cursor?: fatdesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatdes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatdes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fatdes.
     */
    distinct?: FatdesScalarFieldEnum | FatdesScalarFieldEnum[];
  };

  /**
   * fatdes findFirstOrThrow
   */
  export type fatdesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * Filter, which fatdes to fetch.
     */
    where?: fatdesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatdes to fetch.
     */
    orderBy?: fatdesOrderByWithRelationInput | fatdesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fatdes.
     */
    cursor?: fatdesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatdes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatdes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fatdes.
     */
    distinct?: FatdesScalarFieldEnum | FatdesScalarFieldEnum[];
  };

  /**
   * fatdes findMany
   */
  export type fatdesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * Filter, which fatdes to fetch.
     */
    where?: fatdesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatdes to fetch.
     */
    orderBy?: fatdesOrderByWithRelationInput | fatdesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing fatdes.
     */
    cursor?: fatdesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatdes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatdes.
     */
    skip?: number;
    distinct?: FatdesScalarFieldEnum | FatdesScalarFieldEnum[];
  };

  /**
   * fatdes create
   */
  export type fatdesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * The data needed to create a fatdes.
     */
    data: XOR<fatdesCreateInput, fatdesUncheckedCreateInput>;
  };

  /**
   * fatdes createMany
   */
  export type fatdesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many fatdes.
     */
    data: fatdesCreateManyInput | fatdesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fatdes createManyAndReturn
   */
  export type fatdesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * The data used to create many fatdes.
     */
    data: fatdesCreateManyInput | fatdesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fatdes update
   */
  export type fatdesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * The data needed to update a fatdes.
     */
    data: XOR<fatdesUpdateInput, fatdesUncheckedUpdateInput>;
    /**
     * Choose, which fatdes to update.
     */
    where: fatdesWhereUniqueInput;
  };

  /**
   * fatdes updateMany
   */
  export type fatdesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update fatdes.
     */
    data: XOR<fatdesUpdateManyMutationInput, fatdesUncheckedUpdateManyInput>;
    /**
     * Filter which fatdes to update
     */
    where?: fatdesWhereInput;
    /**
     * Limit how many fatdes to update.
     */
    limit?: number;
  };

  /**
   * fatdes updateManyAndReturn
   */
  export type fatdesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * The data used to update fatdes.
     */
    data: XOR<fatdesUpdateManyMutationInput, fatdesUncheckedUpdateManyInput>;
    /**
     * Filter which fatdes to update
     */
    where?: fatdesWhereInput;
    /**
     * Limit how many fatdes to update.
     */
    limit?: number;
  };

  /**
   * fatdes upsert
   */
  export type fatdesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * The filter to search for the fatdes to update in case it exists.
     */
    where: fatdesWhereUniqueInput;
    /**
     * In case the fatdes found by the `where` argument doesn't exist, create a new fatdes with this data.
     */
    create: XOR<fatdesCreateInput, fatdesUncheckedCreateInput>;
    /**
     * In case the fatdes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fatdesUpdateInput, fatdesUncheckedUpdateInput>;
  };

  /**
   * fatdes delete
   */
  export type fatdesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
    /**
     * Filter which fatdes to delete.
     */
    where: fatdesWhereUniqueInput;
  };

  /**
   * fatdes deleteMany
   */
  export type fatdesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fatdes to delete
     */
    where?: fatdesWhereInput;
    /**
     * Limit how many fatdes to delete.
     */
    limit?: number;
  };

  /**
   * fatdes without action
   */
  export type fatdesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatdes
     */
    select?: fatdesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatdes
     */
    omit?: fatdesOmit<ExtArgs> | null;
  };

  /**
   * Model fatfun
   */

  export type AggregateFatfun = {
    _count: FatfunCountAggregateOutputType | null;
    _avg: FatfunAvgAggregateOutputType | null;
    _sum: FatfunSumAggregateOutputType | null;
    _min: FatfunMinAggregateOutputType | null;
    _max: FatfunMaxAggregateOutputType | null;
  };

  export type FatfunAvgAggregateOutputType = {
    cod_fatfun: number | null;
    vrdesl_fatfun: Decimal | null;
    vralm_fatfun: Decimal | null;
    vrsal_fatfun: Decimal | null;
    cod_recurso: number | null;
  };

  export type FatfunSumAggregateOutputType = {
    cod_fatfun: number | null;
    vrdesl_fatfun: Decimal | null;
    vralm_fatfun: Decimal | null;
    vrsal_fatfun: Decimal | null;
    cod_recurso: number | null;
  };

  export type FatfunMinAggregateOutputType = {
    cod_fatfun: number | null;
    mesano_fatfun: string | null;
    nome_fatfun: string | null;
    vrdesl_fatfun: Decimal | null;
    vralm_fatfun: Decimal | null;
    vrsal_fatfun: Decimal | null;
    dtpag_fatfun: Date | null;
    obs_fatfun: Uint8Array | null;
    dtpag1_fatfun: Date | null;
    dtpag2_fatfun: Date | null;
    cod_recurso: number | null;
  };

  export type FatfunMaxAggregateOutputType = {
    cod_fatfun: number | null;
    mesano_fatfun: string | null;
    nome_fatfun: string | null;
    vrdesl_fatfun: Decimal | null;
    vralm_fatfun: Decimal | null;
    vrsal_fatfun: Decimal | null;
    dtpag_fatfun: Date | null;
    obs_fatfun: Uint8Array | null;
    dtpag1_fatfun: Date | null;
    dtpag2_fatfun: Date | null;
    cod_recurso: number | null;
  };

  export type FatfunCountAggregateOutputType = {
    cod_fatfun: number;
    mesano_fatfun: number;
    nome_fatfun: number;
    vrdesl_fatfun: number;
    vralm_fatfun: number;
    vrsal_fatfun: number;
    dtpag_fatfun: number;
    obs_fatfun: number;
    dtpag1_fatfun: number;
    dtpag2_fatfun: number;
    cod_recurso: number;
    _all: number;
  };

  export type FatfunAvgAggregateInputType = {
    cod_fatfun?: true;
    vrdesl_fatfun?: true;
    vralm_fatfun?: true;
    vrsal_fatfun?: true;
    cod_recurso?: true;
  };

  export type FatfunSumAggregateInputType = {
    cod_fatfun?: true;
    vrdesl_fatfun?: true;
    vralm_fatfun?: true;
    vrsal_fatfun?: true;
    cod_recurso?: true;
  };

  export type FatfunMinAggregateInputType = {
    cod_fatfun?: true;
    mesano_fatfun?: true;
    nome_fatfun?: true;
    vrdesl_fatfun?: true;
    vralm_fatfun?: true;
    vrsal_fatfun?: true;
    dtpag_fatfun?: true;
    obs_fatfun?: true;
    dtpag1_fatfun?: true;
    dtpag2_fatfun?: true;
    cod_recurso?: true;
  };

  export type FatfunMaxAggregateInputType = {
    cod_fatfun?: true;
    mesano_fatfun?: true;
    nome_fatfun?: true;
    vrdesl_fatfun?: true;
    vralm_fatfun?: true;
    vrsal_fatfun?: true;
    dtpag_fatfun?: true;
    obs_fatfun?: true;
    dtpag1_fatfun?: true;
    dtpag2_fatfun?: true;
    cod_recurso?: true;
  };

  export type FatfunCountAggregateInputType = {
    cod_fatfun?: true;
    mesano_fatfun?: true;
    nome_fatfun?: true;
    vrdesl_fatfun?: true;
    vralm_fatfun?: true;
    vrsal_fatfun?: true;
    dtpag_fatfun?: true;
    obs_fatfun?: true;
    dtpag1_fatfun?: true;
    dtpag2_fatfun?: true;
    cod_recurso?: true;
    _all?: true;
  };

  export type FatfunAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fatfun to aggregate.
     */
    where?: fatfunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatfuns to fetch.
     */
    orderBy?: fatfunOrderByWithRelationInput | fatfunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: fatfunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatfuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatfuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned fatfuns
     **/
    _count?: true | FatfunCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FatfunAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FatfunSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FatfunMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FatfunMaxAggregateInputType;
  };

  export type GetFatfunAggregateType<T extends FatfunAggregateArgs> = {
    [P in keyof T & keyof AggregateFatfun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFatfun[P]>
      : GetScalarType<T[P], AggregateFatfun[P]>;
  };

  export type fatfunGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: fatfunWhereInput;
    orderBy?:
      | fatfunOrderByWithAggregationInput
      | fatfunOrderByWithAggregationInput[];
    by: FatfunScalarFieldEnum[] | FatfunScalarFieldEnum;
    having?: fatfunScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FatfunCountAggregateInputType | true;
    _avg?: FatfunAvgAggregateInputType;
    _sum?: FatfunSumAggregateInputType;
    _min?: FatfunMinAggregateInputType;
    _max?: FatfunMaxAggregateInputType;
  };

  export type FatfunGroupByOutputType = {
    cod_fatfun: number;
    mesano_fatfun: string | null;
    nome_fatfun: string;
    vrdesl_fatfun: Decimal;
    vralm_fatfun: Decimal;
    vrsal_fatfun: Decimal;
    dtpag_fatfun: Date | null;
    obs_fatfun: Uint8Array | null;
    dtpag1_fatfun: Date | null;
    dtpag2_fatfun: Date | null;
    cod_recurso: number | null;
    _count: FatfunCountAggregateOutputType | null;
    _avg: FatfunAvgAggregateOutputType | null;
    _sum: FatfunSumAggregateOutputType | null;
    _min: FatfunMinAggregateOutputType | null;
    _max: FatfunMaxAggregateOutputType | null;
  };

  type GetFatfunGroupByPayload<T extends fatfunGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FatfunGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FatfunGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FatfunGroupByOutputType[P]>
            : GetScalarType<T[P], FatfunGroupByOutputType[P]>;
        }
      >
    >;

  export type fatfunSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatfun?: boolean;
      mesano_fatfun?: boolean;
      nome_fatfun?: boolean;
      vrdesl_fatfun?: boolean;
      vralm_fatfun?: boolean;
      vrsal_fatfun?: boolean;
      dtpag_fatfun?: boolean;
      obs_fatfun?: boolean;
      dtpag1_fatfun?: boolean;
      dtpag2_fatfun?: boolean;
      cod_recurso?: boolean;
    },
    ExtArgs['result']['fatfun']
  >;

  export type fatfunSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatfun?: boolean;
      mesano_fatfun?: boolean;
      nome_fatfun?: boolean;
      vrdesl_fatfun?: boolean;
      vralm_fatfun?: boolean;
      vrsal_fatfun?: boolean;
      dtpag_fatfun?: boolean;
      obs_fatfun?: boolean;
      dtpag1_fatfun?: boolean;
      dtpag2_fatfun?: boolean;
      cod_recurso?: boolean;
    },
    ExtArgs['result']['fatfun']
  >;

  export type fatfunSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatfun?: boolean;
      mesano_fatfun?: boolean;
      nome_fatfun?: boolean;
      vrdesl_fatfun?: boolean;
      vralm_fatfun?: boolean;
      vrsal_fatfun?: boolean;
      dtpag_fatfun?: boolean;
      obs_fatfun?: boolean;
      dtpag1_fatfun?: boolean;
      dtpag2_fatfun?: boolean;
      cod_recurso?: boolean;
    },
    ExtArgs['result']['fatfun']
  >;

  export type fatfunSelectScalar = {
    cod_fatfun?: boolean;
    mesano_fatfun?: boolean;
    nome_fatfun?: boolean;
    vrdesl_fatfun?: boolean;
    vralm_fatfun?: boolean;
    vrsal_fatfun?: boolean;
    dtpag_fatfun?: boolean;
    obs_fatfun?: boolean;
    dtpag1_fatfun?: boolean;
    dtpag2_fatfun?: boolean;
    cod_recurso?: boolean;
  };

  export type fatfunOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_fatfun'
    | 'mesano_fatfun'
    | 'nome_fatfun'
    | 'vrdesl_fatfun'
    | 'vralm_fatfun'
    | 'vrsal_fatfun'
    | 'dtpag_fatfun'
    | 'obs_fatfun'
    | 'dtpag1_fatfun'
    | 'dtpag2_fatfun'
    | 'cod_recurso',
    ExtArgs['result']['fatfun']
  >;

  export type $fatfunPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'fatfun';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_fatfun: number;
        mesano_fatfun: string | null;
        nome_fatfun: string;
        vrdesl_fatfun: Prisma.Decimal;
        vralm_fatfun: Prisma.Decimal;
        vrsal_fatfun: Prisma.Decimal;
        dtpag_fatfun: Date | null;
        obs_fatfun: Uint8Array | null;
        dtpag1_fatfun: Date | null;
        dtpag2_fatfun: Date | null;
        cod_recurso: number | null;
      },
      ExtArgs['result']['fatfun']
    >;
    composites: {};
  };

  type fatfunGetPayload<
    S extends boolean | null | undefined | fatfunDefaultArgs,
  > = $Result.GetResult<Prisma.$fatfunPayload, S>;

  type fatfunCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<fatfunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FatfunCountAggregateInputType | true;
  };

  export interface fatfunDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['fatfun'];
      meta: { name: 'fatfun' };
    };
    /**
     * Find zero or one Fatfun that matches the filter.
     * @param {fatfunFindUniqueArgs} args - Arguments to find a Fatfun
     * @example
     * // Get one Fatfun
     * const fatfun = await prisma.fatfun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fatfunFindUniqueArgs>(
      args: SelectSubset<T, fatfunFindUniqueArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Fatfun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fatfunFindUniqueOrThrowArgs} args - Arguments to find a Fatfun
     * @example
     * // Get one Fatfun
     * const fatfun = await prisma.fatfun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fatfunFindUniqueOrThrowArgs>(
      args: SelectSubset<T, fatfunFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatfun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatfunFindFirstArgs} args - Arguments to find a Fatfun
     * @example
     * // Get one Fatfun
     * const fatfun = await prisma.fatfun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fatfunFindFirstArgs>(
      args?: SelectSubset<T, fatfunFindFirstArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatfun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatfunFindFirstOrThrowArgs} args - Arguments to find a Fatfun
     * @example
     * // Get one Fatfun
     * const fatfun = await prisma.fatfun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fatfunFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fatfunFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Fatfuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatfunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fatfuns
     * const fatfuns = await prisma.fatfun.findMany()
     *
     * // Get first 10 Fatfuns
     * const fatfuns = await prisma.fatfun.findMany({ take: 10 })
     *
     * // Only select the `cod_fatfun`
     * const fatfunWithCod_fatfunOnly = await prisma.fatfun.findMany({ select: { cod_fatfun: true } })
     *
     */
    findMany<T extends fatfunFindManyArgs>(
      args?: SelectSubset<T, fatfunFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Fatfun.
     * @param {fatfunCreateArgs} args - Arguments to create a Fatfun.
     * @example
     * // Create one Fatfun
     * const Fatfun = await prisma.fatfun.create({
     *   data: {
     *     // ... data to create a Fatfun
     *   }
     * })
     *
     */
    create<T extends fatfunCreateArgs>(
      args: SelectSubset<T, fatfunCreateArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Fatfuns.
     * @param {fatfunCreateManyArgs} args - Arguments to create many Fatfuns.
     * @example
     * // Create many Fatfuns
     * const fatfun = await prisma.fatfun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends fatfunCreateManyArgs>(
      args?: SelectSubset<T, fatfunCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Fatfuns and returns the data saved in the database.
     * @param {fatfunCreateManyAndReturnArgs} args - Arguments to create many Fatfuns.
     * @example
     * // Create many Fatfuns
     * const fatfun = await prisma.fatfun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Fatfuns and only return the `cod_fatfun`
     * const fatfunWithCod_fatfunOnly = await prisma.fatfun.createManyAndReturn({
     *   select: { cod_fatfun: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends fatfunCreateManyAndReturnArgs>(
      args?: SelectSubset<T, fatfunCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Fatfun.
     * @param {fatfunDeleteArgs} args - Arguments to delete one Fatfun.
     * @example
     * // Delete one Fatfun
     * const Fatfun = await prisma.fatfun.delete({
     *   where: {
     *     // ... filter to delete one Fatfun
     *   }
     * })
     *
     */
    delete<T extends fatfunDeleteArgs>(
      args: SelectSubset<T, fatfunDeleteArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Fatfun.
     * @param {fatfunUpdateArgs} args - Arguments to update one Fatfun.
     * @example
     * // Update one Fatfun
     * const fatfun = await prisma.fatfun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends fatfunUpdateArgs>(
      args: SelectSubset<T, fatfunUpdateArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Fatfuns.
     * @param {fatfunDeleteManyArgs} args - Arguments to filter Fatfuns to delete.
     * @example
     * // Delete a few Fatfuns
     * const { count } = await prisma.fatfun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends fatfunDeleteManyArgs>(
      args?: SelectSubset<T, fatfunDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fatfuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatfunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fatfuns
     * const fatfun = await prisma.fatfun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends fatfunUpdateManyArgs>(
      args: SelectSubset<T, fatfunUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fatfuns and returns the data updated in the database.
     * @param {fatfunUpdateManyAndReturnArgs} args - Arguments to update many Fatfuns.
     * @example
     * // Update many Fatfuns
     * const fatfun = await prisma.fatfun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Fatfuns and only return the `cod_fatfun`
     * const fatfunWithCod_fatfunOnly = await prisma.fatfun.updateManyAndReturn({
     *   select: { cod_fatfun: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends fatfunUpdateManyAndReturnArgs>(
      args: SelectSubset<T, fatfunUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Fatfun.
     * @param {fatfunUpsertArgs} args - Arguments to update or create a Fatfun.
     * @example
     * // Update or create a Fatfun
     * const fatfun = await prisma.fatfun.upsert({
     *   create: {
     *     // ... data to create a Fatfun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fatfun we want to update
     *   }
     * })
     */
    upsert<T extends fatfunUpsertArgs>(
      args: SelectSubset<T, fatfunUpsertArgs<ExtArgs>>,
    ): Prisma__fatfunClient<
      $Result.GetResult<
        Prisma.$fatfunPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Fatfuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatfunCountArgs} args - Arguments to filter Fatfuns to count.
     * @example
     * // Count the number of Fatfuns
     * const count = await prisma.fatfun.count({
     *   where: {
     *     // ... the filter for the Fatfuns we want to count
     *   }
     * })
     **/
    count<T extends fatfunCountArgs>(
      args?: Subset<T, fatfunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FatfunCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Fatfun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatfunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FatfunAggregateArgs>(
      args: Subset<T, FatfunAggregateArgs>,
    ): Prisma.PrismaPromise<GetFatfunAggregateType<T>>;

    /**
     * Group by Fatfun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatfunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends fatfunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fatfunGroupByArgs['orderBy'] }
        : { orderBy?: fatfunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, fatfunGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFatfunGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the fatfun model
     */
    readonly fields: fatfunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fatfun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fatfunClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the fatfun model
   */
  interface fatfunFieldRefs {
    readonly cod_fatfun: FieldRef<'fatfun', 'Int'>;
    readonly mesano_fatfun: FieldRef<'fatfun', 'String'>;
    readonly nome_fatfun: FieldRef<'fatfun', 'String'>;
    readonly vrdesl_fatfun: FieldRef<'fatfun', 'Decimal'>;
    readonly vralm_fatfun: FieldRef<'fatfun', 'Decimal'>;
    readonly vrsal_fatfun: FieldRef<'fatfun', 'Decimal'>;
    readonly dtpag_fatfun: FieldRef<'fatfun', 'DateTime'>;
    readonly obs_fatfun: FieldRef<'fatfun', 'Bytes'>;
    readonly dtpag1_fatfun: FieldRef<'fatfun', 'DateTime'>;
    readonly dtpag2_fatfun: FieldRef<'fatfun', 'DateTime'>;
    readonly cod_recurso: FieldRef<'fatfun', 'Int'>;
  }

  // Custom InputTypes
  /**
   * fatfun findUnique
   */
  export type fatfunFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * Filter, which fatfun to fetch.
     */
    where: fatfunWhereUniqueInput;
  };

  /**
   * fatfun findUniqueOrThrow
   */
  export type fatfunFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * Filter, which fatfun to fetch.
     */
    where: fatfunWhereUniqueInput;
  };

  /**
   * fatfun findFirst
   */
  export type fatfunFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * Filter, which fatfun to fetch.
     */
    where?: fatfunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatfuns to fetch.
     */
    orderBy?: fatfunOrderByWithRelationInput | fatfunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fatfuns.
     */
    cursor?: fatfunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatfuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatfuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fatfuns.
     */
    distinct?: FatfunScalarFieldEnum | FatfunScalarFieldEnum[];
  };

  /**
   * fatfun findFirstOrThrow
   */
  export type fatfunFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * Filter, which fatfun to fetch.
     */
    where?: fatfunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatfuns to fetch.
     */
    orderBy?: fatfunOrderByWithRelationInput | fatfunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fatfuns.
     */
    cursor?: fatfunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatfuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatfuns.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fatfuns.
     */
    distinct?: FatfunScalarFieldEnum | FatfunScalarFieldEnum[];
  };

  /**
   * fatfun findMany
   */
  export type fatfunFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * Filter, which fatfuns to fetch.
     */
    where?: fatfunWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatfuns to fetch.
     */
    orderBy?: fatfunOrderByWithRelationInput | fatfunOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing fatfuns.
     */
    cursor?: fatfunWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatfuns from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatfuns.
     */
    skip?: number;
    distinct?: FatfunScalarFieldEnum | FatfunScalarFieldEnum[];
  };

  /**
   * fatfun create
   */
  export type fatfunCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * The data needed to create a fatfun.
     */
    data: XOR<fatfunCreateInput, fatfunUncheckedCreateInput>;
  };

  /**
   * fatfun createMany
   */
  export type fatfunCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many fatfuns.
     */
    data: fatfunCreateManyInput | fatfunCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fatfun createManyAndReturn
   */
  export type fatfunCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * The data used to create many fatfuns.
     */
    data: fatfunCreateManyInput | fatfunCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fatfun update
   */
  export type fatfunUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * The data needed to update a fatfun.
     */
    data: XOR<fatfunUpdateInput, fatfunUncheckedUpdateInput>;
    /**
     * Choose, which fatfun to update.
     */
    where: fatfunWhereUniqueInput;
  };

  /**
   * fatfun updateMany
   */
  export type fatfunUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update fatfuns.
     */
    data: XOR<fatfunUpdateManyMutationInput, fatfunUncheckedUpdateManyInput>;
    /**
     * Filter which fatfuns to update
     */
    where?: fatfunWhereInput;
    /**
     * Limit how many fatfuns to update.
     */
    limit?: number;
  };

  /**
   * fatfun updateManyAndReturn
   */
  export type fatfunUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * The data used to update fatfuns.
     */
    data: XOR<fatfunUpdateManyMutationInput, fatfunUncheckedUpdateManyInput>;
    /**
     * Filter which fatfuns to update
     */
    where?: fatfunWhereInput;
    /**
     * Limit how many fatfuns to update.
     */
    limit?: number;
  };

  /**
   * fatfun upsert
   */
  export type fatfunUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * The filter to search for the fatfun to update in case it exists.
     */
    where: fatfunWhereUniqueInput;
    /**
     * In case the fatfun found by the `where` argument doesn't exist, create a new fatfun with this data.
     */
    create: XOR<fatfunCreateInput, fatfunUncheckedCreateInput>;
    /**
     * In case the fatfun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fatfunUpdateInput, fatfunUncheckedUpdateInput>;
  };

  /**
   * fatfun delete
   */
  export type fatfunDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
    /**
     * Filter which fatfun to delete.
     */
    where: fatfunWhereUniqueInput;
  };

  /**
   * fatfun deleteMany
   */
  export type fatfunDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fatfuns to delete
     */
    where?: fatfunWhereInput;
    /**
     * Limit how many fatfuns to delete.
     */
    limit?: number;
  };

  /**
   * fatfun without action
   */
  export type fatfunDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatfun
     */
    select?: fatfunSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatfun
     */
    omit?: fatfunOmit<ExtArgs> | null;
  };

  /**
   * Model fatrec
   */

  export type AggregateFatrec = {
    _count: FatrecCountAggregateOutputType | null;
    _avg: FatrecAvgAggregateOutputType | null;
    _sum: FatrecSumAggregateOutputType | null;
    _min: FatrecMinAggregateOutputType | null;
    _max: FatrecMaxAggregateOutputType | null;
  };

  export type FatrecAvgAggregateOutputType = {
    cod_fatrec: number | null;
    cod_cliente: number | null;
    qtdhora_fatrec: Decimal | null;
    vrhora_fatrec: Decimal | null;
    vrtot_fatrec: Decimal | null;
    vrpag_fatrec: Decimal | null;
    imp_fatrec: Decimal | null;
    cod_recurso: number | null;
    perccom_fatrec: Decimal | null;
    cod_empresa: number | null;
  };

  export type FatrecSumAggregateOutputType = {
    cod_fatrec: number | null;
    cod_cliente: number | null;
    qtdhora_fatrec: Decimal | null;
    vrhora_fatrec: Decimal | null;
    vrtot_fatrec: Decimal | null;
    vrpag_fatrec: Decimal | null;
    imp_fatrec: Decimal | null;
    cod_recurso: number | null;
    perccom_fatrec: Decimal | null;
    cod_empresa: number | null;
  };

  export type FatrecMinAggregateOutputType = {
    cod_fatrec: number | null;
    cod_cliente: number | null;
    desc_fatrec: string | null;
    qtdhora_fatrec: Decimal | null;
    vrhora_fatrec: Decimal | null;
    vrtot_fatrec: Decimal | null;
    dtvenc_fatrec: Date | null;
    dtnf_fatrec: Date | null;
    dtcob_fatrec: Date | null;
    dtpag_fatrec: Date | null;
    vrpag_fatrec: Decimal | null;
    imp_fatrec: Decimal | null;
    mesano_fatrec: string | null;
    obs_fatrec: Uint8Array | null;
    cod_recurso: number | null;
    perccom_fatrec: Decimal | null;
    dtpgcom_fatrec: Date | null;
    cod_empresa: number | null;
    nf_fatrec: string | null;
  };

  export type FatrecMaxAggregateOutputType = {
    cod_fatrec: number | null;
    cod_cliente: number | null;
    desc_fatrec: string | null;
    qtdhora_fatrec: Decimal | null;
    vrhora_fatrec: Decimal | null;
    vrtot_fatrec: Decimal | null;
    dtvenc_fatrec: Date | null;
    dtnf_fatrec: Date | null;
    dtcob_fatrec: Date | null;
    dtpag_fatrec: Date | null;
    vrpag_fatrec: Decimal | null;
    imp_fatrec: Decimal | null;
    mesano_fatrec: string | null;
    obs_fatrec: Uint8Array | null;
    cod_recurso: number | null;
    perccom_fatrec: Decimal | null;
    dtpgcom_fatrec: Date | null;
    cod_empresa: number | null;
    nf_fatrec: string | null;
  };

  export type FatrecCountAggregateOutputType = {
    cod_fatrec: number;
    cod_cliente: number;
    desc_fatrec: number;
    qtdhora_fatrec: number;
    vrhora_fatrec: number;
    vrtot_fatrec: number;
    dtvenc_fatrec: number;
    dtnf_fatrec: number;
    dtcob_fatrec: number;
    dtpag_fatrec: number;
    vrpag_fatrec: number;
    imp_fatrec: number;
    mesano_fatrec: number;
    obs_fatrec: number;
    cod_recurso: number;
    perccom_fatrec: number;
    dtpgcom_fatrec: number;
    cod_empresa: number;
    nf_fatrec: number;
    _all: number;
  };

  export type FatrecAvgAggregateInputType = {
    cod_fatrec?: true;
    cod_cliente?: true;
    qtdhora_fatrec?: true;
    vrhora_fatrec?: true;
    vrtot_fatrec?: true;
    vrpag_fatrec?: true;
    imp_fatrec?: true;
    cod_recurso?: true;
    perccom_fatrec?: true;
    cod_empresa?: true;
  };

  export type FatrecSumAggregateInputType = {
    cod_fatrec?: true;
    cod_cliente?: true;
    qtdhora_fatrec?: true;
    vrhora_fatrec?: true;
    vrtot_fatrec?: true;
    vrpag_fatrec?: true;
    imp_fatrec?: true;
    cod_recurso?: true;
    perccom_fatrec?: true;
    cod_empresa?: true;
  };

  export type FatrecMinAggregateInputType = {
    cod_fatrec?: true;
    cod_cliente?: true;
    desc_fatrec?: true;
    qtdhora_fatrec?: true;
    vrhora_fatrec?: true;
    vrtot_fatrec?: true;
    dtvenc_fatrec?: true;
    dtnf_fatrec?: true;
    dtcob_fatrec?: true;
    dtpag_fatrec?: true;
    vrpag_fatrec?: true;
    imp_fatrec?: true;
    mesano_fatrec?: true;
    obs_fatrec?: true;
    cod_recurso?: true;
    perccom_fatrec?: true;
    dtpgcom_fatrec?: true;
    cod_empresa?: true;
    nf_fatrec?: true;
  };

  export type FatrecMaxAggregateInputType = {
    cod_fatrec?: true;
    cod_cliente?: true;
    desc_fatrec?: true;
    qtdhora_fatrec?: true;
    vrhora_fatrec?: true;
    vrtot_fatrec?: true;
    dtvenc_fatrec?: true;
    dtnf_fatrec?: true;
    dtcob_fatrec?: true;
    dtpag_fatrec?: true;
    vrpag_fatrec?: true;
    imp_fatrec?: true;
    mesano_fatrec?: true;
    obs_fatrec?: true;
    cod_recurso?: true;
    perccom_fatrec?: true;
    dtpgcom_fatrec?: true;
    cod_empresa?: true;
    nf_fatrec?: true;
  };

  export type FatrecCountAggregateInputType = {
    cod_fatrec?: true;
    cod_cliente?: true;
    desc_fatrec?: true;
    qtdhora_fatrec?: true;
    vrhora_fatrec?: true;
    vrtot_fatrec?: true;
    dtvenc_fatrec?: true;
    dtnf_fatrec?: true;
    dtcob_fatrec?: true;
    dtpag_fatrec?: true;
    vrpag_fatrec?: true;
    imp_fatrec?: true;
    mesano_fatrec?: true;
    obs_fatrec?: true;
    cod_recurso?: true;
    perccom_fatrec?: true;
    dtpgcom_fatrec?: true;
    cod_empresa?: true;
    nf_fatrec?: true;
    _all?: true;
  };

  export type FatrecAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fatrec to aggregate.
     */
    where?: fatrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatrecs to fetch.
     */
    orderBy?: fatrecOrderByWithRelationInput | fatrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: fatrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatrecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned fatrecs
     **/
    _count?: true | FatrecCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FatrecAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FatrecSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FatrecMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FatrecMaxAggregateInputType;
  };

  export type GetFatrecAggregateType<T extends FatrecAggregateArgs> = {
    [P in keyof T & keyof AggregateFatrec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFatrec[P]>
      : GetScalarType<T[P], AggregateFatrec[P]>;
  };

  export type fatrecGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: fatrecWhereInput;
    orderBy?:
      | fatrecOrderByWithAggregationInput
      | fatrecOrderByWithAggregationInput[];
    by: FatrecScalarFieldEnum[] | FatrecScalarFieldEnum;
    having?: fatrecScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FatrecCountAggregateInputType | true;
    _avg?: FatrecAvgAggregateInputType;
    _sum?: FatrecSumAggregateInputType;
    _min?: FatrecMinAggregateInputType;
    _max?: FatrecMaxAggregateInputType;
  };

  export type FatrecGroupByOutputType = {
    cod_fatrec: number;
    cod_cliente: number;
    desc_fatrec: string;
    qtdhora_fatrec: Decimal;
    vrhora_fatrec: Decimal;
    vrtot_fatrec: Decimal;
    dtvenc_fatrec: Date | null;
    dtnf_fatrec: Date | null;
    dtcob_fatrec: Date | null;
    dtpag_fatrec: Date | null;
    vrpag_fatrec: Decimal;
    imp_fatrec: Decimal;
    mesano_fatrec: string | null;
    obs_fatrec: Uint8Array | null;
    cod_recurso: number | null;
    perccom_fatrec: Decimal;
    dtpgcom_fatrec: Date | null;
    cod_empresa: number | null;
    nf_fatrec: string | null;
    _count: FatrecCountAggregateOutputType | null;
    _avg: FatrecAvgAggregateOutputType | null;
    _sum: FatrecSumAggregateOutputType | null;
    _min: FatrecMinAggregateOutputType | null;
    _max: FatrecMaxAggregateOutputType | null;
  };

  type GetFatrecGroupByPayload<T extends fatrecGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FatrecGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FatrecGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FatrecGroupByOutputType[P]>
            : GetScalarType<T[P], FatrecGroupByOutputType[P]>;
        }
      >
    >;

  export type fatrecSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatrec?: boolean;
      cod_cliente?: boolean;
      desc_fatrec?: boolean;
      qtdhora_fatrec?: boolean;
      vrhora_fatrec?: boolean;
      vrtot_fatrec?: boolean;
      dtvenc_fatrec?: boolean;
      dtnf_fatrec?: boolean;
      dtcob_fatrec?: boolean;
      dtpag_fatrec?: boolean;
      vrpag_fatrec?: boolean;
      imp_fatrec?: boolean;
      mesano_fatrec?: boolean;
      obs_fatrec?: boolean;
      cod_recurso?: boolean;
      perccom_fatrec?: boolean;
      dtpgcom_fatrec?: boolean;
      cod_empresa?: boolean;
      nf_fatrec?: boolean;
      cliente?: boolean | clienteDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['fatrec']
  >;

  export type fatrecSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatrec?: boolean;
      cod_cliente?: boolean;
      desc_fatrec?: boolean;
      qtdhora_fatrec?: boolean;
      vrhora_fatrec?: boolean;
      vrtot_fatrec?: boolean;
      dtvenc_fatrec?: boolean;
      dtnf_fatrec?: boolean;
      dtcob_fatrec?: boolean;
      dtpag_fatrec?: boolean;
      vrpag_fatrec?: boolean;
      imp_fatrec?: boolean;
      mesano_fatrec?: boolean;
      obs_fatrec?: boolean;
      cod_recurso?: boolean;
      perccom_fatrec?: boolean;
      dtpgcom_fatrec?: boolean;
      cod_empresa?: boolean;
      nf_fatrec?: boolean;
      cliente?: boolean | clienteDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['fatrec']
  >;

  export type fatrecSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatrec?: boolean;
      cod_cliente?: boolean;
      desc_fatrec?: boolean;
      qtdhora_fatrec?: boolean;
      vrhora_fatrec?: boolean;
      vrtot_fatrec?: boolean;
      dtvenc_fatrec?: boolean;
      dtnf_fatrec?: boolean;
      dtcob_fatrec?: boolean;
      dtpag_fatrec?: boolean;
      vrpag_fatrec?: boolean;
      imp_fatrec?: boolean;
      mesano_fatrec?: boolean;
      obs_fatrec?: boolean;
      cod_recurso?: boolean;
      perccom_fatrec?: boolean;
      dtpgcom_fatrec?: boolean;
      cod_empresa?: boolean;
      nf_fatrec?: boolean;
      cliente?: boolean | clienteDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['fatrec']
  >;

  export type fatrecSelectScalar = {
    cod_fatrec?: boolean;
    cod_cliente?: boolean;
    desc_fatrec?: boolean;
    qtdhora_fatrec?: boolean;
    vrhora_fatrec?: boolean;
    vrtot_fatrec?: boolean;
    dtvenc_fatrec?: boolean;
    dtnf_fatrec?: boolean;
    dtcob_fatrec?: boolean;
    dtpag_fatrec?: boolean;
    vrpag_fatrec?: boolean;
    imp_fatrec?: boolean;
    mesano_fatrec?: boolean;
    obs_fatrec?: boolean;
    cod_recurso?: boolean;
    perccom_fatrec?: boolean;
    dtpgcom_fatrec?: boolean;
    cod_empresa?: boolean;
    nf_fatrec?: boolean;
  };

  export type fatrecOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_fatrec'
    | 'cod_cliente'
    | 'desc_fatrec'
    | 'qtdhora_fatrec'
    | 'vrhora_fatrec'
    | 'vrtot_fatrec'
    | 'dtvenc_fatrec'
    | 'dtnf_fatrec'
    | 'dtcob_fatrec'
    | 'dtpag_fatrec'
    | 'vrpag_fatrec'
    | 'imp_fatrec'
    | 'mesano_fatrec'
    | 'obs_fatrec'
    | 'cod_recurso'
    | 'perccom_fatrec'
    | 'dtpgcom_fatrec'
    | 'cod_empresa'
    | 'nf_fatrec',
    ExtArgs['result']['fatrec']
  >;
  export type fatrecInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>;
  };
  export type fatrecIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>;
  };
  export type fatrecIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>;
  };

  export type $fatrecPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'fatrec';
    objects: {
      cliente: Prisma.$clientePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_fatrec: number;
        cod_cliente: number;
        desc_fatrec: string;
        qtdhora_fatrec: Prisma.Decimal;
        vrhora_fatrec: Prisma.Decimal;
        vrtot_fatrec: Prisma.Decimal;
        dtvenc_fatrec: Date | null;
        dtnf_fatrec: Date | null;
        dtcob_fatrec: Date | null;
        dtpag_fatrec: Date | null;
        vrpag_fatrec: Prisma.Decimal;
        imp_fatrec: Prisma.Decimal;
        mesano_fatrec: string | null;
        obs_fatrec: Uint8Array | null;
        cod_recurso: number | null;
        perccom_fatrec: Prisma.Decimal;
        dtpgcom_fatrec: Date | null;
        cod_empresa: number | null;
        nf_fatrec: string | null;
      },
      ExtArgs['result']['fatrec']
    >;
    composites: {};
  };

  type fatrecGetPayload<
    S extends boolean | null | undefined | fatrecDefaultArgs,
  > = $Result.GetResult<Prisma.$fatrecPayload, S>;

  type fatrecCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<fatrecFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FatrecCountAggregateInputType | true;
  };

  export interface fatrecDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['fatrec'];
      meta: { name: 'fatrec' };
    };
    /**
     * Find zero or one Fatrec that matches the filter.
     * @param {fatrecFindUniqueArgs} args - Arguments to find a Fatrec
     * @example
     * // Get one Fatrec
     * const fatrec = await prisma.fatrec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fatrecFindUniqueArgs>(
      args: SelectSubset<T, fatrecFindUniqueArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Fatrec that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fatrecFindUniqueOrThrowArgs} args - Arguments to find a Fatrec
     * @example
     * // Get one Fatrec
     * const fatrec = await prisma.fatrec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fatrecFindUniqueOrThrowArgs>(
      args: SelectSubset<T, fatrecFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatrec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatrecFindFirstArgs} args - Arguments to find a Fatrec
     * @example
     * // Get one Fatrec
     * const fatrec = await prisma.fatrec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fatrecFindFirstArgs>(
      args?: SelectSubset<T, fatrecFindFirstArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatrec that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatrecFindFirstOrThrowArgs} args - Arguments to find a Fatrec
     * @example
     * // Get one Fatrec
     * const fatrec = await prisma.fatrec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fatrecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fatrecFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Fatrecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatrecFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fatrecs
     * const fatrecs = await prisma.fatrec.findMany()
     *
     * // Get first 10 Fatrecs
     * const fatrecs = await prisma.fatrec.findMany({ take: 10 })
     *
     * // Only select the `cod_fatrec`
     * const fatrecWithCod_fatrecOnly = await prisma.fatrec.findMany({ select: { cod_fatrec: true } })
     *
     */
    findMany<T extends fatrecFindManyArgs>(
      args?: SelectSubset<T, fatrecFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Fatrec.
     * @param {fatrecCreateArgs} args - Arguments to create a Fatrec.
     * @example
     * // Create one Fatrec
     * const Fatrec = await prisma.fatrec.create({
     *   data: {
     *     // ... data to create a Fatrec
     *   }
     * })
     *
     */
    create<T extends fatrecCreateArgs>(
      args: SelectSubset<T, fatrecCreateArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Fatrecs.
     * @param {fatrecCreateManyArgs} args - Arguments to create many Fatrecs.
     * @example
     * // Create many Fatrecs
     * const fatrec = await prisma.fatrec.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends fatrecCreateManyArgs>(
      args?: SelectSubset<T, fatrecCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Fatrecs and returns the data saved in the database.
     * @param {fatrecCreateManyAndReturnArgs} args - Arguments to create many Fatrecs.
     * @example
     * // Create many Fatrecs
     * const fatrec = await prisma.fatrec.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Fatrecs and only return the `cod_fatrec`
     * const fatrecWithCod_fatrecOnly = await prisma.fatrec.createManyAndReturn({
     *   select: { cod_fatrec: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends fatrecCreateManyAndReturnArgs>(
      args?: SelectSubset<T, fatrecCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Fatrec.
     * @param {fatrecDeleteArgs} args - Arguments to delete one Fatrec.
     * @example
     * // Delete one Fatrec
     * const Fatrec = await prisma.fatrec.delete({
     *   where: {
     *     // ... filter to delete one Fatrec
     *   }
     * })
     *
     */
    delete<T extends fatrecDeleteArgs>(
      args: SelectSubset<T, fatrecDeleteArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Fatrec.
     * @param {fatrecUpdateArgs} args - Arguments to update one Fatrec.
     * @example
     * // Update one Fatrec
     * const fatrec = await prisma.fatrec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends fatrecUpdateArgs>(
      args: SelectSubset<T, fatrecUpdateArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Fatrecs.
     * @param {fatrecDeleteManyArgs} args - Arguments to filter Fatrecs to delete.
     * @example
     * // Delete a few Fatrecs
     * const { count } = await prisma.fatrec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends fatrecDeleteManyArgs>(
      args?: SelectSubset<T, fatrecDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fatrecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatrecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fatrecs
     * const fatrec = await prisma.fatrec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends fatrecUpdateManyArgs>(
      args: SelectSubset<T, fatrecUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Fatrecs and returns the data updated in the database.
     * @param {fatrecUpdateManyAndReturnArgs} args - Arguments to update many Fatrecs.
     * @example
     * // Update many Fatrecs
     * const fatrec = await prisma.fatrec.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Fatrecs and only return the `cod_fatrec`
     * const fatrecWithCod_fatrecOnly = await prisma.fatrec.updateManyAndReturn({
     *   select: { cod_fatrec: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends fatrecUpdateManyAndReturnArgs>(
      args: SelectSubset<T, fatrecUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Fatrec.
     * @param {fatrecUpsertArgs} args - Arguments to update or create a Fatrec.
     * @example
     * // Update or create a Fatrec
     * const fatrec = await prisma.fatrec.upsert({
     *   create: {
     *     // ... data to create a Fatrec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fatrec we want to update
     *   }
     * })
     */
    upsert<T extends fatrecUpsertArgs>(
      args: SelectSubset<T, fatrecUpsertArgs<ExtArgs>>,
    ): Prisma__fatrecClient<
      $Result.GetResult<
        Prisma.$fatrecPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Fatrecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatrecCountArgs} args - Arguments to filter Fatrecs to count.
     * @example
     * // Count the number of Fatrecs
     * const count = await prisma.fatrec.count({
     *   where: {
     *     // ... the filter for the Fatrecs we want to count
     *   }
     * })
     **/
    count<T extends fatrecCountArgs>(
      args?: Subset<T, fatrecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FatrecCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Fatrec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatrecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FatrecAggregateArgs>(
      args: Subset<T, FatrecAggregateArgs>,
    ): Prisma.PrismaPromise<GetFatrecAggregateType<T>>;

    /**
     * Group by Fatrec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fatrecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends fatrecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fatrecGroupByArgs['orderBy'] }
        : { orderBy?: fatrecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, fatrecGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFatrecGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the fatrec model
     */
    readonly fields: fatrecFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fatrec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fatrecClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    cliente<T extends clienteDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, clienteDefaultArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      | $Result.GetResult<
          Prisma.$clientePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the fatrec model
   */
  interface fatrecFieldRefs {
    readonly cod_fatrec: FieldRef<'fatrec', 'Int'>;
    readonly cod_cliente: FieldRef<'fatrec', 'Int'>;
    readonly desc_fatrec: FieldRef<'fatrec', 'String'>;
    readonly qtdhora_fatrec: FieldRef<'fatrec', 'Decimal'>;
    readonly vrhora_fatrec: FieldRef<'fatrec', 'Decimal'>;
    readonly vrtot_fatrec: FieldRef<'fatrec', 'Decimal'>;
    readonly dtvenc_fatrec: FieldRef<'fatrec', 'DateTime'>;
    readonly dtnf_fatrec: FieldRef<'fatrec', 'DateTime'>;
    readonly dtcob_fatrec: FieldRef<'fatrec', 'DateTime'>;
    readonly dtpag_fatrec: FieldRef<'fatrec', 'DateTime'>;
    readonly vrpag_fatrec: FieldRef<'fatrec', 'Decimal'>;
    readonly imp_fatrec: FieldRef<'fatrec', 'Decimal'>;
    readonly mesano_fatrec: FieldRef<'fatrec', 'String'>;
    readonly obs_fatrec: FieldRef<'fatrec', 'Bytes'>;
    readonly cod_recurso: FieldRef<'fatrec', 'Int'>;
    readonly perccom_fatrec: FieldRef<'fatrec', 'Decimal'>;
    readonly dtpgcom_fatrec: FieldRef<'fatrec', 'DateTime'>;
    readonly cod_empresa: FieldRef<'fatrec', 'Int'>;
    readonly nf_fatrec: FieldRef<'fatrec', 'String'>;
  }

  // Custom InputTypes
  /**
   * fatrec findUnique
   */
  export type fatrecFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * Filter, which fatrec to fetch.
     */
    where: fatrecWhereUniqueInput;
  };

  /**
   * fatrec findUniqueOrThrow
   */
  export type fatrecFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * Filter, which fatrec to fetch.
     */
    where: fatrecWhereUniqueInput;
  };

  /**
   * fatrec findFirst
   */
  export type fatrecFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * Filter, which fatrec to fetch.
     */
    where?: fatrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatrecs to fetch.
     */
    orderBy?: fatrecOrderByWithRelationInput | fatrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fatrecs.
     */
    cursor?: fatrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatrecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fatrecs.
     */
    distinct?: FatrecScalarFieldEnum | FatrecScalarFieldEnum[];
  };

  /**
   * fatrec findFirstOrThrow
   */
  export type fatrecFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * Filter, which fatrec to fetch.
     */
    where?: fatrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatrecs to fetch.
     */
    orderBy?: fatrecOrderByWithRelationInput | fatrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for fatrecs.
     */
    cursor?: fatrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatrecs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of fatrecs.
     */
    distinct?: FatrecScalarFieldEnum | FatrecScalarFieldEnum[];
  };

  /**
   * fatrec findMany
   */
  export type fatrecFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * Filter, which fatrecs to fetch.
     */
    where?: fatrecWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of fatrecs to fetch.
     */
    orderBy?: fatrecOrderByWithRelationInput | fatrecOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing fatrecs.
     */
    cursor?: fatrecWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` fatrecs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` fatrecs.
     */
    skip?: number;
    distinct?: FatrecScalarFieldEnum | FatrecScalarFieldEnum[];
  };

  /**
   * fatrec create
   */
  export type fatrecCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * The data needed to create a fatrec.
     */
    data: XOR<fatrecCreateInput, fatrecUncheckedCreateInput>;
  };

  /**
   * fatrec createMany
   */
  export type fatrecCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many fatrecs.
     */
    data: fatrecCreateManyInput | fatrecCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fatrec createManyAndReturn
   */
  export type fatrecCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * The data used to create many fatrecs.
     */
    data: fatrecCreateManyInput | fatrecCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * fatrec update
   */
  export type fatrecUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * The data needed to update a fatrec.
     */
    data: XOR<fatrecUpdateInput, fatrecUncheckedUpdateInput>;
    /**
     * Choose, which fatrec to update.
     */
    where: fatrecWhereUniqueInput;
  };

  /**
   * fatrec updateMany
   */
  export type fatrecUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update fatrecs.
     */
    data: XOR<fatrecUpdateManyMutationInput, fatrecUncheckedUpdateManyInput>;
    /**
     * Filter which fatrecs to update
     */
    where?: fatrecWhereInput;
    /**
     * Limit how many fatrecs to update.
     */
    limit?: number;
  };

  /**
   * fatrec updateManyAndReturn
   */
  export type fatrecUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * The data used to update fatrecs.
     */
    data: XOR<fatrecUpdateManyMutationInput, fatrecUncheckedUpdateManyInput>;
    /**
     * Filter which fatrecs to update
     */
    where?: fatrecWhereInput;
    /**
     * Limit how many fatrecs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * fatrec upsert
   */
  export type fatrecUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * The filter to search for the fatrec to update in case it exists.
     */
    where: fatrecWhereUniqueInput;
    /**
     * In case the fatrec found by the `where` argument doesn't exist, create a new fatrec with this data.
     */
    create: XOR<fatrecCreateInput, fatrecUncheckedCreateInput>;
    /**
     * In case the fatrec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fatrecUpdateInput, fatrecUncheckedUpdateInput>;
  };

  /**
   * fatrec delete
   */
  export type fatrecDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
    /**
     * Filter which fatrec to delete.
     */
    where: fatrecWhereUniqueInput;
  };

  /**
   * fatrec deleteMany
   */
  export type fatrecDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fatrecs to delete
     */
    where?: fatrecWhereInput;
    /**
     * Limit how many fatrecs to delete.
     */
    limit?: number;
  };

  /**
   * fatrec without action
   */
  export type fatrecDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatrec
     */
    select?: fatrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatrec
     */
    omit?: fatrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fatrecInclude<ExtArgs> | null;
  };

  /**
   * Model fatura
   */

  export type AggregateFatura = {
    _count: FaturaCountAggregateOutputType | null;
    _avg: FaturaAvgAggregateOutputType | null;
    _sum: FaturaSumAggregateOutputType | null;
    _min: FaturaMinAggregateOutputType | null;
    _max: FaturaMaxAggregateOutputType | null;
  };

  export type FaturaAvgAggregateOutputType = {
    cod_fatura: number | null;
    desp_fatura: Decimal | null;
    imp_fatura: Decimal | null;
    lucro_fatura: Decimal | null;
  };

  export type FaturaSumAggregateOutputType = {
    cod_fatura: number | null;
    desp_fatura: Decimal | null;
    imp_fatura: Decimal | null;
    lucro_fatura: Decimal | null;
  };

  export type FaturaMinAggregateOutputType = {
    cod_fatura: number | null;
    mesano_fatura: string | null;
    desp_fatura: Decimal | null;
    imp_fatura: Decimal | null;
    lucro_fatura: Decimal | null;
  };

  export type FaturaMaxAggregateOutputType = {
    cod_fatura: number | null;
    mesano_fatura: string | null;
    desp_fatura: Decimal | null;
    imp_fatura: Decimal | null;
    lucro_fatura: Decimal | null;
  };

  export type FaturaCountAggregateOutputType = {
    cod_fatura: number;
    mesano_fatura: number;
    desp_fatura: number;
    imp_fatura: number;
    lucro_fatura: number;
    _all: number;
  };

  export type FaturaAvgAggregateInputType = {
    cod_fatura?: true;
    desp_fatura?: true;
    imp_fatura?: true;
    lucro_fatura?: true;
  };

  export type FaturaSumAggregateInputType = {
    cod_fatura?: true;
    desp_fatura?: true;
    imp_fatura?: true;
    lucro_fatura?: true;
  };

  export type FaturaMinAggregateInputType = {
    cod_fatura?: true;
    mesano_fatura?: true;
    desp_fatura?: true;
    imp_fatura?: true;
    lucro_fatura?: true;
  };

  export type FaturaMaxAggregateInputType = {
    cod_fatura?: true;
    mesano_fatura?: true;
    desp_fatura?: true;
    imp_fatura?: true;
    lucro_fatura?: true;
  };

  export type FaturaCountAggregateInputType = {
    cod_fatura?: true;
    mesano_fatura?: true;
    desp_fatura?: true;
    imp_fatura?: true;
    lucro_fatura?: true;
    _all?: true;
  };

  export type FaturaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which fatura to aggregate.
     */
    where?: faturaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturas to fetch.
     */
    orderBy?: faturaOrderByWithRelationInput | faturaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: faturaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned faturas
     **/
    _count?: true | FaturaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FaturaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FaturaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FaturaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FaturaMaxAggregateInputType;
  };

  export type GetFaturaAggregateType<T extends FaturaAggregateArgs> = {
    [P in keyof T & keyof AggregateFatura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFatura[P]>
      : GetScalarType<T[P], AggregateFatura[P]>;
  };

  export type faturaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: faturaWhereInput;
    orderBy?:
      | faturaOrderByWithAggregationInput
      | faturaOrderByWithAggregationInput[];
    by: FaturaScalarFieldEnum[] | FaturaScalarFieldEnum;
    having?: faturaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FaturaCountAggregateInputType | true;
    _avg?: FaturaAvgAggregateInputType;
    _sum?: FaturaSumAggregateInputType;
    _min?: FaturaMinAggregateInputType;
    _max?: FaturaMaxAggregateInputType;
  };

  export type FaturaGroupByOutputType = {
    cod_fatura: number;
    mesano_fatura: string;
    desp_fatura: Decimal | null;
    imp_fatura: Decimal | null;
    lucro_fatura: Decimal | null;
    _count: FaturaCountAggregateOutputType | null;
    _avg: FaturaAvgAggregateOutputType | null;
    _sum: FaturaSumAggregateOutputType | null;
    _min: FaturaMinAggregateOutputType | null;
    _max: FaturaMaxAggregateOutputType | null;
  };

  type GetFaturaGroupByPayload<T extends faturaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FaturaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FaturaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaturaGroupByOutputType[P]>
            : GetScalarType<T[P], FaturaGroupByOutputType[P]>;
        }
      >
    >;

  export type faturaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatura?: boolean;
      mesano_fatura?: boolean;
      desp_fatura?: boolean;
      imp_fatura?: boolean;
      lucro_fatura?: boolean;
    },
    ExtArgs['result']['fatura']
  >;

  export type faturaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatura?: boolean;
      mesano_fatura?: boolean;
      desp_fatura?: boolean;
      imp_fatura?: boolean;
      lucro_fatura?: boolean;
    },
    ExtArgs['result']['fatura']
  >;

  export type faturaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_fatura?: boolean;
      mesano_fatura?: boolean;
      desp_fatura?: boolean;
      imp_fatura?: boolean;
      lucro_fatura?: boolean;
    },
    ExtArgs['result']['fatura']
  >;

  export type faturaSelectScalar = {
    cod_fatura?: boolean;
    mesano_fatura?: boolean;
    desp_fatura?: boolean;
    imp_fatura?: boolean;
    lucro_fatura?: boolean;
  };

  export type faturaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_fatura'
    | 'mesano_fatura'
    | 'desp_fatura'
    | 'imp_fatura'
    | 'lucro_fatura',
    ExtArgs['result']['fatura']
  >;

  export type $faturaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'fatura';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_fatura: number;
        mesano_fatura: string;
        desp_fatura: Prisma.Decimal | null;
        imp_fatura: Prisma.Decimal | null;
        lucro_fatura: Prisma.Decimal | null;
      },
      ExtArgs['result']['fatura']
    >;
    composites: {};
  };

  type faturaGetPayload<
    S extends boolean | null | undefined | faturaDefaultArgs,
  > = $Result.GetResult<Prisma.$faturaPayload, S>;

  type faturaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<faturaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FaturaCountAggregateInputType | true;
  };

  export interface faturaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['fatura'];
      meta: { name: 'fatura' };
    };
    /**
     * Find zero or one Fatura that matches the filter.
     * @param {faturaFindUniqueArgs} args - Arguments to find a Fatura
     * @example
     * // Get one Fatura
     * const fatura = await prisma.fatura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faturaFindUniqueArgs>(
      args: SelectSubset<T, faturaFindUniqueArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Fatura that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faturaFindUniqueOrThrowArgs} args - Arguments to find a Fatura
     * @example
     * // Get one Fatura
     * const fatura = await prisma.fatura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faturaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, faturaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturaFindFirstArgs} args - Arguments to find a Fatura
     * @example
     * // Get one Fatura
     * const fatura = await prisma.fatura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faturaFindFirstArgs>(
      args?: SelectSubset<T, faturaFindFirstArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Fatura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturaFindFirstOrThrowArgs} args - Arguments to find a Fatura
     * @example
     * // Get one Fatura
     * const fatura = await prisma.fatura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faturaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, faturaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Faturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faturas
     * const faturas = await prisma.fatura.findMany()
     *
     * // Get first 10 Faturas
     * const faturas = await prisma.fatura.findMany({ take: 10 })
     *
     * // Only select the `cod_fatura`
     * const faturaWithCod_faturaOnly = await prisma.fatura.findMany({ select: { cod_fatura: true } })
     *
     */
    findMany<T extends faturaFindManyArgs>(
      args?: SelectSubset<T, faturaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Fatura.
     * @param {faturaCreateArgs} args - Arguments to create a Fatura.
     * @example
     * // Create one Fatura
     * const Fatura = await prisma.fatura.create({
     *   data: {
     *     // ... data to create a Fatura
     *   }
     * })
     *
     */
    create<T extends faturaCreateArgs>(
      args: SelectSubset<T, faturaCreateArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Faturas.
     * @param {faturaCreateManyArgs} args - Arguments to create many Faturas.
     * @example
     * // Create many Faturas
     * const fatura = await prisma.fatura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends faturaCreateManyArgs>(
      args?: SelectSubset<T, faturaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Faturas and returns the data saved in the database.
     * @param {faturaCreateManyAndReturnArgs} args - Arguments to create many Faturas.
     * @example
     * // Create many Faturas
     * const fatura = await prisma.fatura.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Faturas and only return the `cod_fatura`
     * const faturaWithCod_faturaOnly = await prisma.fatura.createManyAndReturn({
     *   select: { cod_fatura: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends faturaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, faturaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Fatura.
     * @param {faturaDeleteArgs} args - Arguments to delete one Fatura.
     * @example
     * // Delete one Fatura
     * const Fatura = await prisma.fatura.delete({
     *   where: {
     *     // ... filter to delete one Fatura
     *   }
     * })
     *
     */
    delete<T extends faturaDeleteArgs>(
      args: SelectSubset<T, faturaDeleteArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Fatura.
     * @param {faturaUpdateArgs} args - Arguments to update one Fatura.
     * @example
     * // Update one Fatura
     * const fatura = await prisma.fatura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends faturaUpdateArgs>(
      args: SelectSubset<T, faturaUpdateArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Faturas.
     * @param {faturaDeleteManyArgs} args - Arguments to filter Faturas to delete.
     * @example
     * // Delete a few Faturas
     * const { count } = await prisma.fatura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends faturaDeleteManyArgs>(
      args?: SelectSubset<T, faturaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Faturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faturas
     * const fatura = await prisma.fatura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends faturaUpdateManyArgs>(
      args: SelectSubset<T, faturaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Faturas and returns the data updated in the database.
     * @param {faturaUpdateManyAndReturnArgs} args - Arguments to update many Faturas.
     * @example
     * // Update many Faturas
     * const fatura = await prisma.fatura.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Faturas and only return the `cod_fatura`
     * const faturaWithCod_faturaOnly = await prisma.fatura.updateManyAndReturn({
     *   select: { cod_fatura: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends faturaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, faturaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Fatura.
     * @param {faturaUpsertArgs} args - Arguments to update or create a Fatura.
     * @example
     * // Update or create a Fatura
     * const fatura = await prisma.fatura.upsert({
     *   create: {
     *     // ... data to create a Fatura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fatura we want to update
     *   }
     * })
     */
    upsert<T extends faturaUpsertArgs>(
      args: SelectSubset<T, faturaUpsertArgs<ExtArgs>>,
    ): Prisma__faturaClient<
      $Result.GetResult<
        Prisma.$faturaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Faturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturaCountArgs} args - Arguments to filter Faturas to count.
     * @example
     * // Count the number of Faturas
     * const count = await prisma.fatura.count({
     *   where: {
     *     // ... the filter for the Faturas we want to count
     *   }
     * })
     **/
    count<T extends faturaCountArgs>(
      args?: Subset<T, faturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaturaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Fatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FaturaAggregateArgs>(
      args: Subset<T, FaturaAggregateArgs>,
    ): Prisma.PrismaPromise<GetFaturaAggregateType<T>>;

    /**
     * Group by Fatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends faturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faturaGroupByArgs['orderBy'] }
        : { orderBy?: faturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, faturaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetFaturaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the fatura model
     */
    readonly fields: faturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fatura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faturaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the fatura model
   */
  interface faturaFieldRefs {
    readonly cod_fatura: FieldRef<'fatura', 'Int'>;
    readonly mesano_fatura: FieldRef<'fatura', 'String'>;
    readonly desp_fatura: FieldRef<'fatura', 'Decimal'>;
    readonly imp_fatura: FieldRef<'fatura', 'Decimal'>;
    readonly lucro_fatura: FieldRef<'fatura', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * fatura findUnique
   */
  export type faturaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * Filter, which fatura to fetch.
     */
    where: faturaWhereUniqueInput;
  };

  /**
   * fatura findUniqueOrThrow
   */
  export type faturaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * Filter, which fatura to fetch.
     */
    where: faturaWhereUniqueInput;
  };

  /**
   * fatura findFirst
   */
  export type faturaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * Filter, which fatura to fetch.
     */
    where?: faturaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturas to fetch.
     */
    orderBy?: faturaOrderByWithRelationInput | faturaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for faturas.
     */
    cursor?: faturaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of faturas.
     */
    distinct?: FaturaScalarFieldEnum | FaturaScalarFieldEnum[];
  };

  /**
   * fatura findFirstOrThrow
   */
  export type faturaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * Filter, which fatura to fetch.
     */
    where?: faturaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturas to fetch.
     */
    orderBy?: faturaOrderByWithRelationInput | faturaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for faturas.
     */
    cursor?: faturaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of faturas.
     */
    distinct?: FaturaScalarFieldEnum | FaturaScalarFieldEnum[];
  };

  /**
   * fatura findMany
   */
  export type faturaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * Filter, which faturas to fetch.
     */
    where?: faturaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturas to fetch.
     */
    orderBy?: faturaOrderByWithRelationInput | faturaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing faturas.
     */
    cursor?: faturaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturas.
     */
    skip?: number;
    distinct?: FaturaScalarFieldEnum | FaturaScalarFieldEnum[];
  };

  /**
   * fatura create
   */
  export type faturaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * The data needed to create a fatura.
     */
    data: XOR<faturaCreateInput, faturaUncheckedCreateInput>;
  };

  /**
   * fatura createMany
   */
  export type faturaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many faturas.
     */
    data: faturaCreateManyInput | faturaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fatura createManyAndReturn
   */
  export type faturaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * The data used to create many faturas.
     */
    data: faturaCreateManyInput | faturaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * fatura update
   */
  export type faturaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * The data needed to update a fatura.
     */
    data: XOR<faturaUpdateInput, faturaUncheckedUpdateInput>;
    /**
     * Choose, which fatura to update.
     */
    where: faturaWhereUniqueInput;
  };

  /**
   * fatura updateMany
   */
  export type faturaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update faturas.
     */
    data: XOR<faturaUpdateManyMutationInput, faturaUncheckedUpdateManyInput>;
    /**
     * Filter which faturas to update
     */
    where?: faturaWhereInput;
    /**
     * Limit how many faturas to update.
     */
    limit?: number;
  };

  /**
   * fatura updateManyAndReturn
   */
  export type faturaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * The data used to update faturas.
     */
    data: XOR<faturaUpdateManyMutationInput, faturaUncheckedUpdateManyInput>;
    /**
     * Filter which faturas to update
     */
    where?: faturaWhereInput;
    /**
     * Limit how many faturas to update.
     */
    limit?: number;
  };

  /**
   * fatura upsert
   */
  export type faturaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * The filter to search for the fatura to update in case it exists.
     */
    where: faturaWhereUniqueInput;
    /**
     * In case the fatura found by the `where` argument doesn't exist, create a new fatura with this data.
     */
    create: XOR<faturaCreateInput, faturaUncheckedCreateInput>;
    /**
     * In case the fatura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faturaUpdateInput, faturaUncheckedUpdateInput>;
  };

  /**
   * fatura delete
   */
  export type faturaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
    /**
     * Filter which fatura to delete.
     */
    where: faturaWhereUniqueInput;
  };

  /**
   * fatura deleteMany
   */
  export type faturaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which faturas to delete
     */
    where?: faturaWhereInput;
    /**
     * Limit how many faturas to delete.
     */
    limit?: number;
  };

  /**
   * fatura without action
   */
  export type faturaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the fatura
     */
    select?: faturaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the fatura
     */
    omit?: faturaOmit<ExtArgs> | null;
  };

  /**
   * Model faturamento
   */

  export type AggregateFaturamento = {
    _count: FaturamentoCountAggregateOutputType | null;
    _avg: FaturamentoAvgAggregateOutputType | null;
    _sum: FaturamentoSumAggregateOutputType | null;
    _min: FaturamentoMinAggregateOutputType | null;
    _max: FaturamentoMaxAggregateOutputType | null;
  };

  export type FaturamentoAvgAggregateOutputType = {
    cod_faturamento: number | null;
  };

  export type FaturamentoSumAggregateOutputType = {
    cod_faturamento: number | null;
  };

  export type FaturamentoMinAggregateOutputType = {
    cod_faturamento: number | null;
    data_faturamento: Date | null;
    hora_faturamento: string | null;
    usu_faturamento: string | null;
    ini_faturamento: Date | null;
    fim_faturamento: Date | null;
    status_faturamento: string | null;
    mesano_faturamento: string | null;
  };

  export type FaturamentoMaxAggregateOutputType = {
    cod_faturamento: number | null;
    data_faturamento: Date | null;
    hora_faturamento: string | null;
    usu_faturamento: string | null;
    ini_faturamento: Date | null;
    fim_faturamento: Date | null;
    status_faturamento: string | null;
    mesano_faturamento: string | null;
  };

  export type FaturamentoCountAggregateOutputType = {
    cod_faturamento: number;
    data_faturamento: number;
    hora_faturamento: number;
    usu_faturamento: number;
    ini_faturamento: number;
    fim_faturamento: number;
    status_faturamento: number;
    mesano_faturamento: number;
    _all: number;
  };

  export type FaturamentoAvgAggregateInputType = {
    cod_faturamento?: true;
  };

  export type FaturamentoSumAggregateInputType = {
    cod_faturamento?: true;
  };

  export type FaturamentoMinAggregateInputType = {
    cod_faturamento?: true;
    data_faturamento?: true;
    hora_faturamento?: true;
    usu_faturamento?: true;
    ini_faturamento?: true;
    fim_faturamento?: true;
    status_faturamento?: true;
    mesano_faturamento?: true;
  };

  export type FaturamentoMaxAggregateInputType = {
    cod_faturamento?: true;
    data_faturamento?: true;
    hora_faturamento?: true;
    usu_faturamento?: true;
    ini_faturamento?: true;
    fim_faturamento?: true;
    status_faturamento?: true;
    mesano_faturamento?: true;
  };

  export type FaturamentoCountAggregateInputType = {
    cod_faturamento?: true;
    data_faturamento?: true;
    hora_faturamento?: true;
    usu_faturamento?: true;
    ini_faturamento?: true;
    fim_faturamento?: true;
    status_faturamento?: true;
    mesano_faturamento?: true;
    _all?: true;
  };

  export type FaturamentoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which faturamento to aggregate.
     */
    where?: faturamentoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturamentos to fetch.
     */
    orderBy?:
      | faturamentoOrderByWithRelationInput
      | faturamentoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: faturamentoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturamentos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturamentos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned faturamentos
     **/
    _count?: true | FaturamentoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FaturamentoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FaturamentoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FaturamentoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FaturamentoMaxAggregateInputType;
  };

  export type GetFaturamentoAggregateType<T extends FaturamentoAggregateArgs> =
    {
      [P in keyof T & keyof AggregateFaturamento]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateFaturamento[P]>
        : GetScalarType<T[P], AggregateFaturamento[P]>;
    };

  export type faturamentoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: faturamentoWhereInput;
    orderBy?:
      | faturamentoOrderByWithAggregationInput
      | faturamentoOrderByWithAggregationInput[];
    by: FaturamentoScalarFieldEnum[] | FaturamentoScalarFieldEnum;
    having?: faturamentoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FaturamentoCountAggregateInputType | true;
    _avg?: FaturamentoAvgAggregateInputType;
    _sum?: FaturamentoSumAggregateInputType;
    _min?: FaturamentoMinAggregateInputType;
    _max?: FaturamentoMaxAggregateInputType;
  };

  export type FaturamentoGroupByOutputType = {
    cod_faturamento: number;
    data_faturamento: Date;
    hora_faturamento: string;
    usu_faturamento: string | null;
    ini_faturamento: Date;
    fim_faturamento: Date;
    status_faturamento: string;
    mesano_faturamento: string | null;
    _count: FaturamentoCountAggregateOutputType | null;
    _avg: FaturamentoAvgAggregateOutputType | null;
    _sum: FaturamentoSumAggregateOutputType | null;
    _min: FaturamentoMinAggregateOutputType | null;
    _max: FaturamentoMaxAggregateOutputType | null;
  };

  type GetFaturamentoGroupByPayload<T extends faturamentoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FaturamentoGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FaturamentoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaturamentoGroupByOutputType[P]>
            : GetScalarType<T[P], FaturamentoGroupByOutputType[P]>;
        }
      >
    >;

  export type faturamentoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_faturamento?: boolean;
      data_faturamento?: boolean;
      hora_faturamento?: boolean;
      usu_faturamento?: boolean;
      ini_faturamento?: boolean;
      fim_faturamento?: boolean;
      status_faturamento?: boolean;
      mesano_faturamento?: boolean;
    },
    ExtArgs['result']['faturamento']
  >;

  export type faturamentoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_faturamento?: boolean;
      data_faturamento?: boolean;
      hora_faturamento?: boolean;
      usu_faturamento?: boolean;
      ini_faturamento?: boolean;
      fim_faturamento?: boolean;
      status_faturamento?: boolean;
      mesano_faturamento?: boolean;
    },
    ExtArgs['result']['faturamento']
  >;

  export type faturamentoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_faturamento?: boolean;
      data_faturamento?: boolean;
      hora_faturamento?: boolean;
      usu_faturamento?: boolean;
      ini_faturamento?: boolean;
      fim_faturamento?: boolean;
      status_faturamento?: boolean;
      mesano_faturamento?: boolean;
    },
    ExtArgs['result']['faturamento']
  >;

  export type faturamentoSelectScalar = {
    cod_faturamento?: boolean;
    data_faturamento?: boolean;
    hora_faturamento?: boolean;
    usu_faturamento?: boolean;
    ini_faturamento?: boolean;
    fim_faturamento?: boolean;
    status_faturamento?: boolean;
    mesano_faturamento?: boolean;
  };

  export type faturamentoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_faturamento'
    | 'data_faturamento'
    | 'hora_faturamento'
    | 'usu_faturamento'
    | 'ini_faturamento'
    | 'fim_faturamento'
    | 'status_faturamento'
    | 'mesano_faturamento',
    ExtArgs['result']['faturamento']
  >;

  export type $faturamentoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'faturamento';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_faturamento: number;
        data_faturamento: Date;
        hora_faturamento: string;
        usu_faturamento: string | null;
        ini_faturamento: Date;
        fim_faturamento: Date;
        status_faturamento: string;
        mesano_faturamento: string | null;
      },
      ExtArgs['result']['faturamento']
    >;
    composites: {};
  };

  type faturamentoGetPayload<
    S extends boolean | null | undefined | faturamentoDefaultArgs,
  > = $Result.GetResult<Prisma.$faturamentoPayload, S>;

  type faturamentoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    faturamentoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FaturamentoCountAggregateInputType | true;
  };

  export interface faturamentoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['faturamento'];
      meta: { name: 'faturamento' };
    };
    /**
     * Find zero or one Faturamento that matches the filter.
     * @param {faturamentoFindUniqueArgs} args - Arguments to find a Faturamento
     * @example
     * // Get one Faturamento
     * const faturamento = await prisma.faturamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faturamentoFindUniqueArgs>(
      args: SelectSubset<T, faturamentoFindUniqueArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Faturamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faturamentoFindUniqueOrThrowArgs} args - Arguments to find a Faturamento
     * @example
     * // Get one Faturamento
     * const faturamento = await prisma.faturamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faturamentoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, faturamentoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Faturamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturamentoFindFirstArgs} args - Arguments to find a Faturamento
     * @example
     * // Get one Faturamento
     * const faturamento = await prisma.faturamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faturamentoFindFirstArgs>(
      args?: SelectSubset<T, faturamentoFindFirstArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Faturamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturamentoFindFirstOrThrowArgs} args - Arguments to find a Faturamento
     * @example
     * // Get one Faturamento
     * const faturamento = await prisma.faturamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faturamentoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, faturamentoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Faturamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faturamentos
     * const faturamentos = await prisma.faturamento.findMany()
     *
     * // Get first 10 Faturamentos
     * const faturamentos = await prisma.faturamento.findMany({ take: 10 })
     *
     * // Only select the `cod_faturamento`
     * const faturamentoWithCod_faturamentoOnly = await prisma.faturamento.findMany({ select: { cod_faturamento: true } })
     *
     */
    findMany<T extends faturamentoFindManyArgs>(
      args?: SelectSubset<T, faturamentoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Faturamento.
     * @param {faturamentoCreateArgs} args - Arguments to create a Faturamento.
     * @example
     * // Create one Faturamento
     * const Faturamento = await prisma.faturamento.create({
     *   data: {
     *     // ... data to create a Faturamento
     *   }
     * })
     *
     */
    create<T extends faturamentoCreateArgs>(
      args: SelectSubset<T, faturamentoCreateArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Faturamentos.
     * @param {faturamentoCreateManyArgs} args - Arguments to create many Faturamentos.
     * @example
     * // Create many Faturamentos
     * const faturamento = await prisma.faturamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends faturamentoCreateManyArgs>(
      args?: SelectSubset<T, faturamentoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Faturamentos and returns the data saved in the database.
     * @param {faturamentoCreateManyAndReturnArgs} args - Arguments to create many Faturamentos.
     * @example
     * // Create many Faturamentos
     * const faturamento = await prisma.faturamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Faturamentos and only return the `cod_faturamento`
     * const faturamentoWithCod_faturamentoOnly = await prisma.faturamento.createManyAndReturn({
     *   select: { cod_faturamento: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends faturamentoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, faturamentoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Faturamento.
     * @param {faturamentoDeleteArgs} args - Arguments to delete one Faturamento.
     * @example
     * // Delete one Faturamento
     * const Faturamento = await prisma.faturamento.delete({
     *   where: {
     *     // ... filter to delete one Faturamento
     *   }
     * })
     *
     */
    delete<T extends faturamentoDeleteArgs>(
      args: SelectSubset<T, faturamentoDeleteArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Faturamento.
     * @param {faturamentoUpdateArgs} args - Arguments to update one Faturamento.
     * @example
     * // Update one Faturamento
     * const faturamento = await prisma.faturamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends faturamentoUpdateArgs>(
      args: SelectSubset<T, faturamentoUpdateArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Faturamentos.
     * @param {faturamentoDeleteManyArgs} args - Arguments to filter Faturamentos to delete.
     * @example
     * // Delete a few Faturamentos
     * const { count } = await prisma.faturamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends faturamentoDeleteManyArgs>(
      args?: SelectSubset<T, faturamentoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Faturamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faturamentos
     * const faturamento = await prisma.faturamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends faturamentoUpdateManyArgs>(
      args: SelectSubset<T, faturamentoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Faturamentos and returns the data updated in the database.
     * @param {faturamentoUpdateManyAndReturnArgs} args - Arguments to update many Faturamentos.
     * @example
     * // Update many Faturamentos
     * const faturamento = await prisma.faturamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Faturamentos and only return the `cod_faturamento`
     * const faturamentoWithCod_faturamentoOnly = await prisma.faturamento.updateManyAndReturn({
     *   select: { cod_faturamento: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends faturamentoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, faturamentoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Faturamento.
     * @param {faturamentoUpsertArgs} args - Arguments to update or create a Faturamento.
     * @example
     * // Update or create a Faturamento
     * const faturamento = await prisma.faturamento.upsert({
     *   create: {
     *     // ... data to create a Faturamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faturamento we want to update
     *   }
     * })
     */
    upsert<T extends faturamentoUpsertArgs>(
      args: SelectSubset<T, faturamentoUpsertArgs<ExtArgs>>,
    ): Prisma__faturamentoClient<
      $Result.GetResult<
        Prisma.$faturamentoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Faturamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturamentoCountArgs} args - Arguments to filter Faturamentos to count.
     * @example
     * // Count the number of Faturamentos
     * const count = await prisma.faturamento.count({
     *   where: {
     *     // ... the filter for the Faturamentos we want to count
     *   }
     * })
     **/
    count<T extends faturamentoCountArgs>(
      args?: Subset<T, faturamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaturamentoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Faturamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaturamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FaturamentoAggregateArgs>(
      args: Subset<T, FaturamentoAggregateArgs>,
    ): Prisma.PrismaPromise<GetFaturamentoAggregateType<T>>;

    /**
     * Group by Faturamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faturamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends faturamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faturamentoGroupByArgs['orderBy'] }
        : { orderBy?: faturamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, faturamentoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetFaturamentoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the faturamento model
     */
    readonly fields: faturamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faturamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faturamentoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the faturamento model
   */
  interface faturamentoFieldRefs {
    readonly cod_faturamento: FieldRef<'faturamento', 'Int'>;
    readonly data_faturamento: FieldRef<'faturamento', 'DateTime'>;
    readonly hora_faturamento: FieldRef<'faturamento', 'String'>;
    readonly usu_faturamento: FieldRef<'faturamento', 'String'>;
    readonly ini_faturamento: FieldRef<'faturamento', 'DateTime'>;
    readonly fim_faturamento: FieldRef<'faturamento', 'DateTime'>;
    readonly status_faturamento: FieldRef<'faturamento', 'String'>;
    readonly mesano_faturamento: FieldRef<'faturamento', 'String'>;
  }

  // Custom InputTypes
  /**
   * faturamento findUnique
   */
  export type faturamentoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * Filter, which faturamento to fetch.
     */
    where: faturamentoWhereUniqueInput;
  };

  /**
   * faturamento findUniqueOrThrow
   */
  export type faturamentoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * Filter, which faturamento to fetch.
     */
    where: faturamentoWhereUniqueInput;
  };

  /**
   * faturamento findFirst
   */
  export type faturamentoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * Filter, which faturamento to fetch.
     */
    where?: faturamentoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturamentos to fetch.
     */
    orderBy?:
      | faturamentoOrderByWithRelationInput
      | faturamentoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for faturamentos.
     */
    cursor?: faturamentoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturamentos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturamentos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of faturamentos.
     */
    distinct?: FaturamentoScalarFieldEnum | FaturamentoScalarFieldEnum[];
  };

  /**
   * faturamento findFirstOrThrow
   */
  export type faturamentoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * Filter, which faturamento to fetch.
     */
    where?: faturamentoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturamentos to fetch.
     */
    orderBy?:
      | faturamentoOrderByWithRelationInput
      | faturamentoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for faturamentos.
     */
    cursor?: faturamentoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturamentos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturamentos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of faturamentos.
     */
    distinct?: FaturamentoScalarFieldEnum | FaturamentoScalarFieldEnum[];
  };

  /**
   * faturamento findMany
   */
  export type faturamentoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * Filter, which faturamentos to fetch.
     */
    where?: faturamentoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of faturamentos to fetch.
     */
    orderBy?:
      | faturamentoOrderByWithRelationInput
      | faturamentoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing faturamentos.
     */
    cursor?: faturamentoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` faturamentos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` faturamentos.
     */
    skip?: number;
    distinct?: FaturamentoScalarFieldEnum | FaturamentoScalarFieldEnum[];
  };

  /**
   * faturamento create
   */
  export type faturamentoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * The data needed to create a faturamento.
     */
    data: XOR<faturamentoCreateInput, faturamentoUncheckedCreateInput>;
  };

  /**
   * faturamento createMany
   */
  export type faturamentoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many faturamentos.
     */
    data: faturamentoCreateManyInput | faturamentoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * faturamento createManyAndReturn
   */
  export type faturamentoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * The data used to create many faturamentos.
     */
    data: faturamentoCreateManyInput | faturamentoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * faturamento update
   */
  export type faturamentoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * The data needed to update a faturamento.
     */
    data: XOR<faturamentoUpdateInput, faturamentoUncheckedUpdateInput>;
    /**
     * Choose, which faturamento to update.
     */
    where: faturamentoWhereUniqueInput;
  };

  /**
   * faturamento updateMany
   */
  export type faturamentoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update faturamentos.
     */
    data: XOR<
      faturamentoUpdateManyMutationInput,
      faturamentoUncheckedUpdateManyInput
    >;
    /**
     * Filter which faturamentos to update
     */
    where?: faturamentoWhereInput;
    /**
     * Limit how many faturamentos to update.
     */
    limit?: number;
  };

  /**
   * faturamento updateManyAndReturn
   */
  export type faturamentoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * The data used to update faturamentos.
     */
    data: XOR<
      faturamentoUpdateManyMutationInput,
      faturamentoUncheckedUpdateManyInput
    >;
    /**
     * Filter which faturamentos to update
     */
    where?: faturamentoWhereInput;
    /**
     * Limit how many faturamentos to update.
     */
    limit?: number;
  };

  /**
   * faturamento upsert
   */
  export type faturamentoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * The filter to search for the faturamento to update in case it exists.
     */
    where: faturamentoWhereUniqueInput;
    /**
     * In case the faturamento found by the `where` argument doesn't exist, create a new faturamento with this data.
     */
    create: XOR<faturamentoCreateInput, faturamentoUncheckedCreateInput>;
    /**
     * In case the faturamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faturamentoUpdateInput, faturamentoUncheckedUpdateInput>;
  };

  /**
   * faturamento delete
   */
  export type faturamentoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
    /**
     * Filter which faturamento to delete.
     */
    where: faturamentoWhereUniqueInput;
  };

  /**
   * faturamento deleteMany
   */
  export type faturamentoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which faturamentos to delete
     */
    where?: faturamentoWhereInput;
    /**
     * Limit how many faturamentos to delete.
     */
    limit?: number;
  };

  /**
   * faturamento without action
   */
  export type faturamentoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the faturamento
     */
    select?: faturamentoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the faturamento
     */
    omit?: faturamentoOmit<ExtArgs> | null;
  };

  /**
   * Model grupo
   */

  export type AggregateGrupo = {
    _count: GrupoCountAggregateOutputType | null;
    _avg: GrupoAvgAggregateOutputType | null;
    _sum: GrupoSumAggregateOutputType | null;
    _min: GrupoMinAggregateOutputType | null;
    _max: GrupoMaxAggregateOutputType | null;
  };

  export type GrupoAvgAggregateOutputType = {
    cod_grupo: number | null;
  };

  export type GrupoSumAggregateOutputType = {
    cod_grupo: number | null;
  };

  export type GrupoMinAggregateOutputType = {
    cod_grupo: number | null;
    desc_grupo: string | null;
  };

  export type GrupoMaxAggregateOutputType = {
    cod_grupo: number | null;
    desc_grupo: string | null;
  };

  export type GrupoCountAggregateOutputType = {
    cod_grupo: number;
    desc_grupo: number;
    _all: number;
  };

  export type GrupoAvgAggregateInputType = {
    cod_grupo?: true;
  };

  export type GrupoSumAggregateInputType = {
    cod_grupo?: true;
  };

  export type GrupoMinAggregateInputType = {
    cod_grupo?: true;
    desc_grupo?: true;
  };

  export type GrupoMaxAggregateInputType = {
    cod_grupo?: true;
    desc_grupo?: true;
  };

  export type GrupoCountAggregateInputType = {
    cod_grupo?: true;
    desc_grupo?: true;
    _all?: true;
  };

  export type GrupoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which grupo to aggregate.
     */
    where?: grupoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: grupoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` grupos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned grupos
     **/
    _count?: true | GrupoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: GrupoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: GrupoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GrupoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GrupoMaxAggregateInputType;
  };

  export type GetGrupoAggregateType<T extends GrupoAggregateArgs> = {
    [P in keyof T & keyof AggregateGrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrupo[P]>
      : GetScalarType<T[P], AggregateGrupo[P]>;
  };

  export type grupoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: grupoWhereInput;
    orderBy?:
      | grupoOrderByWithAggregationInput
      | grupoOrderByWithAggregationInput[];
    by: GrupoScalarFieldEnum[] | GrupoScalarFieldEnum;
    having?: grupoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GrupoCountAggregateInputType | true;
    _avg?: GrupoAvgAggregateInputType;
    _sum?: GrupoSumAggregateInputType;
    _min?: GrupoMinAggregateInputType;
    _max?: GrupoMaxAggregateInputType;
  };

  export type GrupoGroupByOutputType = {
    cod_grupo: number;
    desc_grupo: string;
    _count: GrupoCountAggregateOutputType | null;
    _avg: GrupoAvgAggregateOutputType | null;
    _sum: GrupoSumAggregateOutputType | null;
    _min: GrupoMinAggregateOutputType | null;
    _max: GrupoMaxAggregateOutputType | null;
  };

  type GetGrupoGroupByPayload<T extends grupoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<GrupoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof GrupoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrupoGroupByOutputType[P]>
            : GetScalarType<T[P], GrupoGroupByOutputType[P]>;
        }
      >
    >;

  export type grupoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_grupo?: boolean;
      desc_grupo?: boolean;
    },
    ExtArgs['result']['grupo']
  >;

  export type grupoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_grupo?: boolean;
      desc_grupo?: boolean;
    },
    ExtArgs['result']['grupo']
  >;

  export type grupoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_grupo?: boolean;
      desc_grupo?: boolean;
    },
    ExtArgs['result']['grupo']
  >;

  export type grupoSelectScalar = {
    cod_grupo?: boolean;
    desc_grupo?: boolean;
  };

  export type grupoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_grupo' | 'desc_grupo',
    ExtArgs['result']['grupo']
  >;

  export type $grupoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'grupo';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_grupo: number;
        desc_grupo: string;
      },
      ExtArgs['result']['grupo']
    >;
    composites: {};
  };

  type grupoGetPayload<
    S extends boolean | null | undefined | grupoDefaultArgs,
  > = $Result.GetResult<Prisma.$grupoPayload, S>;

  type grupoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<grupoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: GrupoCountAggregateInputType | true;
  };

  export interface grupoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['grupo'];
      meta: { name: 'grupo' };
    };
    /**
     * Find zero or one Grupo that matches the filter.
     * @param {grupoFindUniqueArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grupoFindUniqueArgs>(
      args: SelectSubset<T, grupoFindUniqueArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Grupo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {grupoFindUniqueOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grupoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, grupoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Grupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindFirstArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grupoFindFirstArgs>(
      args?: SelectSubset<T, grupoFindFirstArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Grupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindFirstOrThrowArgs} args - Arguments to find a Grupo
     * @example
     * // Get one Grupo
     * const grupo = await prisma.grupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grupoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, grupoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Grupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grupos
     * const grupos = await prisma.grupo.findMany()
     *
     * // Get first 10 Grupos
     * const grupos = await prisma.grupo.findMany({ take: 10 })
     *
     * // Only select the `cod_grupo`
     * const grupoWithCod_grupoOnly = await prisma.grupo.findMany({ select: { cod_grupo: true } })
     *
     */
    findMany<T extends grupoFindManyArgs>(
      args?: SelectSubset<T, grupoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Grupo.
     * @param {grupoCreateArgs} args - Arguments to create a Grupo.
     * @example
     * // Create one Grupo
     * const Grupo = await prisma.grupo.create({
     *   data: {
     *     // ... data to create a Grupo
     *   }
     * })
     *
     */
    create<T extends grupoCreateArgs>(
      args: SelectSubset<T, grupoCreateArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Grupos.
     * @param {grupoCreateManyArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends grupoCreateManyArgs>(
      args?: SelectSubset<T, grupoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Grupos and returns the data saved in the database.
     * @param {grupoCreateManyAndReturnArgs} args - Arguments to create many Grupos.
     * @example
     * // Create many Grupos
     * const grupo = await prisma.grupo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Grupos and only return the `cod_grupo`
     * const grupoWithCod_grupoOnly = await prisma.grupo.createManyAndReturn({
     *   select: { cod_grupo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends grupoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, grupoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Grupo.
     * @param {grupoDeleteArgs} args - Arguments to delete one Grupo.
     * @example
     * // Delete one Grupo
     * const Grupo = await prisma.grupo.delete({
     *   where: {
     *     // ... filter to delete one Grupo
     *   }
     * })
     *
     */
    delete<T extends grupoDeleteArgs>(
      args: SelectSubset<T, grupoDeleteArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Grupo.
     * @param {grupoUpdateArgs} args - Arguments to update one Grupo.
     * @example
     * // Update one Grupo
     * const grupo = await prisma.grupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends grupoUpdateArgs>(
      args: SelectSubset<T, grupoUpdateArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Grupos.
     * @param {grupoDeleteManyArgs} args - Arguments to filter Grupos to delete.
     * @example
     * // Delete a few Grupos
     * const { count } = await prisma.grupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends grupoDeleteManyArgs>(
      args?: SelectSubset<T, grupoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grupos
     * const grupo = await prisma.grupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends grupoUpdateManyArgs>(
      args: SelectSubset<T, grupoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Grupos and returns the data updated in the database.
     * @param {grupoUpdateManyAndReturnArgs} args - Arguments to update many Grupos.
     * @example
     * // Update many Grupos
     * const grupo = await prisma.grupo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Grupos and only return the `cod_grupo`
     * const grupoWithCod_grupoOnly = await prisma.grupo.updateManyAndReturn({
     *   select: { cod_grupo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends grupoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, grupoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Grupo.
     * @param {grupoUpsertArgs} args - Arguments to update or create a Grupo.
     * @example
     * // Update or create a Grupo
     * const grupo = await prisma.grupo.upsert({
     *   create: {
     *     // ... data to create a Grupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grupo we want to update
     *   }
     * })
     */
    upsert<T extends grupoUpsertArgs>(
      args: SelectSubset<T, grupoUpsertArgs<ExtArgs>>,
    ): Prisma__grupoClient<
      $Result.GetResult<
        Prisma.$grupoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Grupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoCountArgs} args - Arguments to filter Grupos to count.
     * @example
     * // Count the number of Grupos
     * const count = await prisma.grupo.count({
     *   where: {
     *     // ... the filter for the Grupos we want to count
     *   }
     * })
     **/
    count<T extends grupoCountArgs>(
      args?: Subset<T, grupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrupoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GrupoAggregateArgs>(
      args: Subset<T, GrupoAggregateArgs>,
    ): Prisma.PrismaPromise<GetGrupoAggregateType<T>>;

    /**
     * Group by Grupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends grupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grupoGroupByArgs['orderBy'] }
        : { orderBy?: grupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, grupoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetGrupoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the grupo model
     */
    readonly fields: grupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grupoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the grupo model
   */
  interface grupoFieldRefs {
    readonly cod_grupo: FieldRef<'grupo', 'Int'>;
    readonly desc_grupo: FieldRef<'grupo', 'String'>;
  }

  // Custom InputTypes
  /**
   * grupo findUnique
   */
  export type grupoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * Filter, which grupo to fetch.
     */
    where: grupoWhereUniqueInput;
  };

  /**
   * grupo findUniqueOrThrow
   */
  export type grupoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * Filter, which grupo to fetch.
     */
    where: grupoWhereUniqueInput;
  };

  /**
   * grupo findFirst
   */
  export type grupoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * Filter, which grupo to fetch.
     */
    where?: grupoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for grupos.
     */
    cursor?: grupoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` grupos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[];
  };

  /**
   * grupo findFirstOrThrow
   */
  export type grupoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * Filter, which grupo to fetch.
     */
    where?: grupoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for grupos.
     */
    cursor?: grupoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` grupos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of grupos.
     */
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[];
  };

  /**
   * grupo findMany
   */
  export type grupoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * Filter, which grupos to fetch.
     */
    where?: grupoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of grupos to fetch.
     */
    orderBy?: grupoOrderByWithRelationInput | grupoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing grupos.
     */
    cursor?: grupoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` grupos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` grupos.
     */
    skip?: number;
    distinct?: GrupoScalarFieldEnum | GrupoScalarFieldEnum[];
  };

  /**
   * grupo create
   */
  export type grupoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * The data needed to create a grupo.
     */
    data: XOR<grupoCreateInput, grupoUncheckedCreateInput>;
  };

  /**
   * grupo createMany
   */
  export type grupoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many grupos.
     */
    data: grupoCreateManyInput | grupoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * grupo createManyAndReturn
   */
  export type grupoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * The data used to create many grupos.
     */
    data: grupoCreateManyInput | grupoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * grupo update
   */
  export type grupoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * The data needed to update a grupo.
     */
    data: XOR<grupoUpdateInput, grupoUncheckedUpdateInput>;
    /**
     * Choose, which grupo to update.
     */
    where: grupoWhereUniqueInput;
  };

  /**
   * grupo updateMany
   */
  export type grupoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update grupos.
     */
    data: XOR<grupoUpdateManyMutationInput, grupoUncheckedUpdateManyInput>;
    /**
     * Filter which grupos to update
     */
    where?: grupoWhereInput;
    /**
     * Limit how many grupos to update.
     */
    limit?: number;
  };

  /**
   * grupo updateManyAndReturn
   */
  export type grupoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * The data used to update grupos.
     */
    data: XOR<grupoUpdateManyMutationInput, grupoUncheckedUpdateManyInput>;
    /**
     * Filter which grupos to update
     */
    where?: grupoWhereInput;
    /**
     * Limit how many grupos to update.
     */
    limit?: number;
  };

  /**
   * grupo upsert
   */
  export type grupoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * The filter to search for the grupo to update in case it exists.
     */
    where: grupoWhereUniqueInput;
    /**
     * In case the grupo found by the `where` argument doesn't exist, create a new grupo with this data.
     */
    create: XOR<grupoCreateInput, grupoUncheckedCreateInput>;
    /**
     * In case the grupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grupoUpdateInput, grupoUncheckedUpdateInput>;
  };

  /**
   * grupo delete
   */
  export type grupoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
    /**
     * Filter which grupo to delete.
     */
    where: grupoWhereUniqueInput;
  };

  /**
   * grupo deleteMany
   */
  export type grupoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which grupos to delete
     */
    where?: grupoWhereInput;
    /**
     * Limit how many grupos to delete.
     */
    limit?: number;
  };

  /**
   * grupo without action
   */
  export type grupoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the grupo
     */
    select?: grupoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the grupo
     */
    omit?: grupoOmit<ExtArgs> | null;
  };

  /**
   * Model histchamado
   */

  export type AggregateHistchamado = {
    _count: HistchamadoCountAggregateOutputType | null;
    _avg: HistchamadoAvgAggregateOutputType | null;
    _sum: HistchamadoSumAggregateOutputType | null;
    _min: HistchamadoMinAggregateOutputType | null;
    _max: HistchamadoMaxAggregateOutputType | null;
  };

  export type HistchamadoAvgAggregateOutputType = {
    cod_histchamado: number | null;
    cod_chamado: number | null;
  };

  export type HistchamadoSumAggregateOutputType = {
    cod_histchamado: number | null;
    cod_chamado: number | null;
  };

  export type HistchamadoMinAggregateOutputType = {
    cod_histchamado: number | null;
    cod_chamado: number | null;
    data_histchamado: Date | null;
    hora_histchamado: string | null;
    desc_histchamado: string | null;
  };

  export type HistchamadoMaxAggregateOutputType = {
    cod_histchamado: number | null;
    cod_chamado: number | null;
    data_histchamado: Date | null;
    hora_histchamado: string | null;
    desc_histchamado: string | null;
  };

  export type HistchamadoCountAggregateOutputType = {
    cod_histchamado: number;
    cod_chamado: number;
    data_histchamado: number;
    hora_histchamado: number;
    desc_histchamado: number;
    _all: number;
  };

  export type HistchamadoAvgAggregateInputType = {
    cod_histchamado?: true;
    cod_chamado?: true;
  };

  export type HistchamadoSumAggregateInputType = {
    cod_histchamado?: true;
    cod_chamado?: true;
  };

  export type HistchamadoMinAggregateInputType = {
    cod_histchamado?: true;
    cod_chamado?: true;
    data_histchamado?: true;
    hora_histchamado?: true;
    desc_histchamado?: true;
  };

  export type HistchamadoMaxAggregateInputType = {
    cod_histchamado?: true;
    cod_chamado?: true;
    data_histchamado?: true;
    hora_histchamado?: true;
    desc_histchamado?: true;
  };

  export type HistchamadoCountAggregateInputType = {
    cod_histchamado?: true;
    cod_chamado?: true;
    data_histchamado?: true;
    hora_histchamado?: true;
    desc_histchamado?: true;
    _all?: true;
  };

  export type HistchamadoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which histchamado to aggregate.
     */
    where?: histchamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of histchamados to fetch.
     */
    orderBy?:
      | histchamadoOrderByWithRelationInput
      | histchamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: histchamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` histchamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` histchamados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned histchamados
     **/
    _count?: true | HistchamadoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: HistchamadoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: HistchamadoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: HistchamadoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: HistchamadoMaxAggregateInputType;
  };

  export type GetHistchamadoAggregateType<T extends HistchamadoAggregateArgs> =
    {
      [P in keyof T & keyof AggregateHistchamado]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateHistchamado[P]>
        : GetScalarType<T[P], AggregateHistchamado[P]>;
    };

  export type histchamadoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: histchamadoWhereInput;
    orderBy?:
      | histchamadoOrderByWithAggregationInput
      | histchamadoOrderByWithAggregationInput[];
    by: HistchamadoScalarFieldEnum[] | HistchamadoScalarFieldEnum;
    having?: histchamadoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HistchamadoCountAggregateInputType | true;
    _avg?: HistchamadoAvgAggregateInputType;
    _sum?: HistchamadoSumAggregateInputType;
    _min?: HistchamadoMinAggregateInputType;
    _max?: HistchamadoMaxAggregateInputType;
  };

  export type HistchamadoGroupByOutputType = {
    cod_histchamado: number;
    cod_chamado: number;
    data_histchamado: Date;
    hora_histchamado: string;
    desc_histchamado: string | null;
    _count: HistchamadoCountAggregateOutputType | null;
    _avg: HistchamadoAvgAggregateOutputType | null;
    _sum: HistchamadoSumAggregateOutputType | null;
    _min: HistchamadoMinAggregateOutputType | null;
    _max: HistchamadoMaxAggregateOutputType | null;
  };

  type GetHistchamadoGroupByPayload<T extends histchamadoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<HistchamadoGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof HistchamadoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistchamadoGroupByOutputType[P]>
            : GetScalarType<T[P], HistchamadoGroupByOutputType[P]>;
        }
      >
    >;

  export type histchamadoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_histchamado?: boolean;
      cod_chamado?: boolean;
      data_histchamado?: boolean;
      hora_histchamado?: boolean;
      desc_histchamado?: boolean;
    },
    ExtArgs['result']['histchamado']
  >;

  export type histchamadoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_histchamado?: boolean;
      cod_chamado?: boolean;
      data_histchamado?: boolean;
      hora_histchamado?: boolean;
      desc_histchamado?: boolean;
    },
    ExtArgs['result']['histchamado']
  >;

  export type histchamadoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_histchamado?: boolean;
      cod_chamado?: boolean;
      data_histchamado?: boolean;
      hora_histchamado?: boolean;
      desc_histchamado?: boolean;
    },
    ExtArgs['result']['histchamado']
  >;

  export type histchamadoSelectScalar = {
    cod_histchamado?: boolean;
    cod_chamado?: boolean;
    data_histchamado?: boolean;
    hora_histchamado?: boolean;
    desc_histchamado?: boolean;
  };

  export type histchamadoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_histchamado'
    | 'cod_chamado'
    | 'data_histchamado'
    | 'hora_histchamado'
    | 'desc_histchamado',
    ExtArgs['result']['histchamado']
  >;

  export type $histchamadoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'histchamado';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_histchamado: number;
        cod_chamado: number;
        data_histchamado: Date;
        hora_histchamado: string;
        desc_histchamado: string | null;
      },
      ExtArgs['result']['histchamado']
    >;
    composites: {};
  };

  type histchamadoGetPayload<
    S extends boolean | null | undefined | histchamadoDefaultArgs,
  > = $Result.GetResult<Prisma.$histchamadoPayload, S>;

  type histchamadoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    histchamadoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: HistchamadoCountAggregateInputType | true;
  };

  export interface histchamadoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['histchamado'];
      meta: { name: 'histchamado' };
    };
    /**
     * Find zero or one Histchamado that matches the filter.
     * @param {histchamadoFindUniqueArgs} args - Arguments to find a Histchamado
     * @example
     * // Get one Histchamado
     * const histchamado = await prisma.histchamado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends histchamadoFindUniqueArgs>(
      args: SelectSubset<T, histchamadoFindUniqueArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Histchamado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {histchamadoFindUniqueOrThrowArgs} args - Arguments to find a Histchamado
     * @example
     * // Get one Histchamado
     * const histchamado = await prisma.histchamado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends histchamadoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, histchamadoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Histchamado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histchamadoFindFirstArgs} args - Arguments to find a Histchamado
     * @example
     * // Get one Histchamado
     * const histchamado = await prisma.histchamado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends histchamadoFindFirstArgs>(
      args?: SelectSubset<T, histchamadoFindFirstArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Histchamado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histchamadoFindFirstOrThrowArgs} args - Arguments to find a Histchamado
     * @example
     * // Get one Histchamado
     * const histchamado = await prisma.histchamado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends histchamadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, histchamadoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Histchamados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histchamadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Histchamados
     * const histchamados = await prisma.histchamado.findMany()
     *
     * // Get first 10 Histchamados
     * const histchamados = await prisma.histchamado.findMany({ take: 10 })
     *
     * // Only select the `cod_histchamado`
     * const histchamadoWithCod_histchamadoOnly = await prisma.histchamado.findMany({ select: { cod_histchamado: true } })
     *
     */
    findMany<T extends histchamadoFindManyArgs>(
      args?: SelectSubset<T, histchamadoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Histchamado.
     * @param {histchamadoCreateArgs} args - Arguments to create a Histchamado.
     * @example
     * // Create one Histchamado
     * const Histchamado = await prisma.histchamado.create({
     *   data: {
     *     // ... data to create a Histchamado
     *   }
     * })
     *
     */
    create<T extends histchamadoCreateArgs>(
      args: SelectSubset<T, histchamadoCreateArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Histchamados.
     * @param {histchamadoCreateManyArgs} args - Arguments to create many Histchamados.
     * @example
     * // Create many Histchamados
     * const histchamado = await prisma.histchamado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends histchamadoCreateManyArgs>(
      args?: SelectSubset<T, histchamadoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Histchamados and returns the data saved in the database.
     * @param {histchamadoCreateManyAndReturnArgs} args - Arguments to create many Histchamados.
     * @example
     * // Create many Histchamados
     * const histchamado = await prisma.histchamado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Histchamados and only return the `cod_histchamado`
     * const histchamadoWithCod_histchamadoOnly = await prisma.histchamado.createManyAndReturn({
     *   select: { cod_histchamado: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends histchamadoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, histchamadoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Histchamado.
     * @param {histchamadoDeleteArgs} args - Arguments to delete one Histchamado.
     * @example
     * // Delete one Histchamado
     * const Histchamado = await prisma.histchamado.delete({
     *   where: {
     *     // ... filter to delete one Histchamado
     *   }
     * })
     *
     */
    delete<T extends histchamadoDeleteArgs>(
      args: SelectSubset<T, histchamadoDeleteArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Histchamado.
     * @param {histchamadoUpdateArgs} args - Arguments to update one Histchamado.
     * @example
     * // Update one Histchamado
     * const histchamado = await prisma.histchamado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends histchamadoUpdateArgs>(
      args: SelectSubset<T, histchamadoUpdateArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Histchamados.
     * @param {histchamadoDeleteManyArgs} args - Arguments to filter Histchamados to delete.
     * @example
     * // Delete a few Histchamados
     * const { count } = await prisma.histchamado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends histchamadoDeleteManyArgs>(
      args?: SelectSubset<T, histchamadoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Histchamados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histchamadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Histchamados
     * const histchamado = await prisma.histchamado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends histchamadoUpdateManyArgs>(
      args: SelectSubset<T, histchamadoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Histchamados and returns the data updated in the database.
     * @param {histchamadoUpdateManyAndReturnArgs} args - Arguments to update many Histchamados.
     * @example
     * // Update many Histchamados
     * const histchamado = await prisma.histchamado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Histchamados and only return the `cod_histchamado`
     * const histchamadoWithCod_histchamadoOnly = await prisma.histchamado.updateManyAndReturn({
     *   select: { cod_histchamado: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends histchamadoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, histchamadoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Histchamado.
     * @param {histchamadoUpsertArgs} args - Arguments to update or create a Histchamado.
     * @example
     * // Update or create a Histchamado
     * const histchamado = await prisma.histchamado.upsert({
     *   create: {
     *     // ... data to create a Histchamado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Histchamado we want to update
     *   }
     * })
     */
    upsert<T extends histchamadoUpsertArgs>(
      args: SelectSubset<T, histchamadoUpsertArgs<ExtArgs>>,
    ): Prisma__histchamadoClient<
      $Result.GetResult<
        Prisma.$histchamadoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Histchamados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histchamadoCountArgs} args - Arguments to filter Histchamados to count.
     * @example
     * // Count the number of Histchamados
     * const count = await prisma.histchamado.count({
     *   where: {
     *     // ... the filter for the Histchamados we want to count
     *   }
     * })
     **/
    count<T extends histchamadoCountArgs>(
      args?: Subset<T, histchamadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistchamadoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Histchamado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistchamadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends HistchamadoAggregateArgs>(
      args: Subset<T, HistchamadoAggregateArgs>,
    ): Prisma.PrismaPromise<GetHistchamadoAggregateType<T>>;

    /**
     * Group by Histchamado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histchamadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends histchamadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: histchamadoGroupByArgs['orderBy'] }
        : { orderBy?: histchamadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, histchamadoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetHistchamadoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the histchamado model
     */
    readonly fields: histchamadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for histchamado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__histchamadoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the histchamado model
   */
  interface histchamadoFieldRefs {
    readonly cod_histchamado: FieldRef<'histchamado', 'Int'>;
    readonly cod_chamado: FieldRef<'histchamado', 'Int'>;
    readonly data_histchamado: FieldRef<'histchamado', 'DateTime'>;
    readonly hora_histchamado: FieldRef<'histchamado', 'String'>;
    readonly desc_histchamado: FieldRef<'histchamado', 'String'>;
  }

  // Custom InputTypes
  /**
   * histchamado findUnique
   */
  export type histchamadoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * Filter, which histchamado to fetch.
     */
    where: histchamadoWhereUniqueInput;
  };

  /**
   * histchamado findUniqueOrThrow
   */
  export type histchamadoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * Filter, which histchamado to fetch.
     */
    where: histchamadoWhereUniqueInput;
  };

  /**
   * histchamado findFirst
   */
  export type histchamadoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * Filter, which histchamado to fetch.
     */
    where?: histchamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of histchamados to fetch.
     */
    orderBy?:
      | histchamadoOrderByWithRelationInput
      | histchamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for histchamados.
     */
    cursor?: histchamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` histchamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` histchamados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of histchamados.
     */
    distinct?: HistchamadoScalarFieldEnum | HistchamadoScalarFieldEnum[];
  };

  /**
   * histchamado findFirstOrThrow
   */
  export type histchamadoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * Filter, which histchamado to fetch.
     */
    where?: histchamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of histchamados to fetch.
     */
    orderBy?:
      | histchamadoOrderByWithRelationInput
      | histchamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for histchamados.
     */
    cursor?: histchamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` histchamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` histchamados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of histchamados.
     */
    distinct?: HistchamadoScalarFieldEnum | HistchamadoScalarFieldEnum[];
  };

  /**
   * histchamado findMany
   */
  export type histchamadoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * Filter, which histchamados to fetch.
     */
    where?: histchamadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of histchamados to fetch.
     */
    orderBy?:
      | histchamadoOrderByWithRelationInput
      | histchamadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing histchamados.
     */
    cursor?: histchamadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` histchamados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` histchamados.
     */
    skip?: number;
    distinct?: HistchamadoScalarFieldEnum | HistchamadoScalarFieldEnum[];
  };

  /**
   * histchamado create
   */
  export type histchamadoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * The data needed to create a histchamado.
     */
    data: XOR<histchamadoCreateInput, histchamadoUncheckedCreateInput>;
  };

  /**
   * histchamado createMany
   */
  export type histchamadoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many histchamados.
     */
    data: histchamadoCreateManyInput | histchamadoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * histchamado createManyAndReturn
   */
  export type histchamadoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * The data used to create many histchamados.
     */
    data: histchamadoCreateManyInput | histchamadoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * histchamado update
   */
  export type histchamadoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * The data needed to update a histchamado.
     */
    data: XOR<histchamadoUpdateInput, histchamadoUncheckedUpdateInput>;
    /**
     * Choose, which histchamado to update.
     */
    where: histchamadoWhereUniqueInput;
  };

  /**
   * histchamado updateMany
   */
  export type histchamadoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update histchamados.
     */
    data: XOR<
      histchamadoUpdateManyMutationInput,
      histchamadoUncheckedUpdateManyInput
    >;
    /**
     * Filter which histchamados to update
     */
    where?: histchamadoWhereInput;
    /**
     * Limit how many histchamados to update.
     */
    limit?: number;
  };

  /**
   * histchamado updateManyAndReturn
   */
  export type histchamadoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * The data used to update histchamados.
     */
    data: XOR<
      histchamadoUpdateManyMutationInput,
      histchamadoUncheckedUpdateManyInput
    >;
    /**
     * Filter which histchamados to update
     */
    where?: histchamadoWhereInput;
    /**
     * Limit how many histchamados to update.
     */
    limit?: number;
  };

  /**
   * histchamado upsert
   */
  export type histchamadoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * The filter to search for the histchamado to update in case it exists.
     */
    where: histchamadoWhereUniqueInput;
    /**
     * In case the histchamado found by the `where` argument doesn't exist, create a new histchamado with this data.
     */
    create: XOR<histchamadoCreateInput, histchamadoUncheckedCreateInput>;
    /**
     * In case the histchamado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<histchamadoUpdateInput, histchamadoUncheckedUpdateInput>;
  };

  /**
   * histchamado delete
   */
  export type histchamadoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
    /**
     * Filter which histchamado to delete.
     */
    where: histchamadoWhereUniqueInput;
  };

  /**
   * histchamado deleteMany
   */
  export type histchamadoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which histchamados to delete
     */
    where?: histchamadoWhereInput;
    /**
     * Limit how many histchamados to delete.
     */
    limit?: number;
  };

  /**
   * histchamado without action
   */
  export type histchamadoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the histchamado
     */
    select?: histchamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the histchamado
     */
    omit?: histchamadoOmit<ExtArgs> | null;
  };

  /**
   * Model itavaliado
   */

  export type AggregateItavaliado = {
    _count: ItavaliadoCountAggregateOutputType | null;
    _avg: ItavaliadoAvgAggregateOutputType | null;
    _sum: ItavaliadoSumAggregateOutputType | null;
    _min: ItavaliadoMinAggregateOutputType | null;
    _max: ItavaliadoMaxAggregateOutputType | null;
  };

  export type ItavaliadoAvgAggregateOutputType = {
    codaval_itavaliado: number | null;
    codrec_itavaliado: number | null;
    codmat_itavaliado: number | null;
    coditmat_itavaliado: number | null;
    ptoger_itavaliado: number | null;
    ptorec_itavaliado: number | null;
    nota1_itavaliado: Decimal | null;
    nota2_itavaliado: Decimal | null;
    nota3_itavaliado: Decimal | null;
  };

  export type ItavaliadoSumAggregateOutputType = {
    codaval_itavaliado: number | null;
    codrec_itavaliado: number | null;
    codmat_itavaliado: number | null;
    coditmat_itavaliado: number | null;
    ptoger_itavaliado: number | null;
    ptorec_itavaliado: number | null;
    nota1_itavaliado: Decimal | null;
    nota2_itavaliado: Decimal | null;
    nota3_itavaliado: Decimal | null;
  };

  export type ItavaliadoMinAggregateOutputType = {
    codaval_itavaliado: number | null;
    codrec_itavaliado: number | null;
    codmat_itavaliado: number | null;
    coditmat_itavaliado: number | null;
    ptoger_itavaliado: number | null;
    ptorec_itavaliado: number | null;
    obs_itavaliado: string | null;
    nota1_itavaliado: Decimal | null;
    nota2_itavaliado: Decimal | null;
    nota3_itavaliado: Decimal | null;
  };

  export type ItavaliadoMaxAggregateOutputType = {
    codaval_itavaliado: number | null;
    codrec_itavaliado: number | null;
    codmat_itavaliado: number | null;
    coditmat_itavaliado: number | null;
    ptoger_itavaliado: number | null;
    ptorec_itavaliado: number | null;
    obs_itavaliado: string | null;
    nota1_itavaliado: Decimal | null;
    nota2_itavaliado: Decimal | null;
    nota3_itavaliado: Decimal | null;
  };

  export type ItavaliadoCountAggregateOutputType = {
    codaval_itavaliado: number;
    codrec_itavaliado: number;
    codmat_itavaliado: number;
    coditmat_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado: number;
    nota1_itavaliado: number;
    nota2_itavaliado: number;
    nota3_itavaliado: number;
    _all: number;
  };

  export type ItavaliadoAvgAggregateInputType = {
    codaval_itavaliado?: true;
    codrec_itavaliado?: true;
    codmat_itavaliado?: true;
    coditmat_itavaliado?: true;
    ptoger_itavaliado?: true;
    ptorec_itavaliado?: true;
    nota1_itavaliado?: true;
    nota2_itavaliado?: true;
    nota3_itavaliado?: true;
  };

  export type ItavaliadoSumAggregateInputType = {
    codaval_itavaliado?: true;
    codrec_itavaliado?: true;
    codmat_itavaliado?: true;
    coditmat_itavaliado?: true;
    ptoger_itavaliado?: true;
    ptorec_itavaliado?: true;
    nota1_itavaliado?: true;
    nota2_itavaliado?: true;
    nota3_itavaliado?: true;
  };

  export type ItavaliadoMinAggregateInputType = {
    codaval_itavaliado?: true;
    codrec_itavaliado?: true;
    codmat_itavaliado?: true;
    coditmat_itavaliado?: true;
    ptoger_itavaliado?: true;
    ptorec_itavaliado?: true;
    obs_itavaliado?: true;
    nota1_itavaliado?: true;
    nota2_itavaliado?: true;
    nota3_itavaliado?: true;
  };

  export type ItavaliadoMaxAggregateInputType = {
    codaval_itavaliado?: true;
    codrec_itavaliado?: true;
    codmat_itavaliado?: true;
    coditmat_itavaliado?: true;
    ptoger_itavaliado?: true;
    ptorec_itavaliado?: true;
    obs_itavaliado?: true;
    nota1_itavaliado?: true;
    nota2_itavaliado?: true;
    nota3_itavaliado?: true;
  };

  export type ItavaliadoCountAggregateInputType = {
    codaval_itavaliado?: true;
    codrec_itavaliado?: true;
    codmat_itavaliado?: true;
    coditmat_itavaliado?: true;
    ptoger_itavaliado?: true;
    ptorec_itavaliado?: true;
    obs_itavaliado?: true;
    nota1_itavaliado?: true;
    nota2_itavaliado?: true;
    nota3_itavaliado?: true;
    _all?: true;
  };

  export type ItavaliadoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which itavaliado to aggregate.
     */
    where?: itavaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itavaliados to fetch.
     */
    orderBy?:
      | itavaliadoOrderByWithRelationInput
      | itavaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: itavaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itavaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itavaliados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned itavaliados
     **/
    _count?: true | ItavaliadoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ItavaliadoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ItavaliadoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ItavaliadoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ItavaliadoMaxAggregateInputType;
  };

  export type GetItavaliadoAggregateType<T extends ItavaliadoAggregateArgs> = {
    [P in keyof T & keyof AggregateItavaliado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItavaliado[P]>
      : GetScalarType<T[P], AggregateItavaliado[P]>;
  };

  export type itavaliadoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: itavaliadoWhereInput;
    orderBy?:
      | itavaliadoOrderByWithAggregationInput
      | itavaliadoOrderByWithAggregationInput[];
    by: ItavaliadoScalarFieldEnum[] | ItavaliadoScalarFieldEnum;
    having?: itavaliadoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ItavaliadoCountAggregateInputType | true;
    _avg?: ItavaliadoAvgAggregateInputType;
    _sum?: ItavaliadoSumAggregateInputType;
    _min?: ItavaliadoMinAggregateInputType;
    _max?: ItavaliadoMaxAggregateInputType;
  };

  export type ItavaliadoGroupByOutputType = {
    codaval_itavaliado: number;
    codrec_itavaliado: number;
    codmat_itavaliado: number;
    coditmat_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado: string | null;
    nota1_itavaliado: Decimal;
    nota2_itavaliado: Decimal;
    nota3_itavaliado: Decimal;
    _count: ItavaliadoCountAggregateOutputType | null;
    _avg: ItavaliadoAvgAggregateOutputType | null;
    _sum: ItavaliadoSumAggregateOutputType | null;
    _min: ItavaliadoMinAggregateOutputType | null;
    _max: ItavaliadoMaxAggregateOutputType | null;
  };

  type GetItavaliadoGroupByPayload<T extends itavaliadoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ItavaliadoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ItavaliadoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItavaliadoGroupByOutputType[P]>
            : GetScalarType<T[P], ItavaliadoGroupByOutputType[P]>;
        }
      >
    >;

  export type itavaliadoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codaval_itavaliado?: boolean;
      codrec_itavaliado?: boolean;
      codmat_itavaliado?: boolean;
      coditmat_itavaliado?: boolean;
      ptoger_itavaliado?: boolean;
      ptorec_itavaliado?: boolean;
      obs_itavaliado?: boolean;
      nota1_itavaliado?: boolean;
      nota2_itavaliado?: boolean;
      nota3_itavaliado?: boolean;
      avaliado?: boolean | avaliadoDefaultArgs<ExtArgs>;
      itmatriz?: boolean | itmatrizDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['itavaliado']
  >;

  export type itavaliadoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codaval_itavaliado?: boolean;
      codrec_itavaliado?: boolean;
      codmat_itavaliado?: boolean;
      coditmat_itavaliado?: boolean;
      ptoger_itavaliado?: boolean;
      ptorec_itavaliado?: boolean;
      obs_itavaliado?: boolean;
      nota1_itavaliado?: boolean;
      nota2_itavaliado?: boolean;
      nota3_itavaliado?: boolean;
      avaliado?: boolean | avaliadoDefaultArgs<ExtArgs>;
      itmatriz?: boolean | itmatrizDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['itavaliado']
  >;

  export type itavaliadoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codaval_itavaliado?: boolean;
      codrec_itavaliado?: boolean;
      codmat_itavaliado?: boolean;
      coditmat_itavaliado?: boolean;
      ptoger_itavaliado?: boolean;
      ptorec_itavaliado?: boolean;
      obs_itavaliado?: boolean;
      nota1_itavaliado?: boolean;
      nota2_itavaliado?: boolean;
      nota3_itavaliado?: boolean;
      avaliado?: boolean | avaliadoDefaultArgs<ExtArgs>;
      itmatriz?: boolean | itmatrizDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['itavaliado']
  >;

  export type itavaliadoSelectScalar = {
    codaval_itavaliado?: boolean;
    codrec_itavaliado?: boolean;
    codmat_itavaliado?: boolean;
    coditmat_itavaliado?: boolean;
    ptoger_itavaliado?: boolean;
    ptorec_itavaliado?: boolean;
    obs_itavaliado?: boolean;
    nota1_itavaliado?: boolean;
    nota2_itavaliado?: boolean;
    nota3_itavaliado?: boolean;
  };

  export type itavaliadoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'codaval_itavaliado'
    | 'codrec_itavaliado'
    | 'codmat_itavaliado'
    | 'coditmat_itavaliado'
    | 'ptoger_itavaliado'
    | 'ptorec_itavaliado'
    | 'obs_itavaliado'
    | 'nota1_itavaliado'
    | 'nota2_itavaliado'
    | 'nota3_itavaliado',
    ExtArgs['result']['itavaliado']
  >;
  export type itavaliadoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliado?: boolean | avaliadoDefaultArgs<ExtArgs>;
    itmatriz?: boolean | itmatrizDefaultArgs<ExtArgs>;
  };
  export type itavaliadoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliado?: boolean | avaliadoDefaultArgs<ExtArgs>;
    itmatriz?: boolean | itmatrizDefaultArgs<ExtArgs>;
  };
  export type itavaliadoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliado?: boolean | avaliadoDefaultArgs<ExtArgs>;
    itmatriz?: boolean | itmatrizDefaultArgs<ExtArgs>;
  };

  export type $itavaliadoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'itavaliado';
    objects: {
      avaliado: Prisma.$avaliadoPayload<ExtArgs>;
      itmatriz: Prisma.$itmatrizPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        codaval_itavaliado: number;
        codrec_itavaliado: number;
        codmat_itavaliado: number;
        coditmat_itavaliado: number;
        ptoger_itavaliado: number;
        ptorec_itavaliado: number;
        obs_itavaliado: string | null;
        nota1_itavaliado: Prisma.Decimal;
        nota2_itavaliado: Prisma.Decimal;
        nota3_itavaliado: Prisma.Decimal;
      },
      ExtArgs['result']['itavaliado']
    >;
    composites: {};
  };

  type itavaliadoGetPayload<
    S extends boolean | null | undefined | itavaliadoDefaultArgs,
  > = $Result.GetResult<Prisma.$itavaliadoPayload, S>;

  type itavaliadoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    itavaliadoFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ItavaliadoCountAggregateInputType | true;
  };

  export interface itavaliadoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['itavaliado'];
      meta: { name: 'itavaliado' };
    };
    /**
     * Find zero or one Itavaliado that matches the filter.
     * @param {itavaliadoFindUniqueArgs} args - Arguments to find a Itavaliado
     * @example
     * // Get one Itavaliado
     * const itavaliado = await prisma.itavaliado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itavaliadoFindUniqueArgs>(
      args: SelectSubset<T, itavaliadoFindUniqueArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Itavaliado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itavaliadoFindUniqueOrThrowArgs} args - Arguments to find a Itavaliado
     * @example
     * // Get one Itavaliado
     * const itavaliado = await prisma.itavaliado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itavaliadoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, itavaliadoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Itavaliado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itavaliadoFindFirstArgs} args - Arguments to find a Itavaliado
     * @example
     * // Get one Itavaliado
     * const itavaliado = await prisma.itavaliado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itavaliadoFindFirstArgs>(
      args?: SelectSubset<T, itavaliadoFindFirstArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Itavaliado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itavaliadoFindFirstOrThrowArgs} args - Arguments to find a Itavaliado
     * @example
     * // Get one Itavaliado
     * const itavaliado = await prisma.itavaliado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itavaliadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, itavaliadoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Itavaliados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itavaliadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itavaliados
     * const itavaliados = await prisma.itavaliado.findMany()
     *
     * // Get first 10 Itavaliados
     * const itavaliados = await prisma.itavaliado.findMany({ take: 10 })
     *
     * // Only select the `codaval_itavaliado`
     * const itavaliadoWithCodaval_itavaliadoOnly = await prisma.itavaliado.findMany({ select: { codaval_itavaliado: true } })
     *
     */
    findMany<T extends itavaliadoFindManyArgs>(
      args?: SelectSubset<T, itavaliadoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Itavaliado.
     * @param {itavaliadoCreateArgs} args - Arguments to create a Itavaliado.
     * @example
     * // Create one Itavaliado
     * const Itavaliado = await prisma.itavaliado.create({
     *   data: {
     *     // ... data to create a Itavaliado
     *   }
     * })
     *
     */
    create<T extends itavaliadoCreateArgs>(
      args: SelectSubset<T, itavaliadoCreateArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Itavaliados.
     * @param {itavaliadoCreateManyArgs} args - Arguments to create many Itavaliados.
     * @example
     * // Create many Itavaliados
     * const itavaliado = await prisma.itavaliado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends itavaliadoCreateManyArgs>(
      args?: SelectSubset<T, itavaliadoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Itavaliados and returns the data saved in the database.
     * @param {itavaliadoCreateManyAndReturnArgs} args - Arguments to create many Itavaliados.
     * @example
     * // Create many Itavaliados
     * const itavaliado = await prisma.itavaliado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Itavaliados and only return the `codaval_itavaliado`
     * const itavaliadoWithCodaval_itavaliadoOnly = await prisma.itavaliado.createManyAndReturn({
     *   select: { codaval_itavaliado: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends itavaliadoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, itavaliadoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Itavaliado.
     * @param {itavaliadoDeleteArgs} args - Arguments to delete one Itavaliado.
     * @example
     * // Delete one Itavaliado
     * const Itavaliado = await prisma.itavaliado.delete({
     *   where: {
     *     // ... filter to delete one Itavaliado
     *   }
     * })
     *
     */
    delete<T extends itavaliadoDeleteArgs>(
      args: SelectSubset<T, itavaliadoDeleteArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Itavaliado.
     * @param {itavaliadoUpdateArgs} args - Arguments to update one Itavaliado.
     * @example
     * // Update one Itavaliado
     * const itavaliado = await prisma.itavaliado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends itavaliadoUpdateArgs>(
      args: SelectSubset<T, itavaliadoUpdateArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Itavaliados.
     * @param {itavaliadoDeleteManyArgs} args - Arguments to filter Itavaliados to delete.
     * @example
     * // Delete a few Itavaliados
     * const { count } = await prisma.itavaliado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends itavaliadoDeleteManyArgs>(
      args?: SelectSubset<T, itavaliadoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Itavaliados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itavaliadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itavaliados
     * const itavaliado = await prisma.itavaliado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends itavaliadoUpdateManyArgs>(
      args: SelectSubset<T, itavaliadoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Itavaliados and returns the data updated in the database.
     * @param {itavaliadoUpdateManyAndReturnArgs} args - Arguments to update many Itavaliados.
     * @example
     * // Update many Itavaliados
     * const itavaliado = await prisma.itavaliado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Itavaliados and only return the `codaval_itavaliado`
     * const itavaliadoWithCodaval_itavaliadoOnly = await prisma.itavaliado.updateManyAndReturn({
     *   select: { codaval_itavaliado: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends itavaliadoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, itavaliadoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Itavaliado.
     * @param {itavaliadoUpsertArgs} args - Arguments to update or create a Itavaliado.
     * @example
     * // Update or create a Itavaliado
     * const itavaliado = await prisma.itavaliado.upsert({
     *   create: {
     *     // ... data to create a Itavaliado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itavaliado we want to update
     *   }
     * })
     */
    upsert<T extends itavaliadoUpsertArgs>(
      args: SelectSubset<T, itavaliadoUpsertArgs<ExtArgs>>,
    ): Prisma__itavaliadoClient<
      $Result.GetResult<
        Prisma.$itavaliadoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Itavaliados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itavaliadoCountArgs} args - Arguments to filter Itavaliados to count.
     * @example
     * // Count the number of Itavaliados
     * const count = await prisma.itavaliado.count({
     *   where: {
     *     // ... the filter for the Itavaliados we want to count
     *   }
     * })
     **/
    count<T extends itavaliadoCountArgs>(
      args?: Subset<T, itavaliadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItavaliadoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Itavaliado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItavaliadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ItavaliadoAggregateArgs>(
      args: Subset<T, ItavaliadoAggregateArgs>,
    ): Prisma.PrismaPromise<GetItavaliadoAggregateType<T>>;

    /**
     * Group by Itavaliado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itavaliadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends itavaliadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itavaliadoGroupByArgs['orderBy'] }
        : { orderBy?: itavaliadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, itavaliadoGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetItavaliadoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the itavaliado model
     */
    readonly fields: itavaliadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itavaliado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itavaliadoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    avaliado<T extends avaliadoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, avaliadoDefaultArgs<ExtArgs>>,
    ): Prisma__avaliadoClient<
      | $Result.GetResult<
          Prisma.$avaliadoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    itmatriz<T extends itmatrizDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, itmatrizDefaultArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      | $Result.GetResult<
          Prisma.$itmatrizPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the itavaliado model
   */
  interface itavaliadoFieldRefs {
    readonly codaval_itavaliado: FieldRef<'itavaliado', 'Int'>;
    readonly codrec_itavaliado: FieldRef<'itavaliado', 'Int'>;
    readonly codmat_itavaliado: FieldRef<'itavaliado', 'Int'>;
    readonly coditmat_itavaliado: FieldRef<'itavaliado', 'Int'>;
    readonly ptoger_itavaliado: FieldRef<'itavaliado', 'Int'>;
    readonly ptorec_itavaliado: FieldRef<'itavaliado', 'Int'>;
    readonly obs_itavaliado: FieldRef<'itavaliado', 'String'>;
    readonly nota1_itavaliado: FieldRef<'itavaliado', 'Decimal'>;
    readonly nota2_itavaliado: FieldRef<'itavaliado', 'Decimal'>;
    readonly nota3_itavaliado: FieldRef<'itavaliado', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * itavaliado findUnique
   */
  export type itavaliadoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which itavaliado to fetch.
     */
    where: itavaliadoWhereUniqueInput;
  };

  /**
   * itavaliado findUniqueOrThrow
   */
  export type itavaliadoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which itavaliado to fetch.
     */
    where: itavaliadoWhereUniqueInput;
  };

  /**
   * itavaliado findFirst
   */
  export type itavaliadoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which itavaliado to fetch.
     */
    where?: itavaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itavaliados to fetch.
     */
    orderBy?:
      | itavaliadoOrderByWithRelationInput
      | itavaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for itavaliados.
     */
    cursor?: itavaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itavaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itavaliados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of itavaliados.
     */
    distinct?: ItavaliadoScalarFieldEnum | ItavaliadoScalarFieldEnum[];
  };

  /**
   * itavaliado findFirstOrThrow
   */
  export type itavaliadoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which itavaliado to fetch.
     */
    where?: itavaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itavaliados to fetch.
     */
    orderBy?:
      | itavaliadoOrderByWithRelationInput
      | itavaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for itavaliados.
     */
    cursor?: itavaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itavaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itavaliados.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of itavaliados.
     */
    distinct?: ItavaliadoScalarFieldEnum | ItavaliadoScalarFieldEnum[];
  };

  /**
   * itavaliado findMany
   */
  export type itavaliadoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * Filter, which itavaliados to fetch.
     */
    where?: itavaliadoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itavaliados to fetch.
     */
    orderBy?:
      | itavaliadoOrderByWithRelationInput
      | itavaliadoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing itavaliados.
     */
    cursor?: itavaliadoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itavaliados from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itavaliados.
     */
    skip?: number;
    distinct?: ItavaliadoScalarFieldEnum | ItavaliadoScalarFieldEnum[];
  };

  /**
   * itavaliado create
   */
  export type itavaliadoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * The data needed to create a itavaliado.
     */
    data: XOR<itavaliadoCreateInput, itavaliadoUncheckedCreateInput>;
  };

  /**
   * itavaliado createMany
   */
  export type itavaliadoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many itavaliados.
     */
    data: itavaliadoCreateManyInput | itavaliadoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * itavaliado createManyAndReturn
   */
  export type itavaliadoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * The data used to create many itavaliados.
     */
    data: itavaliadoCreateManyInput | itavaliadoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * itavaliado update
   */
  export type itavaliadoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * The data needed to update a itavaliado.
     */
    data: XOR<itavaliadoUpdateInput, itavaliadoUncheckedUpdateInput>;
    /**
     * Choose, which itavaliado to update.
     */
    where: itavaliadoWhereUniqueInput;
  };

  /**
   * itavaliado updateMany
   */
  export type itavaliadoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update itavaliados.
     */
    data: XOR<
      itavaliadoUpdateManyMutationInput,
      itavaliadoUncheckedUpdateManyInput
    >;
    /**
     * Filter which itavaliados to update
     */
    where?: itavaliadoWhereInput;
    /**
     * Limit how many itavaliados to update.
     */
    limit?: number;
  };

  /**
   * itavaliado updateManyAndReturn
   */
  export type itavaliadoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * The data used to update itavaliados.
     */
    data: XOR<
      itavaliadoUpdateManyMutationInput,
      itavaliadoUncheckedUpdateManyInput
    >;
    /**
     * Filter which itavaliados to update
     */
    where?: itavaliadoWhereInput;
    /**
     * Limit how many itavaliados to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * itavaliado upsert
   */
  export type itavaliadoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * The filter to search for the itavaliado to update in case it exists.
     */
    where: itavaliadoWhereUniqueInput;
    /**
     * In case the itavaliado found by the `where` argument doesn't exist, create a new itavaliado with this data.
     */
    create: XOR<itavaliadoCreateInput, itavaliadoUncheckedCreateInput>;
    /**
     * In case the itavaliado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itavaliadoUpdateInput, itavaliadoUncheckedUpdateInput>;
  };

  /**
   * itavaliado delete
   */
  export type itavaliadoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    /**
     * Filter which itavaliado to delete.
     */
    where: itavaliadoWhereUniqueInput;
  };

  /**
   * itavaliado deleteMany
   */
  export type itavaliadoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which itavaliados to delete
     */
    where?: itavaliadoWhereInput;
    /**
     * Limit how many itavaliados to delete.
     */
    limit?: number;
  };

  /**
   * itavaliado without action
   */
  export type itavaliadoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
  };

  /**
   * Model itmatriz
   */

  export type AggregateItmatriz = {
    _count: ItmatrizCountAggregateOutputType | null;
    _avg: ItmatrizAvgAggregateOutputType | null;
    _sum: ItmatrizSumAggregateOutputType | null;
    _min: ItmatrizMinAggregateOutputType | null;
    _max: ItmatrizMaxAggregateOutputType | null;
  };

  export type ItmatrizAvgAggregateOutputType = {
    codmat_itmatriz: number | null;
    cod_itmatriz: number | null;
    nota1_itmatriz: Decimal | null;
    nota2_itmatriz: Decimal | null;
    nota3_itmatriz: Decimal | null;
  };

  export type ItmatrizSumAggregateOutputType = {
    codmat_itmatriz: number | null;
    cod_itmatriz: number | null;
    nota1_itmatriz: Decimal | null;
    nota2_itmatriz: Decimal | null;
    nota3_itmatriz: Decimal | null;
  };

  export type ItmatrizMinAggregateOutputType = {
    codmat_itmatriz: number | null;
    cod_itmatriz: number | null;
    nota1_itmatriz: Decimal | null;
    nota2_itmatriz: Decimal | null;
    nota3_itmatriz: Decimal | null;
    questao_itmatriz: Uint8Array | null;
  };

  export type ItmatrizMaxAggregateOutputType = {
    codmat_itmatriz: number | null;
    cod_itmatriz: number | null;
    nota1_itmatriz: Decimal | null;
    nota2_itmatriz: Decimal | null;
    nota3_itmatriz: Decimal | null;
    questao_itmatriz: Uint8Array | null;
  };

  export type ItmatrizCountAggregateOutputType = {
    codmat_itmatriz: number;
    cod_itmatriz: number;
    nota1_itmatriz: number;
    nota2_itmatriz: number;
    nota3_itmatriz: number;
    questao_itmatriz: number;
    _all: number;
  };

  export type ItmatrizAvgAggregateInputType = {
    codmat_itmatriz?: true;
    cod_itmatriz?: true;
    nota1_itmatriz?: true;
    nota2_itmatriz?: true;
    nota3_itmatriz?: true;
  };

  export type ItmatrizSumAggregateInputType = {
    codmat_itmatriz?: true;
    cod_itmatriz?: true;
    nota1_itmatriz?: true;
    nota2_itmatriz?: true;
    nota3_itmatriz?: true;
  };

  export type ItmatrizMinAggregateInputType = {
    codmat_itmatriz?: true;
    cod_itmatriz?: true;
    nota1_itmatriz?: true;
    nota2_itmatriz?: true;
    nota3_itmatriz?: true;
    questao_itmatriz?: true;
  };

  export type ItmatrizMaxAggregateInputType = {
    codmat_itmatriz?: true;
    cod_itmatriz?: true;
    nota1_itmatriz?: true;
    nota2_itmatriz?: true;
    nota3_itmatriz?: true;
    questao_itmatriz?: true;
  };

  export type ItmatrizCountAggregateInputType = {
    codmat_itmatriz?: true;
    cod_itmatriz?: true;
    nota1_itmatriz?: true;
    nota2_itmatriz?: true;
    nota3_itmatriz?: true;
    questao_itmatriz?: true;
    _all?: true;
  };

  export type ItmatrizAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which itmatriz to aggregate.
     */
    where?: itmatrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itmatrizs to fetch.
     */
    orderBy?:
      | itmatrizOrderByWithRelationInput
      | itmatrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: itmatrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itmatrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itmatrizs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned itmatrizs
     **/
    _count?: true | ItmatrizCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ItmatrizAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ItmatrizSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ItmatrizMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ItmatrizMaxAggregateInputType;
  };

  export type GetItmatrizAggregateType<T extends ItmatrizAggregateArgs> = {
    [P in keyof T & keyof AggregateItmatriz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItmatriz[P]>
      : GetScalarType<T[P], AggregateItmatriz[P]>;
  };

  export type itmatrizGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: itmatrizWhereInput;
    orderBy?:
      | itmatrizOrderByWithAggregationInput
      | itmatrizOrderByWithAggregationInput[];
    by: ItmatrizScalarFieldEnum[] | ItmatrizScalarFieldEnum;
    having?: itmatrizScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ItmatrizCountAggregateInputType | true;
    _avg?: ItmatrizAvgAggregateInputType;
    _sum?: ItmatrizSumAggregateInputType;
    _min?: ItmatrizMinAggregateInputType;
    _max?: ItmatrizMaxAggregateInputType;
  };

  export type ItmatrizGroupByOutputType = {
    codmat_itmatriz: number;
    cod_itmatriz: number;
    nota1_itmatriz: Decimal;
    nota2_itmatriz: Decimal;
    nota3_itmatriz: Decimal;
    questao_itmatriz: Uint8Array | null;
    _count: ItmatrizCountAggregateOutputType | null;
    _avg: ItmatrizAvgAggregateOutputType | null;
    _sum: ItmatrizSumAggregateOutputType | null;
    _min: ItmatrizMinAggregateOutputType | null;
    _max: ItmatrizMaxAggregateOutputType | null;
  };

  type GetItmatrizGroupByPayload<T extends itmatrizGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ItmatrizGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ItmatrizGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItmatrizGroupByOutputType[P]>
            : GetScalarType<T[P], ItmatrizGroupByOutputType[P]>;
        }
      >
    >;

  export type itmatrizSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codmat_itmatriz?: boolean;
      cod_itmatriz?: boolean;
      nota1_itmatriz?: boolean;
      nota2_itmatriz?: boolean;
      nota3_itmatriz?: boolean;
      questao_itmatriz?: boolean;
      itavaliado?: boolean | itmatriz$itavaliadoArgs<ExtArgs>;
      matriz?: boolean | matrizDefaultArgs<ExtArgs>;
      _count?: boolean | ItmatrizCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['itmatriz']
  >;

  export type itmatrizSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codmat_itmatriz?: boolean;
      cod_itmatriz?: boolean;
      nota1_itmatriz?: boolean;
      nota2_itmatriz?: boolean;
      nota3_itmatriz?: boolean;
      questao_itmatriz?: boolean;
      matriz?: boolean | matrizDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['itmatriz']
  >;

  export type itmatrizSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codmat_itmatriz?: boolean;
      cod_itmatriz?: boolean;
      nota1_itmatriz?: boolean;
      nota2_itmatriz?: boolean;
      nota3_itmatriz?: boolean;
      questao_itmatriz?: boolean;
      matriz?: boolean | matrizDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['itmatriz']
  >;

  export type itmatrizSelectScalar = {
    codmat_itmatriz?: boolean;
    cod_itmatriz?: boolean;
    nota1_itmatriz?: boolean;
    nota2_itmatriz?: boolean;
    nota3_itmatriz?: boolean;
    questao_itmatriz?: boolean;
  };

  export type itmatrizOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'codmat_itmatriz'
    | 'cod_itmatriz'
    | 'nota1_itmatriz'
    | 'nota2_itmatriz'
    | 'nota3_itmatriz'
    | 'questao_itmatriz',
    ExtArgs['result']['itmatriz']
  >;
  export type itmatrizInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    itavaliado?: boolean | itmatriz$itavaliadoArgs<ExtArgs>;
    matriz?: boolean | matrizDefaultArgs<ExtArgs>;
    _count?: boolean | ItmatrizCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type itmatrizIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    matriz?: boolean | matrizDefaultArgs<ExtArgs>;
  };
  export type itmatrizIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    matriz?: boolean | matrizDefaultArgs<ExtArgs>;
  };

  export type $itmatrizPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'itmatriz';
    objects: {
      itavaliado: Prisma.$itavaliadoPayload<ExtArgs>[];
      matriz: Prisma.$matrizPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        codmat_itmatriz: number;
        cod_itmatriz: number;
        nota1_itmatriz: Prisma.Decimal;
        nota2_itmatriz: Prisma.Decimal;
        nota3_itmatriz: Prisma.Decimal;
        questao_itmatriz: Uint8Array | null;
      },
      ExtArgs['result']['itmatriz']
    >;
    composites: {};
  };

  type itmatrizGetPayload<
    S extends boolean | null | undefined | itmatrizDefaultArgs,
  > = $Result.GetResult<Prisma.$itmatrizPayload, S>;

  type itmatrizCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<itmatrizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ItmatrizCountAggregateInputType | true;
  };

  export interface itmatrizDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['itmatriz'];
      meta: { name: 'itmatriz' };
    };
    /**
     * Find zero or one Itmatriz that matches the filter.
     * @param {itmatrizFindUniqueArgs} args - Arguments to find a Itmatriz
     * @example
     * // Get one Itmatriz
     * const itmatriz = await prisma.itmatriz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itmatrizFindUniqueArgs>(
      args: SelectSubset<T, itmatrizFindUniqueArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Itmatriz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itmatrizFindUniqueOrThrowArgs} args - Arguments to find a Itmatriz
     * @example
     * // Get one Itmatriz
     * const itmatriz = await prisma.itmatriz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itmatrizFindUniqueOrThrowArgs>(
      args: SelectSubset<T, itmatrizFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Itmatriz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itmatrizFindFirstArgs} args - Arguments to find a Itmatriz
     * @example
     * // Get one Itmatriz
     * const itmatriz = await prisma.itmatriz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itmatrizFindFirstArgs>(
      args?: SelectSubset<T, itmatrizFindFirstArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Itmatriz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itmatrizFindFirstOrThrowArgs} args - Arguments to find a Itmatriz
     * @example
     * // Get one Itmatriz
     * const itmatriz = await prisma.itmatriz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itmatrizFindFirstOrThrowArgs>(
      args?: SelectSubset<T, itmatrizFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Itmatrizs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itmatrizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itmatrizs
     * const itmatrizs = await prisma.itmatriz.findMany()
     *
     * // Get first 10 Itmatrizs
     * const itmatrizs = await prisma.itmatriz.findMany({ take: 10 })
     *
     * // Only select the `codmat_itmatriz`
     * const itmatrizWithCodmat_itmatrizOnly = await prisma.itmatriz.findMany({ select: { codmat_itmatriz: true } })
     *
     */
    findMany<T extends itmatrizFindManyArgs>(
      args?: SelectSubset<T, itmatrizFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Itmatriz.
     * @param {itmatrizCreateArgs} args - Arguments to create a Itmatriz.
     * @example
     * // Create one Itmatriz
     * const Itmatriz = await prisma.itmatriz.create({
     *   data: {
     *     // ... data to create a Itmatriz
     *   }
     * })
     *
     */
    create<T extends itmatrizCreateArgs>(
      args: SelectSubset<T, itmatrizCreateArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Itmatrizs.
     * @param {itmatrizCreateManyArgs} args - Arguments to create many Itmatrizs.
     * @example
     * // Create many Itmatrizs
     * const itmatriz = await prisma.itmatriz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends itmatrizCreateManyArgs>(
      args?: SelectSubset<T, itmatrizCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Itmatrizs and returns the data saved in the database.
     * @param {itmatrizCreateManyAndReturnArgs} args - Arguments to create many Itmatrizs.
     * @example
     * // Create many Itmatrizs
     * const itmatriz = await prisma.itmatriz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Itmatrizs and only return the `codmat_itmatriz`
     * const itmatrizWithCodmat_itmatrizOnly = await prisma.itmatriz.createManyAndReturn({
     *   select: { codmat_itmatriz: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends itmatrizCreateManyAndReturnArgs>(
      args?: SelectSubset<T, itmatrizCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Itmatriz.
     * @param {itmatrizDeleteArgs} args - Arguments to delete one Itmatriz.
     * @example
     * // Delete one Itmatriz
     * const Itmatriz = await prisma.itmatriz.delete({
     *   where: {
     *     // ... filter to delete one Itmatriz
     *   }
     * })
     *
     */
    delete<T extends itmatrizDeleteArgs>(
      args: SelectSubset<T, itmatrizDeleteArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Itmatriz.
     * @param {itmatrizUpdateArgs} args - Arguments to update one Itmatriz.
     * @example
     * // Update one Itmatriz
     * const itmatriz = await prisma.itmatriz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends itmatrizUpdateArgs>(
      args: SelectSubset<T, itmatrizUpdateArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Itmatrizs.
     * @param {itmatrizDeleteManyArgs} args - Arguments to filter Itmatrizs to delete.
     * @example
     * // Delete a few Itmatrizs
     * const { count } = await prisma.itmatriz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends itmatrizDeleteManyArgs>(
      args?: SelectSubset<T, itmatrizDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Itmatrizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itmatrizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itmatrizs
     * const itmatriz = await prisma.itmatriz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends itmatrizUpdateManyArgs>(
      args: SelectSubset<T, itmatrizUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Itmatrizs and returns the data updated in the database.
     * @param {itmatrizUpdateManyAndReturnArgs} args - Arguments to update many Itmatrizs.
     * @example
     * // Update many Itmatrizs
     * const itmatriz = await prisma.itmatriz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Itmatrizs and only return the `codmat_itmatriz`
     * const itmatrizWithCodmat_itmatrizOnly = await prisma.itmatriz.updateManyAndReturn({
     *   select: { codmat_itmatriz: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends itmatrizUpdateManyAndReturnArgs>(
      args: SelectSubset<T, itmatrizUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Itmatriz.
     * @param {itmatrizUpsertArgs} args - Arguments to update or create a Itmatriz.
     * @example
     * // Update or create a Itmatriz
     * const itmatriz = await prisma.itmatriz.upsert({
     *   create: {
     *     // ... data to create a Itmatriz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itmatriz we want to update
     *   }
     * })
     */
    upsert<T extends itmatrizUpsertArgs>(
      args: SelectSubset<T, itmatrizUpsertArgs<ExtArgs>>,
    ): Prisma__itmatrizClient<
      $Result.GetResult<
        Prisma.$itmatrizPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Itmatrizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itmatrizCountArgs} args - Arguments to filter Itmatrizs to count.
     * @example
     * // Count the number of Itmatrizs
     * const count = await prisma.itmatriz.count({
     *   where: {
     *     // ... the filter for the Itmatrizs we want to count
     *   }
     * })
     **/
    count<T extends itmatrizCountArgs>(
      args?: Subset<T, itmatrizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItmatrizCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Itmatriz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItmatrizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ItmatrizAggregateArgs>(
      args: Subset<T, ItmatrizAggregateArgs>,
    ): Prisma.PrismaPromise<GetItmatrizAggregateType<T>>;

    /**
     * Group by Itmatriz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itmatrizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends itmatrizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itmatrizGroupByArgs['orderBy'] }
        : { orderBy?: itmatrizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, itmatrizGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetItmatrizGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the itmatriz model
     */
    readonly fields: itmatrizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itmatriz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itmatrizClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    itavaliado<T extends itmatriz$itavaliadoArgs<ExtArgs> = {}>(
      args?: Subset<T, itmatriz$itavaliadoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$itavaliadoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    matriz<T extends matrizDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, matrizDefaultArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      | $Result.GetResult<
          Prisma.$matrizPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the itmatriz model
   */
  interface itmatrizFieldRefs {
    readonly codmat_itmatriz: FieldRef<'itmatriz', 'Int'>;
    readonly cod_itmatriz: FieldRef<'itmatriz', 'Int'>;
    readonly nota1_itmatriz: FieldRef<'itmatriz', 'Decimal'>;
    readonly nota2_itmatriz: FieldRef<'itmatriz', 'Decimal'>;
    readonly nota3_itmatriz: FieldRef<'itmatriz', 'Decimal'>;
    readonly questao_itmatriz: FieldRef<'itmatriz', 'Bytes'>;
  }

  // Custom InputTypes
  /**
   * itmatriz findUnique
   */
  export type itmatrizFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * Filter, which itmatriz to fetch.
     */
    where: itmatrizWhereUniqueInput;
  };

  /**
   * itmatriz findUniqueOrThrow
   */
  export type itmatrizFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * Filter, which itmatriz to fetch.
     */
    where: itmatrizWhereUniqueInput;
  };

  /**
   * itmatriz findFirst
   */
  export type itmatrizFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * Filter, which itmatriz to fetch.
     */
    where?: itmatrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itmatrizs to fetch.
     */
    orderBy?:
      | itmatrizOrderByWithRelationInput
      | itmatrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for itmatrizs.
     */
    cursor?: itmatrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itmatrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itmatrizs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of itmatrizs.
     */
    distinct?: ItmatrizScalarFieldEnum | ItmatrizScalarFieldEnum[];
  };

  /**
   * itmatriz findFirstOrThrow
   */
  export type itmatrizFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * Filter, which itmatriz to fetch.
     */
    where?: itmatrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itmatrizs to fetch.
     */
    orderBy?:
      | itmatrizOrderByWithRelationInput
      | itmatrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for itmatrizs.
     */
    cursor?: itmatrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itmatrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itmatrizs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of itmatrizs.
     */
    distinct?: ItmatrizScalarFieldEnum | ItmatrizScalarFieldEnum[];
  };

  /**
   * itmatriz findMany
   */
  export type itmatrizFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * Filter, which itmatrizs to fetch.
     */
    where?: itmatrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of itmatrizs to fetch.
     */
    orderBy?:
      | itmatrizOrderByWithRelationInput
      | itmatrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing itmatrizs.
     */
    cursor?: itmatrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` itmatrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` itmatrizs.
     */
    skip?: number;
    distinct?: ItmatrizScalarFieldEnum | ItmatrizScalarFieldEnum[];
  };

  /**
   * itmatriz create
   */
  export type itmatrizCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * The data needed to create a itmatriz.
     */
    data: XOR<itmatrizCreateInput, itmatrizUncheckedCreateInput>;
  };

  /**
   * itmatriz createMany
   */
  export type itmatrizCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many itmatrizs.
     */
    data: itmatrizCreateManyInput | itmatrizCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * itmatriz createManyAndReturn
   */
  export type itmatrizCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * The data used to create many itmatrizs.
     */
    data: itmatrizCreateManyInput | itmatrizCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * itmatriz update
   */
  export type itmatrizUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * The data needed to update a itmatriz.
     */
    data: XOR<itmatrizUpdateInput, itmatrizUncheckedUpdateInput>;
    /**
     * Choose, which itmatriz to update.
     */
    where: itmatrizWhereUniqueInput;
  };

  /**
   * itmatriz updateMany
   */
  export type itmatrizUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update itmatrizs.
     */
    data: XOR<
      itmatrizUpdateManyMutationInput,
      itmatrizUncheckedUpdateManyInput
    >;
    /**
     * Filter which itmatrizs to update
     */
    where?: itmatrizWhereInput;
    /**
     * Limit how many itmatrizs to update.
     */
    limit?: number;
  };

  /**
   * itmatriz updateManyAndReturn
   */
  export type itmatrizUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * The data used to update itmatrizs.
     */
    data: XOR<
      itmatrizUpdateManyMutationInput,
      itmatrizUncheckedUpdateManyInput
    >;
    /**
     * Filter which itmatrizs to update
     */
    where?: itmatrizWhereInput;
    /**
     * Limit how many itmatrizs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * itmatriz upsert
   */
  export type itmatrizUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * The filter to search for the itmatriz to update in case it exists.
     */
    where: itmatrizWhereUniqueInput;
    /**
     * In case the itmatriz found by the `where` argument doesn't exist, create a new itmatriz with this data.
     */
    create: XOR<itmatrizCreateInput, itmatrizUncheckedCreateInput>;
    /**
     * In case the itmatriz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itmatrizUpdateInput, itmatrizUncheckedUpdateInput>;
  };

  /**
   * itmatriz delete
   */
  export type itmatrizDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    /**
     * Filter which itmatriz to delete.
     */
    where: itmatrizWhereUniqueInput;
  };

  /**
   * itmatriz deleteMany
   */
  export type itmatrizDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which itmatrizs to delete
     */
    where?: itmatrizWhereInput;
    /**
     * Limit how many itmatrizs to delete.
     */
    limit?: number;
  };

  /**
   * itmatriz.itavaliado
   */
  export type itmatriz$itavaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itavaliado
     */
    select?: itavaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itavaliado
     */
    omit?: itavaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itavaliadoInclude<ExtArgs> | null;
    where?: itavaliadoWhereInput;
    orderBy?:
      | itavaliadoOrderByWithRelationInput
      | itavaliadoOrderByWithRelationInput[];
    cursor?: itavaliadoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItavaliadoScalarFieldEnum | ItavaliadoScalarFieldEnum[];
  };

  /**
   * itmatriz without action
   */
  export type itmatrizDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
  };

  /**
   * Model layout
   */

  export type AggregateLayout = {
    _count: LayoutCountAggregateOutputType | null;
    _avg: LayoutAvgAggregateOutputType | null;
    _sum: LayoutSumAggregateOutputType | null;
    _min: LayoutMinAggregateOutputType | null;
    _max: LayoutMaxAggregateOutputType | null;
  };

  export type LayoutAvgAggregateOutputType = {
    cod_layout: number | null;
    posicao_layout: number | null;
  };

  export type LayoutSumAggregateOutputType = {
    cod_layout: number | null;
    posicao_layout: number | null;
  };

  export type LayoutMinAggregateOutputType = {
    cod_layout: number | null;
    tabela_layout: string | null;
    campo_layout: string | null;
    posicao_layout: number | null;
  };

  export type LayoutMaxAggregateOutputType = {
    cod_layout: number | null;
    tabela_layout: string | null;
    campo_layout: string | null;
    posicao_layout: number | null;
  };

  export type LayoutCountAggregateOutputType = {
    cod_layout: number;
    tabela_layout: number;
    campo_layout: number;
    posicao_layout: number;
    _all: number;
  };

  export type LayoutAvgAggregateInputType = {
    cod_layout?: true;
    posicao_layout?: true;
  };

  export type LayoutSumAggregateInputType = {
    cod_layout?: true;
    posicao_layout?: true;
  };

  export type LayoutMinAggregateInputType = {
    cod_layout?: true;
    tabela_layout?: true;
    campo_layout?: true;
    posicao_layout?: true;
  };

  export type LayoutMaxAggregateInputType = {
    cod_layout?: true;
    tabela_layout?: true;
    campo_layout?: true;
    posicao_layout?: true;
  };

  export type LayoutCountAggregateInputType = {
    cod_layout?: true;
    tabela_layout?: true;
    campo_layout?: true;
    posicao_layout?: true;
    _all?: true;
  };

  export type LayoutAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which layout to aggregate.
     */
    where?: layoutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of layouts to fetch.
     */
    orderBy?: layoutOrderByWithRelationInput | layoutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: layoutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` layouts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` layouts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned layouts
     **/
    _count?: true | LayoutCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: LayoutAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: LayoutSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LayoutMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LayoutMaxAggregateInputType;
  };

  export type GetLayoutAggregateType<T extends LayoutAggregateArgs> = {
    [P in keyof T & keyof AggregateLayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLayout[P]>
      : GetScalarType<T[P], AggregateLayout[P]>;
  };

  export type layoutGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: layoutWhereInput;
    orderBy?:
      | layoutOrderByWithAggregationInput
      | layoutOrderByWithAggregationInput[];
    by: LayoutScalarFieldEnum[] | LayoutScalarFieldEnum;
    having?: layoutScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LayoutCountAggregateInputType | true;
    _avg?: LayoutAvgAggregateInputType;
    _sum?: LayoutSumAggregateInputType;
    _min?: LayoutMinAggregateInputType;
    _max?: LayoutMaxAggregateInputType;
  };

  export type LayoutGroupByOutputType = {
    cod_layout: number;
    tabela_layout: string | null;
    campo_layout: string | null;
    posicao_layout: number | null;
    _count: LayoutCountAggregateOutputType | null;
    _avg: LayoutAvgAggregateOutputType | null;
    _sum: LayoutSumAggregateOutputType | null;
    _min: LayoutMinAggregateOutputType | null;
    _max: LayoutMaxAggregateOutputType | null;
  };

  type GetLayoutGroupByPayload<T extends layoutGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LayoutGroupByOutputType, T['by']> & {
          [P in keyof T & keyof LayoutGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LayoutGroupByOutputType[P]>
            : GetScalarType<T[P], LayoutGroupByOutputType[P]>;
        }
      >
    >;

  export type layoutSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_layout?: boolean;
      tabela_layout?: boolean;
      campo_layout?: boolean;
      posicao_layout?: boolean;
    },
    ExtArgs['result']['layout']
  >;

  export type layoutSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_layout?: boolean;
      tabela_layout?: boolean;
      campo_layout?: boolean;
      posicao_layout?: boolean;
    },
    ExtArgs['result']['layout']
  >;

  export type layoutSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_layout?: boolean;
      tabela_layout?: boolean;
      campo_layout?: boolean;
      posicao_layout?: boolean;
    },
    ExtArgs['result']['layout']
  >;

  export type layoutSelectScalar = {
    cod_layout?: boolean;
    tabela_layout?: boolean;
    campo_layout?: boolean;
    posicao_layout?: boolean;
  };

  export type layoutOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_layout' | 'tabela_layout' | 'campo_layout' | 'posicao_layout',
    ExtArgs['result']['layout']
  >;

  export type $layoutPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'layout';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_layout: number;
        tabela_layout: string | null;
        campo_layout: string | null;
        posicao_layout: number | null;
      },
      ExtArgs['result']['layout']
    >;
    composites: {};
  };

  type layoutGetPayload<
    S extends boolean | null | undefined | layoutDefaultArgs,
  > = $Result.GetResult<Prisma.$layoutPayload, S>;

  type layoutCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<layoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: LayoutCountAggregateInputType | true;
  };

  export interface layoutDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['layout'];
      meta: { name: 'layout' };
    };
    /**
     * Find zero or one Layout that matches the filter.
     * @param {layoutFindUniqueArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends layoutFindUniqueArgs>(
      args: SelectSubset<T, layoutFindUniqueArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Layout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {layoutFindUniqueOrThrowArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends layoutFindUniqueOrThrowArgs>(
      args: SelectSubset<T, layoutFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Layout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layoutFindFirstArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends layoutFindFirstArgs>(
      args?: SelectSubset<T, layoutFindFirstArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Layout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layoutFindFirstOrThrowArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends layoutFindFirstOrThrowArgs>(
      args?: SelectSubset<T, layoutFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Layouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Layouts
     * const layouts = await prisma.layout.findMany()
     *
     * // Get first 10 Layouts
     * const layouts = await prisma.layout.findMany({ take: 10 })
     *
     * // Only select the `cod_layout`
     * const layoutWithCod_layoutOnly = await prisma.layout.findMany({ select: { cod_layout: true } })
     *
     */
    findMany<T extends layoutFindManyArgs>(
      args?: SelectSubset<T, layoutFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Layout.
     * @param {layoutCreateArgs} args - Arguments to create a Layout.
     * @example
     * // Create one Layout
     * const Layout = await prisma.layout.create({
     *   data: {
     *     // ... data to create a Layout
     *   }
     * })
     *
     */
    create<T extends layoutCreateArgs>(
      args: SelectSubset<T, layoutCreateArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Layouts.
     * @param {layoutCreateManyArgs} args - Arguments to create many Layouts.
     * @example
     * // Create many Layouts
     * const layout = await prisma.layout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends layoutCreateManyArgs>(
      args?: SelectSubset<T, layoutCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Layouts and returns the data saved in the database.
     * @param {layoutCreateManyAndReturnArgs} args - Arguments to create many Layouts.
     * @example
     * // Create many Layouts
     * const layout = await prisma.layout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Layouts and only return the `cod_layout`
     * const layoutWithCod_layoutOnly = await prisma.layout.createManyAndReturn({
     *   select: { cod_layout: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends layoutCreateManyAndReturnArgs>(
      args?: SelectSubset<T, layoutCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Layout.
     * @param {layoutDeleteArgs} args - Arguments to delete one Layout.
     * @example
     * // Delete one Layout
     * const Layout = await prisma.layout.delete({
     *   where: {
     *     // ... filter to delete one Layout
     *   }
     * })
     *
     */
    delete<T extends layoutDeleteArgs>(
      args: SelectSubset<T, layoutDeleteArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Layout.
     * @param {layoutUpdateArgs} args - Arguments to update one Layout.
     * @example
     * // Update one Layout
     * const layout = await prisma.layout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends layoutUpdateArgs>(
      args: SelectSubset<T, layoutUpdateArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Layouts.
     * @param {layoutDeleteManyArgs} args - Arguments to filter Layouts to delete.
     * @example
     * // Delete a few Layouts
     * const { count } = await prisma.layout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends layoutDeleteManyArgs>(
      args?: SelectSubset<T, layoutDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Layouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Layouts
     * const layout = await prisma.layout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends layoutUpdateManyArgs>(
      args: SelectSubset<T, layoutUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Layouts and returns the data updated in the database.
     * @param {layoutUpdateManyAndReturnArgs} args - Arguments to update many Layouts.
     * @example
     * // Update many Layouts
     * const layout = await prisma.layout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Layouts and only return the `cod_layout`
     * const layoutWithCod_layoutOnly = await prisma.layout.updateManyAndReturn({
     *   select: { cod_layout: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends layoutUpdateManyAndReturnArgs>(
      args: SelectSubset<T, layoutUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Layout.
     * @param {layoutUpsertArgs} args - Arguments to update or create a Layout.
     * @example
     * // Update or create a Layout
     * const layout = await prisma.layout.upsert({
     *   create: {
     *     // ... data to create a Layout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Layout we want to update
     *   }
     * })
     */
    upsert<T extends layoutUpsertArgs>(
      args: SelectSubset<T, layoutUpsertArgs<ExtArgs>>,
    ): Prisma__layoutClient<
      $Result.GetResult<
        Prisma.$layoutPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Layouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layoutCountArgs} args - Arguments to filter Layouts to count.
     * @example
     * // Count the number of Layouts
     * const count = await prisma.layout.count({
     *   where: {
     *     // ... the filter for the Layouts we want to count
     *   }
     * })
     **/
    count<T extends layoutCountArgs>(
      args?: Subset<T, layoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LayoutCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Layout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LayoutAggregateArgs>(
      args: Subset<T, LayoutAggregateArgs>,
    ): Prisma.PrismaPromise<GetLayoutAggregateType<T>>;

    /**
     * Group by Layout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {layoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends layoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: layoutGroupByArgs['orderBy'] }
        : { orderBy?: layoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, layoutGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetLayoutGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the layout model
     */
    readonly fields: layoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for layout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__layoutClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the layout model
   */
  interface layoutFieldRefs {
    readonly cod_layout: FieldRef<'layout', 'Int'>;
    readonly tabela_layout: FieldRef<'layout', 'String'>;
    readonly campo_layout: FieldRef<'layout', 'String'>;
    readonly posicao_layout: FieldRef<'layout', 'Int'>;
  }

  // Custom InputTypes
  /**
   * layout findUnique
   */
  export type layoutFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * Filter, which layout to fetch.
     */
    where: layoutWhereUniqueInput;
  };

  /**
   * layout findUniqueOrThrow
   */
  export type layoutFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * Filter, which layout to fetch.
     */
    where: layoutWhereUniqueInput;
  };

  /**
   * layout findFirst
   */
  export type layoutFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * Filter, which layout to fetch.
     */
    where?: layoutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of layouts to fetch.
     */
    orderBy?: layoutOrderByWithRelationInput | layoutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for layouts.
     */
    cursor?: layoutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` layouts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` layouts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of layouts.
     */
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[];
  };

  /**
   * layout findFirstOrThrow
   */
  export type layoutFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * Filter, which layout to fetch.
     */
    where?: layoutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of layouts to fetch.
     */
    orderBy?: layoutOrderByWithRelationInput | layoutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for layouts.
     */
    cursor?: layoutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` layouts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` layouts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of layouts.
     */
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[];
  };

  /**
   * layout findMany
   */
  export type layoutFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * Filter, which layouts to fetch.
     */
    where?: layoutWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of layouts to fetch.
     */
    orderBy?: layoutOrderByWithRelationInput | layoutOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing layouts.
     */
    cursor?: layoutWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` layouts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` layouts.
     */
    skip?: number;
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[];
  };

  /**
   * layout create
   */
  export type layoutCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * The data needed to create a layout.
     */
    data: XOR<layoutCreateInput, layoutUncheckedCreateInput>;
  };

  /**
   * layout createMany
   */
  export type layoutCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many layouts.
     */
    data: layoutCreateManyInput | layoutCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * layout createManyAndReturn
   */
  export type layoutCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * The data used to create many layouts.
     */
    data: layoutCreateManyInput | layoutCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * layout update
   */
  export type layoutUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * The data needed to update a layout.
     */
    data: XOR<layoutUpdateInput, layoutUncheckedUpdateInput>;
    /**
     * Choose, which layout to update.
     */
    where: layoutWhereUniqueInput;
  };

  /**
   * layout updateMany
   */
  export type layoutUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update layouts.
     */
    data: XOR<layoutUpdateManyMutationInput, layoutUncheckedUpdateManyInput>;
    /**
     * Filter which layouts to update
     */
    where?: layoutWhereInput;
    /**
     * Limit how many layouts to update.
     */
    limit?: number;
  };

  /**
   * layout updateManyAndReturn
   */
  export type layoutUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * The data used to update layouts.
     */
    data: XOR<layoutUpdateManyMutationInput, layoutUncheckedUpdateManyInput>;
    /**
     * Filter which layouts to update
     */
    where?: layoutWhereInput;
    /**
     * Limit how many layouts to update.
     */
    limit?: number;
  };

  /**
   * layout upsert
   */
  export type layoutUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * The filter to search for the layout to update in case it exists.
     */
    where: layoutWhereUniqueInput;
    /**
     * In case the layout found by the `where` argument doesn't exist, create a new layout with this data.
     */
    create: XOR<layoutCreateInput, layoutUncheckedCreateInput>;
    /**
     * In case the layout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<layoutUpdateInput, layoutUncheckedUpdateInput>;
  };

  /**
   * layout delete
   */
  export type layoutDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
    /**
     * Filter which layout to delete.
     */
    where: layoutWhereUniqueInput;
  };

  /**
   * layout deleteMany
   */
  export type layoutDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which layouts to delete
     */
    where?: layoutWhereInput;
    /**
     * Limit how many layouts to delete.
     */
    limit?: number;
  };

  /**
   * layout without action
   */
  export type layoutDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the layout
     */
    select?: layoutSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the layout
     */
    omit?: layoutOmit<ExtArgs> | null;
  };

  /**
   * Model lista
   */

  export type AggregateLista = {
    _count: ListaCountAggregateOutputType | null;
    _avg: ListaAvgAggregateOutputType | null;
    _sum: ListaSumAggregateOutputType | null;
    _min: ListaMinAggregateOutputType | null;
    _max: ListaMaxAggregateOutputType | null;
  };

  export type ListaAvgAggregateOutputType = {
    cod_lista: number | null;
    cod_grupo: number | null;
    cod_status: number | null;
  };

  export type ListaSumAggregateOutputType = {
    cod_lista: number | null;
    cod_grupo: number | null;
    cod_status: number | null;
  };

  export type ListaMinAggregateOutputType = {
    cod_lista: number | null;
    cod_grupo: number | null;
    cod_status: number | null;
    cgccpf_lista: string | null;
    id_lista: string | null;
    nome_lista: string | null;
    end_lista: string | null;
    num_lista: string | null;
    comp_lista: string | null;
    cep_lista: string | null;
    bairro_lista: string | null;
    cidade_lista: string | null;
    uf_lista: string | null;
    email_lista: string | null;
    dtcontactar_lista: Date | null;
    dtcad_lista: Date | null;
    obs_lista: Uint8Array | null;
  };

  export type ListaMaxAggregateOutputType = {
    cod_lista: number | null;
    cod_grupo: number | null;
    cod_status: number | null;
    cgccpf_lista: string | null;
    id_lista: string | null;
    nome_lista: string | null;
    end_lista: string | null;
    num_lista: string | null;
    comp_lista: string | null;
    cep_lista: string | null;
    bairro_lista: string | null;
    cidade_lista: string | null;
    uf_lista: string | null;
    email_lista: string | null;
    dtcontactar_lista: Date | null;
    dtcad_lista: Date | null;
    obs_lista: Uint8Array | null;
  };

  export type ListaCountAggregateOutputType = {
    cod_lista: number;
    cod_grupo: number;
    cod_status: number;
    cgccpf_lista: number;
    id_lista: number;
    nome_lista: number;
    end_lista: number;
    num_lista: number;
    comp_lista: number;
    cep_lista: number;
    bairro_lista: number;
    cidade_lista: number;
    uf_lista: number;
    email_lista: number;
    dtcontactar_lista: number;
    dtcad_lista: number;
    obs_lista: number;
    _all: number;
  };

  export type ListaAvgAggregateInputType = {
    cod_lista?: true;
    cod_grupo?: true;
    cod_status?: true;
  };

  export type ListaSumAggregateInputType = {
    cod_lista?: true;
    cod_grupo?: true;
    cod_status?: true;
  };

  export type ListaMinAggregateInputType = {
    cod_lista?: true;
    cod_grupo?: true;
    cod_status?: true;
    cgccpf_lista?: true;
    id_lista?: true;
    nome_lista?: true;
    end_lista?: true;
    num_lista?: true;
    comp_lista?: true;
    cep_lista?: true;
    bairro_lista?: true;
    cidade_lista?: true;
    uf_lista?: true;
    email_lista?: true;
    dtcontactar_lista?: true;
    dtcad_lista?: true;
    obs_lista?: true;
  };

  export type ListaMaxAggregateInputType = {
    cod_lista?: true;
    cod_grupo?: true;
    cod_status?: true;
    cgccpf_lista?: true;
    id_lista?: true;
    nome_lista?: true;
    end_lista?: true;
    num_lista?: true;
    comp_lista?: true;
    cep_lista?: true;
    bairro_lista?: true;
    cidade_lista?: true;
    uf_lista?: true;
    email_lista?: true;
    dtcontactar_lista?: true;
    dtcad_lista?: true;
    obs_lista?: true;
  };

  export type ListaCountAggregateInputType = {
    cod_lista?: true;
    cod_grupo?: true;
    cod_status?: true;
    cgccpf_lista?: true;
    id_lista?: true;
    nome_lista?: true;
    end_lista?: true;
    num_lista?: true;
    comp_lista?: true;
    cep_lista?: true;
    bairro_lista?: true;
    cidade_lista?: true;
    uf_lista?: true;
    email_lista?: true;
    dtcontactar_lista?: true;
    dtcad_lista?: true;
    obs_lista?: true;
    _all?: true;
  };

  export type ListaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which lista to aggregate.
     */
    where?: listaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: listaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` listas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` listas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned listas
     **/
    _count?: true | ListaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ListaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ListaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ListaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ListaMaxAggregateInputType;
  };

  export type GetListaAggregateType<T extends ListaAggregateArgs> = {
    [P in keyof T & keyof AggregateLista]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLista[P]>
      : GetScalarType<T[P], AggregateLista[P]>;
  };

  export type listaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: listaWhereInput;
    orderBy?:
      | listaOrderByWithAggregationInput
      | listaOrderByWithAggregationInput[];
    by: ListaScalarFieldEnum[] | ListaScalarFieldEnum;
    having?: listaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ListaCountAggregateInputType | true;
    _avg?: ListaAvgAggregateInputType;
    _sum?: ListaSumAggregateInputType;
    _min?: ListaMinAggregateInputType;
    _max?: ListaMaxAggregateInputType;
  };

  export type ListaGroupByOutputType = {
    cod_lista: number;
    cod_grupo: number;
    cod_status: number;
    cgccpf_lista: string;
    id_lista: string | null;
    nome_lista: string;
    end_lista: string | null;
    num_lista: string | null;
    comp_lista: string | null;
    cep_lista: string | null;
    bairro_lista: string | null;
    cidade_lista: string | null;
    uf_lista: string | null;
    email_lista: string | null;
    dtcontactar_lista: Date;
    dtcad_lista: Date;
    obs_lista: Uint8Array | null;
    _count: ListaCountAggregateOutputType | null;
    _avg: ListaAvgAggregateOutputType | null;
    _sum: ListaSumAggregateOutputType | null;
    _min: ListaMinAggregateOutputType | null;
    _max: ListaMaxAggregateOutputType | null;
  };

  type GetListaGroupByPayload<T extends listaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ListaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ListaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListaGroupByOutputType[P]>
            : GetScalarType<T[P], ListaGroupByOutputType[P]>;
        }
      >
    >;

  export type listaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_lista?: boolean;
      cod_grupo?: boolean;
      cod_status?: boolean;
      cgccpf_lista?: boolean;
      id_lista?: boolean;
      nome_lista?: boolean;
      end_lista?: boolean;
      num_lista?: boolean;
      comp_lista?: boolean;
      cep_lista?: boolean;
      bairro_lista?: boolean;
      cidade_lista?: boolean;
      uf_lista?: boolean;
      email_lista?: boolean;
      dtcontactar_lista?: boolean;
      dtcad_lista?: boolean;
      obs_lista?: boolean;
    },
    ExtArgs['result']['lista']
  >;

  export type listaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_lista?: boolean;
      cod_grupo?: boolean;
      cod_status?: boolean;
      cgccpf_lista?: boolean;
      id_lista?: boolean;
      nome_lista?: boolean;
      end_lista?: boolean;
      num_lista?: boolean;
      comp_lista?: boolean;
      cep_lista?: boolean;
      bairro_lista?: boolean;
      cidade_lista?: boolean;
      uf_lista?: boolean;
      email_lista?: boolean;
      dtcontactar_lista?: boolean;
      dtcad_lista?: boolean;
      obs_lista?: boolean;
    },
    ExtArgs['result']['lista']
  >;

  export type listaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_lista?: boolean;
      cod_grupo?: boolean;
      cod_status?: boolean;
      cgccpf_lista?: boolean;
      id_lista?: boolean;
      nome_lista?: boolean;
      end_lista?: boolean;
      num_lista?: boolean;
      comp_lista?: boolean;
      cep_lista?: boolean;
      bairro_lista?: boolean;
      cidade_lista?: boolean;
      uf_lista?: boolean;
      email_lista?: boolean;
      dtcontactar_lista?: boolean;
      dtcad_lista?: boolean;
      obs_lista?: boolean;
    },
    ExtArgs['result']['lista']
  >;

  export type listaSelectScalar = {
    cod_lista?: boolean;
    cod_grupo?: boolean;
    cod_status?: boolean;
    cgccpf_lista?: boolean;
    id_lista?: boolean;
    nome_lista?: boolean;
    end_lista?: boolean;
    num_lista?: boolean;
    comp_lista?: boolean;
    cep_lista?: boolean;
    bairro_lista?: boolean;
    cidade_lista?: boolean;
    uf_lista?: boolean;
    email_lista?: boolean;
    dtcontactar_lista?: boolean;
    dtcad_lista?: boolean;
    obs_lista?: boolean;
  };

  export type listaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_lista'
    | 'cod_grupo'
    | 'cod_status'
    | 'cgccpf_lista'
    | 'id_lista'
    | 'nome_lista'
    | 'end_lista'
    | 'num_lista'
    | 'comp_lista'
    | 'cep_lista'
    | 'bairro_lista'
    | 'cidade_lista'
    | 'uf_lista'
    | 'email_lista'
    | 'dtcontactar_lista'
    | 'dtcad_lista'
    | 'obs_lista',
    ExtArgs['result']['lista']
  >;

  export type $listaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'lista';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_lista: number;
        cod_grupo: number;
        cod_status: number;
        cgccpf_lista: string;
        id_lista: string | null;
        nome_lista: string;
        end_lista: string | null;
        num_lista: string | null;
        comp_lista: string | null;
        cep_lista: string | null;
        bairro_lista: string | null;
        cidade_lista: string | null;
        uf_lista: string | null;
        email_lista: string | null;
        dtcontactar_lista: Date;
        dtcad_lista: Date;
        obs_lista: Uint8Array | null;
      },
      ExtArgs['result']['lista']
    >;
    composites: {};
  };

  type listaGetPayload<
    S extends boolean | null | undefined | listaDefaultArgs,
  > = $Result.GetResult<Prisma.$listaPayload, S>;

  type listaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<listaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ListaCountAggregateInputType | true;
  };

  export interface listaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['lista'];
      meta: { name: 'lista' };
    };
    /**
     * Find zero or one Lista that matches the filter.
     * @param {listaFindUniqueArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends listaFindUniqueArgs>(
      args: SelectSubset<T, listaFindUniqueArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Lista that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {listaFindUniqueOrThrowArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends listaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, listaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Lista that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaFindFirstArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends listaFindFirstArgs>(
      args?: SelectSubset<T, listaFindFirstArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Lista that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaFindFirstOrThrowArgs} args - Arguments to find a Lista
     * @example
     * // Get one Lista
     * const lista = await prisma.lista.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends listaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, listaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Listas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listas
     * const listas = await prisma.lista.findMany()
     *
     * // Get first 10 Listas
     * const listas = await prisma.lista.findMany({ take: 10 })
     *
     * // Only select the `cod_lista`
     * const listaWithCod_listaOnly = await prisma.lista.findMany({ select: { cod_lista: true } })
     *
     */
    findMany<T extends listaFindManyArgs>(
      args?: SelectSubset<T, listaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Lista.
     * @param {listaCreateArgs} args - Arguments to create a Lista.
     * @example
     * // Create one Lista
     * const Lista = await prisma.lista.create({
     *   data: {
     *     // ... data to create a Lista
     *   }
     * })
     *
     */
    create<T extends listaCreateArgs>(
      args: SelectSubset<T, listaCreateArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Listas.
     * @param {listaCreateManyArgs} args - Arguments to create many Listas.
     * @example
     * // Create many Listas
     * const lista = await prisma.lista.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends listaCreateManyArgs>(
      args?: SelectSubset<T, listaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Listas and returns the data saved in the database.
     * @param {listaCreateManyAndReturnArgs} args - Arguments to create many Listas.
     * @example
     * // Create many Listas
     * const lista = await prisma.lista.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Listas and only return the `cod_lista`
     * const listaWithCod_listaOnly = await prisma.lista.createManyAndReturn({
     *   select: { cod_lista: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends listaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, listaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Lista.
     * @param {listaDeleteArgs} args - Arguments to delete one Lista.
     * @example
     * // Delete one Lista
     * const Lista = await prisma.lista.delete({
     *   where: {
     *     // ... filter to delete one Lista
     *   }
     * })
     *
     */
    delete<T extends listaDeleteArgs>(
      args: SelectSubset<T, listaDeleteArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Lista.
     * @param {listaUpdateArgs} args - Arguments to update one Lista.
     * @example
     * // Update one Lista
     * const lista = await prisma.lista.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends listaUpdateArgs>(
      args: SelectSubset<T, listaUpdateArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Listas.
     * @param {listaDeleteManyArgs} args - Arguments to filter Listas to delete.
     * @example
     * // Delete a few Listas
     * const { count } = await prisma.lista.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends listaDeleteManyArgs>(
      args?: SelectSubset<T, listaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Listas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listas
     * const lista = await prisma.lista.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends listaUpdateManyArgs>(
      args: SelectSubset<T, listaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Listas and returns the data updated in the database.
     * @param {listaUpdateManyAndReturnArgs} args - Arguments to update many Listas.
     * @example
     * // Update many Listas
     * const lista = await prisma.lista.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Listas and only return the `cod_lista`
     * const listaWithCod_listaOnly = await prisma.lista.updateManyAndReturn({
     *   select: { cod_lista: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends listaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, listaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Lista.
     * @param {listaUpsertArgs} args - Arguments to update or create a Lista.
     * @example
     * // Update or create a Lista
     * const lista = await prisma.lista.upsert({
     *   create: {
     *     // ... data to create a Lista
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lista we want to update
     *   }
     * })
     */
    upsert<T extends listaUpsertArgs>(
      args: SelectSubset<T, listaUpsertArgs<ExtArgs>>,
    ): Prisma__listaClient<
      $Result.GetResult<
        Prisma.$listaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Listas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaCountArgs} args - Arguments to filter Listas to count.
     * @example
     * // Count the number of Listas
     * const count = await prisma.lista.count({
     *   where: {
     *     // ... the filter for the Listas we want to count
     *   }
     * })
     **/
    count<T extends listaCountArgs>(
      args?: Subset<T, listaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Lista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ListaAggregateArgs>(
      args: Subset<T, ListaAggregateArgs>,
    ): Prisma.PrismaPromise<GetListaAggregateType<T>>;

    /**
     * Group by Lista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends listaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: listaGroupByArgs['orderBy'] }
        : { orderBy?: listaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, listaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetListaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the lista model
     */
    readonly fields: listaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lista.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__listaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the lista model
   */
  interface listaFieldRefs {
    readonly cod_lista: FieldRef<'lista', 'Int'>;
    readonly cod_grupo: FieldRef<'lista', 'Int'>;
    readonly cod_status: FieldRef<'lista', 'Int'>;
    readonly cgccpf_lista: FieldRef<'lista', 'String'>;
    readonly id_lista: FieldRef<'lista', 'String'>;
    readonly nome_lista: FieldRef<'lista', 'String'>;
    readonly end_lista: FieldRef<'lista', 'String'>;
    readonly num_lista: FieldRef<'lista', 'String'>;
    readonly comp_lista: FieldRef<'lista', 'String'>;
    readonly cep_lista: FieldRef<'lista', 'String'>;
    readonly bairro_lista: FieldRef<'lista', 'String'>;
    readonly cidade_lista: FieldRef<'lista', 'String'>;
    readonly uf_lista: FieldRef<'lista', 'String'>;
    readonly email_lista: FieldRef<'lista', 'String'>;
    readonly dtcontactar_lista: FieldRef<'lista', 'DateTime'>;
    readonly dtcad_lista: FieldRef<'lista', 'DateTime'>;
    readonly obs_lista: FieldRef<'lista', 'Bytes'>;
  }

  // Custom InputTypes
  /**
   * lista findUnique
   */
  export type listaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * Filter, which lista to fetch.
     */
    where: listaWhereUniqueInput;
  };

  /**
   * lista findUniqueOrThrow
   */
  export type listaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * Filter, which lista to fetch.
     */
    where: listaWhereUniqueInput;
  };

  /**
   * lista findFirst
   */
  export type listaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * Filter, which lista to fetch.
     */
    where?: listaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for listas.
     */
    cursor?: listaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` listas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` listas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of listas.
     */
    distinct?: ListaScalarFieldEnum | ListaScalarFieldEnum[];
  };

  /**
   * lista findFirstOrThrow
   */
  export type listaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * Filter, which lista to fetch.
     */
    where?: listaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for listas.
     */
    cursor?: listaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` listas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` listas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of listas.
     */
    distinct?: ListaScalarFieldEnum | ListaScalarFieldEnum[];
  };

  /**
   * lista findMany
   */
  export type listaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * Filter, which listas to fetch.
     */
    where?: listaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of listas to fetch.
     */
    orderBy?: listaOrderByWithRelationInput | listaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing listas.
     */
    cursor?: listaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` listas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` listas.
     */
    skip?: number;
    distinct?: ListaScalarFieldEnum | ListaScalarFieldEnum[];
  };

  /**
   * lista create
   */
  export type listaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * The data needed to create a lista.
     */
    data: XOR<listaCreateInput, listaUncheckedCreateInput>;
  };

  /**
   * lista createMany
   */
  export type listaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many listas.
     */
    data: listaCreateManyInput | listaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * lista createManyAndReturn
   */
  export type listaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * The data used to create many listas.
     */
    data: listaCreateManyInput | listaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * lista update
   */
  export type listaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * The data needed to update a lista.
     */
    data: XOR<listaUpdateInput, listaUncheckedUpdateInput>;
    /**
     * Choose, which lista to update.
     */
    where: listaWhereUniqueInput;
  };

  /**
   * lista updateMany
   */
  export type listaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update listas.
     */
    data: XOR<listaUpdateManyMutationInput, listaUncheckedUpdateManyInput>;
    /**
     * Filter which listas to update
     */
    where?: listaWhereInput;
    /**
     * Limit how many listas to update.
     */
    limit?: number;
  };

  /**
   * lista updateManyAndReturn
   */
  export type listaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * The data used to update listas.
     */
    data: XOR<listaUpdateManyMutationInput, listaUncheckedUpdateManyInput>;
    /**
     * Filter which listas to update
     */
    where?: listaWhereInput;
    /**
     * Limit how many listas to update.
     */
    limit?: number;
  };

  /**
   * lista upsert
   */
  export type listaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * The filter to search for the lista to update in case it exists.
     */
    where: listaWhereUniqueInput;
    /**
     * In case the lista found by the `where` argument doesn't exist, create a new lista with this data.
     */
    create: XOR<listaCreateInput, listaUncheckedCreateInput>;
    /**
     * In case the lista was found with the provided `where` argument, update it with this data.
     */
    update: XOR<listaUpdateInput, listaUncheckedUpdateInput>;
  };

  /**
   * lista delete
   */
  export type listaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
    /**
     * Filter which lista to delete.
     */
    where: listaWhereUniqueInput;
  };

  /**
   * lista deleteMany
   */
  export type listaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which listas to delete
     */
    where?: listaWhereInput;
    /**
     * Limit how many listas to delete.
     */
    limit?: number;
  };

  /**
   * lista without action
   */
  export type listaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the lista
     */
    select?: listaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the lista
     */
    omit?: listaOmit<ExtArgs> | null;
  };

  /**
   * Model matriz
   */

  export type AggregateMatriz = {
    _count: MatrizCountAggregateOutputType | null;
    _avg: MatrizAvgAggregateOutputType | null;
    _sum: MatrizSumAggregateOutputType | null;
    _min: MatrizMinAggregateOutputType | null;
    _max: MatrizMaxAggregateOutputType | null;
  };

  export type MatrizAvgAggregateOutputType = {
    cod_matriz: number | null;
  };

  export type MatrizSumAggregateOutputType = {
    cod_matriz: number | null;
  };

  export type MatrizMinAggregateOutputType = {
    cod_matriz: number | null;
    desc_matriz: string | null;
    status_matriz: string | null;
  };

  export type MatrizMaxAggregateOutputType = {
    cod_matriz: number | null;
    desc_matriz: string | null;
    status_matriz: string | null;
  };

  export type MatrizCountAggregateOutputType = {
    cod_matriz: number;
    desc_matriz: number;
    status_matriz: number;
    _all: number;
  };

  export type MatrizAvgAggregateInputType = {
    cod_matriz?: true;
  };

  export type MatrizSumAggregateInputType = {
    cod_matriz?: true;
  };

  export type MatrizMinAggregateInputType = {
    cod_matriz?: true;
    desc_matriz?: true;
    status_matriz?: true;
  };

  export type MatrizMaxAggregateInputType = {
    cod_matriz?: true;
    desc_matriz?: true;
    status_matriz?: true;
  };

  export type MatrizCountAggregateInputType = {
    cod_matriz?: true;
    desc_matriz?: true;
    status_matriz?: true;
    _all?: true;
  };

  export type MatrizAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which matriz to aggregate.
     */
    where?: matrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of matrizs to fetch.
     */
    orderBy?: matrizOrderByWithRelationInput | matrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: matrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` matrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` matrizs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned matrizs
     **/
    _count?: true | MatrizCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MatrizAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MatrizSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MatrizMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MatrizMaxAggregateInputType;
  };

  export type GetMatrizAggregateType<T extends MatrizAggregateArgs> = {
    [P in keyof T & keyof AggregateMatriz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatriz[P]>
      : GetScalarType<T[P], AggregateMatriz[P]>;
  };

  export type matrizGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: matrizWhereInput;
    orderBy?:
      | matrizOrderByWithAggregationInput
      | matrizOrderByWithAggregationInput[];
    by: MatrizScalarFieldEnum[] | MatrizScalarFieldEnum;
    having?: matrizScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MatrizCountAggregateInputType | true;
    _avg?: MatrizAvgAggregateInputType;
    _sum?: MatrizSumAggregateInputType;
    _min?: MatrizMinAggregateInputType;
    _max?: MatrizMaxAggregateInputType;
  };

  export type MatrizGroupByOutputType = {
    cod_matriz: number;
    desc_matriz: string;
    status_matriz: string;
    _count: MatrizCountAggregateOutputType | null;
    _avg: MatrizAvgAggregateOutputType | null;
    _sum: MatrizSumAggregateOutputType | null;
    _min: MatrizMinAggregateOutputType | null;
    _max: MatrizMaxAggregateOutputType | null;
  };

  type GetMatrizGroupByPayload<T extends matrizGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MatrizGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MatrizGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrizGroupByOutputType[P]>
            : GetScalarType<T[P], MatrizGroupByOutputType[P]>;
        }
      >
    >;

  export type matrizSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_matriz?: boolean;
      desc_matriz?: boolean;
      status_matriz?: boolean;
      itmatriz?: boolean | matriz$itmatrizArgs<ExtArgs>;
      _count?: boolean | MatrizCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['matriz']
  >;

  export type matrizSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_matriz?: boolean;
      desc_matriz?: boolean;
      status_matriz?: boolean;
    },
    ExtArgs['result']['matriz']
  >;

  export type matrizSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_matriz?: boolean;
      desc_matriz?: boolean;
      status_matriz?: boolean;
    },
    ExtArgs['result']['matriz']
  >;

  export type matrizSelectScalar = {
    cod_matriz?: boolean;
    desc_matriz?: boolean;
    status_matriz?: boolean;
  };

  export type matrizOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_matriz' | 'desc_matriz' | 'status_matriz',
    ExtArgs['result']['matriz']
  >;
  export type matrizInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    itmatriz?: boolean | matriz$itmatrizArgs<ExtArgs>;
    _count?: boolean | MatrizCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type matrizIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type matrizIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $matrizPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'matriz';
    objects: {
      itmatriz: Prisma.$itmatrizPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_matriz: number;
        desc_matriz: string;
        status_matriz: string;
      },
      ExtArgs['result']['matriz']
    >;
    composites: {};
  };

  type matrizGetPayload<
    S extends boolean | null | undefined | matrizDefaultArgs,
  > = $Result.GetResult<Prisma.$matrizPayload, S>;

  type matrizCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<matrizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MatrizCountAggregateInputType | true;
  };

  export interface matrizDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['matriz'];
      meta: { name: 'matriz' };
    };
    /**
     * Find zero or one Matriz that matches the filter.
     * @param {matrizFindUniqueArgs} args - Arguments to find a Matriz
     * @example
     * // Get one Matriz
     * const matriz = await prisma.matriz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends matrizFindUniqueArgs>(
      args: SelectSubset<T, matrizFindUniqueArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Matriz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {matrizFindUniqueOrThrowArgs} args - Arguments to find a Matriz
     * @example
     * // Get one Matriz
     * const matriz = await prisma.matriz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends matrizFindUniqueOrThrowArgs>(
      args: SelectSubset<T, matrizFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Matriz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrizFindFirstArgs} args - Arguments to find a Matriz
     * @example
     * // Get one Matriz
     * const matriz = await prisma.matriz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends matrizFindFirstArgs>(
      args?: SelectSubset<T, matrizFindFirstArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Matriz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrizFindFirstOrThrowArgs} args - Arguments to find a Matriz
     * @example
     * // Get one Matriz
     * const matriz = await prisma.matriz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends matrizFindFirstOrThrowArgs>(
      args?: SelectSubset<T, matrizFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Matrizs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matrizs
     * const matrizs = await prisma.matriz.findMany()
     *
     * // Get first 10 Matrizs
     * const matrizs = await prisma.matriz.findMany({ take: 10 })
     *
     * // Only select the `cod_matriz`
     * const matrizWithCod_matrizOnly = await prisma.matriz.findMany({ select: { cod_matriz: true } })
     *
     */
    findMany<T extends matrizFindManyArgs>(
      args?: SelectSubset<T, matrizFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Matriz.
     * @param {matrizCreateArgs} args - Arguments to create a Matriz.
     * @example
     * // Create one Matriz
     * const Matriz = await prisma.matriz.create({
     *   data: {
     *     // ... data to create a Matriz
     *   }
     * })
     *
     */
    create<T extends matrizCreateArgs>(
      args: SelectSubset<T, matrizCreateArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Matrizs.
     * @param {matrizCreateManyArgs} args - Arguments to create many Matrizs.
     * @example
     * // Create many Matrizs
     * const matriz = await prisma.matriz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends matrizCreateManyArgs>(
      args?: SelectSubset<T, matrizCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Matrizs and returns the data saved in the database.
     * @param {matrizCreateManyAndReturnArgs} args - Arguments to create many Matrizs.
     * @example
     * // Create many Matrizs
     * const matriz = await prisma.matriz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Matrizs and only return the `cod_matriz`
     * const matrizWithCod_matrizOnly = await prisma.matriz.createManyAndReturn({
     *   select: { cod_matriz: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends matrizCreateManyAndReturnArgs>(
      args?: SelectSubset<T, matrizCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Matriz.
     * @param {matrizDeleteArgs} args - Arguments to delete one Matriz.
     * @example
     * // Delete one Matriz
     * const Matriz = await prisma.matriz.delete({
     *   where: {
     *     // ... filter to delete one Matriz
     *   }
     * })
     *
     */
    delete<T extends matrizDeleteArgs>(
      args: SelectSubset<T, matrizDeleteArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Matriz.
     * @param {matrizUpdateArgs} args - Arguments to update one Matriz.
     * @example
     * // Update one Matriz
     * const matriz = await prisma.matriz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends matrizUpdateArgs>(
      args: SelectSubset<T, matrizUpdateArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Matrizs.
     * @param {matrizDeleteManyArgs} args - Arguments to filter Matrizs to delete.
     * @example
     * // Delete a few Matrizs
     * const { count } = await prisma.matriz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends matrizDeleteManyArgs>(
      args?: SelectSubset<T, matrizDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Matrizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matrizs
     * const matriz = await prisma.matriz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends matrizUpdateManyArgs>(
      args: SelectSubset<T, matrizUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Matrizs and returns the data updated in the database.
     * @param {matrizUpdateManyAndReturnArgs} args - Arguments to update many Matrizs.
     * @example
     * // Update many Matrizs
     * const matriz = await prisma.matriz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Matrizs and only return the `cod_matriz`
     * const matrizWithCod_matrizOnly = await prisma.matriz.updateManyAndReturn({
     *   select: { cod_matriz: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends matrizUpdateManyAndReturnArgs>(
      args: SelectSubset<T, matrizUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Matriz.
     * @param {matrizUpsertArgs} args - Arguments to update or create a Matriz.
     * @example
     * // Update or create a Matriz
     * const matriz = await prisma.matriz.upsert({
     *   create: {
     *     // ... data to create a Matriz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matriz we want to update
     *   }
     * })
     */
    upsert<T extends matrizUpsertArgs>(
      args: SelectSubset<T, matrizUpsertArgs<ExtArgs>>,
    ): Prisma__matrizClient<
      $Result.GetResult<
        Prisma.$matrizPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Matrizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrizCountArgs} args - Arguments to filter Matrizs to count.
     * @example
     * // Count the number of Matrizs
     * const count = await prisma.matriz.count({
     *   where: {
     *     // ... the filter for the Matrizs we want to count
     *   }
     * })
     **/
    count<T extends matrizCountArgs>(
      args?: Subset<T, matrizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrizCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Matriz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MatrizAggregateArgs>(
      args: Subset<T, MatrizAggregateArgs>,
    ): Prisma.PrismaPromise<GetMatrizAggregateType<T>>;

    /**
     * Group by Matriz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matrizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends matrizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: matrizGroupByArgs['orderBy'] }
        : { orderBy?: matrizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, matrizGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetMatrizGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the matriz model
     */
    readonly fields: matrizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for matriz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__matrizClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    itmatriz<T extends matriz$itmatrizArgs<ExtArgs> = {}>(
      args?: Subset<T, matriz$itmatrizArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$itmatrizPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the matriz model
   */
  interface matrizFieldRefs {
    readonly cod_matriz: FieldRef<'matriz', 'Int'>;
    readonly desc_matriz: FieldRef<'matriz', 'String'>;
    readonly status_matriz: FieldRef<'matriz', 'String'>;
  }

  // Custom InputTypes
  /**
   * matriz findUnique
   */
  export type matrizFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * Filter, which matriz to fetch.
     */
    where: matrizWhereUniqueInput;
  };

  /**
   * matriz findUniqueOrThrow
   */
  export type matrizFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * Filter, which matriz to fetch.
     */
    where: matrizWhereUniqueInput;
  };

  /**
   * matriz findFirst
   */
  export type matrizFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * Filter, which matriz to fetch.
     */
    where?: matrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of matrizs to fetch.
     */
    orderBy?: matrizOrderByWithRelationInput | matrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for matrizs.
     */
    cursor?: matrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` matrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` matrizs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of matrizs.
     */
    distinct?: MatrizScalarFieldEnum | MatrizScalarFieldEnum[];
  };

  /**
   * matriz findFirstOrThrow
   */
  export type matrizFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * Filter, which matriz to fetch.
     */
    where?: matrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of matrizs to fetch.
     */
    orderBy?: matrizOrderByWithRelationInput | matrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for matrizs.
     */
    cursor?: matrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` matrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` matrizs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of matrizs.
     */
    distinct?: MatrizScalarFieldEnum | MatrizScalarFieldEnum[];
  };

  /**
   * matriz findMany
   */
  export type matrizFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * Filter, which matrizs to fetch.
     */
    where?: matrizWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of matrizs to fetch.
     */
    orderBy?: matrizOrderByWithRelationInput | matrizOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing matrizs.
     */
    cursor?: matrizWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` matrizs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` matrizs.
     */
    skip?: number;
    distinct?: MatrizScalarFieldEnum | MatrizScalarFieldEnum[];
  };

  /**
   * matriz create
   */
  export type matrizCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * The data needed to create a matriz.
     */
    data: XOR<matrizCreateInput, matrizUncheckedCreateInput>;
  };

  /**
   * matriz createMany
   */
  export type matrizCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many matrizs.
     */
    data: matrizCreateManyInput | matrizCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * matriz createManyAndReturn
   */
  export type matrizCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * The data used to create many matrizs.
     */
    data: matrizCreateManyInput | matrizCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * matriz update
   */
  export type matrizUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * The data needed to update a matriz.
     */
    data: XOR<matrizUpdateInput, matrizUncheckedUpdateInput>;
    /**
     * Choose, which matriz to update.
     */
    where: matrizWhereUniqueInput;
  };

  /**
   * matriz updateMany
   */
  export type matrizUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update matrizs.
     */
    data: XOR<matrizUpdateManyMutationInput, matrizUncheckedUpdateManyInput>;
    /**
     * Filter which matrizs to update
     */
    where?: matrizWhereInput;
    /**
     * Limit how many matrizs to update.
     */
    limit?: number;
  };

  /**
   * matriz updateManyAndReturn
   */
  export type matrizUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * The data used to update matrizs.
     */
    data: XOR<matrizUpdateManyMutationInput, matrizUncheckedUpdateManyInput>;
    /**
     * Filter which matrizs to update
     */
    where?: matrizWhereInput;
    /**
     * Limit how many matrizs to update.
     */
    limit?: number;
  };

  /**
   * matriz upsert
   */
  export type matrizUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * The filter to search for the matriz to update in case it exists.
     */
    where: matrizWhereUniqueInput;
    /**
     * In case the matriz found by the `where` argument doesn't exist, create a new matriz with this data.
     */
    create: XOR<matrizCreateInput, matrizUncheckedCreateInput>;
    /**
     * In case the matriz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<matrizUpdateInput, matrizUncheckedUpdateInput>;
  };

  /**
   * matriz delete
   */
  export type matrizDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
    /**
     * Filter which matriz to delete.
     */
    where: matrizWhereUniqueInput;
  };

  /**
   * matriz deleteMany
   */
  export type matrizDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which matrizs to delete
     */
    where?: matrizWhereInput;
    /**
     * Limit how many matrizs to delete.
     */
    limit?: number;
  };

  /**
   * matriz.itmatriz
   */
  export type matriz$itmatrizArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the itmatriz
     */
    select?: itmatrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the itmatriz
     */
    omit?: itmatrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itmatrizInclude<ExtArgs> | null;
    where?: itmatrizWhereInput;
    orderBy?:
      | itmatrizOrderByWithRelationInput
      | itmatrizOrderByWithRelationInput[];
    cursor?: itmatrizWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ItmatrizScalarFieldEnum | ItmatrizScalarFieldEnum[];
  };

  /**
   * matriz without action
   */
  export type matrizDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the matriz
     */
    select?: matrizSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the matriz
     */
    omit?: matrizOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: matrizInclude<ExtArgs> | null;
  };

  /**
   * Model mensagem
   */

  export type AggregateMensagem = {
    _count: MensagemCountAggregateOutputType | null;
    _avg: MensagemAvgAggregateOutputType | null;
    _sum: MensagemSumAggregateOutputType | null;
    _min: MensagemMinAggregateOutputType | null;
    _max: MensagemMaxAggregateOutputType | null;
  };

  export type MensagemAvgAggregateOutputType = {
    cod_mensagem: number | null;
  };

  export type MensagemSumAggregateOutputType = {
    cod_mensagem: number | null;
  };

  export type MensagemMinAggregateOutputType = {
    cod_mensagem: number | null;
    desc_mensagem: string | null;
  };

  export type MensagemMaxAggregateOutputType = {
    cod_mensagem: number | null;
    desc_mensagem: string | null;
  };

  export type MensagemCountAggregateOutputType = {
    cod_mensagem: number;
    desc_mensagem: number;
    _all: number;
  };

  export type MensagemAvgAggregateInputType = {
    cod_mensagem?: true;
  };

  export type MensagemSumAggregateInputType = {
    cod_mensagem?: true;
  };

  export type MensagemMinAggregateInputType = {
    cod_mensagem?: true;
    desc_mensagem?: true;
  };

  export type MensagemMaxAggregateInputType = {
    cod_mensagem?: true;
    desc_mensagem?: true;
  };

  export type MensagemCountAggregateInputType = {
    cod_mensagem?: true;
    desc_mensagem?: true;
    _all?: true;
  };

  export type MensagemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which mensagem to aggregate.
     */
    where?: mensagemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of mensagems to fetch.
     */
    orderBy?:
      | mensagemOrderByWithRelationInput
      | mensagemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: mensagemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` mensagems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` mensagems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned mensagems
     **/
    _count?: true | MensagemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MensagemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MensagemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MensagemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MensagemMaxAggregateInputType;
  };

  export type GetMensagemAggregateType<T extends MensagemAggregateArgs> = {
    [P in keyof T & keyof AggregateMensagem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensagem[P]>
      : GetScalarType<T[P], AggregateMensagem[P]>;
  };

  export type mensagemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: mensagemWhereInput;
    orderBy?:
      | mensagemOrderByWithAggregationInput
      | mensagemOrderByWithAggregationInput[];
    by: MensagemScalarFieldEnum[] | MensagemScalarFieldEnum;
    having?: mensagemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MensagemCountAggregateInputType | true;
    _avg?: MensagemAvgAggregateInputType;
    _sum?: MensagemSumAggregateInputType;
    _min?: MensagemMinAggregateInputType;
    _max?: MensagemMaxAggregateInputType;
  };

  export type MensagemGroupByOutputType = {
    cod_mensagem: number;
    desc_mensagem: string;
    _count: MensagemCountAggregateOutputType | null;
    _avg: MensagemAvgAggregateOutputType | null;
    _sum: MensagemSumAggregateOutputType | null;
    _min: MensagemMinAggregateOutputType | null;
    _max: MensagemMaxAggregateOutputType | null;
  };

  type GetMensagemGroupByPayload<T extends mensagemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MensagemGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MensagemGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MensagemGroupByOutputType[P]>
            : GetScalarType<T[P], MensagemGroupByOutputType[P]>;
        }
      >
    >;

  export type mensagemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_mensagem?: boolean;
      desc_mensagem?: boolean;
    },
    ExtArgs['result']['mensagem']
  >;

  export type mensagemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_mensagem?: boolean;
      desc_mensagem?: boolean;
    },
    ExtArgs['result']['mensagem']
  >;

  export type mensagemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_mensagem?: boolean;
      desc_mensagem?: boolean;
    },
    ExtArgs['result']['mensagem']
  >;

  export type mensagemSelectScalar = {
    cod_mensagem?: boolean;
    desc_mensagem?: boolean;
  };

  export type mensagemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_mensagem' | 'desc_mensagem',
    ExtArgs['result']['mensagem']
  >;

  export type $mensagemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'mensagem';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_mensagem: number;
        desc_mensagem: string;
      },
      ExtArgs['result']['mensagem']
    >;
    composites: {};
  };

  type mensagemGetPayload<
    S extends boolean | null | undefined | mensagemDefaultArgs,
  > = $Result.GetResult<Prisma.$mensagemPayload, S>;

  type mensagemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<mensagemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MensagemCountAggregateInputType | true;
  };

  export interface mensagemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['mensagem'];
      meta: { name: 'mensagem' };
    };
    /**
     * Find zero or one Mensagem that matches the filter.
     * @param {mensagemFindUniqueArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mensagemFindUniqueArgs>(
      args: SelectSubset<T, mensagemFindUniqueArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Mensagem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mensagemFindUniqueOrThrowArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mensagemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, mensagemFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Mensagem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagemFindFirstArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mensagemFindFirstArgs>(
      args?: SelectSubset<T, mensagemFindFirstArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Mensagem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagemFindFirstOrThrowArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mensagemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mensagemFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Mensagems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensagems
     * const mensagems = await prisma.mensagem.findMany()
     *
     * // Get first 10 Mensagems
     * const mensagems = await prisma.mensagem.findMany({ take: 10 })
     *
     * // Only select the `cod_mensagem`
     * const mensagemWithCod_mensagemOnly = await prisma.mensagem.findMany({ select: { cod_mensagem: true } })
     *
     */
    findMany<T extends mensagemFindManyArgs>(
      args?: SelectSubset<T, mensagemFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Mensagem.
     * @param {mensagemCreateArgs} args - Arguments to create a Mensagem.
     * @example
     * // Create one Mensagem
     * const Mensagem = await prisma.mensagem.create({
     *   data: {
     *     // ... data to create a Mensagem
     *   }
     * })
     *
     */
    create<T extends mensagemCreateArgs>(
      args: SelectSubset<T, mensagemCreateArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Mensagems.
     * @param {mensagemCreateManyArgs} args - Arguments to create many Mensagems.
     * @example
     * // Create many Mensagems
     * const mensagem = await prisma.mensagem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends mensagemCreateManyArgs>(
      args?: SelectSubset<T, mensagemCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Mensagems and returns the data saved in the database.
     * @param {mensagemCreateManyAndReturnArgs} args - Arguments to create many Mensagems.
     * @example
     * // Create many Mensagems
     * const mensagem = await prisma.mensagem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Mensagems and only return the `cod_mensagem`
     * const mensagemWithCod_mensagemOnly = await prisma.mensagem.createManyAndReturn({
     *   select: { cod_mensagem: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends mensagemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, mensagemCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Mensagem.
     * @param {mensagemDeleteArgs} args - Arguments to delete one Mensagem.
     * @example
     * // Delete one Mensagem
     * const Mensagem = await prisma.mensagem.delete({
     *   where: {
     *     // ... filter to delete one Mensagem
     *   }
     * })
     *
     */
    delete<T extends mensagemDeleteArgs>(
      args: SelectSubset<T, mensagemDeleteArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Mensagem.
     * @param {mensagemUpdateArgs} args - Arguments to update one Mensagem.
     * @example
     * // Update one Mensagem
     * const mensagem = await prisma.mensagem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends mensagemUpdateArgs>(
      args: SelectSubset<T, mensagemUpdateArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Mensagems.
     * @param {mensagemDeleteManyArgs} args - Arguments to filter Mensagems to delete.
     * @example
     * // Delete a few Mensagems
     * const { count } = await prisma.mensagem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends mensagemDeleteManyArgs>(
      args?: SelectSubset<T, mensagemDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Mensagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensagems
     * const mensagem = await prisma.mensagem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends mensagemUpdateManyArgs>(
      args: SelectSubset<T, mensagemUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Mensagems and returns the data updated in the database.
     * @param {mensagemUpdateManyAndReturnArgs} args - Arguments to update many Mensagems.
     * @example
     * // Update many Mensagems
     * const mensagem = await prisma.mensagem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Mensagems and only return the `cod_mensagem`
     * const mensagemWithCod_mensagemOnly = await prisma.mensagem.updateManyAndReturn({
     *   select: { cod_mensagem: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends mensagemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, mensagemUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Mensagem.
     * @param {mensagemUpsertArgs} args - Arguments to update or create a Mensagem.
     * @example
     * // Update or create a Mensagem
     * const mensagem = await prisma.mensagem.upsert({
     *   create: {
     *     // ... data to create a Mensagem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensagem we want to update
     *   }
     * })
     */
    upsert<T extends mensagemUpsertArgs>(
      args: SelectSubset<T, mensagemUpsertArgs<ExtArgs>>,
    ): Prisma__mensagemClient<
      $Result.GetResult<
        Prisma.$mensagemPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Mensagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagemCountArgs} args - Arguments to filter Mensagems to count.
     * @example
     * // Count the number of Mensagems
     * const count = await prisma.mensagem.count({
     *   where: {
     *     // ... the filter for the Mensagems we want to count
     *   }
     * })
     **/
    count<T extends mensagemCountArgs>(
      args?: Subset<T, mensagemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MensagemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Mensagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MensagemAggregateArgs>(
      args: Subset<T, MensagemAggregateArgs>,
    ): Prisma.PrismaPromise<GetMensagemAggregateType<T>>;

    /**
     * Group by Mensagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mensagemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends mensagemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mensagemGroupByArgs['orderBy'] }
        : { orderBy?: mensagemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, mensagemGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetMensagemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the mensagem model
     */
    readonly fields: mensagemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mensagem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mensagemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the mensagem model
   */
  interface mensagemFieldRefs {
    readonly cod_mensagem: FieldRef<'mensagem', 'Int'>;
    readonly desc_mensagem: FieldRef<'mensagem', 'String'>;
  }

  // Custom InputTypes
  /**
   * mensagem findUnique
   */
  export type mensagemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * Filter, which mensagem to fetch.
     */
    where: mensagemWhereUniqueInput;
  };

  /**
   * mensagem findUniqueOrThrow
   */
  export type mensagemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * Filter, which mensagem to fetch.
     */
    where: mensagemWhereUniqueInput;
  };

  /**
   * mensagem findFirst
   */
  export type mensagemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * Filter, which mensagem to fetch.
     */
    where?: mensagemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of mensagems to fetch.
     */
    orderBy?:
      | mensagemOrderByWithRelationInput
      | mensagemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for mensagems.
     */
    cursor?: mensagemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` mensagems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` mensagems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of mensagems.
     */
    distinct?: MensagemScalarFieldEnum | MensagemScalarFieldEnum[];
  };

  /**
   * mensagem findFirstOrThrow
   */
  export type mensagemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * Filter, which mensagem to fetch.
     */
    where?: mensagemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of mensagems to fetch.
     */
    orderBy?:
      | mensagemOrderByWithRelationInput
      | mensagemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for mensagems.
     */
    cursor?: mensagemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` mensagems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` mensagems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of mensagems.
     */
    distinct?: MensagemScalarFieldEnum | MensagemScalarFieldEnum[];
  };

  /**
   * mensagem findMany
   */
  export type mensagemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * Filter, which mensagems to fetch.
     */
    where?: mensagemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of mensagems to fetch.
     */
    orderBy?:
      | mensagemOrderByWithRelationInput
      | mensagemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing mensagems.
     */
    cursor?: mensagemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` mensagems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` mensagems.
     */
    skip?: number;
    distinct?: MensagemScalarFieldEnum | MensagemScalarFieldEnum[];
  };

  /**
   * mensagem create
   */
  export type mensagemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * The data needed to create a mensagem.
     */
    data: XOR<mensagemCreateInput, mensagemUncheckedCreateInput>;
  };

  /**
   * mensagem createMany
   */
  export type mensagemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many mensagems.
     */
    data: mensagemCreateManyInput | mensagemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * mensagem createManyAndReturn
   */
  export type mensagemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * The data used to create many mensagems.
     */
    data: mensagemCreateManyInput | mensagemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * mensagem update
   */
  export type mensagemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * The data needed to update a mensagem.
     */
    data: XOR<mensagemUpdateInput, mensagemUncheckedUpdateInput>;
    /**
     * Choose, which mensagem to update.
     */
    where: mensagemWhereUniqueInput;
  };

  /**
   * mensagem updateMany
   */
  export type mensagemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update mensagems.
     */
    data: XOR<
      mensagemUpdateManyMutationInput,
      mensagemUncheckedUpdateManyInput
    >;
    /**
     * Filter which mensagems to update
     */
    where?: mensagemWhereInput;
    /**
     * Limit how many mensagems to update.
     */
    limit?: number;
  };

  /**
   * mensagem updateManyAndReturn
   */
  export type mensagemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * The data used to update mensagems.
     */
    data: XOR<
      mensagemUpdateManyMutationInput,
      mensagemUncheckedUpdateManyInput
    >;
    /**
     * Filter which mensagems to update
     */
    where?: mensagemWhereInput;
    /**
     * Limit how many mensagems to update.
     */
    limit?: number;
  };

  /**
   * mensagem upsert
   */
  export type mensagemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * The filter to search for the mensagem to update in case it exists.
     */
    where: mensagemWhereUniqueInput;
    /**
     * In case the mensagem found by the `where` argument doesn't exist, create a new mensagem with this data.
     */
    create: XOR<mensagemCreateInput, mensagemUncheckedCreateInput>;
    /**
     * In case the mensagem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mensagemUpdateInput, mensagemUncheckedUpdateInput>;
  };

  /**
   * mensagem delete
   */
  export type mensagemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
    /**
     * Filter which mensagem to delete.
     */
    where: mensagemWhereUniqueInput;
  };

  /**
   * mensagem deleteMany
   */
  export type mensagemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which mensagems to delete
     */
    where?: mensagemWhereInput;
    /**
     * Limit how many mensagems to delete.
     */
    limit?: number;
  };

  /**
   * mensagem without action
   */
  export type mensagemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the mensagem
     */
    select?: mensagemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the mensagem
     */
    omit?: mensagemOmit<ExtArgs> | null;
  };

  /**
   * Model meta
   */

  export type AggregateMeta = {
    _count: MetaCountAggregateOutputType | null;
    _avg: MetaAvgAggregateOutputType | null;
    _sum: MetaSumAggregateOutputType | null;
    _min: MetaMinAggregateOutputType | null;
    _max: MetaMaxAggregateOutputType | null;
  };

  export type MetaAvgAggregateOutputType = {
    codproj_meta: number | null;
    codarea_meta: number | null;
    codfase_meta: number | null;
    tempo_meta: Decimal | null;
    altesc_meta: Decimal | null;
  };

  export type MetaSumAggregateOutputType = {
    codproj_meta: number | null;
    codarea_meta: number | null;
    codfase_meta: number | null;
    tempo_meta: Decimal | null;
    altesc_meta: Decimal | null;
  };

  export type MetaMinAggregateOutputType = {
    codproj_meta: number | null;
    codarea_meta: number | null;
    codfase_meta: number | null;
    tempo_meta: Decimal | null;
    altesc_meta: Decimal | null;
  };

  export type MetaMaxAggregateOutputType = {
    codproj_meta: number | null;
    codarea_meta: number | null;
    codfase_meta: number | null;
    tempo_meta: Decimal | null;
    altesc_meta: Decimal | null;
  };

  export type MetaCountAggregateOutputType = {
    codproj_meta: number;
    codarea_meta: number;
    codfase_meta: number;
    tempo_meta: number;
    altesc_meta: number;
    _all: number;
  };

  export type MetaAvgAggregateInputType = {
    codproj_meta?: true;
    codarea_meta?: true;
    codfase_meta?: true;
    tempo_meta?: true;
    altesc_meta?: true;
  };

  export type MetaSumAggregateInputType = {
    codproj_meta?: true;
    codarea_meta?: true;
    codfase_meta?: true;
    tempo_meta?: true;
    altesc_meta?: true;
  };

  export type MetaMinAggregateInputType = {
    codproj_meta?: true;
    codarea_meta?: true;
    codfase_meta?: true;
    tempo_meta?: true;
    altesc_meta?: true;
  };

  export type MetaMaxAggregateInputType = {
    codproj_meta?: true;
    codarea_meta?: true;
    codfase_meta?: true;
    tempo_meta?: true;
    altesc_meta?: true;
  };

  export type MetaCountAggregateInputType = {
    codproj_meta?: true;
    codarea_meta?: true;
    codfase_meta?: true;
    tempo_meta?: true;
    altesc_meta?: true;
    _all?: true;
  };

  export type MetaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which meta to aggregate.
     */
    where?: metaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: metaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` metas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` metas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned metas
     **/
    _count?: true | MetaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MetaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MetaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MetaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MetaMaxAggregateInputType;
  };

  export type GetMetaAggregateType<T extends MetaAggregateArgs> = {
    [P in keyof T & keyof AggregateMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeta[P]>
      : GetScalarType<T[P], AggregateMeta[P]>;
  };

  export type metaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: metaWhereInput;
    orderBy?:
      | metaOrderByWithAggregationInput
      | metaOrderByWithAggregationInput[];
    by: MetaScalarFieldEnum[] | MetaScalarFieldEnum;
    having?: metaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MetaCountAggregateInputType | true;
    _avg?: MetaAvgAggregateInputType;
    _sum?: MetaSumAggregateInputType;
    _min?: MetaMinAggregateInputType;
    _max?: MetaMaxAggregateInputType;
  };

  export type MetaGroupByOutputType = {
    codproj_meta: number;
    codarea_meta: number;
    codfase_meta: number;
    tempo_meta: Decimal;
    altesc_meta: Decimal;
    _count: MetaCountAggregateOutputType | null;
    _avg: MetaAvgAggregateOutputType | null;
    _sum: MetaSumAggregateOutputType | null;
    _min: MetaMinAggregateOutputType | null;
    _max: MetaMaxAggregateOutputType | null;
  };

  type GetMetaGroupByPayload<T extends metaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof MetaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], MetaGroupByOutputType[P]>
          : GetScalarType<T[P], MetaGroupByOutputType[P]>;
      }
    >
  >;

  export type metaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codproj_meta?: boolean;
      codarea_meta?: boolean;
      codfase_meta?: boolean;
      tempo_meta?: boolean;
      altesc_meta?: boolean;
      area?: boolean | areaDefaultArgs<ExtArgs>;
      fase?: boolean | faseDefaultArgs<ExtArgs>;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['meta']
  >;

  export type metaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codproj_meta?: boolean;
      codarea_meta?: boolean;
      codfase_meta?: boolean;
      tempo_meta?: boolean;
      altesc_meta?: boolean;
      area?: boolean | areaDefaultArgs<ExtArgs>;
      fase?: boolean | faseDefaultArgs<ExtArgs>;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['meta']
  >;

  export type metaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codproj_meta?: boolean;
      codarea_meta?: boolean;
      codfase_meta?: boolean;
      tempo_meta?: boolean;
      altesc_meta?: boolean;
      area?: boolean | areaDefaultArgs<ExtArgs>;
      fase?: boolean | faseDefaultArgs<ExtArgs>;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['meta']
  >;

  export type metaSelectScalar = {
    codproj_meta?: boolean;
    codarea_meta?: boolean;
    codfase_meta?: boolean;
    tempo_meta?: boolean;
    altesc_meta?: boolean;
  };

  export type metaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'codproj_meta'
    | 'codarea_meta'
    | 'codfase_meta'
    | 'tempo_meta'
    | 'altesc_meta',
    ExtArgs['result']['meta']
  >;
  export type metaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    area?: boolean | areaDefaultArgs<ExtArgs>;
    fase?: boolean | faseDefaultArgs<ExtArgs>;
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
  };
  export type metaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    area?: boolean | areaDefaultArgs<ExtArgs>;
    fase?: boolean | faseDefaultArgs<ExtArgs>;
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
  };
  export type metaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    area?: boolean | areaDefaultArgs<ExtArgs>;
    fase?: boolean | faseDefaultArgs<ExtArgs>;
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
  };

  export type $metaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'meta';
    objects: {
      area: Prisma.$areaPayload<ExtArgs>;
      fase: Prisma.$fasePayload<ExtArgs>;
      projeto: Prisma.$projetoPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        codproj_meta: number;
        codarea_meta: number;
        codfase_meta: number;
        tempo_meta: Prisma.Decimal;
        altesc_meta: Prisma.Decimal;
      },
      ExtArgs['result']['meta']
    >;
    composites: {};
  };

  type metaGetPayload<S extends boolean | null | undefined | metaDefaultArgs> =
    $Result.GetResult<Prisma.$metaPayload, S>;

  type metaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<metaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MetaCountAggregateInputType | true;
  };

  export interface metaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['meta'];
      meta: { name: 'meta' };
    };
    /**
     * Find zero or one Meta that matches the filter.
     * @param {metaFindUniqueArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends metaFindUniqueArgs>(
      args: SelectSubset<T, metaFindUniqueArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Meta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {metaFindUniqueOrThrowArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends metaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, metaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Meta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaFindFirstArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends metaFindFirstArgs>(
      args?: SelectSubset<T, metaFindFirstArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Meta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaFindFirstOrThrowArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends metaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, metaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Metas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metas
     * const metas = await prisma.meta.findMany()
     *
     * // Get first 10 Metas
     * const metas = await prisma.meta.findMany({ take: 10 })
     *
     * // Only select the `codproj_meta`
     * const metaWithCodproj_metaOnly = await prisma.meta.findMany({ select: { codproj_meta: true } })
     *
     */
    findMany<T extends metaFindManyArgs>(
      args?: SelectSubset<T, metaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Meta.
     * @param {metaCreateArgs} args - Arguments to create a Meta.
     * @example
     * // Create one Meta
     * const Meta = await prisma.meta.create({
     *   data: {
     *     // ... data to create a Meta
     *   }
     * })
     *
     */
    create<T extends metaCreateArgs>(
      args: SelectSubset<T, metaCreateArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Metas.
     * @param {metaCreateManyArgs} args - Arguments to create many Metas.
     * @example
     * // Create many Metas
     * const meta = await prisma.meta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends metaCreateManyArgs>(
      args?: SelectSubset<T, metaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Metas and returns the data saved in the database.
     * @param {metaCreateManyAndReturnArgs} args - Arguments to create many Metas.
     * @example
     * // Create many Metas
     * const meta = await prisma.meta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Metas and only return the `codproj_meta`
     * const metaWithCodproj_metaOnly = await prisma.meta.createManyAndReturn({
     *   select: { codproj_meta: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends metaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, metaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Meta.
     * @param {metaDeleteArgs} args - Arguments to delete one Meta.
     * @example
     * // Delete one Meta
     * const Meta = await prisma.meta.delete({
     *   where: {
     *     // ... filter to delete one Meta
     *   }
     * })
     *
     */
    delete<T extends metaDeleteArgs>(
      args: SelectSubset<T, metaDeleteArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Meta.
     * @param {metaUpdateArgs} args - Arguments to update one Meta.
     * @example
     * // Update one Meta
     * const meta = await prisma.meta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends metaUpdateArgs>(
      args: SelectSubset<T, metaUpdateArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Metas.
     * @param {metaDeleteManyArgs} args - Arguments to filter Metas to delete.
     * @example
     * // Delete a few Metas
     * const { count } = await prisma.meta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends metaDeleteManyArgs>(
      args?: SelectSubset<T, metaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metas
     * const meta = await prisma.meta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends metaUpdateManyArgs>(
      args: SelectSubset<T, metaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Metas and returns the data updated in the database.
     * @param {metaUpdateManyAndReturnArgs} args - Arguments to update many Metas.
     * @example
     * // Update many Metas
     * const meta = await prisma.meta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Metas and only return the `codproj_meta`
     * const metaWithCodproj_metaOnly = await prisma.meta.updateManyAndReturn({
     *   select: { codproj_meta: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends metaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, metaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Meta.
     * @param {metaUpsertArgs} args - Arguments to update or create a Meta.
     * @example
     * // Update or create a Meta
     * const meta = await prisma.meta.upsert({
     *   create: {
     *     // ... data to create a Meta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meta we want to update
     *   }
     * })
     */
    upsert<T extends metaUpsertArgs>(
      args: SelectSubset<T, metaUpsertArgs<ExtArgs>>,
    ): Prisma__metaClient<
      $Result.GetResult<
        Prisma.$metaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaCountArgs} args - Arguments to filter Metas to count.
     * @example
     * // Count the number of Metas
     * const count = await prisma.meta.count({
     *   where: {
     *     // ... the filter for the Metas we want to count
     *   }
     * })
     **/
    count<T extends metaCountArgs>(
      args?: Subset<T, metaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MetaAggregateArgs>(
      args: Subset<T, MetaAggregateArgs>,
    ): Prisma.PrismaPromise<GetMetaAggregateType<T>>;

    /**
     * Group by Meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends metaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: metaGroupByArgs['orderBy'] }
        : { orderBy?: metaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, metaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetMetaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the meta model
     */
    readonly fields: metaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__metaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    area<T extends areaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, areaDefaultArgs<ExtArgs>>,
    ): Prisma__areaClient<
      | $Result.GetResult<
          Prisma.$areaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    fase<T extends faseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, faseDefaultArgs<ExtArgs>>,
    ): Prisma__faseClient<
      | $Result.GetResult<
          Prisma.$fasePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, projetoDefaultArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      | $Result.GetResult<
          Prisma.$projetoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the meta model
   */
  interface metaFieldRefs {
    readonly codproj_meta: FieldRef<'meta', 'Int'>;
    readonly codarea_meta: FieldRef<'meta', 'Int'>;
    readonly codfase_meta: FieldRef<'meta', 'Int'>;
    readonly tempo_meta: FieldRef<'meta', 'Decimal'>;
    readonly altesc_meta: FieldRef<'meta', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * meta findUnique
   */
  export type metaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * Filter, which meta to fetch.
     */
    where: metaWhereUniqueInput;
  };

  /**
   * meta findUniqueOrThrow
   */
  export type metaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * Filter, which meta to fetch.
     */
    where: metaWhereUniqueInput;
  };

  /**
   * meta findFirst
   */
  export type metaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * Filter, which meta to fetch.
     */
    where?: metaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for metas.
     */
    cursor?: metaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` metas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` metas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of metas.
     */
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[];
  };

  /**
   * meta findFirstOrThrow
   */
  export type metaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * Filter, which meta to fetch.
     */
    where?: metaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for metas.
     */
    cursor?: metaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` metas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` metas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of metas.
     */
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[];
  };

  /**
   * meta findMany
   */
  export type metaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * Filter, which metas to fetch.
     */
    where?: metaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing metas.
     */
    cursor?: metaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` metas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` metas.
     */
    skip?: number;
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[];
  };

  /**
   * meta create
   */
  export type metaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * The data needed to create a meta.
     */
    data: XOR<metaCreateInput, metaUncheckedCreateInput>;
  };

  /**
   * meta createMany
   */
  export type metaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many metas.
     */
    data: metaCreateManyInput | metaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * meta createManyAndReturn
   */
  export type metaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * The data used to create many metas.
     */
    data: metaCreateManyInput | metaCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * meta update
   */
  export type metaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * The data needed to update a meta.
     */
    data: XOR<metaUpdateInput, metaUncheckedUpdateInput>;
    /**
     * Choose, which meta to update.
     */
    where: metaWhereUniqueInput;
  };

  /**
   * meta updateMany
   */
  export type metaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update metas.
     */
    data: XOR<metaUpdateManyMutationInput, metaUncheckedUpdateManyInput>;
    /**
     * Filter which metas to update
     */
    where?: metaWhereInput;
    /**
     * Limit how many metas to update.
     */
    limit?: number;
  };

  /**
   * meta updateManyAndReturn
   */
  export type metaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * The data used to update metas.
     */
    data: XOR<metaUpdateManyMutationInput, metaUncheckedUpdateManyInput>;
    /**
     * Filter which metas to update
     */
    where?: metaWhereInput;
    /**
     * Limit how many metas to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * meta upsert
   */
  export type metaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * The filter to search for the meta to update in case it exists.
     */
    where: metaWhereUniqueInput;
    /**
     * In case the meta found by the `where` argument doesn't exist, create a new meta with this data.
     */
    create: XOR<metaCreateInput, metaUncheckedCreateInput>;
    /**
     * In case the meta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<metaUpdateInput, metaUncheckedUpdateInput>;
  };

  /**
   * meta delete
   */
  export type metaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    /**
     * Filter which meta to delete.
     */
    where: metaWhereUniqueInput;
  };

  /**
   * meta deleteMany
   */
  export type metaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which metas to delete
     */
    where?: metaWhereInput;
    /**
     * Limit how many metas to delete.
     */
    limit?: number;
  };

  /**
   * meta without action
   */
  export type metaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
  };

  /**
   * Model modulo_sistema
   */

  export type AggregateModulo_sistema = {
    _count: Modulo_sistemaCountAggregateOutputType | null;
    _avg: Modulo_sistemaAvgAggregateOutputType | null;
    _sum: Modulo_sistemaSumAggregateOutputType | null;
    _min: Modulo_sistemaMinAggregateOutputType | null;
    _max: Modulo_sistemaMaxAggregateOutputType | null;
  };

  export type Modulo_sistemaAvgAggregateOutputType = {
    cod_modulo: number | null;
  };

  export type Modulo_sistemaSumAggregateOutputType = {
    cod_modulo: number | null;
  };

  export type Modulo_sistemaMinAggregateOutputType = {
    cod_modulo: number | null;
    desc_modulo: string | null;
  };

  export type Modulo_sistemaMaxAggregateOutputType = {
    cod_modulo: number | null;
    desc_modulo: string | null;
  };

  export type Modulo_sistemaCountAggregateOutputType = {
    cod_modulo: number;
    desc_modulo: number;
    _all: number;
  };

  export type Modulo_sistemaAvgAggregateInputType = {
    cod_modulo?: true;
  };

  export type Modulo_sistemaSumAggregateInputType = {
    cod_modulo?: true;
  };

  export type Modulo_sistemaMinAggregateInputType = {
    cod_modulo?: true;
    desc_modulo?: true;
  };

  export type Modulo_sistemaMaxAggregateInputType = {
    cod_modulo?: true;
    desc_modulo?: true;
  };

  export type Modulo_sistemaCountAggregateInputType = {
    cod_modulo?: true;
    desc_modulo?: true;
    _all?: true;
  };

  export type Modulo_sistemaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which modulo_sistema to aggregate.
     */
    where?: modulo_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of modulo_sistemas to fetch.
     */
    orderBy?:
      | modulo_sistemaOrderByWithRelationInput
      | modulo_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: modulo_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` modulo_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` modulo_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned modulo_sistemas
     **/
    _count?: true | Modulo_sistemaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Modulo_sistemaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Modulo_sistemaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Modulo_sistemaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Modulo_sistemaMaxAggregateInputType;
  };

  export type GetModulo_sistemaAggregateType<
    T extends Modulo_sistemaAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateModulo_sistema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulo_sistema[P]>
      : GetScalarType<T[P], AggregateModulo_sistema[P]>;
  };

  export type modulo_sistemaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: modulo_sistemaWhereInput;
    orderBy?:
      | modulo_sistemaOrderByWithAggregationInput
      | modulo_sistemaOrderByWithAggregationInput[];
    by: Modulo_sistemaScalarFieldEnum[] | Modulo_sistemaScalarFieldEnum;
    having?: modulo_sistemaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Modulo_sistemaCountAggregateInputType | true;
    _avg?: Modulo_sistemaAvgAggregateInputType;
    _sum?: Modulo_sistemaSumAggregateInputType;
    _min?: Modulo_sistemaMinAggregateInputType;
    _max?: Modulo_sistemaMaxAggregateInputType;
  };

  export type Modulo_sistemaGroupByOutputType = {
    cod_modulo: number;
    desc_modulo: string;
    _count: Modulo_sistemaCountAggregateOutputType | null;
    _avg: Modulo_sistemaAvgAggregateOutputType | null;
    _sum: Modulo_sistemaSumAggregateOutputType | null;
    _min: Modulo_sistemaMinAggregateOutputType | null;
    _max: Modulo_sistemaMaxAggregateOutputType | null;
  };

  type GetModulo_sistemaGroupByPayload<T extends modulo_sistemaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Modulo_sistemaGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof Modulo_sistemaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Modulo_sistemaGroupByOutputType[P]>
            : GetScalarType<T[P], Modulo_sistemaGroupByOutputType[P]>;
        }
      >
    >;

  export type modulo_sistemaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_modulo?: boolean;
      desc_modulo?: boolean;
      acesso_sistema?: boolean | modulo_sistema$acesso_sistemaArgs<ExtArgs>;
      tela_sistema?: boolean | modulo_sistema$tela_sistemaArgs<ExtArgs>;
      _count?: boolean | Modulo_sistemaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['modulo_sistema']
  >;

  export type modulo_sistemaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_modulo?: boolean;
      desc_modulo?: boolean;
    },
    ExtArgs['result']['modulo_sistema']
  >;

  export type modulo_sistemaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_modulo?: boolean;
      desc_modulo?: boolean;
    },
    ExtArgs['result']['modulo_sistema']
  >;

  export type modulo_sistemaSelectScalar = {
    cod_modulo?: boolean;
    desc_modulo?: boolean;
  };

  export type modulo_sistemaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_modulo' | 'desc_modulo',
    ExtArgs['result']['modulo_sistema']
  >;
  export type modulo_sistemaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acesso_sistema?: boolean | modulo_sistema$acesso_sistemaArgs<ExtArgs>;
    tela_sistema?: boolean | modulo_sistema$tela_sistemaArgs<ExtArgs>;
    _count?: boolean | Modulo_sistemaCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type modulo_sistemaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type modulo_sistemaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $modulo_sistemaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'modulo_sistema';
    objects: {
      acesso_sistema: Prisma.$acesso_sistemaPayload<ExtArgs>[];
      tela_sistema: Prisma.$tela_sistemaPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_modulo: number;
        desc_modulo: string;
      },
      ExtArgs['result']['modulo_sistema']
    >;
    composites: {};
  };

  type modulo_sistemaGetPayload<
    S extends boolean | null | undefined | modulo_sistemaDefaultArgs,
  > = $Result.GetResult<Prisma.$modulo_sistemaPayload, S>;

  type modulo_sistemaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    modulo_sistemaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Modulo_sistemaCountAggregateInputType | true;
  };

  export interface modulo_sistemaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['modulo_sistema'];
      meta: { name: 'modulo_sistema' };
    };
    /**
     * Find zero or one Modulo_sistema that matches the filter.
     * @param {modulo_sistemaFindUniqueArgs} args - Arguments to find a Modulo_sistema
     * @example
     * // Get one Modulo_sistema
     * const modulo_sistema = await prisma.modulo_sistema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modulo_sistemaFindUniqueArgs>(
      args: SelectSubset<T, modulo_sistemaFindUniqueArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Modulo_sistema that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {modulo_sistemaFindUniqueOrThrowArgs} args - Arguments to find a Modulo_sistema
     * @example
     * // Get one Modulo_sistema
     * const modulo_sistema = await prisma.modulo_sistema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modulo_sistemaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, modulo_sistemaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Modulo_sistema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulo_sistemaFindFirstArgs} args - Arguments to find a Modulo_sistema
     * @example
     * // Get one Modulo_sistema
     * const modulo_sistema = await prisma.modulo_sistema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modulo_sistemaFindFirstArgs>(
      args?: SelectSubset<T, modulo_sistemaFindFirstArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Modulo_sistema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulo_sistemaFindFirstOrThrowArgs} args - Arguments to find a Modulo_sistema
     * @example
     * // Get one Modulo_sistema
     * const modulo_sistema = await prisma.modulo_sistema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modulo_sistemaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, modulo_sistemaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Modulo_sistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulo_sistemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulo_sistemas
     * const modulo_sistemas = await prisma.modulo_sistema.findMany()
     *
     * // Get first 10 Modulo_sistemas
     * const modulo_sistemas = await prisma.modulo_sistema.findMany({ take: 10 })
     *
     * // Only select the `cod_modulo`
     * const modulo_sistemaWithCod_moduloOnly = await prisma.modulo_sistema.findMany({ select: { cod_modulo: true } })
     *
     */
    findMany<T extends modulo_sistemaFindManyArgs>(
      args?: SelectSubset<T, modulo_sistemaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Modulo_sistema.
     * @param {modulo_sistemaCreateArgs} args - Arguments to create a Modulo_sistema.
     * @example
     * // Create one Modulo_sistema
     * const Modulo_sistema = await prisma.modulo_sistema.create({
     *   data: {
     *     // ... data to create a Modulo_sistema
     *   }
     * })
     *
     */
    create<T extends modulo_sistemaCreateArgs>(
      args: SelectSubset<T, modulo_sistemaCreateArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Modulo_sistemas.
     * @param {modulo_sistemaCreateManyArgs} args - Arguments to create many Modulo_sistemas.
     * @example
     * // Create many Modulo_sistemas
     * const modulo_sistema = await prisma.modulo_sistema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends modulo_sistemaCreateManyArgs>(
      args?: SelectSubset<T, modulo_sistemaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Modulo_sistemas and returns the data saved in the database.
     * @param {modulo_sistemaCreateManyAndReturnArgs} args - Arguments to create many Modulo_sistemas.
     * @example
     * // Create many Modulo_sistemas
     * const modulo_sistema = await prisma.modulo_sistema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Modulo_sistemas and only return the `cod_modulo`
     * const modulo_sistemaWithCod_moduloOnly = await prisma.modulo_sistema.createManyAndReturn({
     *   select: { cod_modulo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends modulo_sistemaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, modulo_sistemaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Modulo_sistema.
     * @param {modulo_sistemaDeleteArgs} args - Arguments to delete one Modulo_sistema.
     * @example
     * // Delete one Modulo_sistema
     * const Modulo_sistema = await prisma.modulo_sistema.delete({
     *   where: {
     *     // ... filter to delete one Modulo_sistema
     *   }
     * })
     *
     */
    delete<T extends modulo_sistemaDeleteArgs>(
      args: SelectSubset<T, modulo_sistemaDeleteArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Modulo_sistema.
     * @param {modulo_sistemaUpdateArgs} args - Arguments to update one Modulo_sistema.
     * @example
     * // Update one Modulo_sistema
     * const modulo_sistema = await prisma.modulo_sistema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends modulo_sistemaUpdateArgs>(
      args: SelectSubset<T, modulo_sistemaUpdateArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Modulo_sistemas.
     * @param {modulo_sistemaDeleteManyArgs} args - Arguments to filter Modulo_sistemas to delete.
     * @example
     * // Delete a few Modulo_sistemas
     * const { count } = await prisma.modulo_sistema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends modulo_sistemaDeleteManyArgs>(
      args?: SelectSubset<T, modulo_sistemaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Modulo_sistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulo_sistemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulo_sistemas
     * const modulo_sistema = await prisma.modulo_sistema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends modulo_sistemaUpdateManyArgs>(
      args: SelectSubset<T, modulo_sistemaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Modulo_sistemas and returns the data updated in the database.
     * @param {modulo_sistemaUpdateManyAndReturnArgs} args - Arguments to update many Modulo_sistemas.
     * @example
     * // Update many Modulo_sistemas
     * const modulo_sistema = await prisma.modulo_sistema.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Modulo_sistemas and only return the `cod_modulo`
     * const modulo_sistemaWithCod_moduloOnly = await prisma.modulo_sistema.updateManyAndReturn({
     *   select: { cod_modulo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends modulo_sistemaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, modulo_sistemaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Modulo_sistema.
     * @param {modulo_sistemaUpsertArgs} args - Arguments to update or create a Modulo_sistema.
     * @example
     * // Update or create a Modulo_sistema
     * const modulo_sistema = await prisma.modulo_sistema.upsert({
     *   create: {
     *     // ... data to create a Modulo_sistema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulo_sistema we want to update
     *   }
     * })
     */
    upsert<T extends modulo_sistemaUpsertArgs>(
      args: SelectSubset<T, modulo_sistemaUpsertArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      $Result.GetResult<
        Prisma.$modulo_sistemaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Modulo_sistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulo_sistemaCountArgs} args - Arguments to filter Modulo_sistemas to count.
     * @example
     * // Count the number of Modulo_sistemas
     * const count = await prisma.modulo_sistema.count({
     *   where: {
     *     // ... the filter for the Modulo_sistemas we want to count
     *   }
     * })
     **/
    count<T extends modulo_sistemaCountArgs>(
      args?: Subset<T, modulo_sistemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Modulo_sistemaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Modulo_sistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Modulo_sistemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Modulo_sistemaAggregateArgs>(
      args: Subset<T, Modulo_sistemaAggregateArgs>,
    ): Prisma.PrismaPromise<GetModulo_sistemaAggregateType<T>>;

    /**
     * Group by Modulo_sistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulo_sistemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends modulo_sistemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modulo_sistemaGroupByArgs['orderBy'] }
        : { orderBy?: modulo_sistemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, modulo_sistemaGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetModulo_sistemaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the modulo_sistema model
     */
    readonly fields: modulo_sistemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for modulo_sistema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modulo_sistemaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    acesso_sistema<T extends modulo_sistema$acesso_sistemaArgs<ExtArgs> = {}>(
      args?: Subset<T, modulo_sistema$acesso_sistemaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$acesso_sistemaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    tela_sistema<T extends modulo_sistema$tela_sistemaArgs<ExtArgs> = {}>(
      args?: Subset<T, modulo_sistema$tela_sistemaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$tela_sistemaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the modulo_sistema model
   */
  interface modulo_sistemaFieldRefs {
    readonly cod_modulo: FieldRef<'modulo_sistema', 'Int'>;
    readonly desc_modulo: FieldRef<'modulo_sistema', 'String'>;
  }

  // Custom InputTypes
  /**
   * modulo_sistema findUnique
   */
  export type modulo_sistemaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which modulo_sistema to fetch.
     */
    where: modulo_sistemaWhereUniqueInput;
  };

  /**
   * modulo_sistema findUniqueOrThrow
   */
  export type modulo_sistemaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which modulo_sistema to fetch.
     */
    where: modulo_sistemaWhereUniqueInput;
  };

  /**
   * modulo_sistema findFirst
   */
  export type modulo_sistemaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which modulo_sistema to fetch.
     */
    where?: modulo_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of modulo_sistemas to fetch.
     */
    orderBy?:
      | modulo_sistemaOrderByWithRelationInput
      | modulo_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for modulo_sistemas.
     */
    cursor?: modulo_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` modulo_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` modulo_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of modulo_sistemas.
     */
    distinct?: Modulo_sistemaScalarFieldEnum | Modulo_sistemaScalarFieldEnum[];
  };

  /**
   * modulo_sistema findFirstOrThrow
   */
  export type modulo_sistemaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which modulo_sistema to fetch.
     */
    where?: modulo_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of modulo_sistemas to fetch.
     */
    orderBy?:
      | modulo_sistemaOrderByWithRelationInput
      | modulo_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for modulo_sistemas.
     */
    cursor?: modulo_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` modulo_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` modulo_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of modulo_sistemas.
     */
    distinct?: Modulo_sistemaScalarFieldEnum | Modulo_sistemaScalarFieldEnum[];
  };

  /**
   * modulo_sistema findMany
   */
  export type modulo_sistemaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which modulo_sistemas to fetch.
     */
    where?: modulo_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of modulo_sistemas to fetch.
     */
    orderBy?:
      | modulo_sistemaOrderByWithRelationInput
      | modulo_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing modulo_sistemas.
     */
    cursor?: modulo_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` modulo_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` modulo_sistemas.
     */
    skip?: number;
    distinct?: Modulo_sistemaScalarFieldEnum | Modulo_sistemaScalarFieldEnum[];
  };

  /**
   * modulo_sistema create
   */
  export type modulo_sistemaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * The data needed to create a modulo_sistema.
     */
    data: XOR<modulo_sistemaCreateInput, modulo_sistemaUncheckedCreateInput>;
  };

  /**
   * modulo_sistema createMany
   */
  export type modulo_sistemaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many modulo_sistemas.
     */
    data: modulo_sistemaCreateManyInput | modulo_sistemaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * modulo_sistema createManyAndReturn
   */
  export type modulo_sistemaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * The data used to create many modulo_sistemas.
     */
    data: modulo_sistemaCreateManyInput | modulo_sistemaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * modulo_sistema update
   */
  export type modulo_sistemaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * The data needed to update a modulo_sistema.
     */
    data: XOR<modulo_sistemaUpdateInput, modulo_sistemaUncheckedUpdateInput>;
    /**
     * Choose, which modulo_sistema to update.
     */
    where: modulo_sistemaWhereUniqueInput;
  };

  /**
   * modulo_sistema updateMany
   */
  export type modulo_sistemaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update modulo_sistemas.
     */
    data: XOR<
      modulo_sistemaUpdateManyMutationInput,
      modulo_sistemaUncheckedUpdateManyInput
    >;
    /**
     * Filter which modulo_sistemas to update
     */
    where?: modulo_sistemaWhereInput;
    /**
     * Limit how many modulo_sistemas to update.
     */
    limit?: number;
  };

  /**
   * modulo_sistema updateManyAndReturn
   */
  export type modulo_sistemaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * The data used to update modulo_sistemas.
     */
    data: XOR<
      modulo_sistemaUpdateManyMutationInput,
      modulo_sistemaUncheckedUpdateManyInput
    >;
    /**
     * Filter which modulo_sistemas to update
     */
    where?: modulo_sistemaWhereInput;
    /**
     * Limit how many modulo_sistemas to update.
     */
    limit?: number;
  };

  /**
   * modulo_sistema upsert
   */
  export type modulo_sistemaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * The filter to search for the modulo_sistema to update in case it exists.
     */
    where: modulo_sistemaWhereUniqueInput;
    /**
     * In case the modulo_sistema found by the `where` argument doesn't exist, create a new modulo_sistema with this data.
     */
    create: XOR<modulo_sistemaCreateInput, modulo_sistemaUncheckedCreateInput>;
    /**
     * In case the modulo_sistema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modulo_sistemaUpdateInput, modulo_sistemaUncheckedUpdateInput>;
  };

  /**
   * modulo_sistema delete
   */
  export type modulo_sistemaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
    /**
     * Filter which modulo_sistema to delete.
     */
    where: modulo_sistemaWhereUniqueInput;
  };

  /**
   * modulo_sistema deleteMany
   */
  export type modulo_sistemaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which modulo_sistemas to delete
     */
    where?: modulo_sistemaWhereInput;
    /**
     * Limit how many modulo_sistemas to delete.
     */
    limit?: number;
  };

  /**
   * modulo_sistema.acesso_sistema
   */
  export type modulo_sistema$acesso_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    where?: acesso_sistemaWhereInput;
    orderBy?:
      | acesso_sistemaOrderByWithRelationInput
      | acesso_sistemaOrderByWithRelationInput[];
    cursor?: acesso_sistemaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Acesso_sistemaScalarFieldEnum | Acesso_sistemaScalarFieldEnum[];
  };

  /**
   * modulo_sistema.tela_sistema
   */
  export type modulo_sistema$tela_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    where?: tela_sistemaWhereInput;
    orderBy?:
      | tela_sistemaOrderByWithRelationInput
      | tela_sistemaOrderByWithRelationInput[];
    cursor?: tela_sistemaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Tela_sistemaScalarFieldEnum | Tela_sistemaScalarFieldEnum[];
  };

  /**
   * modulo_sistema without action
   */
  export type modulo_sistemaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the modulo_sistema
     */
    select?: modulo_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the modulo_sistema
     */
    omit?: modulo_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulo_sistemaInclude<ExtArgs> | null;
  };

  /**
   * Model nfse
   */

  export type AggregateNfse = {
    _count: NfseCountAggregateOutputType | null;
    _avg: NfseAvgAggregateOutputType | null;
    _sum: NfseSumAggregateOutputType | null;
    _min: NfseMinAggregateOutputType | null;
    _max: NfseMaxAggregateOutputType | null;
  };

  export type NfseAvgAggregateOutputType = {
    cod_nfse: number | null;
    cod_empresa: number | null;
    cod_cliente: number | null;
    cod_ctiss: number | null;
    natoper_nfse: number | null;
    regtrib_nfse: number | null;
    vrtot_nfse: Decimal | null;
    vrded_nfse: Decimal | null;
    vrdesc1_nfse: Decimal | null;
    vrdesc2_nfse: Decimal | null;
    vrir_nfse: Decimal | null;
    vrpis_nfse: Decimal | null;
    vrcofins_nfse: Decimal | null;
    vrcsll_nfse: Decimal | null;
    vrout_nfse: Decimal | null;
    issret_nfse: number | null;
    aliqiss_nfse: Decimal | null;
    vrinss_nfse: Decimal | null;
    aliqissret_nfse: Decimal | null;
    tipoper_nfse: number | null;
    opsimnac_nfse: number | null;
    csll_nfse: Decimal | null;
    pis_nfse: Decimal | null;
    cofins_nfse: Decimal | null;
    irrf_nfse: Decimal | null;
  };

  export type NfseSumAggregateOutputType = {
    cod_nfse: number | null;
    cod_empresa: number | null;
    cod_cliente: number | null;
    cod_ctiss: number | null;
    natoper_nfse: number | null;
    regtrib_nfse: number | null;
    vrtot_nfse: Decimal | null;
    vrded_nfse: Decimal | null;
    vrdesc1_nfse: Decimal | null;
    vrdesc2_nfse: Decimal | null;
    vrir_nfse: Decimal | null;
    vrpis_nfse: Decimal | null;
    vrcofins_nfse: Decimal | null;
    vrcsll_nfse: Decimal | null;
    vrout_nfse: Decimal | null;
    issret_nfse: number | null;
    aliqiss_nfse: Decimal | null;
    vrinss_nfse: Decimal | null;
    aliqissret_nfse: Decimal | null;
    tipoper_nfse: number | null;
    opsimnac_nfse: number | null;
    csll_nfse: Decimal | null;
    pis_nfse: Decimal | null;
    cofins_nfse: Decimal | null;
    irrf_nfse: Decimal | null;
  };

  export type NfseMinAggregateOutputType = {
    cod_nfse: number | null;
    num_nfse: string | null;
    dtemissao_nfse: Date | null;
    hremissao_nfse: string | null;
    cod_empresa: number | null;
    cod_cliente: number | null;
    discr_nfse: Uint8Array | null;
    cod_ctiss: number | null;
    natoper_nfse: number | null;
    regtrib_nfse: number | null;
    vrtot_nfse: Decimal | null;
    vrded_nfse: Decimal | null;
    vrdesc1_nfse: Decimal | null;
    vrdesc2_nfse: Decimal | null;
    vrir_nfse: Decimal | null;
    vrpis_nfse: Decimal | null;
    vrcofins_nfse: Decimal | null;
    vrcsll_nfse: Decimal | null;
    vrout_nfse: Decimal | null;
    issret_nfse: number | null;
    aliqiss_nfse: Decimal | null;
    vrinss_nfse: Decimal | null;
    doc_nfse: string | null;
    aliqissret_nfse: Decimal | null;
    xml_nfse: Uint8Array | null;
    codver_nfse: string | null;
    logtrans_nfse: Uint8Array | null;
    logcan_nfse: Uint8Array | null;
    xmlformat_nfse: Uint8Array | null;
    prot_nfse: string | null;
    chvcan_nfse: string | null;
    dtcanc_nfse: string | null;
    tipoper_nfse: number | null;
    opsimnac_nfse: number | null;
    csll_nfse: Decimal | null;
    pis_nfse: Decimal | null;
    cofins_nfse: Decimal | null;
    irrf_nfse: Decimal | null;
  };

  export type NfseMaxAggregateOutputType = {
    cod_nfse: number | null;
    num_nfse: string | null;
    dtemissao_nfse: Date | null;
    hremissao_nfse: string | null;
    cod_empresa: number | null;
    cod_cliente: number | null;
    discr_nfse: Uint8Array | null;
    cod_ctiss: number | null;
    natoper_nfse: number | null;
    regtrib_nfse: number | null;
    vrtot_nfse: Decimal | null;
    vrded_nfse: Decimal | null;
    vrdesc1_nfse: Decimal | null;
    vrdesc2_nfse: Decimal | null;
    vrir_nfse: Decimal | null;
    vrpis_nfse: Decimal | null;
    vrcofins_nfse: Decimal | null;
    vrcsll_nfse: Decimal | null;
    vrout_nfse: Decimal | null;
    issret_nfse: number | null;
    aliqiss_nfse: Decimal | null;
    vrinss_nfse: Decimal | null;
    doc_nfse: string | null;
    aliqissret_nfse: Decimal | null;
    xml_nfse: Uint8Array | null;
    codver_nfse: string | null;
    logtrans_nfse: Uint8Array | null;
    logcan_nfse: Uint8Array | null;
    xmlformat_nfse: Uint8Array | null;
    prot_nfse: string | null;
    chvcan_nfse: string | null;
    dtcanc_nfse: string | null;
    tipoper_nfse: number | null;
    opsimnac_nfse: number | null;
    csll_nfse: Decimal | null;
    pis_nfse: Decimal | null;
    cofins_nfse: Decimal | null;
    irrf_nfse: Decimal | null;
  };

  export type NfseCountAggregateOutputType = {
    cod_nfse: number;
    num_nfse: number;
    dtemissao_nfse: number;
    hremissao_nfse: number;
    cod_empresa: number;
    cod_cliente: number;
    discr_nfse: number;
    cod_ctiss: number;
    natoper_nfse: number;
    regtrib_nfse: number;
    vrtot_nfse: number;
    vrded_nfse: number;
    vrdesc1_nfse: number;
    vrdesc2_nfse: number;
    vrir_nfse: number;
    vrpis_nfse: number;
    vrcofins_nfse: number;
    vrcsll_nfse: number;
    vrout_nfse: number;
    issret_nfse: number;
    aliqiss_nfse: number;
    vrinss_nfse: number;
    doc_nfse: number;
    aliqissret_nfse: number;
    xml_nfse: number;
    codver_nfse: number;
    logtrans_nfse: number;
    logcan_nfse: number;
    xmlformat_nfse: number;
    prot_nfse: number;
    chvcan_nfse: number;
    dtcanc_nfse: number;
    tipoper_nfse: number;
    opsimnac_nfse: number;
    csll_nfse: number;
    pis_nfse: number;
    cofins_nfse: number;
    irrf_nfse: number;
    _all: number;
  };

  export type NfseAvgAggregateInputType = {
    cod_nfse?: true;
    cod_empresa?: true;
    cod_cliente?: true;
    cod_ctiss?: true;
    natoper_nfse?: true;
    regtrib_nfse?: true;
    vrtot_nfse?: true;
    vrded_nfse?: true;
    vrdesc1_nfse?: true;
    vrdesc2_nfse?: true;
    vrir_nfse?: true;
    vrpis_nfse?: true;
    vrcofins_nfse?: true;
    vrcsll_nfse?: true;
    vrout_nfse?: true;
    issret_nfse?: true;
    aliqiss_nfse?: true;
    vrinss_nfse?: true;
    aliqissret_nfse?: true;
    tipoper_nfse?: true;
    opsimnac_nfse?: true;
    csll_nfse?: true;
    pis_nfse?: true;
    cofins_nfse?: true;
    irrf_nfse?: true;
  };

  export type NfseSumAggregateInputType = {
    cod_nfse?: true;
    cod_empresa?: true;
    cod_cliente?: true;
    cod_ctiss?: true;
    natoper_nfse?: true;
    regtrib_nfse?: true;
    vrtot_nfse?: true;
    vrded_nfse?: true;
    vrdesc1_nfse?: true;
    vrdesc2_nfse?: true;
    vrir_nfse?: true;
    vrpis_nfse?: true;
    vrcofins_nfse?: true;
    vrcsll_nfse?: true;
    vrout_nfse?: true;
    issret_nfse?: true;
    aliqiss_nfse?: true;
    vrinss_nfse?: true;
    aliqissret_nfse?: true;
    tipoper_nfse?: true;
    opsimnac_nfse?: true;
    csll_nfse?: true;
    pis_nfse?: true;
    cofins_nfse?: true;
    irrf_nfse?: true;
  };

  export type NfseMinAggregateInputType = {
    cod_nfse?: true;
    num_nfse?: true;
    dtemissao_nfse?: true;
    hremissao_nfse?: true;
    cod_empresa?: true;
    cod_cliente?: true;
    discr_nfse?: true;
    cod_ctiss?: true;
    natoper_nfse?: true;
    regtrib_nfse?: true;
    vrtot_nfse?: true;
    vrded_nfse?: true;
    vrdesc1_nfse?: true;
    vrdesc2_nfse?: true;
    vrir_nfse?: true;
    vrpis_nfse?: true;
    vrcofins_nfse?: true;
    vrcsll_nfse?: true;
    vrout_nfse?: true;
    issret_nfse?: true;
    aliqiss_nfse?: true;
    vrinss_nfse?: true;
    doc_nfse?: true;
    aliqissret_nfse?: true;
    xml_nfse?: true;
    codver_nfse?: true;
    logtrans_nfse?: true;
    logcan_nfse?: true;
    xmlformat_nfse?: true;
    prot_nfse?: true;
    chvcan_nfse?: true;
    dtcanc_nfse?: true;
    tipoper_nfse?: true;
    opsimnac_nfse?: true;
    csll_nfse?: true;
    pis_nfse?: true;
    cofins_nfse?: true;
    irrf_nfse?: true;
  };

  export type NfseMaxAggregateInputType = {
    cod_nfse?: true;
    num_nfse?: true;
    dtemissao_nfse?: true;
    hremissao_nfse?: true;
    cod_empresa?: true;
    cod_cliente?: true;
    discr_nfse?: true;
    cod_ctiss?: true;
    natoper_nfse?: true;
    regtrib_nfse?: true;
    vrtot_nfse?: true;
    vrded_nfse?: true;
    vrdesc1_nfse?: true;
    vrdesc2_nfse?: true;
    vrir_nfse?: true;
    vrpis_nfse?: true;
    vrcofins_nfse?: true;
    vrcsll_nfse?: true;
    vrout_nfse?: true;
    issret_nfse?: true;
    aliqiss_nfse?: true;
    vrinss_nfse?: true;
    doc_nfse?: true;
    aliqissret_nfse?: true;
    xml_nfse?: true;
    codver_nfse?: true;
    logtrans_nfse?: true;
    logcan_nfse?: true;
    xmlformat_nfse?: true;
    prot_nfse?: true;
    chvcan_nfse?: true;
    dtcanc_nfse?: true;
    tipoper_nfse?: true;
    opsimnac_nfse?: true;
    csll_nfse?: true;
    pis_nfse?: true;
    cofins_nfse?: true;
    irrf_nfse?: true;
  };

  export type NfseCountAggregateInputType = {
    cod_nfse?: true;
    num_nfse?: true;
    dtemissao_nfse?: true;
    hremissao_nfse?: true;
    cod_empresa?: true;
    cod_cliente?: true;
    discr_nfse?: true;
    cod_ctiss?: true;
    natoper_nfse?: true;
    regtrib_nfse?: true;
    vrtot_nfse?: true;
    vrded_nfse?: true;
    vrdesc1_nfse?: true;
    vrdesc2_nfse?: true;
    vrir_nfse?: true;
    vrpis_nfse?: true;
    vrcofins_nfse?: true;
    vrcsll_nfse?: true;
    vrout_nfse?: true;
    issret_nfse?: true;
    aliqiss_nfse?: true;
    vrinss_nfse?: true;
    doc_nfse?: true;
    aliqissret_nfse?: true;
    xml_nfse?: true;
    codver_nfse?: true;
    logtrans_nfse?: true;
    logcan_nfse?: true;
    xmlformat_nfse?: true;
    prot_nfse?: true;
    chvcan_nfse?: true;
    dtcanc_nfse?: true;
    tipoper_nfse?: true;
    opsimnac_nfse?: true;
    csll_nfse?: true;
    pis_nfse?: true;
    cofins_nfse?: true;
    irrf_nfse?: true;
    _all?: true;
  };

  export type NfseAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which nfse to aggregate.
     */
    where?: nfseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nfses to fetch.
     */
    orderBy?: nfseOrderByWithRelationInput | nfseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: nfseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nfses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nfses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned nfses
     **/
    _count?: true | NfseCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NfseAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NfseSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NfseMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NfseMaxAggregateInputType;
  };

  export type GetNfseAggregateType<T extends NfseAggregateArgs> = {
    [P in keyof T & keyof AggregateNfse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNfse[P]>
      : GetScalarType<T[P], AggregateNfse[P]>;
  };

  export type nfseGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: nfseWhereInput;
    orderBy?:
      | nfseOrderByWithAggregationInput
      | nfseOrderByWithAggregationInput[];
    by: NfseScalarFieldEnum[] | NfseScalarFieldEnum;
    having?: nfseScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NfseCountAggregateInputType | true;
    _avg?: NfseAvgAggregateInputType;
    _sum?: NfseSumAggregateInputType;
    _min?: NfseMinAggregateInputType;
    _max?: NfseMaxAggregateInputType;
  };

  export type NfseGroupByOutputType = {
    cod_nfse: number;
    num_nfse: string | null;
    dtemissao_nfse: Date;
    hremissao_nfse: string;
    cod_empresa: number;
    cod_cliente: number;
    discr_nfse: Uint8Array | null;
    cod_ctiss: number;
    natoper_nfse: number;
    regtrib_nfse: number;
    vrtot_nfse: Decimal;
    vrded_nfse: Decimal;
    vrdesc1_nfse: Decimal;
    vrdesc2_nfse: Decimal;
    vrir_nfse: Decimal;
    vrpis_nfse: Decimal;
    vrcofins_nfse: Decimal;
    vrcsll_nfse: Decimal;
    vrout_nfse: Decimal;
    issret_nfse: number;
    aliqiss_nfse: Decimal;
    vrinss_nfse: Decimal;
    doc_nfse: string | null;
    aliqissret_nfse: Decimal;
    xml_nfse: Uint8Array | null;
    codver_nfse: string | null;
    logtrans_nfse: Uint8Array | null;
    logcan_nfse: Uint8Array | null;
    xmlformat_nfse: Uint8Array | null;
    prot_nfse: string | null;
    chvcan_nfse: string | null;
    dtcanc_nfse: string | null;
    tipoper_nfse: number;
    opsimnac_nfse: number;
    csll_nfse: Decimal;
    pis_nfse: Decimal;
    cofins_nfse: Decimal;
    irrf_nfse: Decimal;
    _count: NfseCountAggregateOutputType | null;
    _avg: NfseAvgAggregateOutputType | null;
    _sum: NfseSumAggregateOutputType | null;
    _min: NfseMinAggregateOutputType | null;
    _max: NfseMaxAggregateOutputType | null;
  };

  type GetNfseGroupByPayload<T extends nfseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NfseGroupByOutputType, T['by']> & {
        [P in keyof T & keyof NfseGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NfseGroupByOutputType[P]>
          : GetScalarType<T[P], NfseGroupByOutputType[P]>;
      }
    >
  >;

  export type nfseSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_nfse?: boolean;
      num_nfse?: boolean;
      dtemissao_nfse?: boolean;
      hremissao_nfse?: boolean;
      cod_empresa?: boolean;
      cod_cliente?: boolean;
      discr_nfse?: boolean;
      cod_ctiss?: boolean;
      natoper_nfse?: boolean;
      regtrib_nfse?: boolean;
      vrtot_nfse?: boolean;
      vrded_nfse?: boolean;
      vrdesc1_nfse?: boolean;
      vrdesc2_nfse?: boolean;
      vrir_nfse?: boolean;
      vrpis_nfse?: boolean;
      vrcofins_nfse?: boolean;
      vrcsll_nfse?: boolean;
      vrout_nfse?: boolean;
      issret_nfse?: boolean;
      aliqiss_nfse?: boolean;
      vrinss_nfse?: boolean;
      doc_nfse?: boolean;
      aliqissret_nfse?: boolean;
      xml_nfse?: boolean;
      codver_nfse?: boolean;
      logtrans_nfse?: boolean;
      logcan_nfse?: boolean;
      xmlformat_nfse?: boolean;
      prot_nfse?: boolean;
      chvcan_nfse?: boolean;
      dtcanc_nfse?: boolean;
      tipoper_nfse?: boolean;
      opsimnac_nfse?: boolean;
      csll_nfse?: boolean;
      pis_nfse?: boolean;
      cofins_nfse?: boolean;
      irrf_nfse?: boolean;
    },
    ExtArgs['result']['nfse']
  >;

  export type nfseSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_nfse?: boolean;
      num_nfse?: boolean;
      dtemissao_nfse?: boolean;
      hremissao_nfse?: boolean;
      cod_empresa?: boolean;
      cod_cliente?: boolean;
      discr_nfse?: boolean;
      cod_ctiss?: boolean;
      natoper_nfse?: boolean;
      regtrib_nfse?: boolean;
      vrtot_nfse?: boolean;
      vrded_nfse?: boolean;
      vrdesc1_nfse?: boolean;
      vrdesc2_nfse?: boolean;
      vrir_nfse?: boolean;
      vrpis_nfse?: boolean;
      vrcofins_nfse?: boolean;
      vrcsll_nfse?: boolean;
      vrout_nfse?: boolean;
      issret_nfse?: boolean;
      aliqiss_nfse?: boolean;
      vrinss_nfse?: boolean;
      doc_nfse?: boolean;
      aliqissret_nfse?: boolean;
      xml_nfse?: boolean;
      codver_nfse?: boolean;
      logtrans_nfse?: boolean;
      logcan_nfse?: boolean;
      xmlformat_nfse?: boolean;
      prot_nfse?: boolean;
      chvcan_nfse?: boolean;
      dtcanc_nfse?: boolean;
      tipoper_nfse?: boolean;
      opsimnac_nfse?: boolean;
      csll_nfse?: boolean;
      pis_nfse?: boolean;
      cofins_nfse?: boolean;
      irrf_nfse?: boolean;
    },
    ExtArgs['result']['nfse']
  >;

  export type nfseSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_nfse?: boolean;
      num_nfse?: boolean;
      dtemissao_nfse?: boolean;
      hremissao_nfse?: boolean;
      cod_empresa?: boolean;
      cod_cliente?: boolean;
      discr_nfse?: boolean;
      cod_ctiss?: boolean;
      natoper_nfse?: boolean;
      regtrib_nfse?: boolean;
      vrtot_nfse?: boolean;
      vrded_nfse?: boolean;
      vrdesc1_nfse?: boolean;
      vrdesc2_nfse?: boolean;
      vrir_nfse?: boolean;
      vrpis_nfse?: boolean;
      vrcofins_nfse?: boolean;
      vrcsll_nfse?: boolean;
      vrout_nfse?: boolean;
      issret_nfse?: boolean;
      aliqiss_nfse?: boolean;
      vrinss_nfse?: boolean;
      doc_nfse?: boolean;
      aliqissret_nfse?: boolean;
      xml_nfse?: boolean;
      codver_nfse?: boolean;
      logtrans_nfse?: boolean;
      logcan_nfse?: boolean;
      xmlformat_nfse?: boolean;
      prot_nfse?: boolean;
      chvcan_nfse?: boolean;
      dtcanc_nfse?: boolean;
      tipoper_nfse?: boolean;
      opsimnac_nfse?: boolean;
      csll_nfse?: boolean;
      pis_nfse?: boolean;
      cofins_nfse?: boolean;
      irrf_nfse?: boolean;
    },
    ExtArgs['result']['nfse']
  >;

  export type nfseSelectScalar = {
    cod_nfse?: boolean;
    num_nfse?: boolean;
    dtemissao_nfse?: boolean;
    hremissao_nfse?: boolean;
    cod_empresa?: boolean;
    cod_cliente?: boolean;
    discr_nfse?: boolean;
    cod_ctiss?: boolean;
    natoper_nfse?: boolean;
    regtrib_nfse?: boolean;
    vrtot_nfse?: boolean;
    vrded_nfse?: boolean;
    vrdesc1_nfse?: boolean;
    vrdesc2_nfse?: boolean;
    vrir_nfse?: boolean;
    vrpis_nfse?: boolean;
    vrcofins_nfse?: boolean;
    vrcsll_nfse?: boolean;
    vrout_nfse?: boolean;
    issret_nfse?: boolean;
    aliqiss_nfse?: boolean;
    vrinss_nfse?: boolean;
    doc_nfse?: boolean;
    aliqissret_nfse?: boolean;
    xml_nfse?: boolean;
    codver_nfse?: boolean;
    logtrans_nfse?: boolean;
    logcan_nfse?: boolean;
    xmlformat_nfse?: boolean;
    prot_nfse?: boolean;
    chvcan_nfse?: boolean;
    dtcanc_nfse?: boolean;
    tipoper_nfse?: boolean;
    opsimnac_nfse?: boolean;
    csll_nfse?: boolean;
    pis_nfse?: boolean;
    cofins_nfse?: boolean;
    irrf_nfse?: boolean;
  };

  export type nfseOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_nfse'
    | 'num_nfse'
    | 'dtemissao_nfse'
    | 'hremissao_nfse'
    | 'cod_empresa'
    | 'cod_cliente'
    | 'discr_nfse'
    | 'cod_ctiss'
    | 'natoper_nfse'
    | 'regtrib_nfse'
    | 'vrtot_nfse'
    | 'vrded_nfse'
    | 'vrdesc1_nfse'
    | 'vrdesc2_nfse'
    | 'vrir_nfse'
    | 'vrpis_nfse'
    | 'vrcofins_nfse'
    | 'vrcsll_nfse'
    | 'vrout_nfse'
    | 'issret_nfse'
    | 'aliqiss_nfse'
    | 'vrinss_nfse'
    | 'doc_nfse'
    | 'aliqissret_nfse'
    | 'xml_nfse'
    | 'codver_nfse'
    | 'logtrans_nfse'
    | 'logcan_nfse'
    | 'xmlformat_nfse'
    | 'prot_nfse'
    | 'chvcan_nfse'
    | 'dtcanc_nfse'
    | 'tipoper_nfse'
    | 'opsimnac_nfse'
    | 'csll_nfse'
    | 'pis_nfse'
    | 'cofins_nfse'
    | 'irrf_nfse',
    ExtArgs['result']['nfse']
  >;

  export type $nfsePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'nfse';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_nfse: number;
        num_nfse: string | null;
        dtemissao_nfse: Date;
        hremissao_nfse: string;
        cod_empresa: number;
        cod_cliente: number;
        discr_nfse: Uint8Array | null;
        cod_ctiss: number;
        natoper_nfse: number;
        regtrib_nfse: number;
        vrtot_nfse: Prisma.Decimal;
        vrded_nfse: Prisma.Decimal;
        vrdesc1_nfse: Prisma.Decimal;
        vrdesc2_nfse: Prisma.Decimal;
        vrir_nfse: Prisma.Decimal;
        vrpis_nfse: Prisma.Decimal;
        vrcofins_nfse: Prisma.Decimal;
        vrcsll_nfse: Prisma.Decimal;
        vrout_nfse: Prisma.Decimal;
        issret_nfse: number;
        aliqiss_nfse: Prisma.Decimal;
        vrinss_nfse: Prisma.Decimal;
        doc_nfse: string | null;
        aliqissret_nfse: Prisma.Decimal;
        xml_nfse: Uint8Array | null;
        codver_nfse: string | null;
        logtrans_nfse: Uint8Array | null;
        logcan_nfse: Uint8Array | null;
        xmlformat_nfse: Uint8Array | null;
        prot_nfse: string | null;
        chvcan_nfse: string | null;
        dtcanc_nfse: string | null;
        tipoper_nfse: number;
        opsimnac_nfse: number;
        csll_nfse: Prisma.Decimal;
        pis_nfse: Prisma.Decimal;
        cofins_nfse: Prisma.Decimal;
        irrf_nfse: Prisma.Decimal;
      },
      ExtArgs['result']['nfse']
    >;
    composites: {};
  };

  type nfseGetPayload<S extends boolean | null | undefined | nfseDefaultArgs> =
    $Result.GetResult<Prisma.$nfsePayload, S>;

  type nfseCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<nfseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NfseCountAggregateInputType | true;
  };

  export interface nfseDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['nfse'];
      meta: { name: 'nfse' };
    };
    /**
     * Find zero or one Nfse that matches the filter.
     * @param {nfseFindUniqueArgs} args - Arguments to find a Nfse
     * @example
     * // Get one Nfse
     * const nfse = await prisma.nfse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends nfseFindUniqueArgs>(
      args: SelectSubset<T, nfseFindUniqueArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Nfse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {nfseFindUniqueOrThrowArgs} args - Arguments to find a Nfse
     * @example
     * // Get one Nfse
     * const nfse = await prisma.nfse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends nfseFindUniqueOrThrowArgs>(
      args: SelectSubset<T, nfseFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Nfse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nfseFindFirstArgs} args - Arguments to find a Nfse
     * @example
     * // Get one Nfse
     * const nfse = await prisma.nfse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends nfseFindFirstArgs>(
      args?: SelectSubset<T, nfseFindFirstArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Nfse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nfseFindFirstOrThrowArgs} args - Arguments to find a Nfse
     * @example
     * // Get one Nfse
     * const nfse = await prisma.nfse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends nfseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, nfseFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Nfses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nfseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nfses
     * const nfses = await prisma.nfse.findMany()
     *
     * // Get first 10 Nfses
     * const nfses = await prisma.nfse.findMany({ take: 10 })
     *
     * // Only select the `cod_nfse`
     * const nfseWithCod_nfseOnly = await prisma.nfse.findMany({ select: { cod_nfse: true } })
     *
     */
    findMany<T extends nfseFindManyArgs>(
      args?: SelectSubset<T, nfseFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Nfse.
     * @param {nfseCreateArgs} args - Arguments to create a Nfse.
     * @example
     * // Create one Nfse
     * const Nfse = await prisma.nfse.create({
     *   data: {
     *     // ... data to create a Nfse
     *   }
     * })
     *
     */
    create<T extends nfseCreateArgs>(
      args: SelectSubset<T, nfseCreateArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Nfses.
     * @param {nfseCreateManyArgs} args - Arguments to create many Nfses.
     * @example
     * // Create many Nfses
     * const nfse = await prisma.nfse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends nfseCreateManyArgs>(
      args?: SelectSubset<T, nfseCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Nfses and returns the data saved in the database.
     * @param {nfseCreateManyAndReturnArgs} args - Arguments to create many Nfses.
     * @example
     * // Create many Nfses
     * const nfse = await prisma.nfse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Nfses and only return the `cod_nfse`
     * const nfseWithCod_nfseOnly = await prisma.nfse.createManyAndReturn({
     *   select: { cod_nfse: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends nfseCreateManyAndReturnArgs>(
      args?: SelectSubset<T, nfseCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Nfse.
     * @param {nfseDeleteArgs} args - Arguments to delete one Nfse.
     * @example
     * // Delete one Nfse
     * const Nfse = await prisma.nfse.delete({
     *   where: {
     *     // ... filter to delete one Nfse
     *   }
     * })
     *
     */
    delete<T extends nfseDeleteArgs>(
      args: SelectSubset<T, nfseDeleteArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Nfse.
     * @param {nfseUpdateArgs} args - Arguments to update one Nfse.
     * @example
     * // Update one Nfse
     * const nfse = await prisma.nfse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends nfseUpdateArgs>(
      args: SelectSubset<T, nfseUpdateArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Nfses.
     * @param {nfseDeleteManyArgs} args - Arguments to filter Nfses to delete.
     * @example
     * // Delete a few Nfses
     * const { count } = await prisma.nfse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends nfseDeleteManyArgs>(
      args?: SelectSubset<T, nfseDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Nfses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nfseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nfses
     * const nfse = await prisma.nfse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends nfseUpdateManyArgs>(
      args: SelectSubset<T, nfseUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Nfses and returns the data updated in the database.
     * @param {nfseUpdateManyAndReturnArgs} args - Arguments to update many Nfses.
     * @example
     * // Update many Nfses
     * const nfse = await prisma.nfse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Nfses and only return the `cod_nfse`
     * const nfseWithCod_nfseOnly = await prisma.nfse.updateManyAndReturn({
     *   select: { cod_nfse: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends nfseUpdateManyAndReturnArgs>(
      args: SelectSubset<T, nfseUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Nfse.
     * @param {nfseUpsertArgs} args - Arguments to update or create a Nfse.
     * @example
     * // Update or create a Nfse
     * const nfse = await prisma.nfse.upsert({
     *   create: {
     *     // ... data to create a Nfse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nfse we want to update
     *   }
     * })
     */
    upsert<T extends nfseUpsertArgs>(
      args: SelectSubset<T, nfseUpsertArgs<ExtArgs>>,
    ): Prisma__nfseClient<
      $Result.GetResult<
        Prisma.$nfsePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Nfses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nfseCountArgs} args - Arguments to filter Nfses to count.
     * @example
     * // Count the number of Nfses
     * const count = await prisma.nfse.count({
     *   where: {
     *     // ... the filter for the Nfses we want to count
     *   }
     * })
     **/
    count<T extends nfseCountArgs>(
      args?: Subset<T, nfseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NfseCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Nfse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NfseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NfseAggregateArgs>(
      args: Subset<T, NfseAggregateArgs>,
    ): Prisma.PrismaPromise<GetNfseAggregateType<T>>;

    /**
     * Group by Nfse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nfseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends nfseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: nfseGroupByArgs['orderBy'] }
        : { orderBy?: nfseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, nfseGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNfseGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the nfse model
     */
    readonly fields: nfseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for nfse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__nfseClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the nfse model
   */
  interface nfseFieldRefs {
    readonly cod_nfse: FieldRef<'nfse', 'Int'>;
    readonly num_nfse: FieldRef<'nfse', 'String'>;
    readonly dtemissao_nfse: FieldRef<'nfse', 'DateTime'>;
    readonly hremissao_nfse: FieldRef<'nfse', 'String'>;
    readonly cod_empresa: FieldRef<'nfse', 'Int'>;
    readonly cod_cliente: FieldRef<'nfse', 'Int'>;
    readonly discr_nfse: FieldRef<'nfse', 'Bytes'>;
    readonly cod_ctiss: FieldRef<'nfse', 'Int'>;
    readonly natoper_nfse: FieldRef<'nfse', 'Int'>;
    readonly regtrib_nfse: FieldRef<'nfse', 'Int'>;
    readonly vrtot_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrded_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrdesc1_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrdesc2_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrir_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrpis_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrcofins_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrcsll_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrout_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly issret_nfse: FieldRef<'nfse', 'Int'>;
    readonly aliqiss_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly vrinss_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly doc_nfse: FieldRef<'nfse', 'String'>;
    readonly aliqissret_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly xml_nfse: FieldRef<'nfse', 'Bytes'>;
    readonly codver_nfse: FieldRef<'nfse', 'String'>;
    readonly logtrans_nfse: FieldRef<'nfse', 'Bytes'>;
    readonly logcan_nfse: FieldRef<'nfse', 'Bytes'>;
    readonly xmlformat_nfse: FieldRef<'nfse', 'Bytes'>;
    readonly prot_nfse: FieldRef<'nfse', 'String'>;
    readonly chvcan_nfse: FieldRef<'nfse', 'String'>;
    readonly dtcanc_nfse: FieldRef<'nfse', 'String'>;
    readonly tipoper_nfse: FieldRef<'nfse', 'Int'>;
    readonly opsimnac_nfse: FieldRef<'nfse', 'Int'>;
    readonly csll_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly pis_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly cofins_nfse: FieldRef<'nfse', 'Decimal'>;
    readonly irrf_nfse: FieldRef<'nfse', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * nfse findUnique
   */
  export type nfseFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * Filter, which nfse to fetch.
     */
    where: nfseWhereUniqueInput;
  };

  /**
   * nfse findUniqueOrThrow
   */
  export type nfseFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * Filter, which nfse to fetch.
     */
    where: nfseWhereUniqueInput;
  };

  /**
   * nfse findFirst
   */
  export type nfseFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * Filter, which nfse to fetch.
     */
    where?: nfseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nfses to fetch.
     */
    orderBy?: nfseOrderByWithRelationInput | nfseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for nfses.
     */
    cursor?: nfseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nfses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nfses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of nfses.
     */
    distinct?: NfseScalarFieldEnum | NfseScalarFieldEnum[];
  };

  /**
   * nfse findFirstOrThrow
   */
  export type nfseFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * Filter, which nfse to fetch.
     */
    where?: nfseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nfses to fetch.
     */
    orderBy?: nfseOrderByWithRelationInput | nfseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for nfses.
     */
    cursor?: nfseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nfses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nfses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of nfses.
     */
    distinct?: NfseScalarFieldEnum | NfseScalarFieldEnum[];
  };

  /**
   * nfse findMany
   */
  export type nfseFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * Filter, which nfses to fetch.
     */
    where?: nfseWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nfses to fetch.
     */
    orderBy?: nfseOrderByWithRelationInput | nfseOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing nfses.
     */
    cursor?: nfseWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nfses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nfses.
     */
    skip?: number;
    distinct?: NfseScalarFieldEnum | NfseScalarFieldEnum[];
  };

  /**
   * nfse create
   */
  export type nfseCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * The data needed to create a nfse.
     */
    data: XOR<nfseCreateInput, nfseUncheckedCreateInput>;
  };

  /**
   * nfse createMany
   */
  export type nfseCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many nfses.
     */
    data: nfseCreateManyInput | nfseCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * nfse createManyAndReturn
   */
  export type nfseCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * The data used to create many nfses.
     */
    data: nfseCreateManyInput | nfseCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * nfse update
   */
  export type nfseUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * The data needed to update a nfse.
     */
    data: XOR<nfseUpdateInput, nfseUncheckedUpdateInput>;
    /**
     * Choose, which nfse to update.
     */
    where: nfseWhereUniqueInput;
  };

  /**
   * nfse updateMany
   */
  export type nfseUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update nfses.
     */
    data: XOR<nfseUpdateManyMutationInput, nfseUncheckedUpdateManyInput>;
    /**
     * Filter which nfses to update
     */
    where?: nfseWhereInput;
    /**
     * Limit how many nfses to update.
     */
    limit?: number;
  };

  /**
   * nfse updateManyAndReturn
   */
  export type nfseUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * The data used to update nfses.
     */
    data: XOR<nfseUpdateManyMutationInput, nfseUncheckedUpdateManyInput>;
    /**
     * Filter which nfses to update
     */
    where?: nfseWhereInput;
    /**
     * Limit how many nfses to update.
     */
    limit?: number;
  };

  /**
   * nfse upsert
   */
  export type nfseUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * The filter to search for the nfse to update in case it exists.
     */
    where: nfseWhereUniqueInput;
    /**
     * In case the nfse found by the `where` argument doesn't exist, create a new nfse with this data.
     */
    create: XOR<nfseCreateInput, nfseUncheckedCreateInput>;
    /**
     * In case the nfse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nfseUpdateInput, nfseUncheckedUpdateInput>;
  };

  /**
   * nfse delete
   */
  export type nfseDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
    /**
     * Filter which nfse to delete.
     */
    where: nfseWhereUniqueInput;
  };

  /**
   * nfse deleteMany
   */
  export type nfseDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which nfses to delete
     */
    where?: nfseWhereInput;
    /**
     * Limit how many nfses to delete.
     */
    limit?: number;
  };

  /**
   * nfse without action
   */
  export type nfseDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nfse
     */
    select?: nfseSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nfse
     */
    omit?: nfseOmit<ExtArgs> | null;
  };

  /**
   * Model nivel
   */

  export type AggregateNivel = {
    _count: NivelCountAggregateOutputType | null;
    _avg: NivelAvgAggregateOutputType | null;
    _sum: NivelSumAggregateOutputType | null;
    _min: NivelMinAggregateOutputType | null;
    _max: NivelMaxAggregateOutputType | null;
  };

  export type NivelAvgAggregateOutputType = {
    cod_nivel: number | null;
    perc_nivel: Decimal | null;
  };

  export type NivelSumAggregateOutputType = {
    cod_nivel: number | null;
    perc_nivel: Decimal | null;
  };

  export type NivelMinAggregateOutputType = {
    cod_nivel: number | null;
    nome_nivel: string | null;
    perc_nivel: Decimal | null;
  };

  export type NivelMaxAggregateOutputType = {
    cod_nivel: number | null;
    nome_nivel: string | null;
    perc_nivel: Decimal | null;
  };

  export type NivelCountAggregateOutputType = {
    cod_nivel: number;
    nome_nivel: number;
    perc_nivel: number;
    _all: number;
  };

  export type NivelAvgAggregateInputType = {
    cod_nivel?: true;
    perc_nivel?: true;
  };

  export type NivelSumAggregateInputType = {
    cod_nivel?: true;
    perc_nivel?: true;
  };

  export type NivelMinAggregateInputType = {
    cod_nivel?: true;
    nome_nivel?: true;
    perc_nivel?: true;
  };

  export type NivelMaxAggregateInputType = {
    cod_nivel?: true;
    nome_nivel?: true;
    perc_nivel?: true;
  };

  export type NivelCountAggregateInputType = {
    cod_nivel?: true;
    nome_nivel?: true;
    perc_nivel?: true;
    _all?: true;
  };

  export type NivelAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which nivel to aggregate.
     */
    where?: nivelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nivels to fetch.
     */
    orderBy?: nivelOrderByWithRelationInput | nivelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: nivelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nivels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nivels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned nivels
     **/
    _count?: true | NivelCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: NivelAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: NivelSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NivelMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NivelMaxAggregateInputType;
  };

  export type GetNivelAggregateType<T extends NivelAggregateArgs> = {
    [P in keyof T & keyof AggregateNivel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNivel[P]>
      : GetScalarType<T[P], AggregateNivel[P]>;
  };

  export type nivelGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: nivelWhereInput;
    orderBy?:
      | nivelOrderByWithAggregationInput
      | nivelOrderByWithAggregationInput[];
    by: NivelScalarFieldEnum[] | NivelScalarFieldEnum;
    having?: nivelScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NivelCountAggregateInputType | true;
    _avg?: NivelAvgAggregateInputType;
    _sum?: NivelSumAggregateInputType;
    _min?: NivelMinAggregateInputType;
    _max?: NivelMaxAggregateInputType;
  };

  export type NivelGroupByOutputType = {
    cod_nivel: number;
    nome_nivel: string;
    perc_nivel: Decimal;
    _count: NivelCountAggregateOutputType | null;
    _avg: NivelAvgAggregateOutputType | null;
    _sum: NivelSumAggregateOutputType | null;
    _min: NivelMinAggregateOutputType | null;
    _max: NivelMaxAggregateOutputType | null;
  };

  type GetNivelGroupByPayload<T extends nivelGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NivelGroupByOutputType, T['by']> & {
          [P in keyof T & keyof NivelGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NivelGroupByOutputType[P]>
            : GetScalarType<T[P], NivelGroupByOutputType[P]>;
        }
      >
    >;

  export type nivelSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_nivel?: boolean;
      nome_nivel?: boolean;
      perc_nivel?: boolean;
      recurso?: boolean | nivel$recursoArgs<ExtArgs>;
      _count?: boolean | NivelCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['nivel']
  >;

  export type nivelSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_nivel?: boolean;
      nome_nivel?: boolean;
      perc_nivel?: boolean;
    },
    ExtArgs['result']['nivel']
  >;

  export type nivelSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_nivel?: boolean;
      nome_nivel?: boolean;
      perc_nivel?: boolean;
    },
    ExtArgs['result']['nivel']
  >;

  export type nivelSelectScalar = {
    cod_nivel?: boolean;
    nome_nivel?: boolean;
    perc_nivel?: boolean;
  };

  export type nivelOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_nivel' | 'nome_nivel' | 'perc_nivel',
    ExtArgs['result']['nivel']
  >;
  export type nivelInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    recurso?: boolean | nivel$recursoArgs<ExtArgs>;
    _count?: boolean | NivelCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type nivelIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type nivelIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $nivelPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'nivel';
    objects: {
      recurso: Prisma.$recursoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_nivel: number;
        nome_nivel: string;
        perc_nivel: Prisma.Decimal;
      },
      ExtArgs['result']['nivel']
    >;
    composites: {};
  };

  type nivelGetPayload<
    S extends boolean | null | undefined | nivelDefaultArgs,
  > = $Result.GetResult<Prisma.$nivelPayload, S>;

  type nivelCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<nivelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NivelCountAggregateInputType | true;
  };

  export interface nivelDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['nivel'];
      meta: { name: 'nivel' };
    };
    /**
     * Find zero or one Nivel that matches the filter.
     * @param {nivelFindUniqueArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends nivelFindUniqueArgs>(
      args: SelectSubset<T, nivelFindUniqueArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Nivel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {nivelFindUniqueOrThrowArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends nivelFindUniqueOrThrowArgs>(
      args: SelectSubset<T, nivelFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Nivel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nivelFindFirstArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends nivelFindFirstArgs>(
      args?: SelectSubset<T, nivelFindFirstArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Nivel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nivelFindFirstOrThrowArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends nivelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, nivelFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Nivels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nivelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nivels
     * const nivels = await prisma.nivel.findMany()
     *
     * // Get first 10 Nivels
     * const nivels = await prisma.nivel.findMany({ take: 10 })
     *
     * // Only select the `cod_nivel`
     * const nivelWithCod_nivelOnly = await prisma.nivel.findMany({ select: { cod_nivel: true } })
     *
     */
    findMany<T extends nivelFindManyArgs>(
      args?: SelectSubset<T, nivelFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Nivel.
     * @param {nivelCreateArgs} args - Arguments to create a Nivel.
     * @example
     * // Create one Nivel
     * const Nivel = await prisma.nivel.create({
     *   data: {
     *     // ... data to create a Nivel
     *   }
     * })
     *
     */
    create<T extends nivelCreateArgs>(
      args: SelectSubset<T, nivelCreateArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Nivels.
     * @param {nivelCreateManyArgs} args - Arguments to create many Nivels.
     * @example
     * // Create many Nivels
     * const nivel = await prisma.nivel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends nivelCreateManyArgs>(
      args?: SelectSubset<T, nivelCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Nivels and returns the data saved in the database.
     * @param {nivelCreateManyAndReturnArgs} args - Arguments to create many Nivels.
     * @example
     * // Create many Nivels
     * const nivel = await prisma.nivel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Nivels and only return the `cod_nivel`
     * const nivelWithCod_nivelOnly = await prisma.nivel.createManyAndReturn({
     *   select: { cod_nivel: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends nivelCreateManyAndReturnArgs>(
      args?: SelectSubset<T, nivelCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Nivel.
     * @param {nivelDeleteArgs} args - Arguments to delete one Nivel.
     * @example
     * // Delete one Nivel
     * const Nivel = await prisma.nivel.delete({
     *   where: {
     *     // ... filter to delete one Nivel
     *   }
     * })
     *
     */
    delete<T extends nivelDeleteArgs>(
      args: SelectSubset<T, nivelDeleteArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Nivel.
     * @param {nivelUpdateArgs} args - Arguments to update one Nivel.
     * @example
     * // Update one Nivel
     * const nivel = await prisma.nivel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends nivelUpdateArgs>(
      args: SelectSubset<T, nivelUpdateArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Nivels.
     * @param {nivelDeleteManyArgs} args - Arguments to filter Nivels to delete.
     * @example
     * // Delete a few Nivels
     * const { count } = await prisma.nivel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends nivelDeleteManyArgs>(
      args?: SelectSubset<T, nivelDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Nivels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nivelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nivels
     * const nivel = await prisma.nivel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends nivelUpdateManyArgs>(
      args: SelectSubset<T, nivelUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Nivels and returns the data updated in the database.
     * @param {nivelUpdateManyAndReturnArgs} args - Arguments to update many Nivels.
     * @example
     * // Update many Nivels
     * const nivel = await prisma.nivel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Nivels and only return the `cod_nivel`
     * const nivelWithCod_nivelOnly = await prisma.nivel.updateManyAndReturn({
     *   select: { cod_nivel: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends nivelUpdateManyAndReturnArgs>(
      args: SelectSubset<T, nivelUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Nivel.
     * @param {nivelUpsertArgs} args - Arguments to update or create a Nivel.
     * @example
     * // Update or create a Nivel
     * const nivel = await prisma.nivel.upsert({
     *   create: {
     *     // ... data to create a Nivel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nivel we want to update
     *   }
     * })
     */
    upsert<T extends nivelUpsertArgs>(
      args: SelectSubset<T, nivelUpsertArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      $Result.GetResult<
        Prisma.$nivelPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Nivels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nivelCountArgs} args - Arguments to filter Nivels to count.
     * @example
     * // Count the number of Nivels
     * const count = await prisma.nivel.count({
     *   where: {
     *     // ... the filter for the Nivels we want to count
     *   }
     * })
     **/
    count<T extends nivelCountArgs>(
      args?: Subset<T, nivelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NivelCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Nivel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NivelAggregateArgs>(
      args: Subset<T, NivelAggregateArgs>,
    ): Prisma.PrismaPromise<GetNivelAggregateType<T>>;

    /**
     * Group by Nivel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nivelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends nivelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: nivelGroupByArgs['orderBy'] }
        : { orderBy?: nivelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, nivelGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetNivelGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the nivel model
     */
    readonly fields: nivelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for nivel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__nivelClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    recurso<T extends nivel$recursoArgs<ExtArgs> = {}>(
      args?: Subset<T, nivel$recursoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$recursoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the nivel model
   */
  interface nivelFieldRefs {
    readonly cod_nivel: FieldRef<'nivel', 'Int'>;
    readonly nome_nivel: FieldRef<'nivel', 'String'>;
    readonly perc_nivel: FieldRef<'nivel', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * nivel findUnique
   */
  export type nivelFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * Filter, which nivel to fetch.
     */
    where: nivelWhereUniqueInput;
  };

  /**
   * nivel findUniqueOrThrow
   */
  export type nivelFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * Filter, which nivel to fetch.
     */
    where: nivelWhereUniqueInput;
  };

  /**
   * nivel findFirst
   */
  export type nivelFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * Filter, which nivel to fetch.
     */
    where?: nivelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nivels to fetch.
     */
    orderBy?: nivelOrderByWithRelationInput | nivelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for nivels.
     */
    cursor?: nivelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nivels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nivels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of nivels.
     */
    distinct?: NivelScalarFieldEnum | NivelScalarFieldEnum[];
  };

  /**
   * nivel findFirstOrThrow
   */
  export type nivelFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * Filter, which nivel to fetch.
     */
    where?: nivelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nivels to fetch.
     */
    orderBy?: nivelOrderByWithRelationInput | nivelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for nivels.
     */
    cursor?: nivelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nivels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nivels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of nivels.
     */
    distinct?: NivelScalarFieldEnum | NivelScalarFieldEnum[];
  };

  /**
   * nivel findMany
   */
  export type nivelFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * Filter, which nivels to fetch.
     */
    where?: nivelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of nivels to fetch.
     */
    orderBy?: nivelOrderByWithRelationInput | nivelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing nivels.
     */
    cursor?: nivelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` nivels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` nivels.
     */
    skip?: number;
    distinct?: NivelScalarFieldEnum | NivelScalarFieldEnum[];
  };

  /**
   * nivel create
   */
  export type nivelCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * The data needed to create a nivel.
     */
    data: XOR<nivelCreateInput, nivelUncheckedCreateInput>;
  };

  /**
   * nivel createMany
   */
  export type nivelCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many nivels.
     */
    data: nivelCreateManyInput | nivelCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * nivel createManyAndReturn
   */
  export type nivelCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * The data used to create many nivels.
     */
    data: nivelCreateManyInput | nivelCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * nivel update
   */
  export type nivelUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * The data needed to update a nivel.
     */
    data: XOR<nivelUpdateInput, nivelUncheckedUpdateInput>;
    /**
     * Choose, which nivel to update.
     */
    where: nivelWhereUniqueInput;
  };

  /**
   * nivel updateMany
   */
  export type nivelUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update nivels.
     */
    data: XOR<nivelUpdateManyMutationInput, nivelUncheckedUpdateManyInput>;
    /**
     * Filter which nivels to update
     */
    where?: nivelWhereInput;
    /**
     * Limit how many nivels to update.
     */
    limit?: number;
  };

  /**
   * nivel updateManyAndReturn
   */
  export type nivelUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * The data used to update nivels.
     */
    data: XOR<nivelUpdateManyMutationInput, nivelUncheckedUpdateManyInput>;
    /**
     * Filter which nivels to update
     */
    where?: nivelWhereInput;
    /**
     * Limit how many nivels to update.
     */
    limit?: number;
  };

  /**
   * nivel upsert
   */
  export type nivelUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * The filter to search for the nivel to update in case it exists.
     */
    where: nivelWhereUniqueInput;
    /**
     * In case the nivel found by the `where` argument doesn't exist, create a new nivel with this data.
     */
    create: XOR<nivelCreateInput, nivelUncheckedCreateInput>;
    /**
     * In case the nivel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nivelUpdateInput, nivelUncheckedUpdateInput>;
  };

  /**
   * nivel delete
   */
  export type nivelDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
    /**
     * Filter which nivel to delete.
     */
    where: nivelWhereUniqueInput;
  };

  /**
   * nivel deleteMany
   */
  export type nivelDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which nivels to delete
     */
    where?: nivelWhereInput;
    /**
     * Limit how many nivels to delete.
     */
    limit?: number;
  };

  /**
   * nivel.recurso
   */
  export type nivel$recursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    where?: recursoWhereInput;
    orderBy?:
      | recursoOrderByWithRelationInput
      | recursoOrderByWithRelationInput[];
    cursor?: recursoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[];
  };

  /**
   * nivel without action
   */
  export type nivelDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the nivel
     */
    select?: nivelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the nivel
     */
    omit?: nivelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: nivelInclude<ExtArgs> | null;
  };

  /**
   * Model os
   */

  export type AggregateOs = {
    _count: OsCountAggregateOutputType | null;
    _avg: OsAvgAggregateOutputType | null;
    _sum: OsSumAggregateOutputType | null;
    _min: OsMinAggregateOutputType | null;
    _max: OsMaxAggregateOutputType | null;
  };

  export type OsAvgAggregateOutputType = {
    cod_os: number | null;
    codtrf_os: number | null;
    status_os: number | null;
    codrec_os: number | null;
    perc_os: number | null;
    cod_faturamento: number | null;
    vrhr_os: Decimal | null;
  };

  export type OsSumAggregateOutputType = {
    cod_os: number | null;
    codtrf_os: number | null;
    status_os: number | null;
    codrec_os: number | null;
    perc_os: number | null;
    cod_faturamento: number | null;
    vrhr_os: Decimal | null;
  };

  export type OsMinAggregateOutputType = {
    cod_os: number | null;
    codtrf_os: number | null;
    dtini_os: Date | null;
    hrini_os: string | null;
    hrfim_os: string | null;
    obs_os: string | null;
    status_os: number | null;
    produtivo_os: string | null;
    codrec_os: number | null;
    produtivo2_os: string | null;
    respcli_os: string | null;
    remdes_os: string | null;
    abono_os: string | null;
    desloc_os: string | null;
    obs: Uint8Array | null;
    dtinc_os: Date | null;
    faturado_os: string | null;
    perc_os: number | null;
    cod_faturamento: number | null;
    comp_os: string | null;
    valid_os: string | null;
    vrhr_os: Decimal | null;
    num_os: string | null;
    chamado_os: string | null;
  };

  export type OsMaxAggregateOutputType = {
    cod_os: number | null;
    codtrf_os: number | null;
    dtini_os: Date | null;
    hrini_os: string | null;
    hrfim_os: string | null;
    obs_os: string | null;
    status_os: number | null;
    produtivo_os: string | null;
    codrec_os: number | null;
    produtivo2_os: string | null;
    respcli_os: string | null;
    remdes_os: string | null;
    abono_os: string | null;
    desloc_os: string | null;
    obs: Uint8Array | null;
    dtinc_os: Date | null;
    faturado_os: string | null;
    perc_os: number | null;
    cod_faturamento: number | null;
    comp_os: string | null;
    valid_os: string | null;
    vrhr_os: Decimal | null;
    num_os: string | null;
    chamado_os: string | null;
  };

  export type OsCountAggregateOutputType = {
    cod_os: number;
    codtrf_os: number;
    dtini_os: number;
    hrini_os: number;
    hrfim_os: number;
    obs_os: number;
    status_os: number;
    produtivo_os: number;
    codrec_os: number;
    produtivo2_os: number;
    respcli_os: number;
    remdes_os: number;
    abono_os: number;
    desloc_os: number;
    obs: number;
    dtinc_os: number;
    faturado_os: number;
    perc_os: number;
    cod_faturamento: number;
    comp_os: number;
    valid_os: number;
    vrhr_os: number;
    num_os: number;
    chamado_os: number;
    _all: number;
  };

  export type OsAvgAggregateInputType = {
    cod_os?: true;
    codtrf_os?: true;
    status_os?: true;
    codrec_os?: true;
    perc_os?: true;
    cod_faturamento?: true;
    vrhr_os?: true;
  };

  export type OsSumAggregateInputType = {
    cod_os?: true;
    codtrf_os?: true;
    status_os?: true;
    codrec_os?: true;
    perc_os?: true;
    cod_faturamento?: true;
    vrhr_os?: true;
  };

  export type OsMinAggregateInputType = {
    cod_os?: true;
    codtrf_os?: true;
    dtini_os?: true;
    hrini_os?: true;
    hrfim_os?: true;
    obs_os?: true;
    status_os?: true;
    produtivo_os?: true;
    codrec_os?: true;
    produtivo2_os?: true;
    respcli_os?: true;
    remdes_os?: true;
    abono_os?: true;
    desloc_os?: true;
    obs?: true;
    dtinc_os?: true;
    faturado_os?: true;
    perc_os?: true;
    cod_faturamento?: true;
    comp_os?: true;
    valid_os?: true;
    vrhr_os?: true;
    num_os?: true;
    chamado_os?: true;
  };

  export type OsMaxAggregateInputType = {
    cod_os?: true;
    codtrf_os?: true;
    dtini_os?: true;
    hrini_os?: true;
    hrfim_os?: true;
    obs_os?: true;
    status_os?: true;
    produtivo_os?: true;
    codrec_os?: true;
    produtivo2_os?: true;
    respcli_os?: true;
    remdes_os?: true;
    abono_os?: true;
    desloc_os?: true;
    obs?: true;
    dtinc_os?: true;
    faturado_os?: true;
    perc_os?: true;
    cod_faturamento?: true;
    comp_os?: true;
    valid_os?: true;
    vrhr_os?: true;
    num_os?: true;
    chamado_os?: true;
  };

  export type OsCountAggregateInputType = {
    cod_os?: true;
    codtrf_os?: true;
    dtini_os?: true;
    hrini_os?: true;
    hrfim_os?: true;
    obs_os?: true;
    status_os?: true;
    produtivo_os?: true;
    codrec_os?: true;
    produtivo2_os?: true;
    respcli_os?: true;
    remdes_os?: true;
    abono_os?: true;
    desloc_os?: true;
    obs?: true;
    dtinc_os?: true;
    faturado_os?: true;
    perc_os?: true;
    cod_faturamento?: true;
    comp_os?: true;
    valid_os?: true;
    vrhr_os?: true;
    num_os?: true;
    chamado_os?: true;
    _all?: true;
  };

  export type OsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which os to aggregate.
     */
    where?: osWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of os to fetch.
     */
    orderBy?: osOrderByWithRelationInput | osOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: osWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` os from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` os.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned os
     **/
    _count?: true | OsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OsMaxAggregateInputType;
  };

  export type GetOsAggregateType<T extends OsAggregateArgs> = {
    [P in keyof T & keyof AggregateOs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOs[P]>
      : GetScalarType<T[P], AggregateOs[P]>;
  };

  export type osGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: osWhereInput;
    orderBy?: osOrderByWithAggregationInput | osOrderByWithAggregationInput[];
    by: OsScalarFieldEnum[] | OsScalarFieldEnum;
    having?: osScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OsCountAggregateInputType | true;
    _avg?: OsAvgAggregateInputType;
    _sum?: OsSumAggregateInputType;
    _min?: OsMinAggregateInputType;
    _max?: OsMaxAggregateInputType;
  };

  export type OsGroupByOutputType = {
    cod_os: number;
    codtrf_os: number;
    dtini_os: Date;
    hrini_os: string;
    hrfim_os: string;
    obs_os: string | null;
    status_os: number;
    produtivo_os: string;
    codrec_os: number;
    produtivo2_os: string;
    respcli_os: string;
    remdes_os: string;
    abono_os: string;
    desloc_os: string | null;
    obs: Uint8Array | null;
    dtinc_os: Date;
    faturado_os: string;
    perc_os: number;
    cod_faturamento: number | null;
    comp_os: string | null;
    valid_os: string;
    vrhr_os: Decimal;
    num_os: string | null;
    chamado_os: string | null;
    _count: OsCountAggregateOutputType | null;
    _avg: OsAvgAggregateOutputType | null;
    _sum: OsSumAggregateOutputType | null;
    _min: OsMinAggregateOutputType | null;
    _max: OsMaxAggregateOutputType | null;
  };

  type GetOsGroupByPayload<T extends osGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof OsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OsGroupByOutputType[P]>
          : GetScalarType<T[P], OsGroupByOutputType[P]>;
      }
    >
  >;

  export type osSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_os?: boolean;
      codtrf_os?: boolean;
      dtini_os?: boolean;
      hrini_os?: boolean;
      hrfim_os?: boolean;
      obs_os?: boolean;
      status_os?: boolean;
      produtivo_os?: boolean;
      codrec_os?: boolean;
      produtivo2_os?: boolean;
      respcli_os?: boolean;
      remdes_os?: boolean;
      abono_os?: boolean;
      desloc_os?: boolean;
      obs?: boolean;
      dtinc_os?: boolean;
      faturado_os?: boolean;
      perc_os?: boolean;
      cod_faturamento?: boolean;
      comp_os?: boolean;
      valid_os?: boolean;
      vrhr_os?: boolean;
      num_os?: boolean;
      chamado_os?: boolean;
      tarefa?: boolean | tarefaDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['os']
  >;

  export type osSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_os?: boolean;
      codtrf_os?: boolean;
      dtini_os?: boolean;
      hrini_os?: boolean;
      hrfim_os?: boolean;
      obs_os?: boolean;
      status_os?: boolean;
      produtivo_os?: boolean;
      codrec_os?: boolean;
      produtivo2_os?: boolean;
      respcli_os?: boolean;
      remdes_os?: boolean;
      abono_os?: boolean;
      desloc_os?: boolean;
      obs?: boolean;
      dtinc_os?: boolean;
      faturado_os?: boolean;
      perc_os?: boolean;
      cod_faturamento?: boolean;
      comp_os?: boolean;
      valid_os?: boolean;
      vrhr_os?: boolean;
      num_os?: boolean;
      chamado_os?: boolean;
      tarefa?: boolean | tarefaDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['os']
  >;

  export type osSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_os?: boolean;
      codtrf_os?: boolean;
      dtini_os?: boolean;
      hrini_os?: boolean;
      hrfim_os?: boolean;
      obs_os?: boolean;
      status_os?: boolean;
      produtivo_os?: boolean;
      codrec_os?: boolean;
      produtivo2_os?: boolean;
      respcli_os?: boolean;
      remdes_os?: boolean;
      abono_os?: boolean;
      desloc_os?: boolean;
      obs?: boolean;
      dtinc_os?: boolean;
      faturado_os?: boolean;
      perc_os?: boolean;
      cod_faturamento?: boolean;
      comp_os?: boolean;
      valid_os?: boolean;
      vrhr_os?: boolean;
      num_os?: boolean;
      chamado_os?: boolean;
      tarefa?: boolean | tarefaDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['os']
  >;

  export type osSelectScalar = {
    cod_os?: boolean;
    codtrf_os?: boolean;
    dtini_os?: boolean;
    hrini_os?: boolean;
    hrfim_os?: boolean;
    obs_os?: boolean;
    status_os?: boolean;
    produtivo_os?: boolean;
    codrec_os?: boolean;
    produtivo2_os?: boolean;
    respcli_os?: boolean;
    remdes_os?: boolean;
    abono_os?: boolean;
    desloc_os?: boolean;
    obs?: boolean;
    dtinc_os?: boolean;
    faturado_os?: boolean;
    perc_os?: boolean;
    cod_faturamento?: boolean;
    comp_os?: boolean;
    valid_os?: boolean;
    vrhr_os?: boolean;
    num_os?: boolean;
    chamado_os?: boolean;
  };

  export type osOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_os'
    | 'codtrf_os'
    | 'dtini_os'
    | 'hrini_os'
    | 'hrfim_os'
    | 'obs_os'
    | 'status_os'
    | 'produtivo_os'
    | 'codrec_os'
    | 'produtivo2_os'
    | 'respcli_os'
    | 'remdes_os'
    | 'abono_os'
    | 'desloc_os'
    | 'obs'
    | 'dtinc_os'
    | 'faturado_os'
    | 'perc_os'
    | 'cod_faturamento'
    | 'comp_os'
    | 'valid_os'
    | 'vrhr_os'
    | 'num_os'
    | 'chamado_os',
    ExtArgs['result']['os']
  >;
  export type osInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>;
  };
  export type osIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>;
  };
  export type osIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>;
  };

  export type $osPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'os';
    objects: {
      tarefa: Prisma.$tarefaPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_os: number;
        codtrf_os: number;
        dtini_os: Date;
        hrini_os: string;
        hrfim_os: string;
        obs_os: string | null;
        status_os: number;
        produtivo_os: string;
        codrec_os: number;
        produtivo2_os: string;
        respcli_os: string;
        remdes_os: string;
        abono_os: string;
        desloc_os: string | null;
        obs: Uint8Array | null;
        dtinc_os: Date;
        faturado_os: string;
        perc_os: number;
        cod_faturamento: number | null;
        comp_os: string | null;
        valid_os: string;
        vrhr_os: Prisma.Decimal;
        num_os: string | null;
        chamado_os: string | null;
      },
      ExtArgs['result']['os']
    >;
    composites: {};
  };

  type osGetPayload<S extends boolean | null | undefined | osDefaultArgs> =
    $Result.GetResult<Prisma.$osPayload, S>;

  type osCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<osFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: OsCountAggregateInputType | true;
  };

  export interface osDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['os'];
      meta: { name: 'os' };
    };
    /**
     * Find zero or one Os that matches the filter.
     * @param {osFindUniqueArgs} args - Arguments to find a Os
     * @example
     * // Get one Os
     * const os = await prisma.os.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends osFindUniqueArgs>(
      args: SelectSubset<T, osFindUniqueArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Os that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {osFindUniqueOrThrowArgs} args - Arguments to find a Os
     * @example
     * // Get one Os
     * const os = await prisma.os.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends osFindUniqueOrThrowArgs>(
      args: SelectSubset<T, osFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Os that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {osFindFirstArgs} args - Arguments to find a Os
     * @example
     * // Get one Os
     * const os = await prisma.os.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends osFindFirstArgs>(
      args?: SelectSubset<T, osFindFirstArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Os that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {osFindFirstOrThrowArgs} args - Arguments to find a Os
     * @example
     * // Get one Os
     * const os = await prisma.os.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends osFindFirstOrThrowArgs>(
      args?: SelectSubset<T, osFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Os that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {osFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Os
     * const os = await prisma.os.findMany()
     *
     * // Get first 10 Os
     * const os = await prisma.os.findMany({ take: 10 })
     *
     * // Only select the `cod_os`
     * const osWithCod_osOnly = await prisma.os.findMany({ select: { cod_os: true } })
     *
     */
    findMany<T extends osFindManyArgs>(
      args?: SelectSubset<T, osFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Os.
     * @param {osCreateArgs} args - Arguments to create a Os.
     * @example
     * // Create one Os
     * const Os = await prisma.os.create({
     *   data: {
     *     // ... data to create a Os
     *   }
     * })
     *
     */
    create<T extends osCreateArgs>(
      args: SelectSubset<T, osCreateArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Os.
     * @param {osCreateManyArgs} args - Arguments to create many Os.
     * @example
     * // Create many Os
     * const os = await prisma.os.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends osCreateManyArgs>(
      args?: SelectSubset<T, osCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Os and returns the data saved in the database.
     * @param {osCreateManyAndReturnArgs} args - Arguments to create many Os.
     * @example
     * // Create many Os
     * const os = await prisma.os.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Os and only return the `cod_os`
     * const osWithCod_osOnly = await prisma.os.createManyAndReturn({
     *   select: { cod_os: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends osCreateManyAndReturnArgs>(
      args?: SelectSubset<T, osCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Os.
     * @param {osDeleteArgs} args - Arguments to delete one Os.
     * @example
     * // Delete one Os
     * const Os = await prisma.os.delete({
     *   where: {
     *     // ... filter to delete one Os
     *   }
     * })
     *
     */
    delete<T extends osDeleteArgs>(
      args: SelectSubset<T, osDeleteArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Os.
     * @param {osUpdateArgs} args - Arguments to update one Os.
     * @example
     * // Update one Os
     * const os = await prisma.os.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends osUpdateArgs>(
      args: SelectSubset<T, osUpdateArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Os.
     * @param {osDeleteManyArgs} args - Arguments to filter Os to delete.
     * @example
     * // Delete a few Os
     * const { count } = await prisma.os.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends osDeleteManyArgs>(
      args?: SelectSubset<T, osDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Os.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {osUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Os
     * const os = await prisma.os.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends osUpdateManyArgs>(
      args: SelectSubset<T, osUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Os and returns the data updated in the database.
     * @param {osUpdateManyAndReturnArgs} args - Arguments to update many Os.
     * @example
     * // Update many Os
     * const os = await prisma.os.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Os and only return the `cod_os`
     * const osWithCod_osOnly = await prisma.os.updateManyAndReturn({
     *   select: { cod_os: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends osUpdateManyAndReturnArgs>(
      args: SelectSubset<T, osUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Os.
     * @param {osUpsertArgs} args - Arguments to update or create a Os.
     * @example
     * // Update or create a Os
     * const os = await prisma.os.upsert({
     *   create: {
     *     // ... data to create a Os
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Os we want to update
     *   }
     * })
     */
    upsert<T extends osUpsertArgs>(
      args: SelectSubset<T, osUpsertArgs<ExtArgs>>,
    ): Prisma__osClient<
      $Result.GetResult<
        Prisma.$osPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Os.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {osCountArgs} args - Arguments to filter Os to count.
     * @example
     * // Count the number of Os
     * const count = await prisma.os.count({
     *   where: {
     *     // ... the filter for the Os we want to count
     *   }
     * })
     **/
    count<T extends osCountArgs>(
      args?: Subset<T, osCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Os.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OsAggregateArgs>(
      args: Subset<T, OsAggregateArgs>,
    ): Prisma.PrismaPromise<GetOsAggregateType<T>>;

    /**
     * Group by Os.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {osGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends osGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: osGroupByArgs['orderBy'] }
        : { orderBy?: osGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, osGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetOsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the os model
     */
    readonly fields: osFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for os.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__osClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    tarefa<T extends tarefaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, tarefaDefaultArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      | $Result.GetResult<
          Prisma.$tarefaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the os model
   */
  interface osFieldRefs {
    readonly cod_os: FieldRef<'os', 'Int'>;
    readonly codtrf_os: FieldRef<'os', 'Int'>;
    readonly dtini_os: FieldRef<'os', 'DateTime'>;
    readonly hrini_os: FieldRef<'os', 'String'>;
    readonly hrfim_os: FieldRef<'os', 'String'>;
    readonly obs_os: FieldRef<'os', 'String'>;
    readonly status_os: FieldRef<'os', 'Int'>;
    readonly produtivo_os: FieldRef<'os', 'String'>;
    readonly codrec_os: FieldRef<'os', 'Int'>;
    readonly produtivo2_os: FieldRef<'os', 'String'>;
    readonly respcli_os: FieldRef<'os', 'String'>;
    readonly remdes_os: FieldRef<'os', 'String'>;
    readonly abono_os: FieldRef<'os', 'String'>;
    readonly desloc_os: FieldRef<'os', 'String'>;
    readonly obs: FieldRef<'os', 'Bytes'>;
    readonly dtinc_os: FieldRef<'os', 'DateTime'>;
    readonly faturado_os: FieldRef<'os', 'String'>;
    readonly perc_os: FieldRef<'os', 'Int'>;
    readonly cod_faturamento: FieldRef<'os', 'Int'>;
    readonly comp_os: FieldRef<'os', 'String'>;
    readonly valid_os: FieldRef<'os', 'String'>;
    readonly vrhr_os: FieldRef<'os', 'Decimal'>;
    readonly num_os: FieldRef<'os', 'String'>;
    readonly chamado_os: FieldRef<'os', 'String'>;
  }

  // Custom InputTypes
  /**
   * os findUnique
   */
  export type osFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * Filter, which os to fetch.
     */
    where: osWhereUniqueInput;
  };

  /**
   * os findUniqueOrThrow
   */
  export type osFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * Filter, which os to fetch.
     */
    where: osWhereUniqueInput;
  };

  /**
   * os findFirst
   */
  export type osFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * Filter, which os to fetch.
     */
    where?: osWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of os to fetch.
     */
    orderBy?: osOrderByWithRelationInput | osOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for os.
     */
    cursor?: osWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` os from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` os.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of os.
     */
    distinct?: OsScalarFieldEnum | OsScalarFieldEnum[];
  };

  /**
   * os findFirstOrThrow
   */
  export type osFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * Filter, which os to fetch.
     */
    where?: osWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of os to fetch.
     */
    orderBy?: osOrderByWithRelationInput | osOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for os.
     */
    cursor?: osWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` os from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` os.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of os.
     */
    distinct?: OsScalarFieldEnum | OsScalarFieldEnum[];
  };

  /**
   * os findMany
   */
  export type osFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * Filter, which os to fetch.
     */
    where?: osWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of os to fetch.
     */
    orderBy?: osOrderByWithRelationInput | osOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing os.
     */
    cursor?: osWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` os from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` os.
     */
    skip?: number;
    distinct?: OsScalarFieldEnum | OsScalarFieldEnum[];
  };

  /**
   * os create
   */
  export type osCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * The data needed to create a os.
     */
    data: XOR<osCreateInput, osUncheckedCreateInput>;
  };

  /**
   * os createMany
   */
  export type osCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many os.
     */
    data: osCreateManyInput | osCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * os createManyAndReturn
   */
  export type osCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * The data used to create many os.
     */
    data: osCreateManyInput | osCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * os update
   */
  export type osUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * The data needed to update a os.
     */
    data: XOR<osUpdateInput, osUncheckedUpdateInput>;
    /**
     * Choose, which os to update.
     */
    where: osWhereUniqueInput;
  };

  /**
   * os updateMany
   */
  export type osUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update os.
     */
    data: XOR<osUpdateManyMutationInput, osUncheckedUpdateManyInput>;
    /**
     * Filter which os to update
     */
    where?: osWhereInput;
    /**
     * Limit how many os to update.
     */
    limit?: number;
  };

  /**
   * os updateManyAndReturn
   */
  export type osUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * The data used to update os.
     */
    data: XOR<osUpdateManyMutationInput, osUncheckedUpdateManyInput>;
    /**
     * Filter which os to update
     */
    where?: osWhereInput;
    /**
     * Limit how many os to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * os upsert
   */
  export type osUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * The filter to search for the os to update in case it exists.
     */
    where: osWhereUniqueInput;
    /**
     * In case the os found by the `where` argument doesn't exist, create a new os with this data.
     */
    create: XOR<osCreateInput, osUncheckedCreateInput>;
    /**
     * In case the os was found with the provided `where` argument, update it with this data.
     */
    update: XOR<osUpdateInput, osUncheckedUpdateInput>;
  };

  /**
   * os delete
   */
  export type osDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    /**
     * Filter which os to delete.
     */
    where: osWhereUniqueInput;
  };

  /**
   * os deleteMany
   */
  export type osDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which os to delete
     */
    where?: osWhereInput;
    /**
     * Limit how many os to delete.
     */
    limit?: number;
  };

  /**
   * os without action
   */
  export type osDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
  };

  /**
   * Model parametros
   */

  export type AggregateParametros = {
    _count: ParametrosCountAggregateOutputType | null;
    _avg: ParametrosAvgAggregateOutputType | null;
    _sum: ParametrosSumAggregateOutputType | null;
    _min: ParametrosMinAggregateOutputType | null;
    _max: ParametrosMaxAggregateOutputType | null;
  };

  export type ParametrosAvgAggregateOutputType = {
    cod_parametro: number | null;
  };

  export type ParametrosSumAggregateOutputType = {
    cod_parametro: number | null;
  };

  export type ParametrosMinAggregateOutputType = {
    cod_parametro: number | null;
    descr_parametro: string | null;
    valor_parametro: string | null;
  };

  export type ParametrosMaxAggregateOutputType = {
    cod_parametro: number | null;
    descr_parametro: string | null;
    valor_parametro: string | null;
  };

  export type ParametrosCountAggregateOutputType = {
    cod_parametro: number;
    descr_parametro: number;
    valor_parametro: number;
    _all: number;
  };

  export type ParametrosAvgAggregateInputType = {
    cod_parametro?: true;
  };

  export type ParametrosSumAggregateInputType = {
    cod_parametro?: true;
  };

  export type ParametrosMinAggregateInputType = {
    cod_parametro?: true;
    descr_parametro?: true;
    valor_parametro?: true;
  };

  export type ParametrosMaxAggregateInputType = {
    cod_parametro?: true;
    descr_parametro?: true;
    valor_parametro?: true;
  };

  export type ParametrosCountAggregateInputType = {
    cod_parametro?: true;
    descr_parametro?: true;
    valor_parametro?: true;
    _all?: true;
  };

  export type ParametrosAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which parametros to aggregate.
     */
    where?: parametrosWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parametros to fetch.
     */
    orderBy?:
      | parametrosOrderByWithRelationInput
      | parametrosOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: parametrosWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parametros from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parametros.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned parametros
     **/
    _count?: true | ParametrosCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ParametrosAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ParametrosSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ParametrosMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ParametrosMaxAggregateInputType;
  };

  export type GetParametrosAggregateType<T extends ParametrosAggregateArgs> = {
    [P in keyof T & keyof AggregateParametros]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParametros[P]>
      : GetScalarType<T[P], AggregateParametros[P]>;
  };

  export type parametrosGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: parametrosWhereInput;
    orderBy?:
      | parametrosOrderByWithAggregationInput
      | parametrosOrderByWithAggregationInput[];
    by: ParametrosScalarFieldEnum[] | ParametrosScalarFieldEnum;
    having?: parametrosScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ParametrosCountAggregateInputType | true;
    _avg?: ParametrosAvgAggregateInputType;
    _sum?: ParametrosSumAggregateInputType;
    _min?: ParametrosMinAggregateInputType;
    _max?: ParametrosMaxAggregateInputType;
  };

  export type ParametrosGroupByOutputType = {
    cod_parametro: number;
    descr_parametro: string;
    valor_parametro: string | null;
    _count: ParametrosCountAggregateOutputType | null;
    _avg: ParametrosAvgAggregateOutputType | null;
    _sum: ParametrosSumAggregateOutputType | null;
    _min: ParametrosMinAggregateOutputType | null;
    _max: ParametrosMaxAggregateOutputType | null;
  };

  type GetParametrosGroupByPayload<T extends parametrosGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ParametrosGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ParametrosGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParametrosGroupByOutputType[P]>
            : GetScalarType<T[P], ParametrosGroupByOutputType[P]>;
        }
      >
    >;

  export type parametrosSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_parametro?: boolean;
      descr_parametro?: boolean;
      valor_parametro?: boolean;
    },
    ExtArgs['result']['parametros']
  >;

  export type parametrosSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_parametro?: boolean;
      descr_parametro?: boolean;
      valor_parametro?: boolean;
    },
    ExtArgs['result']['parametros']
  >;

  export type parametrosSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_parametro?: boolean;
      descr_parametro?: boolean;
      valor_parametro?: boolean;
    },
    ExtArgs['result']['parametros']
  >;

  export type parametrosSelectScalar = {
    cod_parametro?: boolean;
    descr_parametro?: boolean;
    valor_parametro?: boolean;
  };

  export type parametrosOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_parametro' | 'descr_parametro' | 'valor_parametro',
    ExtArgs['result']['parametros']
  >;

  export type $parametrosPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'parametros';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_parametro: number;
        descr_parametro: string;
        valor_parametro: string | null;
      },
      ExtArgs['result']['parametros']
    >;
    composites: {};
  };

  type parametrosGetPayload<
    S extends boolean | null | undefined | parametrosDefaultArgs,
  > = $Result.GetResult<Prisma.$parametrosPayload, S>;

  type parametrosCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    parametrosFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ParametrosCountAggregateInputType | true;
  };

  export interface parametrosDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['parametros'];
      meta: { name: 'parametros' };
    };
    /**
     * Find zero or one Parametros that matches the filter.
     * @param {parametrosFindUniqueArgs} args - Arguments to find a Parametros
     * @example
     * // Get one Parametros
     * const parametros = await prisma.parametros.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parametrosFindUniqueArgs>(
      args: SelectSubset<T, parametrosFindUniqueArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Parametros that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parametrosFindUniqueOrThrowArgs} args - Arguments to find a Parametros
     * @example
     * // Get one Parametros
     * const parametros = await prisma.parametros.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parametrosFindUniqueOrThrowArgs>(
      args: SelectSubset<T, parametrosFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Parametros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametrosFindFirstArgs} args - Arguments to find a Parametros
     * @example
     * // Get one Parametros
     * const parametros = await prisma.parametros.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parametrosFindFirstArgs>(
      args?: SelectSubset<T, parametrosFindFirstArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Parametros that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametrosFindFirstOrThrowArgs} args - Arguments to find a Parametros
     * @example
     * // Get one Parametros
     * const parametros = await prisma.parametros.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parametrosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, parametrosFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Parametros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametrosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parametros
     * const parametros = await prisma.parametros.findMany()
     *
     * // Get first 10 Parametros
     * const parametros = await prisma.parametros.findMany({ take: 10 })
     *
     * // Only select the `cod_parametro`
     * const parametrosWithCod_parametroOnly = await prisma.parametros.findMany({ select: { cod_parametro: true } })
     *
     */
    findMany<T extends parametrosFindManyArgs>(
      args?: SelectSubset<T, parametrosFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Parametros.
     * @param {parametrosCreateArgs} args - Arguments to create a Parametros.
     * @example
     * // Create one Parametros
     * const Parametros = await prisma.parametros.create({
     *   data: {
     *     // ... data to create a Parametros
     *   }
     * })
     *
     */
    create<T extends parametrosCreateArgs>(
      args: SelectSubset<T, parametrosCreateArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Parametros.
     * @param {parametrosCreateManyArgs} args - Arguments to create many Parametros.
     * @example
     * // Create many Parametros
     * const parametros = await prisma.parametros.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends parametrosCreateManyArgs>(
      args?: SelectSubset<T, parametrosCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Parametros and returns the data saved in the database.
     * @param {parametrosCreateManyAndReturnArgs} args - Arguments to create many Parametros.
     * @example
     * // Create many Parametros
     * const parametros = await prisma.parametros.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Parametros and only return the `cod_parametro`
     * const parametrosWithCod_parametroOnly = await prisma.parametros.createManyAndReturn({
     *   select: { cod_parametro: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends parametrosCreateManyAndReturnArgs>(
      args?: SelectSubset<T, parametrosCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Parametros.
     * @param {parametrosDeleteArgs} args - Arguments to delete one Parametros.
     * @example
     * // Delete one Parametros
     * const Parametros = await prisma.parametros.delete({
     *   where: {
     *     // ... filter to delete one Parametros
     *   }
     * })
     *
     */
    delete<T extends parametrosDeleteArgs>(
      args: SelectSubset<T, parametrosDeleteArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Parametros.
     * @param {parametrosUpdateArgs} args - Arguments to update one Parametros.
     * @example
     * // Update one Parametros
     * const parametros = await prisma.parametros.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends parametrosUpdateArgs>(
      args: SelectSubset<T, parametrosUpdateArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Parametros.
     * @param {parametrosDeleteManyArgs} args - Arguments to filter Parametros to delete.
     * @example
     * // Delete a few Parametros
     * const { count } = await prisma.parametros.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends parametrosDeleteManyArgs>(
      args?: SelectSubset<T, parametrosDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Parametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametrosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parametros
     * const parametros = await prisma.parametros.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends parametrosUpdateManyArgs>(
      args: SelectSubset<T, parametrosUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Parametros and returns the data updated in the database.
     * @param {parametrosUpdateManyAndReturnArgs} args - Arguments to update many Parametros.
     * @example
     * // Update many Parametros
     * const parametros = await prisma.parametros.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Parametros and only return the `cod_parametro`
     * const parametrosWithCod_parametroOnly = await prisma.parametros.updateManyAndReturn({
     *   select: { cod_parametro: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends parametrosUpdateManyAndReturnArgs>(
      args: SelectSubset<T, parametrosUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Parametros.
     * @param {parametrosUpsertArgs} args - Arguments to update or create a Parametros.
     * @example
     * // Update or create a Parametros
     * const parametros = await prisma.parametros.upsert({
     *   create: {
     *     // ... data to create a Parametros
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parametros we want to update
     *   }
     * })
     */
    upsert<T extends parametrosUpsertArgs>(
      args: SelectSubset<T, parametrosUpsertArgs<ExtArgs>>,
    ): Prisma__parametrosClient<
      $Result.GetResult<
        Prisma.$parametrosPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Parametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametrosCountArgs} args - Arguments to filter Parametros to count.
     * @example
     * // Count the number of Parametros
     * const count = await prisma.parametros.count({
     *   where: {
     *     // ... the filter for the Parametros we want to count
     *   }
     * })
     **/
    count<T extends parametrosCountArgs>(
      args?: Subset<T, parametrosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParametrosCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Parametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametrosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ParametrosAggregateArgs>(
      args: Subset<T, ParametrosAggregateArgs>,
    ): Prisma.PrismaPromise<GetParametrosAggregateType<T>>;

    /**
     * Group by Parametros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametrosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends parametrosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parametrosGroupByArgs['orderBy'] }
        : { orderBy?: parametrosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, parametrosGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetParametrosGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the parametros model
     */
    readonly fields: parametrosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parametros.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parametrosClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the parametros model
   */
  interface parametrosFieldRefs {
    readonly cod_parametro: FieldRef<'parametros', 'Int'>;
    readonly descr_parametro: FieldRef<'parametros', 'String'>;
    readonly valor_parametro: FieldRef<'parametros', 'String'>;
  }

  // Custom InputTypes
  /**
   * parametros findUnique
   */
  export type parametrosFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * Filter, which parametros to fetch.
     */
    where: parametrosWhereUniqueInput;
  };

  /**
   * parametros findUniqueOrThrow
   */
  export type parametrosFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * Filter, which parametros to fetch.
     */
    where: parametrosWhereUniqueInput;
  };

  /**
   * parametros findFirst
   */
  export type parametrosFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * Filter, which parametros to fetch.
     */
    where?: parametrosWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parametros to fetch.
     */
    orderBy?:
      | parametrosOrderByWithRelationInput
      | parametrosOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for parametros.
     */
    cursor?: parametrosWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parametros from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parametros.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of parametros.
     */
    distinct?: ParametrosScalarFieldEnum | ParametrosScalarFieldEnum[];
  };

  /**
   * parametros findFirstOrThrow
   */
  export type parametrosFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * Filter, which parametros to fetch.
     */
    where?: parametrosWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parametros to fetch.
     */
    orderBy?:
      | parametrosOrderByWithRelationInput
      | parametrosOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for parametros.
     */
    cursor?: parametrosWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parametros from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parametros.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of parametros.
     */
    distinct?: ParametrosScalarFieldEnum | ParametrosScalarFieldEnum[];
  };

  /**
   * parametros findMany
   */
  export type parametrosFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * Filter, which parametros to fetch.
     */
    where?: parametrosWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parametros to fetch.
     */
    orderBy?:
      | parametrosOrderByWithRelationInput
      | parametrosOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing parametros.
     */
    cursor?: parametrosWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parametros from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parametros.
     */
    skip?: number;
    distinct?: ParametrosScalarFieldEnum | ParametrosScalarFieldEnum[];
  };

  /**
   * parametros create
   */
  export type parametrosCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * The data needed to create a parametros.
     */
    data: XOR<parametrosCreateInput, parametrosUncheckedCreateInput>;
  };

  /**
   * parametros createMany
   */
  export type parametrosCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many parametros.
     */
    data: parametrosCreateManyInput | parametrosCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * parametros createManyAndReturn
   */
  export type parametrosCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * The data used to create many parametros.
     */
    data: parametrosCreateManyInput | parametrosCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * parametros update
   */
  export type parametrosUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * The data needed to update a parametros.
     */
    data: XOR<parametrosUpdateInput, parametrosUncheckedUpdateInput>;
    /**
     * Choose, which parametros to update.
     */
    where: parametrosWhereUniqueInput;
  };

  /**
   * parametros updateMany
   */
  export type parametrosUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update parametros.
     */
    data: XOR<
      parametrosUpdateManyMutationInput,
      parametrosUncheckedUpdateManyInput
    >;
    /**
     * Filter which parametros to update
     */
    where?: parametrosWhereInput;
    /**
     * Limit how many parametros to update.
     */
    limit?: number;
  };

  /**
   * parametros updateManyAndReturn
   */
  export type parametrosUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * The data used to update parametros.
     */
    data: XOR<
      parametrosUpdateManyMutationInput,
      parametrosUncheckedUpdateManyInput
    >;
    /**
     * Filter which parametros to update
     */
    where?: parametrosWhereInput;
    /**
     * Limit how many parametros to update.
     */
    limit?: number;
  };

  /**
   * parametros upsert
   */
  export type parametrosUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * The filter to search for the parametros to update in case it exists.
     */
    where: parametrosWhereUniqueInput;
    /**
     * In case the parametros found by the `where` argument doesn't exist, create a new parametros with this data.
     */
    create: XOR<parametrosCreateInput, parametrosUncheckedCreateInput>;
    /**
     * In case the parametros was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parametrosUpdateInput, parametrosUncheckedUpdateInput>;
  };

  /**
   * parametros delete
   */
  export type parametrosDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
    /**
     * Filter which parametros to delete.
     */
    where: parametrosWhereUniqueInput;
  };

  /**
   * parametros deleteMany
   */
  export type parametrosDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which parametros to delete
     */
    where?: parametrosWhereInput;
    /**
     * Limit how many parametros to delete.
     */
    limit?: number;
  };

  /**
   * parametros without action
   */
  export type parametrosDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parametros
     */
    select?: parametrosSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parametros
     */
    omit?: parametrosOmit<ExtArgs> | null;
  };

  /**
   * Model parcela
   */

  export type AggregateParcela = {
    _count: ParcelaCountAggregateOutputType | null;
    _avg: ParcelaAvgAggregateOutputType | null;
    _sum: ParcelaSumAggregateOutputType | null;
    _min: ParcelaMinAggregateOutputType | null;
    _max: ParcelaMaxAggregateOutputType | null;
  };

  export type ParcelaAvgAggregateOutputType = {
    cod_parcela: number | null;
    cod_lista: number | null;
    valor_parcela: Decimal | null;
    juros_parcela: Decimal | null;
    multa_parcela: Decimal | null;
    desconto_parcela: Decimal | null;
  };

  export type ParcelaSumAggregateOutputType = {
    cod_parcela: number | null;
    cod_lista: number | null;
    valor_parcela: Decimal | null;
    juros_parcela: Decimal | null;
    multa_parcela: Decimal | null;
    desconto_parcela: Decimal | null;
  };

  export type ParcelaMinAggregateOutputType = {
    cod_parcela: number | null;
    cod_lista: number | null;
    data_parcela: string | null;
    venc_parcela: string | null;
    pag_parcela: string | null;
    valor_parcela: Decimal | null;
    juros_parcela: Decimal | null;
    multa_parcela: Decimal | null;
    desconto_parcela: Decimal | null;
    status_parcela: string | null;
    id_parcela: string | null;
  };

  export type ParcelaMaxAggregateOutputType = {
    cod_parcela: number | null;
    cod_lista: number | null;
    data_parcela: string | null;
    venc_parcela: string | null;
    pag_parcela: string | null;
    valor_parcela: Decimal | null;
    juros_parcela: Decimal | null;
    multa_parcela: Decimal | null;
    desconto_parcela: Decimal | null;
    status_parcela: string | null;
    id_parcela: string | null;
  };

  export type ParcelaCountAggregateOutputType = {
    cod_parcela: number;
    cod_lista: number;
    data_parcela: number;
    venc_parcela: number;
    pag_parcela: number;
    valor_parcela: number;
    juros_parcela: number;
    multa_parcela: number;
    desconto_parcela: number;
    status_parcela: number;
    id_parcela: number;
    _all: number;
  };

  export type ParcelaAvgAggregateInputType = {
    cod_parcela?: true;
    cod_lista?: true;
    valor_parcela?: true;
    juros_parcela?: true;
    multa_parcela?: true;
    desconto_parcela?: true;
  };

  export type ParcelaSumAggregateInputType = {
    cod_parcela?: true;
    cod_lista?: true;
    valor_parcela?: true;
    juros_parcela?: true;
    multa_parcela?: true;
    desconto_parcela?: true;
  };

  export type ParcelaMinAggregateInputType = {
    cod_parcela?: true;
    cod_lista?: true;
    data_parcela?: true;
    venc_parcela?: true;
    pag_parcela?: true;
    valor_parcela?: true;
    juros_parcela?: true;
    multa_parcela?: true;
    desconto_parcela?: true;
    status_parcela?: true;
    id_parcela?: true;
  };

  export type ParcelaMaxAggregateInputType = {
    cod_parcela?: true;
    cod_lista?: true;
    data_parcela?: true;
    venc_parcela?: true;
    pag_parcela?: true;
    valor_parcela?: true;
    juros_parcela?: true;
    multa_parcela?: true;
    desconto_parcela?: true;
    status_parcela?: true;
    id_parcela?: true;
  };

  export type ParcelaCountAggregateInputType = {
    cod_parcela?: true;
    cod_lista?: true;
    data_parcela?: true;
    venc_parcela?: true;
    pag_parcela?: true;
    valor_parcela?: true;
    juros_parcela?: true;
    multa_parcela?: true;
    desconto_parcela?: true;
    status_parcela?: true;
    id_parcela?: true;
    _all?: true;
  };

  export type ParcelaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which parcela to aggregate.
     */
    where?: parcelaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parcelas to fetch.
     */
    orderBy?:
      | parcelaOrderByWithRelationInput
      | parcelaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: parcelaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parcelas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned parcelas
     **/
    _count?: true | ParcelaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ParcelaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ParcelaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ParcelaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ParcelaMaxAggregateInputType;
  };

  export type GetParcelaAggregateType<T extends ParcelaAggregateArgs> = {
    [P in keyof T & keyof AggregateParcela]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcela[P]>
      : GetScalarType<T[P], AggregateParcela[P]>;
  };

  export type parcelaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: parcelaWhereInput;
    orderBy?:
      | parcelaOrderByWithAggregationInput
      | parcelaOrderByWithAggregationInput[];
    by: ParcelaScalarFieldEnum[] | ParcelaScalarFieldEnum;
    having?: parcelaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ParcelaCountAggregateInputType | true;
    _avg?: ParcelaAvgAggregateInputType;
    _sum?: ParcelaSumAggregateInputType;
    _min?: ParcelaMinAggregateInputType;
    _max?: ParcelaMaxAggregateInputType;
  };

  export type ParcelaGroupByOutputType = {
    cod_parcela: number;
    cod_lista: number;
    data_parcela: string | null;
    venc_parcela: string | null;
    pag_parcela: string | null;
    valor_parcela: Decimal | null;
    juros_parcela: Decimal | null;
    multa_parcela: Decimal | null;
    desconto_parcela: Decimal | null;
    status_parcela: string;
    id_parcela: string | null;
    _count: ParcelaCountAggregateOutputType | null;
    _avg: ParcelaAvgAggregateOutputType | null;
    _sum: ParcelaSumAggregateOutputType | null;
    _min: ParcelaMinAggregateOutputType | null;
    _max: ParcelaMaxAggregateOutputType | null;
  };

  type GetParcelaGroupByPayload<T extends parcelaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ParcelaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ParcelaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParcelaGroupByOutputType[P]>
            : GetScalarType<T[P], ParcelaGroupByOutputType[P]>;
        }
      >
    >;

  export type parcelaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_parcela?: boolean;
      cod_lista?: boolean;
      data_parcela?: boolean;
      venc_parcela?: boolean;
      pag_parcela?: boolean;
      valor_parcela?: boolean;
      juros_parcela?: boolean;
      multa_parcela?: boolean;
      desconto_parcela?: boolean;
      status_parcela?: boolean;
      id_parcela?: boolean;
    },
    ExtArgs['result']['parcela']
  >;

  export type parcelaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_parcela?: boolean;
      cod_lista?: boolean;
      data_parcela?: boolean;
      venc_parcela?: boolean;
      pag_parcela?: boolean;
      valor_parcela?: boolean;
      juros_parcela?: boolean;
      multa_parcela?: boolean;
      desconto_parcela?: boolean;
      status_parcela?: boolean;
      id_parcela?: boolean;
    },
    ExtArgs['result']['parcela']
  >;

  export type parcelaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_parcela?: boolean;
      cod_lista?: boolean;
      data_parcela?: boolean;
      venc_parcela?: boolean;
      pag_parcela?: boolean;
      valor_parcela?: boolean;
      juros_parcela?: boolean;
      multa_parcela?: boolean;
      desconto_parcela?: boolean;
      status_parcela?: boolean;
      id_parcela?: boolean;
    },
    ExtArgs['result']['parcela']
  >;

  export type parcelaSelectScalar = {
    cod_parcela?: boolean;
    cod_lista?: boolean;
    data_parcela?: boolean;
    venc_parcela?: boolean;
    pag_parcela?: boolean;
    valor_parcela?: boolean;
    juros_parcela?: boolean;
    multa_parcela?: boolean;
    desconto_parcela?: boolean;
    status_parcela?: boolean;
    id_parcela?: boolean;
  };

  export type parcelaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_parcela'
    | 'cod_lista'
    | 'data_parcela'
    | 'venc_parcela'
    | 'pag_parcela'
    | 'valor_parcela'
    | 'juros_parcela'
    | 'multa_parcela'
    | 'desconto_parcela'
    | 'status_parcela'
    | 'id_parcela',
    ExtArgs['result']['parcela']
  >;

  export type $parcelaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'parcela';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_parcela: number;
        cod_lista: number;
        data_parcela: string | null;
        venc_parcela: string | null;
        pag_parcela: string | null;
        valor_parcela: Prisma.Decimal | null;
        juros_parcela: Prisma.Decimal | null;
        multa_parcela: Prisma.Decimal | null;
        desconto_parcela: Prisma.Decimal | null;
        status_parcela: string;
        id_parcela: string | null;
      },
      ExtArgs['result']['parcela']
    >;
    composites: {};
  };

  type parcelaGetPayload<
    S extends boolean | null | undefined | parcelaDefaultArgs,
  > = $Result.GetResult<Prisma.$parcelaPayload, S>;

  type parcelaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<parcelaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ParcelaCountAggregateInputType | true;
  };

  export interface parcelaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['parcela'];
      meta: { name: 'parcela' };
    };
    /**
     * Find zero or one Parcela that matches the filter.
     * @param {parcelaFindUniqueArgs} args - Arguments to find a Parcela
     * @example
     * // Get one Parcela
     * const parcela = await prisma.parcela.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parcelaFindUniqueArgs>(
      args: SelectSubset<T, parcelaFindUniqueArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Parcela that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parcelaFindUniqueOrThrowArgs} args - Arguments to find a Parcela
     * @example
     * // Get one Parcela
     * const parcela = await prisma.parcela.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parcelaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, parcelaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Parcela that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelaFindFirstArgs} args - Arguments to find a Parcela
     * @example
     * // Get one Parcela
     * const parcela = await prisma.parcela.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parcelaFindFirstArgs>(
      args?: SelectSubset<T, parcelaFindFirstArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Parcela that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelaFindFirstOrThrowArgs} args - Arguments to find a Parcela
     * @example
     * // Get one Parcela
     * const parcela = await prisma.parcela.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parcelaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, parcelaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Parcelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcelas
     * const parcelas = await prisma.parcela.findMany()
     *
     * // Get first 10 Parcelas
     * const parcelas = await prisma.parcela.findMany({ take: 10 })
     *
     * // Only select the `cod_parcela`
     * const parcelaWithCod_parcelaOnly = await prisma.parcela.findMany({ select: { cod_parcela: true } })
     *
     */
    findMany<T extends parcelaFindManyArgs>(
      args?: SelectSubset<T, parcelaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Parcela.
     * @param {parcelaCreateArgs} args - Arguments to create a Parcela.
     * @example
     * // Create one Parcela
     * const Parcela = await prisma.parcela.create({
     *   data: {
     *     // ... data to create a Parcela
     *   }
     * })
     *
     */
    create<T extends parcelaCreateArgs>(
      args: SelectSubset<T, parcelaCreateArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Parcelas.
     * @param {parcelaCreateManyArgs} args - Arguments to create many Parcelas.
     * @example
     * // Create many Parcelas
     * const parcela = await prisma.parcela.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends parcelaCreateManyArgs>(
      args?: SelectSubset<T, parcelaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Parcelas and returns the data saved in the database.
     * @param {parcelaCreateManyAndReturnArgs} args - Arguments to create many Parcelas.
     * @example
     * // Create many Parcelas
     * const parcela = await prisma.parcela.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Parcelas and only return the `cod_parcela`
     * const parcelaWithCod_parcelaOnly = await prisma.parcela.createManyAndReturn({
     *   select: { cod_parcela: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends parcelaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, parcelaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Parcela.
     * @param {parcelaDeleteArgs} args - Arguments to delete one Parcela.
     * @example
     * // Delete one Parcela
     * const Parcela = await prisma.parcela.delete({
     *   where: {
     *     // ... filter to delete one Parcela
     *   }
     * })
     *
     */
    delete<T extends parcelaDeleteArgs>(
      args: SelectSubset<T, parcelaDeleteArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Parcela.
     * @param {parcelaUpdateArgs} args - Arguments to update one Parcela.
     * @example
     * // Update one Parcela
     * const parcela = await prisma.parcela.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends parcelaUpdateArgs>(
      args: SelectSubset<T, parcelaUpdateArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Parcelas.
     * @param {parcelaDeleteManyArgs} args - Arguments to filter Parcelas to delete.
     * @example
     * // Delete a few Parcelas
     * const { count } = await prisma.parcela.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends parcelaDeleteManyArgs>(
      args?: SelectSubset<T, parcelaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcelas
     * const parcela = await prisma.parcela.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends parcelaUpdateManyArgs>(
      args: SelectSubset<T, parcelaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Parcelas and returns the data updated in the database.
     * @param {parcelaUpdateManyAndReturnArgs} args - Arguments to update many Parcelas.
     * @example
     * // Update many Parcelas
     * const parcela = await prisma.parcela.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Parcelas and only return the `cod_parcela`
     * const parcelaWithCod_parcelaOnly = await prisma.parcela.updateManyAndReturn({
     *   select: { cod_parcela: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends parcelaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, parcelaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Parcela.
     * @param {parcelaUpsertArgs} args - Arguments to update or create a Parcela.
     * @example
     * // Update or create a Parcela
     * const parcela = await prisma.parcela.upsert({
     *   create: {
     *     // ... data to create a Parcela
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcela we want to update
     *   }
     * })
     */
    upsert<T extends parcelaUpsertArgs>(
      args: SelectSubset<T, parcelaUpsertArgs<ExtArgs>>,
    ): Prisma__parcelaClient<
      $Result.GetResult<
        Prisma.$parcelaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelaCountArgs} args - Arguments to filter Parcelas to count.
     * @example
     * // Count the number of Parcelas
     * const count = await prisma.parcela.count({
     *   where: {
     *     // ... the filter for the Parcelas we want to count
     *   }
     * })
     **/
    count<T extends parcelaCountArgs>(
      args?: Subset<T, parcelaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParcelaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Parcela.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ParcelaAggregateArgs>(
      args: Subset<T, ParcelaAggregateArgs>,
    ): Prisma.PrismaPromise<GetParcelaAggregateType<T>>;

    /**
     * Group by Parcela.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends parcelaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parcelaGroupByArgs['orderBy'] }
        : { orderBy?: parcelaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, parcelaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetParcelaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the parcela model
     */
    readonly fields: parcelaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parcela.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parcelaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the parcela model
   */
  interface parcelaFieldRefs {
    readonly cod_parcela: FieldRef<'parcela', 'Int'>;
    readonly cod_lista: FieldRef<'parcela', 'Int'>;
    readonly data_parcela: FieldRef<'parcela', 'String'>;
    readonly venc_parcela: FieldRef<'parcela', 'String'>;
    readonly pag_parcela: FieldRef<'parcela', 'String'>;
    readonly valor_parcela: FieldRef<'parcela', 'Decimal'>;
    readonly juros_parcela: FieldRef<'parcela', 'Decimal'>;
    readonly multa_parcela: FieldRef<'parcela', 'Decimal'>;
    readonly desconto_parcela: FieldRef<'parcela', 'Decimal'>;
    readonly status_parcela: FieldRef<'parcela', 'String'>;
    readonly id_parcela: FieldRef<'parcela', 'String'>;
  }

  // Custom InputTypes
  /**
   * parcela findUnique
   */
  export type parcelaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * Filter, which parcela to fetch.
     */
    where: parcelaWhereUniqueInput;
  };

  /**
   * parcela findUniqueOrThrow
   */
  export type parcelaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * Filter, which parcela to fetch.
     */
    where: parcelaWhereUniqueInput;
  };

  /**
   * parcela findFirst
   */
  export type parcelaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * Filter, which parcela to fetch.
     */
    where?: parcelaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parcelas to fetch.
     */
    orderBy?:
      | parcelaOrderByWithRelationInput
      | parcelaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parcelas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of parcelas.
     */
    distinct?: ParcelaScalarFieldEnum | ParcelaScalarFieldEnum[];
  };

  /**
   * parcela findFirstOrThrow
   */
  export type parcelaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * Filter, which parcela to fetch.
     */
    where?: parcelaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parcelas to fetch.
     */
    orderBy?:
      | parcelaOrderByWithRelationInput
      | parcelaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parcelas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of parcelas.
     */
    distinct?: ParcelaScalarFieldEnum | ParcelaScalarFieldEnum[];
  };

  /**
   * parcela findMany
   */
  export type parcelaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of parcelas to fetch.
     */
    orderBy?:
      | parcelaOrderByWithRelationInput
      | parcelaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing parcelas.
     */
    cursor?: parcelaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` parcelas.
     */
    skip?: number;
    distinct?: ParcelaScalarFieldEnum | ParcelaScalarFieldEnum[];
  };

  /**
   * parcela create
   */
  export type parcelaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * The data needed to create a parcela.
     */
    data: XOR<parcelaCreateInput, parcelaUncheckedCreateInput>;
  };

  /**
   * parcela createMany
   */
  export type parcelaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many parcelas.
     */
    data: parcelaCreateManyInput | parcelaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * parcela createManyAndReturn
   */
  export type parcelaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * The data used to create many parcelas.
     */
    data: parcelaCreateManyInput | parcelaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * parcela update
   */
  export type parcelaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * The data needed to update a parcela.
     */
    data: XOR<parcelaUpdateInput, parcelaUncheckedUpdateInput>;
    /**
     * Choose, which parcela to update.
     */
    where: parcelaWhereUniqueInput;
  };

  /**
   * parcela updateMany
   */
  export type parcelaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update parcelas.
     */
    data: XOR<parcelaUpdateManyMutationInput, parcelaUncheckedUpdateManyInput>;
    /**
     * Filter which parcelas to update
     */
    where?: parcelaWhereInput;
    /**
     * Limit how many parcelas to update.
     */
    limit?: number;
  };

  /**
   * parcela updateManyAndReturn
   */
  export type parcelaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * The data used to update parcelas.
     */
    data: XOR<parcelaUpdateManyMutationInput, parcelaUncheckedUpdateManyInput>;
    /**
     * Filter which parcelas to update
     */
    where?: parcelaWhereInput;
    /**
     * Limit how many parcelas to update.
     */
    limit?: number;
  };

  /**
   * parcela upsert
   */
  export type parcelaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * The filter to search for the parcela to update in case it exists.
     */
    where: parcelaWhereUniqueInput;
    /**
     * In case the parcela found by the `where` argument doesn't exist, create a new parcela with this data.
     */
    create: XOR<parcelaCreateInput, parcelaUncheckedCreateInput>;
    /**
     * In case the parcela was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parcelaUpdateInput, parcelaUncheckedUpdateInput>;
  };

  /**
   * parcela delete
   */
  export type parcelaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
    /**
     * Filter which parcela to delete.
     */
    where: parcelaWhereUniqueInput;
  };

  /**
   * parcela deleteMany
   */
  export type parcelaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which parcelas to delete
     */
    where?: parcelaWhereInput;
    /**
     * Limit how many parcelas to delete.
     */
    limit?: number;
  };

  /**
   * parcela without action
   */
  export type parcelaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the parcela
     */
    select?: parcelaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the parcela
     */
    omit?: parcelaOmit<ExtArgs> | null;
  };

  /**
   * Model pauta
   */

  export type AggregatePauta = {
    _count: PautaCountAggregateOutputType | null;
    _avg: PautaAvgAggregateOutputType | null;
    _sum: PautaSumAggregateOutputType | null;
    _min: PautaMinAggregateOutputType | null;
    _max: PautaMaxAggregateOutputType | null;
  };

  export type PautaAvgAggregateOutputType = {
    cod_pauta: number | null;
    cod_recurso: number | null;
  };

  export type PautaSumAggregateOutputType = {
    cod_pauta: number | null;
    cod_recurso: number | null;
  };

  export type PautaMinAggregateOutputType = {
    cod_pauta: number | null;
    cod_recurso: number | null;
    data_pauta: Date | null;
    prazo_pauta: Date | null;
    concl_pauta: Date | null;
    desc_pauta: string | null;
    obs_pauta: Uint8Array | null;
  };

  export type PautaMaxAggregateOutputType = {
    cod_pauta: number | null;
    cod_recurso: number | null;
    data_pauta: Date | null;
    prazo_pauta: Date | null;
    concl_pauta: Date | null;
    desc_pauta: string | null;
    obs_pauta: Uint8Array | null;
  };

  export type PautaCountAggregateOutputType = {
    cod_pauta: number;
    cod_recurso: number;
    data_pauta: number;
    prazo_pauta: number;
    concl_pauta: number;
    desc_pauta: number;
    obs_pauta: number;
    _all: number;
  };

  export type PautaAvgAggregateInputType = {
    cod_pauta?: true;
    cod_recurso?: true;
  };

  export type PautaSumAggregateInputType = {
    cod_pauta?: true;
    cod_recurso?: true;
  };

  export type PautaMinAggregateInputType = {
    cod_pauta?: true;
    cod_recurso?: true;
    data_pauta?: true;
    prazo_pauta?: true;
    concl_pauta?: true;
    desc_pauta?: true;
    obs_pauta?: true;
  };

  export type PautaMaxAggregateInputType = {
    cod_pauta?: true;
    cod_recurso?: true;
    data_pauta?: true;
    prazo_pauta?: true;
    concl_pauta?: true;
    desc_pauta?: true;
    obs_pauta?: true;
  };

  export type PautaCountAggregateInputType = {
    cod_pauta?: true;
    cod_recurso?: true;
    data_pauta?: true;
    prazo_pauta?: true;
    concl_pauta?: true;
    desc_pauta?: true;
    obs_pauta?: true;
    _all?: true;
  };

  export type PautaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which pauta to aggregate.
     */
    where?: pautaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pautas to fetch.
     */
    orderBy?: pautaOrderByWithRelationInput | pautaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: pautaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pautas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pautas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned pautas
     **/
    _count?: true | PautaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PautaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PautaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PautaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PautaMaxAggregateInputType;
  };

  export type GetPautaAggregateType<T extends PautaAggregateArgs> = {
    [P in keyof T & keyof AggregatePauta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePauta[P]>
      : GetScalarType<T[P], AggregatePauta[P]>;
  };

  export type pautaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: pautaWhereInput;
    orderBy?:
      | pautaOrderByWithAggregationInput
      | pautaOrderByWithAggregationInput[];
    by: PautaScalarFieldEnum[] | PautaScalarFieldEnum;
    having?: pautaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PautaCountAggregateInputType | true;
    _avg?: PautaAvgAggregateInputType;
    _sum?: PautaSumAggregateInputType;
    _min?: PautaMinAggregateInputType;
    _max?: PautaMaxAggregateInputType;
  };

  export type PautaGroupByOutputType = {
    cod_pauta: number;
    cod_recurso: number;
    data_pauta: Date;
    prazo_pauta: Date;
    concl_pauta: Date | null;
    desc_pauta: string | null;
    obs_pauta: Uint8Array | null;
    _count: PautaCountAggregateOutputType | null;
    _avg: PautaAvgAggregateOutputType | null;
    _sum: PautaSumAggregateOutputType | null;
    _min: PautaMinAggregateOutputType | null;
    _max: PautaMaxAggregateOutputType | null;
  };

  type GetPautaGroupByPayload<T extends pautaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PautaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PautaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PautaGroupByOutputType[P]>
            : GetScalarType<T[P], PautaGroupByOutputType[P]>;
        }
      >
    >;

  export type pautaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_pauta?: boolean;
      cod_recurso?: boolean;
      data_pauta?: boolean;
      prazo_pauta?: boolean;
      concl_pauta?: boolean;
      desc_pauta?: boolean;
      obs_pauta?: boolean;
    },
    ExtArgs['result']['pauta']
  >;

  export type pautaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_pauta?: boolean;
      cod_recurso?: boolean;
      data_pauta?: boolean;
      prazo_pauta?: boolean;
      concl_pauta?: boolean;
      desc_pauta?: boolean;
      obs_pauta?: boolean;
    },
    ExtArgs['result']['pauta']
  >;

  export type pautaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_pauta?: boolean;
      cod_recurso?: boolean;
      data_pauta?: boolean;
      prazo_pauta?: boolean;
      concl_pauta?: boolean;
      desc_pauta?: boolean;
      obs_pauta?: boolean;
    },
    ExtArgs['result']['pauta']
  >;

  export type pautaSelectScalar = {
    cod_pauta?: boolean;
    cod_recurso?: boolean;
    data_pauta?: boolean;
    prazo_pauta?: boolean;
    concl_pauta?: boolean;
    desc_pauta?: boolean;
    obs_pauta?: boolean;
  };

  export type pautaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_pauta'
    | 'cod_recurso'
    | 'data_pauta'
    | 'prazo_pauta'
    | 'concl_pauta'
    | 'desc_pauta'
    | 'obs_pauta',
    ExtArgs['result']['pauta']
  >;

  export type $pautaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'pauta';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_pauta: number;
        cod_recurso: number;
        data_pauta: Date;
        prazo_pauta: Date;
        concl_pauta: Date | null;
        desc_pauta: string | null;
        obs_pauta: Uint8Array | null;
      },
      ExtArgs['result']['pauta']
    >;
    composites: {};
  };

  type pautaGetPayload<
    S extends boolean | null | undefined | pautaDefaultArgs,
  > = $Result.GetResult<Prisma.$pautaPayload, S>;

  type pautaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<pautaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PautaCountAggregateInputType | true;
  };

  export interface pautaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['pauta'];
      meta: { name: 'pauta' };
    };
    /**
     * Find zero or one Pauta that matches the filter.
     * @param {pautaFindUniqueArgs} args - Arguments to find a Pauta
     * @example
     * // Get one Pauta
     * const pauta = await prisma.pauta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pautaFindUniqueArgs>(
      args: SelectSubset<T, pautaFindUniqueArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Pauta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pautaFindUniqueOrThrowArgs} args - Arguments to find a Pauta
     * @example
     * // Get one Pauta
     * const pauta = await prisma.pauta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pautaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, pautaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Pauta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pautaFindFirstArgs} args - Arguments to find a Pauta
     * @example
     * // Get one Pauta
     * const pauta = await prisma.pauta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pautaFindFirstArgs>(
      args?: SelectSubset<T, pautaFindFirstArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Pauta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pautaFindFirstOrThrowArgs} args - Arguments to find a Pauta
     * @example
     * // Get one Pauta
     * const pauta = await prisma.pauta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pautaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pautaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Pautas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pautaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pautas
     * const pautas = await prisma.pauta.findMany()
     *
     * // Get first 10 Pautas
     * const pautas = await prisma.pauta.findMany({ take: 10 })
     *
     * // Only select the `cod_pauta`
     * const pautaWithCod_pautaOnly = await prisma.pauta.findMany({ select: { cod_pauta: true } })
     *
     */
    findMany<T extends pautaFindManyArgs>(
      args?: SelectSubset<T, pautaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Pauta.
     * @param {pautaCreateArgs} args - Arguments to create a Pauta.
     * @example
     * // Create one Pauta
     * const Pauta = await prisma.pauta.create({
     *   data: {
     *     // ... data to create a Pauta
     *   }
     * })
     *
     */
    create<T extends pautaCreateArgs>(
      args: SelectSubset<T, pautaCreateArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Pautas.
     * @param {pautaCreateManyArgs} args - Arguments to create many Pautas.
     * @example
     * // Create many Pautas
     * const pauta = await prisma.pauta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends pautaCreateManyArgs>(
      args?: SelectSubset<T, pautaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Pautas and returns the data saved in the database.
     * @param {pautaCreateManyAndReturnArgs} args - Arguments to create many Pautas.
     * @example
     * // Create many Pautas
     * const pauta = await prisma.pauta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Pautas and only return the `cod_pauta`
     * const pautaWithCod_pautaOnly = await prisma.pauta.createManyAndReturn({
     *   select: { cod_pauta: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends pautaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, pautaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Pauta.
     * @param {pautaDeleteArgs} args - Arguments to delete one Pauta.
     * @example
     * // Delete one Pauta
     * const Pauta = await prisma.pauta.delete({
     *   where: {
     *     // ... filter to delete one Pauta
     *   }
     * })
     *
     */
    delete<T extends pautaDeleteArgs>(
      args: SelectSubset<T, pautaDeleteArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Pauta.
     * @param {pautaUpdateArgs} args - Arguments to update one Pauta.
     * @example
     * // Update one Pauta
     * const pauta = await prisma.pauta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends pautaUpdateArgs>(
      args: SelectSubset<T, pautaUpdateArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Pautas.
     * @param {pautaDeleteManyArgs} args - Arguments to filter Pautas to delete.
     * @example
     * // Delete a few Pautas
     * const { count } = await prisma.pauta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends pautaDeleteManyArgs>(
      args?: SelectSubset<T, pautaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Pautas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pautaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pautas
     * const pauta = await prisma.pauta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends pautaUpdateManyArgs>(
      args: SelectSubset<T, pautaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Pautas and returns the data updated in the database.
     * @param {pautaUpdateManyAndReturnArgs} args - Arguments to update many Pautas.
     * @example
     * // Update many Pautas
     * const pauta = await prisma.pauta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Pautas and only return the `cod_pauta`
     * const pautaWithCod_pautaOnly = await prisma.pauta.updateManyAndReturn({
     *   select: { cod_pauta: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends pautaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, pautaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Pauta.
     * @param {pautaUpsertArgs} args - Arguments to update or create a Pauta.
     * @example
     * // Update or create a Pauta
     * const pauta = await prisma.pauta.upsert({
     *   create: {
     *     // ... data to create a Pauta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pauta we want to update
     *   }
     * })
     */
    upsert<T extends pautaUpsertArgs>(
      args: SelectSubset<T, pautaUpsertArgs<ExtArgs>>,
    ): Prisma__pautaClient<
      $Result.GetResult<
        Prisma.$pautaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Pautas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pautaCountArgs} args - Arguments to filter Pautas to count.
     * @example
     * // Count the number of Pautas
     * const count = await prisma.pauta.count({
     *   where: {
     *     // ... the filter for the Pautas we want to count
     *   }
     * })
     **/
    count<T extends pautaCountArgs>(
      args?: Subset<T, pautaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PautaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Pauta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PautaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PautaAggregateArgs>(
      args: Subset<T, PautaAggregateArgs>,
    ): Prisma.PrismaPromise<GetPautaAggregateType<T>>;

    /**
     * Group by Pauta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pautaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends pautaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pautaGroupByArgs['orderBy'] }
        : { orderBy?: pautaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, pautaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetPautaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the pauta model
     */
    readonly fields: pautaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pauta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pautaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the pauta model
   */
  interface pautaFieldRefs {
    readonly cod_pauta: FieldRef<'pauta', 'Int'>;
    readonly cod_recurso: FieldRef<'pauta', 'Int'>;
    readonly data_pauta: FieldRef<'pauta', 'DateTime'>;
    readonly prazo_pauta: FieldRef<'pauta', 'DateTime'>;
    readonly concl_pauta: FieldRef<'pauta', 'DateTime'>;
    readonly desc_pauta: FieldRef<'pauta', 'String'>;
    readonly obs_pauta: FieldRef<'pauta', 'Bytes'>;
  }

  // Custom InputTypes
  /**
   * pauta findUnique
   */
  export type pautaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * Filter, which pauta to fetch.
     */
    where: pautaWhereUniqueInput;
  };

  /**
   * pauta findUniqueOrThrow
   */
  export type pautaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * Filter, which pauta to fetch.
     */
    where: pautaWhereUniqueInput;
  };

  /**
   * pauta findFirst
   */
  export type pautaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * Filter, which pauta to fetch.
     */
    where?: pautaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pautas to fetch.
     */
    orderBy?: pautaOrderByWithRelationInput | pautaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for pautas.
     */
    cursor?: pautaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pautas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pautas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of pautas.
     */
    distinct?: PautaScalarFieldEnum | PautaScalarFieldEnum[];
  };

  /**
   * pauta findFirstOrThrow
   */
  export type pautaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * Filter, which pauta to fetch.
     */
    where?: pautaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pautas to fetch.
     */
    orderBy?: pautaOrderByWithRelationInput | pautaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for pautas.
     */
    cursor?: pautaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pautas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pautas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of pautas.
     */
    distinct?: PautaScalarFieldEnum | PautaScalarFieldEnum[];
  };

  /**
   * pauta findMany
   */
  export type pautaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * Filter, which pautas to fetch.
     */
    where?: pautaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pautas to fetch.
     */
    orderBy?: pautaOrderByWithRelationInput | pautaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing pautas.
     */
    cursor?: pautaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pautas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pautas.
     */
    skip?: number;
    distinct?: PautaScalarFieldEnum | PautaScalarFieldEnum[];
  };

  /**
   * pauta create
   */
  export type pautaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * The data needed to create a pauta.
     */
    data: XOR<pautaCreateInput, pautaUncheckedCreateInput>;
  };

  /**
   * pauta createMany
   */
  export type pautaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many pautas.
     */
    data: pautaCreateManyInput | pautaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * pauta createManyAndReturn
   */
  export type pautaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * The data used to create many pautas.
     */
    data: pautaCreateManyInput | pautaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * pauta update
   */
  export type pautaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * The data needed to update a pauta.
     */
    data: XOR<pautaUpdateInput, pautaUncheckedUpdateInput>;
    /**
     * Choose, which pauta to update.
     */
    where: pautaWhereUniqueInput;
  };

  /**
   * pauta updateMany
   */
  export type pautaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update pautas.
     */
    data: XOR<pautaUpdateManyMutationInput, pautaUncheckedUpdateManyInput>;
    /**
     * Filter which pautas to update
     */
    where?: pautaWhereInput;
    /**
     * Limit how many pautas to update.
     */
    limit?: number;
  };

  /**
   * pauta updateManyAndReturn
   */
  export type pautaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * The data used to update pautas.
     */
    data: XOR<pautaUpdateManyMutationInput, pautaUncheckedUpdateManyInput>;
    /**
     * Filter which pautas to update
     */
    where?: pautaWhereInput;
    /**
     * Limit how many pautas to update.
     */
    limit?: number;
  };

  /**
   * pauta upsert
   */
  export type pautaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * The filter to search for the pauta to update in case it exists.
     */
    where: pautaWhereUniqueInput;
    /**
     * In case the pauta found by the `where` argument doesn't exist, create a new pauta with this data.
     */
    create: XOR<pautaCreateInput, pautaUncheckedCreateInput>;
    /**
     * In case the pauta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pautaUpdateInput, pautaUncheckedUpdateInput>;
  };

  /**
   * pauta delete
   */
  export type pautaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
    /**
     * Filter which pauta to delete.
     */
    where: pautaWhereUniqueInput;
  };

  /**
   * pauta deleteMany
   */
  export type pautaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which pautas to delete
     */
    where?: pautaWhereInput;
    /**
     * Limit how many pautas to delete.
     */
    limit?: number;
  };

  /**
   * pauta without action
   */
  export type pautaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the pauta
     */
    select?: pautaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the pauta
     */
    omit?: pautaOmit<ExtArgs> | null;
  };

  /**
   * Model ponto
   */

  export type AggregatePonto = {
    _count: PontoCountAggregateOutputType | null;
    _avg: PontoAvgAggregateOutputType | null;
    _sum: PontoSumAggregateOutputType | null;
    _min: PontoMinAggregateOutputType | null;
    _max: PontoMaxAggregateOutputType | null;
  };

  export type PontoAvgAggregateOutputType = {
    cod_ponto: number | null;
    cod_recurso: number | null;
  };

  export type PontoSumAggregateOutputType = {
    cod_ponto: number | null;
    cod_recurso: number | null;
  };

  export type PontoMinAggregateOutputType = {
    cod_ponto: number | null;
    entrada_ponto: Date | null;
    saida_ponto: Date | null;
    cod_recurso: number | null;
  };

  export type PontoMaxAggregateOutputType = {
    cod_ponto: number | null;
    entrada_ponto: Date | null;
    saida_ponto: Date | null;
    cod_recurso: number | null;
  };

  export type PontoCountAggregateOutputType = {
    cod_ponto: number;
    entrada_ponto: number;
    saida_ponto: number;
    cod_recurso: number;
    _all: number;
  };

  export type PontoAvgAggregateInputType = {
    cod_ponto?: true;
    cod_recurso?: true;
  };

  export type PontoSumAggregateInputType = {
    cod_ponto?: true;
    cod_recurso?: true;
  };

  export type PontoMinAggregateInputType = {
    cod_ponto?: true;
    entrada_ponto?: true;
    saida_ponto?: true;
    cod_recurso?: true;
  };

  export type PontoMaxAggregateInputType = {
    cod_ponto?: true;
    entrada_ponto?: true;
    saida_ponto?: true;
    cod_recurso?: true;
  };

  export type PontoCountAggregateInputType = {
    cod_ponto?: true;
    entrada_ponto?: true;
    saida_ponto?: true;
    cod_recurso?: true;
    _all?: true;
  };

  export type PontoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ponto to aggregate.
     */
    where?: pontoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pontos to fetch.
     */
    orderBy?: pontoOrderByWithRelationInput | pontoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: pontoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pontos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned pontos
     **/
    _count?: true | PontoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PontoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PontoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PontoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PontoMaxAggregateInputType;
  };

  export type GetPontoAggregateType<T extends PontoAggregateArgs> = {
    [P in keyof T & keyof AggregatePonto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePonto[P]>
      : GetScalarType<T[P], AggregatePonto[P]>;
  };

  export type pontoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: pontoWhereInput;
    orderBy?:
      | pontoOrderByWithAggregationInput
      | pontoOrderByWithAggregationInput[];
    by: PontoScalarFieldEnum[] | PontoScalarFieldEnum;
    having?: pontoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PontoCountAggregateInputType | true;
    _avg?: PontoAvgAggregateInputType;
    _sum?: PontoSumAggregateInputType;
    _min?: PontoMinAggregateInputType;
    _max?: PontoMaxAggregateInputType;
  };

  export type PontoGroupByOutputType = {
    cod_ponto: number;
    entrada_ponto: Date;
    saida_ponto: Date | null;
    cod_recurso: number;
    _count: PontoCountAggregateOutputType | null;
    _avg: PontoAvgAggregateOutputType | null;
    _sum: PontoSumAggregateOutputType | null;
    _min: PontoMinAggregateOutputType | null;
    _max: PontoMaxAggregateOutputType | null;
  };

  type GetPontoGroupByPayload<T extends pontoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PontoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PontoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PontoGroupByOutputType[P]>
            : GetScalarType<T[P], PontoGroupByOutputType[P]>;
        }
      >
    >;

  export type pontoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_ponto?: boolean;
      entrada_ponto?: boolean;
      saida_ponto?: boolean;
      cod_recurso?: boolean;
    },
    ExtArgs['result']['ponto']
  >;

  export type pontoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_ponto?: boolean;
      entrada_ponto?: boolean;
      saida_ponto?: boolean;
      cod_recurso?: boolean;
    },
    ExtArgs['result']['ponto']
  >;

  export type pontoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_ponto?: boolean;
      entrada_ponto?: boolean;
      saida_ponto?: boolean;
      cod_recurso?: boolean;
    },
    ExtArgs['result']['ponto']
  >;

  export type pontoSelectScalar = {
    cod_ponto?: boolean;
    entrada_ponto?: boolean;
    saida_ponto?: boolean;
    cod_recurso?: boolean;
  };

  export type pontoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_ponto' | 'entrada_ponto' | 'saida_ponto' | 'cod_recurso',
    ExtArgs['result']['ponto']
  >;

  export type $pontoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ponto';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_ponto: number;
        entrada_ponto: Date;
        saida_ponto: Date | null;
        cod_recurso: number;
      },
      ExtArgs['result']['ponto']
    >;
    composites: {};
  };

  type pontoGetPayload<
    S extends boolean | null | undefined | pontoDefaultArgs,
  > = $Result.GetResult<Prisma.$pontoPayload, S>;

  type pontoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<pontoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PontoCountAggregateInputType | true;
  };

  export interface pontoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ponto'];
      meta: { name: 'ponto' };
    };
    /**
     * Find zero or one Ponto that matches the filter.
     * @param {pontoFindUniqueArgs} args - Arguments to find a Ponto
     * @example
     * // Get one Ponto
     * const ponto = await prisma.ponto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pontoFindUniqueArgs>(
      args: SelectSubset<T, pontoFindUniqueArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Ponto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pontoFindUniqueOrThrowArgs} args - Arguments to find a Ponto
     * @example
     * // Get one Ponto
     * const ponto = await prisma.ponto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pontoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, pontoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Ponto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontoFindFirstArgs} args - Arguments to find a Ponto
     * @example
     * // Get one Ponto
     * const ponto = await prisma.ponto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pontoFindFirstArgs>(
      args?: SelectSubset<T, pontoFindFirstArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Ponto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontoFindFirstOrThrowArgs} args - Arguments to find a Ponto
     * @example
     * // Get one Ponto
     * const ponto = await prisma.ponto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pontoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pontoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Pontos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pontos
     * const pontos = await prisma.ponto.findMany()
     *
     * // Get first 10 Pontos
     * const pontos = await prisma.ponto.findMany({ take: 10 })
     *
     * // Only select the `cod_ponto`
     * const pontoWithCod_pontoOnly = await prisma.ponto.findMany({ select: { cod_ponto: true } })
     *
     */
    findMany<T extends pontoFindManyArgs>(
      args?: SelectSubset<T, pontoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Ponto.
     * @param {pontoCreateArgs} args - Arguments to create a Ponto.
     * @example
     * // Create one Ponto
     * const Ponto = await prisma.ponto.create({
     *   data: {
     *     // ... data to create a Ponto
     *   }
     * })
     *
     */
    create<T extends pontoCreateArgs>(
      args: SelectSubset<T, pontoCreateArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Pontos.
     * @param {pontoCreateManyArgs} args - Arguments to create many Pontos.
     * @example
     * // Create many Pontos
     * const ponto = await prisma.ponto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends pontoCreateManyArgs>(
      args?: SelectSubset<T, pontoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Pontos and returns the data saved in the database.
     * @param {pontoCreateManyAndReturnArgs} args - Arguments to create many Pontos.
     * @example
     * // Create many Pontos
     * const ponto = await prisma.ponto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Pontos and only return the `cod_ponto`
     * const pontoWithCod_pontoOnly = await prisma.ponto.createManyAndReturn({
     *   select: { cod_ponto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends pontoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, pontoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Ponto.
     * @param {pontoDeleteArgs} args - Arguments to delete one Ponto.
     * @example
     * // Delete one Ponto
     * const Ponto = await prisma.ponto.delete({
     *   where: {
     *     // ... filter to delete one Ponto
     *   }
     * })
     *
     */
    delete<T extends pontoDeleteArgs>(
      args: SelectSubset<T, pontoDeleteArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Ponto.
     * @param {pontoUpdateArgs} args - Arguments to update one Ponto.
     * @example
     * // Update one Ponto
     * const ponto = await prisma.ponto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends pontoUpdateArgs>(
      args: SelectSubset<T, pontoUpdateArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Pontos.
     * @param {pontoDeleteManyArgs} args - Arguments to filter Pontos to delete.
     * @example
     * // Delete a few Pontos
     * const { count } = await prisma.ponto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends pontoDeleteManyArgs>(
      args?: SelectSubset<T, pontoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Pontos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pontos
     * const ponto = await prisma.ponto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends pontoUpdateManyArgs>(
      args: SelectSubset<T, pontoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Pontos and returns the data updated in the database.
     * @param {pontoUpdateManyAndReturnArgs} args - Arguments to update many Pontos.
     * @example
     * // Update many Pontos
     * const ponto = await prisma.ponto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Pontos and only return the `cod_ponto`
     * const pontoWithCod_pontoOnly = await prisma.ponto.updateManyAndReturn({
     *   select: { cod_ponto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends pontoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, pontoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Ponto.
     * @param {pontoUpsertArgs} args - Arguments to update or create a Ponto.
     * @example
     * // Update or create a Ponto
     * const ponto = await prisma.ponto.upsert({
     *   create: {
     *     // ... data to create a Ponto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ponto we want to update
     *   }
     * })
     */
    upsert<T extends pontoUpsertArgs>(
      args: SelectSubset<T, pontoUpsertArgs<ExtArgs>>,
    ): Prisma__pontoClient<
      $Result.GetResult<
        Prisma.$pontoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Pontos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontoCountArgs} args - Arguments to filter Pontos to count.
     * @example
     * // Count the number of Pontos
     * const count = await prisma.ponto.count({
     *   where: {
     *     // ... the filter for the Pontos we want to count
     *   }
     * })
     **/
    count<T extends pontoCountArgs>(
      args?: Subset<T, pontoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PontoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Ponto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PontoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PontoAggregateArgs>(
      args: Subset<T, PontoAggregateArgs>,
    ): Prisma.PrismaPromise<GetPontoAggregateType<T>>;

    /**
     * Group by Ponto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pontoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends pontoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pontoGroupByArgs['orderBy'] }
        : { orderBy?: pontoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, pontoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetPontoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ponto model
     */
    readonly fields: pontoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ponto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pontoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ponto model
   */
  interface pontoFieldRefs {
    readonly cod_ponto: FieldRef<'ponto', 'Int'>;
    readonly entrada_ponto: FieldRef<'ponto', 'DateTime'>;
    readonly saida_ponto: FieldRef<'ponto', 'DateTime'>;
    readonly cod_recurso: FieldRef<'ponto', 'Int'>;
  }

  // Custom InputTypes
  /**
   * ponto findUnique
   */
  export type pontoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * Filter, which ponto to fetch.
     */
    where: pontoWhereUniqueInput;
  };

  /**
   * ponto findUniqueOrThrow
   */
  export type pontoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * Filter, which ponto to fetch.
     */
    where: pontoWhereUniqueInput;
  };

  /**
   * ponto findFirst
   */
  export type pontoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * Filter, which ponto to fetch.
     */
    where?: pontoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pontos to fetch.
     */
    orderBy?: pontoOrderByWithRelationInput | pontoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for pontos.
     */
    cursor?: pontoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pontos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of pontos.
     */
    distinct?: PontoScalarFieldEnum | PontoScalarFieldEnum[];
  };

  /**
   * ponto findFirstOrThrow
   */
  export type pontoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * Filter, which ponto to fetch.
     */
    where?: pontoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pontos to fetch.
     */
    orderBy?: pontoOrderByWithRelationInput | pontoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for pontos.
     */
    cursor?: pontoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pontos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of pontos.
     */
    distinct?: PontoScalarFieldEnum | PontoScalarFieldEnum[];
  };

  /**
   * ponto findMany
   */
  export type pontoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * Filter, which pontos to fetch.
     */
    where?: pontoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of pontos to fetch.
     */
    orderBy?: pontoOrderByWithRelationInput | pontoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing pontos.
     */
    cursor?: pontoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` pontos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` pontos.
     */
    skip?: number;
    distinct?: PontoScalarFieldEnum | PontoScalarFieldEnum[];
  };

  /**
   * ponto create
   */
  export type pontoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * The data needed to create a ponto.
     */
    data: XOR<pontoCreateInput, pontoUncheckedCreateInput>;
  };

  /**
   * ponto createMany
   */
  export type pontoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many pontos.
     */
    data: pontoCreateManyInput | pontoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ponto createManyAndReturn
   */
  export type pontoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * The data used to create many pontos.
     */
    data: pontoCreateManyInput | pontoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ponto update
   */
  export type pontoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * The data needed to update a ponto.
     */
    data: XOR<pontoUpdateInput, pontoUncheckedUpdateInput>;
    /**
     * Choose, which ponto to update.
     */
    where: pontoWhereUniqueInput;
  };

  /**
   * ponto updateMany
   */
  export type pontoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update pontos.
     */
    data: XOR<pontoUpdateManyMutationInput, pontoUncheckedUpdateManyInput>;
    /**
     * Filter which pontos to update
     */
    where?: pontoWhereInput;
    /**
     * Limit how many pontos to update.
     */
    limit?: number;
  };

  /**
   * ponto updateManyAndReturn
   */
  export type pontoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * The data used to update pontos.
     */
    data: XOR<pontoUpdateManyMutationInput, pontoUncheckedUpdateManyInput>;
    /**
     * Filter which pontos to update
     */
    where?: pontoWhereInput;
    /**
     * Limit how many pontos to update.
     */
    limit?: number;
  };

  /**
   * ponto upsert
   */
  export type pontoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * The filter to search for the ponto to update in case it exists.
     */
    where: pontoWhereUniqueInput;
    /**
     * In case the ponto found by the `where` argument doesn't exist, create a new ponto with this data.
     */
    create: XOR<pontoCreateInput, pontoUncheckedCreateInput>;
    /**
     * In case the ponto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pontoUpdateInput, pontoUncheckedUpdateInput>;
  };

  /**
   * ponto delete
   */
  export type pontoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
    /**
     * Filter which ponto to delete.
     */
    where: pontoWhereUniqueInput;
  };

  /**
   * ponto deleteMany
   */
  export type pontoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which pontos to delete
     */
    where?: pontoWhereInput;
    /**
     * Limit how many pontos to delete.
     */
    limit?: number;
  };

  /**
   * ponto without action
   */
  export type pontoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ponto
     */
    select?: pontoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ponto
     */
    omit?: pontoOmit<ExtArgs> | null;
  };

  /**
   * Model projeto
   */

  export type AggregateProjeto = {
    _count: ProjetoCountAggregateOutputType | null;
    _avg: ProjetoAvgAggregateOutputType | null;
    _sum: ProjetoSumAggregateOutputType | null;
    _min: ProjetoMinAggregateOutputType | null;
    _max: ProjetoMaxAggregateOutputType | null;
  };

  export type ProjetoAvgAggregateOutputType = {
    cod_projeto: number | null;
    codcli_projeto: number | null;
    codrec_projeto: number | null;
    perc_projeto: Decimal | null;
    qtdhoras_projeto: Decimal | null;
  };

  export type ProjetoSumAggregateOutputType = {
    cod_projeto: number | null;
    codcli_projeto: number | null;
    codrec_projeto: number | null;
    perc_projeto: Decimal | null;
    qtdhoras_projeto: Decimal | null;
  };

  export type ProjetoMinAggregateOutputType = {
    cod_projeto: number | null;
    nome_projeto: string | null;
    codcli_projeto: number | null;
    respcli_projeto: string | null;
    proposta_projeto: string | null;
    codrec_projeto: number | null;
    perc_projeto: Decimal | null;
    loginc_projeto: string | null;
    logalt_projeto: string | null;
    qtdhoras_projeto: Decimal | null;
    status_projeto: string | null;
  };

  export type ProjetoMaxAggregateOutputType = {
    cod_projeto: number | null;
    nome_projeto: string | null;
    codcli_projeto: number | null;
    respcli_projeto: string | null;
    proposta_projeto: string | null;
    codrec_projeto: number | null;
    perc_projeto: Decimal | null;
    loginc_projeto: string | null;
    logalt_projeto: string | null;
    qtdhoras_projeto: Decimal | null;
    status_projeto: string | null;
  };

  export type ProjetoCountAggregateOutputType = {
    cod_projeto: number;
    nome_projeto: number;
    codcli_projeto: number;
    respcli_projeto: number;
    proposta_projeto: number;
    codrec_projeto: number;
    perc_projeto: number;
    loginc_projeto: number;
    logalt_projeto: number;
    qtdhoras_projeto: number;
    status_projeto: number;
    _all: number;
  };

  export type ProjetoAvgAggregateInputType = {
    cod_projeto?: true;
    codcli_projeto?: true;
    codrec_projeto?: true;
    perc_projeto?: true;
    qtdhoras_projeto?: true;
  };

  export type ProjetoSumAggregateInputType = {
    cod_projeto?: true;
    codcli_projeto?: true;
    codrec_projeto?: true;
    perc_projeto?: true;
    qtdhoras_projeto?: true;
  };

  export type ProjetoMinAggregateInputType = {
    cod_projeto?: true;
    nome_projeto?: true;
    codcli_projeto?: true;
    respcli_projeto?: true;
    proposta_projeto?: true;
    codrec_projeto?: true;
    perc_projeto?: true;
    loginc_projeto?: true;
    logalt_projeto?: true;
    qtdhoras_projeto?: true;
    status_projeto?: true;
  };

  export type ProjetoMaxAggregateInputType = {
    cod_projeto?: true;
    nome_projeto?: true;
    codcli_projeto?: true;
    respcli_projeto?: true;
    proposta_projeto?: true;
    codrec_projeto?: true;
    perc_projeto?: true;
    loginc_projeto?: true;
    logalt_projeto?: true;
    qtdhoras_projeto?: true;
    status_projeto?: true;
  };

  export type ProjetoCountAggregateInputType = {
    cod_projeto?: true;
    nome_projeto?: true;
    codcli_projeto?: true;
    respcli_projeto?: true;
    proposta_projeto?: true;
    codrec_projeto?: true;
    perc_projeto?: true;
    loginc_projeto?: true;
    logalt_projeto?: true;
    qtdhoras_projeto?: true;
    status_projeto?: true;
    _all?: true;
  };

  export type ProjetoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which projeto to aggregate.
     */
    where?: projetoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of projetos to fetch.
     */
    orderBy?:
      | projetoOrderByWithRelationInput
      | projetoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: projetoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` projetos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned projetos
     **/
    _count?: true | ProjetoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProjetoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProjetoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProjetoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProjetoMaxAggregateInputType;
  };

  export type GetProjetoAggregateType<T extends ProjetoAggregateArgs> = {
    [P in keyof T & keyof AggregateProjeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjeto[P]>
      : GetScalarType<T[P], AggregateProjeto[P]>;
  };

  export type projetoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: projetoWhereInput;
    orderBy?:
      | projetoOrderByWithAggregationInput
      | projetoOrderByWithAggregationInput[];
    by: ProjetoScalarFieldEnum[] | ProjetoScalarFieldEnum;
    having?: projetoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProjetoCountAggregateInputType | true;
    _avg?: ProjetoAvgAggregateInputType;
    _sum?: ProjetoSumAggregateInputType;
    _min?: ProjetoMinAggregateInputType;
    _max?: ProjetoMaxAggregateInputType;
  };

  export type ProjetoGroupByOutputType = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto: string | null;
    codrec_projeto: number;
    perc_projeto: Decimal;
    loginc_projeto: string | null;
    logalt_projeto: string | null;
    qtdhoras_projeto: Decimal;
    status_projeto: string;
    _count: ProjetoCountAggregateOutputType | null;
    _avg: ProjetoAvgAggregateOutputType | null;
    _sum: ProjetoSumAggregateOutputType | null;
    _min: ProjetoMinAggregateOutputType | null;
    _max: ProjetoMaxAggregateOutputType | null;
  };

  type GetProjetoGroupByPayload<T extends projetoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProjetoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ProjetoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetoGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetoGroupByOutputType[P]>;
        }
      >
    >;

  export type projetoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_projeto?: boolean;
      nome_projeto?: boolean;
      codcli_projeto?: boolean;
      respcli_projeto?: boolean;
      proposta_projeto?: boolean;
      codrec_projeto?: boolean;
      perc_projeto?: boolean;
      loginc_projeto?: boolean;
      logalt_projeto?: boolean;
      qtdhoras_projeto?: boolean;
      status_projeto?: boolean;
      avaliacao?: boolean | projeto$avaliacaoArgs<ExtArgs>;
      meta?: boolean | projeto$metaArgs<ExtArgs>;
      cliente?: boolean | clienteDefaultArgs<ExtArgs>;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
      tarefa?: boolean | projeto$tarefaArgs<ExtArgs>;
      valor?: boolean | projeto$valorArgs<ExtArgs>;
      _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['projeto']
  >;

  export type projetoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_projeto?: boolean;
      nome_projeto?: boolean;
      codcli_projeto?: boolean;
      respcli_projeto?: boolean;
      proposta_projeto?: boolean;
      codrec_projeto?: boolean;
      perc_projeto?: boolean;
      loginc_projeto?: boolean;
      logalt_projeto?: boolean;
      qtdhoras_projeto?: boolean;
      status_projeto?: boolean;
      cliente?: boolean | clienteDefaultArgs<ExtArgs>;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['projeto']
  >;

  export type projetoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_projeto?: boolean;
      nome_projeto?: boolean;
      codcli_projeto?: boolean;
      respcli_projeto?: boolean;
      proposta_projeto?: boolean;
      codrec_projeto?: boolean;
      perc_projeto?: boolean;
      loginc_projeto?: boolean;
      logalt_projeto?: boolean;
      qtdhoras_projeto?: boolean;
      status_projeto?: boolean;
      cliente?: boolean | clienteDefaultArgs<ExtArgs>;
      recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['projeto']
  >;

  export type projetoSelectScalar = {
    cod_projeto?: boolean;
    nome_projeto?: boolean;
    codcli_projeto?: boolean;
    respcli_projeto?: boolean;
    proposta_projeto?: boolean;
    codrec_projeto?: boolean;
    perc_projeto?: boolean;
    loginc_projeto?: boolean;
    logalt_projeto?: boolean;
    qtdhoras_projeto?: boolean;
    status_projeto?: boolean;
  };

  export type projetoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_projeto'
    | 'nome_projeto'
    | 'codcli_projeto'
    | 'respcli_projeto'
    | 'proposta_projeto'
    | 'codrec_projeto'
    | 'perc_projeto'
    | 'loginc_projeto'
    | 'logalt_projeto'
    | 'qtdhoras_projeto'
    | 'status_projeto',
    ExtArgs['result']['projeto']
  >;
  export type projetoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    avaliacao?: boolean | projeto$avaliacaoArgs<ExtArgs>;
    meta?: boolean | projeto$metaArgs<ExtArgs>;
    cliente?: boolean | clienteDefaultArgs<ExtArgs>;
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
    tarefa?: boolean | projeto$tarefaArgs<ExtArgs>;
    valor?: boolean | projeto$valorArgs<ExtArgs>;
    _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type projetoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>;
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
  };
  export type projetoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>;
    recurso?: boolean | recursoDefaultArgs<ExtArgs>;
  };

  export type $projetoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'projeto';
    objects: {
      avaliacao: Prisma.$avaliacaoPayload<ExtArgs>[];
      meta: Prisma.$metaPayload<ExtArgs>[];
      cliente: Prisma.$clientePayload<ExtArgs>;
      recurso: Prisma.$recursoPayload<ExtArgs>;
      tarefa: Prisma.$tarefaPayload<ExtArgs>[];
      valor: Prisma.$valorPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_projeto: number;
        nome_projeto: string;
        codcli_projeto: number;
        respcli_projeto: string;
        proposta_projeto: string | null;
        codrec_projeto: number;
        perc_projeto: Prisma.Decimal;
        loginc_projeto: string | null;
        logalt_projeto: string | null;
        qtdhoras_projeto: Prisma.Decimal;
        status_projeto: string;
      },
      ExtArgs['result']['projeto']
    >;
    composites: {};
  };

  type projetoGetPayload<
    S extends boolean | null | undefined | projetoDefaultArgs,
  > = $Result.GetResult<Prisma.$projetoPayload, S>;

  type projetoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<projetoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProjetoCountAggregateInputType | true;
  };

  export interface projetoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['projeto'];
      meta: { name: 'projeto' };
    };
    /**
     * Find zero or one Projeto that matches the filter.
     * @param {projetoFindUniqueArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projetoFindUniqueArgs>(
      args: SelectSubset<T, projetoFindUniqueArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Projeto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projetoFindUniqueOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projetoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, projetoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Projeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindFirstArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projetoFindFirstArgs>(
      args?: SelectSubset<T, projetoFindFirstArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Projeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindFirstOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projetoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, projetoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Projetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projetos
     * const projetos = await prisma.projeto.findMany()
     *
     * // Get first 10 Projetos
     * const projetos = await prisma.projeto.findMany({ take: 10 })
     *
     * // Only select the `cod_projeto`
     * const projetoWithCod_projetoOnly = await prisma.projeto.findMany({ select: { cod_projeto: true } })
     *
     */
    findMany<T extends projetoFindManyArgs>(
      args?: SelectSubset<T, projetoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Projeto.
     * @param {projetoCreateArgs} args - Arguments to create a Projeto.
     * @example
     * // Create one Projeto
     * const Projeto = await prisma.projeto.create({
     *   data: {
     *     // ... data to create a Projeto
     *   }
     * })
     *
     */
    create<T extends projetoCreateArgs>(
      args: SelectSubset<T, projetoCreateArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Projetos.
     * @param {projetoCreateManyArgs} args - Arguments to create many Projetos.
     * @example
     * // Create many Projetos
     * const projeto = await prisma.projeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends projetoCreateManyArgs>(
      args?: SelectSubset<T, projetoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Projetos and returns the data saved in the database.
     * @param {projetoCreateManyAndReturnArgs} args - Arguments to create many Projetos.
     * @example
     * // Create many Projetos
     * const projeto = await prisma.projeto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Projetos and only return the `cod_projeto`
     * const projetoWithCod_projetoOnly = await prisma.projeto.createManyAndReturn({
     *   select: { cod_projeto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends projetoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, projetoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Projeto.
     * @param {projetoDeleteArgs} args - Arguments to delete one Projeto.
     * @example
     * // Delete one Projeto
     * const Projeto = await prisma.projeto.delete({
     *   where: {
     *     // ... filter to delete one Projeto
     *   }
     * })
     *
     */
    delete<T extends projetoDeleteArgs>(
      args: SelectSubset<T, projetoDeleteArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Projeto.
     * @param {projetoUpdateArgs} args - Arguments to update one Projeto.
     * @example
     * // Update one Projeto
     * const projeto = await prisma.projeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends projetoUpdateArgs>(
      args: SelectSubset<T, projetoUpdateArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Projetos.
     * @param {projetoDeleteManyArgs} args - Arguments to filter Projetos to delete.
     * @example
     * // Delete a few Projetos
     * const { count } = await prisma.projeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends projetoDeleteManyArgs>(
      args?: SelectSubset<T, projetoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projetos
     * const projeto = await prisma.projeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends projetoUpdateManyArgs>(
      args: SelectSubset<T, projetoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Projetos and returns the data updated in the database.
     * @param {projetoUpdateManyAndReturnArgs} args - Arguments to update many Projetos.
     * @example
     * // Update many Projetos
     * const projeto = await prisma.projeto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Projetos and only return the `cod_projeto`
     * const projetoWithCod_projetoOnly = await prisma.projeto.updateManyAndReturn({
     *   select: { cod_projeto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends projetoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, projetoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Projeto.
     * @param {projetoUpsertArgs} args - Arguments to update or create a Projeto.
     * @example
     * // Update or create a Projeto
     * const projeto = await prisma.projeto.upsert({
     *   create: {
     *     // ... data to create a Projeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projeto we want to update
     *   }
     * })
     */
    upsert<T extends projetoUpsertArgs>(
      args: SelectSubset<T, projetoUpsertArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      $Result.GetResult<
        Prisma.$projetoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoCountArgs} args - Arguments to filter Projetos to count.
     * @example
     * // Count the number of Projetos
     * const count = await prisma.projeto.count({
     *   where: {
     *     // ... the filter for the Projetos we want to count
     *   }
     * })
     **/
    count<T extends projetoCountArgs>(
      args?: Subset<T, projetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProjetoAggregateArgs>(
      args: Subset<T, ProjetoAggregateArgs>,
    ): Prisma.PrismaPromise<GetProjetoAggregateType<T>>;

    /**
     * Group by Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends projetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projetoGroupByArgs['orderBy'] }
        : { orderBy?: projetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, projetoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetProjetoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the projeto model
     */
    readonly fields: projetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projetoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    avaliacao<T extends projeto$avaliacaoArgs<ExtArgs> = {}>(
      args?: Subset<T, projeto$avaliacaoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$avaliacaoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    meta<T extends projeto$metaArgs<ExtArgs> = {}>(
      args?: Subset<T, projeto$metaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$metaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    cliente<T extends clienteDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, clienteDefaultArgs<ExtArgs>>,
    ): Prisma__clienteClient<
      | $Result.GetResult<
          Prisma.$clientePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    recurso<T extends recursoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, recursoDefaultArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      | $Result.GetResult<
          Prisma.$recursoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tarefa<T extends projeto$tarefaArgs<ExtArgs> = {}>(
      args?: Subset<T, projeto$tarefaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$tarefaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    valor<T extends projeto$valorArgs<ExtArgs> = {}>(
      args?: Subset<T, projeto$valorArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$valorPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the projeto model
   */
  interface projetoFieldRefs {
    readonly cod_projeto: FieldRef<'projeto', 'Int'>;
    readonly nome_projeto: FieldRef<'projeto', 'String'>;
    readonly codcli_projeto: FieldRef<'projeto', 'Int'>;
    readonly respcli_projeto: FieldRef<'projeto', 'String'>;
    readonly proposta_projeto: FieldRef<'projeto', 'String'>;
    readonly codrec_projeto: FieldRef<'projeto', 'Int'>;
    readonly perc_projeto: FieldRef<'projeto', 'Decimal'>;
    readonly loginc_projeto: FieldRef<'projeto', 'String'>;
    readonly logalt_projeto: FieldRef<'projeto', 'String'>;
    readonly qtdhoras_projeto: FieldRef<'projeto', 'Decimal'>;
    readonly status_projeto: FieldRef<'projeto', 'String'>;
  }

  // Custom InputTypes
  /**
   * projeto findUnique
   */
  export type projetoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * Filter, which projeto to fetch.
     */
    where: projetoWhereUniqueInput;
  };

  /**
   * projeto findUniqueOrThrow
   */
  export type projetoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * Filter, which projeto to fetch.
     */
    where: projetoWhereUniqueInput;
  };

  /**
   * projeto findFirst
   */
  export type projetoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * Filter, which projeto to fetch.
     */
    where?: projetoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of projetos to fetch.
     */
    orderBy?:
      | projetoOrderByWithRelationInput
      | projetoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for projetos.
     */
    cursor?: projetoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` projetos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[];
  };

  /**
   * projeto findFirstOrThrow
   */
  export type projetoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * Filter, which projeto to fetch.
     */
    where?: projetoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of projetos to fetch.
     */
    orderBy?:
      | projetoOrderByWithRelationInput
      | projetoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for projetos.
     */
    cursor?: projetoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` projetos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[];
  };

  /**
   * projeto findMany
   */
  export type projetoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * Filter, which projetos to fetch.
     */
    where?: projetoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of projetos to fetch.
     */
    orderBy?:
      | projetoOrderByWithRelationInput
      | projetoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing projetos.
     */
    cursor?: projetoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` projetos.
     */
    skip?: number;
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[];
  };

  /**
   * projeto create
   */
  export type projetoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * The data needed to create a projeto.
     */
    data: XOR<projetoCreateInput, projetoUncheckedCreateInput>;
  };

  /**
   * projeto createMany
   */
  export type projetoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many projetos.
     */
    data: projetoCreateManyInput | projetoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * projeto createManyAndReturn
   */
  export type projetoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * The data used to create many projetos.
     */
    data: projetoCreateManyInput | projetoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * projeto update
   */
  export type projetoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * The data needed to update a projeto.
     */
    data: XOR<projetoUpdateInput, projetoUncheckedUpdateInput>;
    /**
     * Choose, which projeto to update.
     */
    where: projetoWhereUniqueInput;
  };

  /**
   * projeto updateMany
   */
  export type projetoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update projetos.
     */
    data: XOR<projetoUpdateManyMutationInput, projetoUncheckedUpdateManyInput>;
    /**
     * Filter which projetos to update
     */
    where?: projetoWhereInput;
    /**
     * Limit how many projetos to update.
     */
    limit?: number;
  };

  /**
   * projeto updateManyAndReturn
   */
  export type projetoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * The data used to update projetos.
     */
    data: XOR<projetoUpdateManyMutationInput, projetoUncheckedUpdateManyInput>;
    /**
     * Filter which projetos to update
     */
    where?: projetoWhereInput;
    /**
     * Limit how many projetos to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * projeto upsert
   */
  export type projetoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * The filter to search for the projeto to update in case it exists.
     */
    where: projetoWhereUniqueInput;
    /**
     * In case the projeto found by the `where` argument doesn't exist, create a new projeto with this data.
     */
    create: XOR<projetoCreateInput, projetoUncheckedCreateInput>;
    /**
     * In case the projeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projetoUpdateInput, projetoUncheckedUpdateInput>;
  };

  /**
   * projeto delete
   */
  export type projetoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    /**
     * Filter which projeto to delete.
     */
    where: projetoWhereUniqueInput;
  };

  /**
   * projeto deleteMany
   */
  export type projetoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which projetos to delete
     */
    where?: projetoWhereInput;
    /**
     * Limit how many projetos to delete.
     */
    limit?: number;
  };

  /**
   * projeto.avaliacao
   */
  export type projeto$avaliacaoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliacao
     */
    select?: avaliacaoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliacao
     */
    omit?: avaliacaoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliacaoInclude<ExtArgs> | null;
    where?: avaliacaoWhereInput;
    orderBy?:
      | avaliacaoOrderByWithRelationInput
      | avaliacaoOrderByWithRelationInput[];
    cursor?: avaliacaoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[];
  };

  /**
   * projeto.meta
   */
  export type projeto$metaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: metaInclude<ExtArgs> | null;
    where?: metaWhereInput;
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[];
    cursor?: metaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[];
  };

  /**
   * projeto.tarefa
   */
  export type projeto$tarefaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    where?: tarefaWhereInput;
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    cursor?: tarefaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * projeto.valor
   */
  export type projeto$valorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    where?: valorWhereInput;
    orderBy?: valorOrderByWithRelationInput | valorOrderByWithRelationInput[];
    cursor?: valorWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ValorScalarFieldEnum | ValorScalarFieldEnum[];
  };

  /**
   * projeto without action
   */
  export type projetoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
  };

  /**
   * Model recurso
   */

  export type AggregateRecurso = {
    _count: RecursoCountAggregateOutputType | null;
    _avg: RecursoAvgAggregateOutputType | null;
    _sum: RecursoSumAggregateOutputType | null;
    _min: RecursoMinAggregateOutputType | null;
    _max: RecursoMaxAggregateOutputType | null;
  };

  export type RecursoAvgAggregateOutputType = {
    cod_recurso: number | null;
    ativo_recurso: number | null;
    codusr_recurso: number | null;
    cod_nivel: number | null;
    percprod_recurso: Decimal | null;
    custo_recurso: Decimal | null;
    receita_recurso: Decimal | null;
    tpcusto_recurso: number | null;
  };

  export type RecursoSumAggregateOutputType = {
    cod_recurso: number | null;
    ativo_recurso: number | null;
    codusr_recurso: number | null;
    cod_nivel: number | null;
    percprod_recurso: Decimal | null;
    custo_recurso: Decimal | null;
    receita_recurso: Decimal | null;
    tpcusto_recurso: number | null;
  };

  export type RecursoMinAggregateOutputType = {
    cod_recurso: number | null;
    nome_recurso: string | null;
    fone_recurso: string | null;
    ativo_recurso: number | null;
    codusr_recurso: number | null;
    cod_nivel: number | null;
    hrdia_recurso: string | null;
    percprod_recurso: Decimal | null;
    email_recurso: string | null;
    dtlimite_recurso: Date | null;
    permapo_recurso: string | null;
    matr_recurso: string | null;
    obs_recurso: Uint8Array | null;
    custo_recurso: Decimal | null;
    receita_recurso: Decimal | null;
    tpcusto_recurso: number | null;
  };

  export type RecursoMaxAggregateOutputType = {
    cod_recurso: number | null;
    nome_recurso: string | null;
    fone_recurso: string | null;
    ativo_recurso: number | null;
    codusr_recurso: number | null;
    cod_nivel: number | null;
    hrdia_recurso: string | null;
    percprod_recurso: Decimal | null;
    email_recurso: string | null;
    dtlimite_recurso: Date | null;
    permapo_recurso: string | null;
    matr_recurso: string | null;
    obs_recurso: Uint8Array | null;
    custo_recurso: Decimal | null;
    receita_recurso: Decimal | null;
    tpcusto_recurso: number | null;
  };

  export type RecursoCountAggregateOutputType = {
    cod_recurso: number;
    nome_recurso: number;
    fone_recurso: number;
    ativo_recurso: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso: number;
    percprod_recurso: number;
    email_recurso: number;
    dtlimite_recurso: number;
    permapo_recurso: number;
    matr_recurso: number;
    obs_recurso: number;
    custo_recurso: number;
    receita_recurso: number;
    tpcusto_recurso: number;
    _all: number;
  };

  export type RecursoAvgAggregateInputType = {
    cod_recurso?: true;
    ativo_recurso?: true;
    codusr_recurso?: true;
    cod_nivel?: true;
    percprod_recurso?: true;
    custo_recurso?: true;
    receita_recurso?: true;
    tpcusto_recurso?: true;
  };

  export type RecursoSumAggregateInputType = {
    cod_recurso?: true;
    ativo_recurso?: true;
    codusr_recurso?: true;
    cod_nivel?: true;
    percprod_recurso?: true;
    custo_recurso?: true;
    receita_recurso?: true;
    tpcusto_recurso?: true;
  };

  export type RecursoMinAggregateInputType = {
    cod_recurso?: true;
    nome_recurso?: true;
    fone_recurso?: true;
    ativo_recurso?: true;
    codusr_recurso?: true;
    cod_nivel?: true;
    hrdia_recurso?: true;
    percprod_recurso?: true;
    email_recurso?: true;
    dtlimite_recurso?: true;
    permapo_recurso?: true;
    matr_recurso?: true;
    obs_recurso?: true;
    custo_recurso?: true;
    receita_recurso?: true;
    tpcusto_recurso?: true;
  };

  export type RecursoMaxAggregateInputType = {
    cod_recurso?: true;
    nome_recurso?: true;
    fone_recurso?: true;
    ativo_recurso?: true;
    codusr_recurso?: true;
    cod_nivel?: true;
    hrdia_recurso?: true;
    percprod_recurso?: true;
    email_recurso?: true;
    dtlimite_recurso?: true;
    permapo_recurso?: true;
    matr_recurso?: true;
    obs_recurso?: true;
    custo_recurso?: true;
    receita_recurso?: true;
    tpcusto_recurso?: true;
  };

  export type RecursoCountAggregateInputType = {
    cod_recurso?: true;
    nome_recurso?: true;
    fone_recurso?: true;
    ativo_recurso?: true;
    codusr_recurso?: true;
    cod_nivel?: true;
    hrdia_recurso?: true;
    percprod_recurso?: true;
    email_recurso?: true;
    dtlimite_recurso?: true;
    permapo_recurso?: true;
    matr_recurso?: true;
    obs_recurso?: true;
    custo_recurso?: true;
    receita_recurso?: true;
    tpcusto_recurso?: true;
    _all?: true;
  };

  export type RecursoAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which recurso to aggregate.
     */
    where?: recursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of recursos to fetch.
     */
    orderBy?:
      | recursoOrderByWithRelationInput
      | recursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: recursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` recursos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned recursos
     **/
    _count?: true | RecursoCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RecursoAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RecursoSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RecursoMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RecursoMaxAggregateInputType;
  };

  export type GetRecursoAggregateType<T extends RecursoAggregateArgs> = {
    [P in keyof T & keyof AggregateRecurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurso[P]>
      : GetScalarType<T[P], AggregateRecurso[P]>;
  };

  export type recursoGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: recursoWhereInput;
    orderBy?:
      | recursoOrderByWithAggregationInput
      | recursoOrderByWithAggregationInput[];
    by: RecursoScalarFieldEnum[] | RecursoScalarFieldEnum;
    having?: recursoScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RecursoCountAggregateInputType | true;
    _avg?: RecursoAvgAggregateInputType;
    _sum?: RecursoSumAggregateInputType;
    _min?: RecursoMinAggregateInputType;
    _max?: RecursoMaxAggregateInputType;
  };

  export type RecursoGroupByOutputType = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso: string | null;
    ativo_recurso: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso: string | null;
    percprod_recurso: Decimal | null;
    email_recurso: string | null;
    dtlimite_recurso: Date | null;
    permapo_recurso: string;
    matr_recurso: string | null;
    obs_recurso: Uint8Array | null;
    custo_recurso: Decimal | null;
    receita_recurso: Decimal | null;
    tpcusto_recurso: number | null;
    _count: RecursoCountAggregateOutputType | null;
    _avg: RecursoAvgAggregateOutputType | null;
    _sum: RecursoSumAggregateOutputType | null;
    _min: RecursoMinAggregateOutputType | null;
    _max: RecursoMaxAggregateOutputType | null;
  };

  type GetRecursoGroupByPayload<T extends recursoGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RecursoGroupByOutputType, T['by']> & {
          [P in keyof T & keyof RecursoGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecursoGroupByOutputType[P]>
            : GetScalarType<T[P], RecursoGroupByOutputType[P]>;
        }
      >
    >;

  export type recursoSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_recurso?: boolean;
      nome_recurso?: boolean;
      fone_recurso?: boolean;
      ativo_recurso?: boolean;
      codusr_recurso?: boolean;
      cod_nivel?: boolean;
      hrdia_recurso?: boolean;
      percprod_recurso?: boolean;
      email_recurso?: boolean;
      dtlimite_recurso?: boolean;
      permapo_recurso?: boolean;
      matr_recurso?: boolean;
      obs_recurso?: boolean;
      custo_recurso?: boolean;
      receita_recurso?: boolean;
      tpcusto_recurso?: boolean;
      agenrec?: boolean | recurso$agenrecArgs<ExtArgs>;
      avaliado?: boolean | recurso$avaliadoArgs<ExtArgs>;
      projeto?: boolean | recurso$projetoArgs<ExtArgs>;
      nivel?: boolean | nivelDefaultArgs<ExtArgs>;
      usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
      tarefa_tarefa_codrecresp_tarefaTorecurso?:
        | boolean
        | recurso$tarefa_tarefa_codrecresp_tarefaTorecursoArgs<ExtArgs>;
      tarefa_tarefa_codrec_tarefaTorecurso?:
        | boolean
        | recurso$tarefa_tarefa_codrec_tarefaTorecursoArgs<ExtArgs>;
      chamado?: boolean | recurso$chamadoArgs<ExtArgs>;
      _count?: boolean | RecursoCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['recurso']
  >;

  export type recursoSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_recurso?: boolean;
      nome_recurso?: boolean;
      fone_recurso?: boolean;
      ativo_recurso?: boolean;
      codusr_recurso?: boolean;
      cod_nivel?: boolean;
      hrdia_recurso?: boolean;
      percprod_recurso?: boolean;
      email_recurso?: boolean;
      dtlimite_recurso?: boolean;
      permapo_recurso?: boolean;
      matr_recurso?: boolean;
      obs_recurso?: boolean;
      custo_recurso?: boolean;
      receita_recurso?: boolean;
      tpcusto_recurso?: boolean;
      nivel?: boolean | nivelDefaultArgs<ExtArgs>;
      usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['recurso']
  >;

  export type recursoSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_recurso?: boolean;
      nome_recurso?: boolean;
      fone_recurso?: boolean;
      ativo_recurso?: boolean;
      codusr_recurso?: boolean;
      cod_nivel?: boolean;
      hrdia_recurso?: boolean;
      percprod_recurso?: boolean;
      email_recurso?: boolean;
      dtlimite_recurso?: boolean;
      permapo_recurso?: boolean;
      matr_recurso?: boolean;
      obs_recurso?: boolean;
      custo_recurso?: boolean;
      receita_recurso?: boolean;
      tpcusto_recurso?: boolean;
      nivel?: boolean | nivelDefaultArgs<ExtArgs>;
      usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['recurso']
  >;

  export type recursoSelectScalar = {
    cod_recurso?: boolean;
    nome_recurso?: boolean;
    fone_recurso?: boolean;
    ativo_recurso?: boolean;
    codusr_recurso?: boolean;
    cod_nivel?: boolean;
    hrdia_recurso?: boolean;
    percprod_recurso?: boolean;
    email_recurso?: boolean;
    dtlimite_recurso?: boolean;
    permapo_recurso?: boolean;
    matr_recurso?: boolean;
    obs_recurso?: boolean;
    custo_recurso?: boolean;
    receita_recurso?: boolean;
    tpcusto_recurso?: boolean;
  };

  export type recursoOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_recurso'
    | 'nome_recurso'
    | 'fone_recurso'
    | 'ativo_recurso'
    | 'codusr_recurso'
    | 'cod_nivel'
    | 'hrdia_recurso'
    | 'percprod_recurso'
    | 'email_recurso'
    | 'dtlimite_recurso'
    | 'permapo_recurso'
    | 'matr_recurso'
    | 'obs_recurso'
    | 'custo_recurso'
    | 'receita_recurso'
    | 'tpcusto_recurso',
    ExtArgs['result']['recurso']
  >;
  export type recursoInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    agenrec?: boolean | recurso$agenrecArgs<ExtArgs>;
    avaliado?: boolean | recurso$avaliadoArgs<ExtArgs>;
    projeto?: boolean | recurso$projetoArgs<ExtArgs>;
    nivel?: boolean | nivelDefaultArgs<ExtArgs>;
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
    tarefa_tarefa_codrecresp_tarefaTorecurso?:
      | boolean
      | recurso$tarefa_tarefa_codrecresp_tarefaTorecursoArgs<ExtArgs>;
    tarefa_tarefa_codrec_tarefaTorecurso?:
      | boolean
      | recurso$tarefa_tarefa_codrec_tarefaTorecursoArgs<ExtArgs>;
    chamado?: boolean | recurso$chamadoArgs<ExtArgs>;
    _count?: boolean | RecursoCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type recursoIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    nivel?: boolean | nivelDefaultArgs<ExtArgs>;
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
  };
  export type recursoIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    nivel?: boolean | nivelDefaultArgs<ExtArgs>;
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>;
  };

  export type $recursoPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'recurso';
    objects: {
      agenrec: Prisma.$agenrecPayload<ExtArgs>[];
      avaliado: Prisma.$avaliadoPayload<ExtArgs>[];
      projeto: Prisma.$projetoPayload<ExtArgs>[];
      nivel: Prisma.$nivelPayload<ExtArgs>;
      usuario: Prisma.$usuarioPayload<ExtArgs>;
      tarefa_tarefa_codrecresp_tarefaTorecurso: Prisma.$tarefaPayload<ExtArgs>[];
      tarefa_tarefa_codrec_tarefaTorecurso: Prisma.$tarefaPayload<ExtArgs>[];
      chamado: Prisma.$chamadoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_recurso: number;
        nome_recurso: string;
        fone_recurso: string | null;
        ativo_recurso: number;
        codusr_recurso: number;
        cod_nivel: number;
        hrdia_recurso: string | null;
        percprod_recurso: Prisma.Decimal | null;
        email_recurso: string | null;
        dtlimite_recurso: Date | null;
        permapo_recurso: string;
        matr_recurso: string | null;
        obs_recurso: Uint8Array | null;
        custo_recurso: Prisma.Decimal | null;
        receita_recurso: Prisma.Decimal | null;
        tpcusto_recurso: number | null;
      },
      ExtArgs['result']['recurso']
    >;
    composites: {};
  };

  type recursoGetPayload<
    S extends boolean | null | undefined | recursoDefaultArgs,
  > = $Result.GetResult<Prisma.$recursoPayload, S>;

  type recursoCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<recursoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RecursoCountAggregateInputType | true;
  };

  export interface recursoDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['recurso'];
      meta: { name: 'recurso' };
    };
    /**
     * Find zero or one Recurso that matches the filter.
     * @param {recursoFindUniqueArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recursoFindUniqueArgs>(
      args: SelectSubset<T, recursoFindUniqueArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Recurso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recursoFindUniqueOrThrowArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recursoFindUniqueOrThrowArgs>(
      args: SelectSubset<T, recursoFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Recurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoFindFirstArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recursoFindFirstArgs>(
      args?: SelectSubset<T, recursoFindFirstArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Recurso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoFindFirstOrThrowArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recursoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, recursoFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Recursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recursos
     * const recursos = await prisma.recurso.findMany()
     *
     * // Get first 10 Recursos
     * const recursos = await prisma.recurso.findMany({ take: 10 })
     *
     * // Only select the `cod_recurso`
     * const recursoWithCod_recursoOnly = await prisma.recurso.findMany({ select: { cod_recurso: true } })
     *
     */
    findMany<T extends recursoFindManyArgs>(
      args?: SelectSubset<T, recursoFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Recurso.
     * @param {recursoCreateArgs} args - Arguments to create a Recurso.
     * @example
     * // Create one Recurso
     * const Recurso = await prisma.recurso.create({
     *   data: {
     *     // ... data to create a Recurso
     *   }
     * })
     *
     */
    create<T extends recursoCreateArgs>(
      args: SelectSubset<T, recursoCreateArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Recursos.
     * @param {recursoCreateManyArgs} args - Arguments to create many Recursos.
     * @example
     * // Create many Recursos
     * const recurso = await prisma.recurso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends recursoCreateManyArgs>(
      args?: SelectSubset<T, recursoCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Recursos and returns the data saved in the database.
     * @param {recursoCreateManyAndReturnArgs} args - Arguments to create many Recursos.
     * @example
     * // Create many Recursos
     * const recurso = await prisma.recurso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Recursos and only return the `cod_recurso`
     * const recursoWithCod_recursoOnly = await prisma.recurso.createManyAndReturn({
     *   select: { cod_recurso: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends recursoCreateManyAndReturnArgs>(
      args?: SelectSubset<T, recursoCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Recurso.
     * @param {recursoDeleteArgs} args - Arguments to delete one Recurso.
     * @example
     * // Delete one Recurso
     * const Recurso = await prisma.recurso.delete({
     *   where: {
     *     // ... filter to delete one Recurso
     *   }
     * })
     *
     */
    delete<T extends recursoDeleteArgs>(
      args: SelectSubset<T, recursoDeleteArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Recurso.
     * @param {recursoUpdateArgs} args - Arguments to update one Recurso.
     * @example
     * // Update one Recurso
     * const recurso = await prisma.recurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends recursoUpdateArgs>(
      args: SelectSubset<T, recursoUpdateArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Recursos.
     * @param {recursoDeleteManyArgs} args - Arguments to filter Recursos to delete.
     * @example
     * // Delete a few Recursos
     * const { count } = await prisma.recurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends recursoDeleteManyArgs>(
      args?: SelectSubset<T, recursoDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Recursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recursos
     * const recurso = await prisma.recurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends recursoUpdateManyArgs>(
      args: SelectSubset<T, recursoUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Recursos and returns the data updated in the database.
     * @param {recursoUpdateManyAndReturnArgs} args - Arguments to update many Recursos.
     * @example
     * // Update many Recursos
     * const recurso = await prisma.recurso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Recursos and only return the `cod_recurso`
     * const recursoWithCod_recursoOnly = await prisma.recurso.updateManyAndReturn({
     *   select: { cod_recurso: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends recursoUpdateManyAndReturnArgs>(
      args: SelectSubset<T, recursoUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Recurso.
     * @param {recursoUpsertArgs} args - Arguments to update or create a Recurso.
     * @example
     * // Update or create a Recurso
     * const recurso = await prisma.recurso.upsert({
     *   create: {
     *     // ... data to create a Recurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recurso we want to update
     *   }
     * })
     */
    upsert<T extends recursoUpsertArgs>(
      args: SelectSubset<T, recursoUpsertArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      $Result.GetResult<
        Prisma.$recursoPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Recursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoCountArgs} args - Arguments to filter Recursos to count.
     * @example
     * // Count the number of Recursos
     * const count = await prisma.recurso.count({
     *   where: {
     *     // ... the filter for the Recursos we want to count
     *   }
     * })
     **/
    count<T extends recursoCountArgs>(
      args?: Subset<T, recursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecursoCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Recurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RecursoAggregateArgs>(
      args: Subset<T, RecursoAggregateArgs>,
    ): Prisma.PrismaPromise<GetRecursoAggregateType<T>>;

    /**
     * Group by Recurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends recursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recursoGroupByArgs['orderBy'] }
        : { orderBy?: recursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, recursoGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetRecursoGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the recurso model
     */
    readonly fields: recursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recursoClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    agenrec<T extends recurso$agenrecArgs<ExtArgs> = {}>(
      args?: Subset<T, recurso$agenrecArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$agenrecPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    avaliado<T extends recurso$avaliadoArgs<ExtArgs> = {}>(
      args?: Subset<T, recurso$avaliadoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$avaliadoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    projeto<T extends recurso$projetoArgs<ExtArgs> = {}>(
      args?: Subset<T, recurso$projetoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$projetoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    nivel<T extends nivelDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, nivelDefaultArgs<ExtArgs>>,
    ): Prisma__nivelClient<
      | $Result.GetResult<
          Prisma.$nivelPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usuarioDefaultArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      | $Result.GetResult<
          Prisma.$usuarioPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tarefa_tarefa_codrecresp_tarefaTorecurso<
      T extends
        recurso$tarefa_tarefa_codrecresp_tarefaTorecursoArgs<ExtArgs> = {},
    >(
      args?: Subset<
        T,
        recurso$tarefa_tarefa_codrecresp_tarefaTorecursoArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$tarefaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    tarefa_tarefa_codrec_tarefaTorecurso<
      T extends recurso$tarefa_tarefa_codrec_tarefaTorecursoArgs<ExtArgs> = {},
    >(
      args?: Subset<
        T,
        recurso$tarefa_tarefa_codrec_tarefaTorecursoArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$tarefaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    chamado<T extends recurso$chamadoArgs<ExtArgs> = {}>(
      args?: Subset<T, recurso$chamadoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$chamadoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the recurso model
   */
  interface recursoFieldRefs {
    readonly cod_recurso: FieldRef<'recurso', 'Int'>;
    readonly nome_recurso: FieldRef<'recurso', 'String'>;
    readonly fone_recurso: FieldRef<'recurso', 'String'>;
    readonly ativo_recurso: FieldRef<'recurso', 'Int'>;
    readonly codusr_recurso: FieldRef<'recurso', 'Int'>;
    readonly cod_nivel: FieldRef<'recurso', 'Int'>;
    readonly hrdia_recurso: FieldRef<'recurso', 'String'>;
    readonly percprod_recurso: FieldRef<'recurso', 'Decimal'>;
    readonly email_recurso: FieldRef<'recurso', 'String'>;
    readonly dtlimite_recurso: FieldRef<'recurso', 'DateTime'>;
    readonly permapo_recurso: FieldRef<'recurso', 'String'>;
    readonly matr_recurso: FieldRef<'recurso', 'String'>;
    readonly obs_recurso: FieldRef<'recurso', 'Bytes'>;
    readonly custo_recurso: FieldRef<'recurso', 'Decimal'>;
    readonly receita_recurso: FieldRef<'recurso', 'Decimal'>;
    readonly tpcusto_recurso: FieldRef<'recurso', 'Int'>;
  }

  // Custom InputTypes
  /**
   * recurso findUnique
   */
  export type recursoFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * Filter, which recurso to fetch.
     */
    where: recursoWhereUniqueInput;
  };

  /**
   * recurso findUniqueOrThrow
   */
  export type recursoFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * Filter, which recurso to fetch.
     */
    where: recursoWhereUniqueInput;
  };

  /**
   * recurso findFirst
   */
  export type recursoFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * Filter, which recurso to fetch.
     */
    where?: recursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of recursos to fetch.
     */
    orderBy?:
      | recursoOrderByWithRelationInput
      | recursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for recursos.
     */
    cursor?: recursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` recursos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of recursos.
     */
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[];
  };

  /**
   * recurso findFirstOrThrow
   */
  export type recursoFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * Filter, which recurso to fetch.
     */
    where?: recursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of recursos to fetch.
     */
    orderBy?:
      | recursoOrderByWithRelationInput
      | recursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for recursos.
     */
    cursor?: recursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` recursos.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of recursos.
     */
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[];
  };

  /**
   * recurso findMany
   */
  export type recursoFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * Filter, which recursos to fetch.
     */
    where?: recursoWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of recursos to fetch.
     */
    orderBy?:
      | recursoOrderByWithRelationInput
      | recursoOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing recursos.
     */
    cursor?: recursoWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` recursos.
     */
    skip?: number;
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[];
  };

  /**
   * recurso create
   */
  export type recursoCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * The data needed to create a recurso.
     */
    data: XOR<recursoCreateInput, recursoUncheckedCreateInput>;
  };

  /**
   * recurso createMany
   */
  export type recursoCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many recursos.
     */
    data: recursoCreateManyInput | recursoCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * recurso createManyAndReturn
   */
  export type recursoCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * The data used to create many recursos.
     */
    data: recursoCreateManyInput | recursoCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * recurso update
   */
  export type recursoUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * The data needed to update a recurso.
     */
    data: XOR<recursoUpdateInput, recursoUncheckedUpdateInput>;
    /**
     * Choose, which recurso to update.
     */
    where: recursoWhereUniqueInput;
  };

  /**
   * recurso updateMany
   */
  export type recursoUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update recursos.
     */
    data: XOR<recursoUpdateManyMutationInput, recursoUncheckedUpdateManyInput>;
    /**
     * Filter which recursos to update
     */
    where?: recursoWhereInput;
    /**
     * Limit how many recursos to update.
     */
    limit?: number;
  };

  /**
   * recurso updateManyAndReturn
   */
  export type recursoUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * The data used to update recursos.
     */
    data: XOR<recursoUpdateManyMutationInput, recursoUncheckedUpdateManyInput>;
    /**
     * Filter which recursos to update
     */
    where?: recursoWhereInput;
    /**
     * Limit how many recursos to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * recurso upsert
   */
  export type recursoUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * The filter to search for the recurso to update in case it exists.
     */
    where: recursoWhereUniqueInput;
    /**
     * In case the recurso found by the `where` argument doesn't exist, create a new recurso with this data.
     */
    create: XOR<recursoCreateInput, recursoUncheckedCreateInput>;
    /**
     * In case the recurso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recursoUpdateInput, recursoUncheckedUpdateInput>;
  };

  /**
   * recurso delete
   */
  export type recursoDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    /**
     * Filter which recurso to delete.
     */
    where: recursoWhereUniqueInput;
  };

  /**
   * recurso deleteMany
   */
  export type recursoDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which recursos to delete
     */
    where?: recursoWhereInput;
    /**
     * Limit how many recursos to delete.
     */
    limit?: number;
  };

  /**
   * recurso.agenrec
   */
  export type recurso$agenrecArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the agenrec
     */
    select?: agenrecSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the agenrec
     */
    omit?: agenrecOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agenrecInclude<ExtArgs> | null;
    where?: agenrecWhereInput;
    orderBy?:
      | agenrecOrderByWithRelationInput
      | agenrecOrderByWithRelationInput[];
    cursor?: agenrecWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AgenrecScalarFieldEnum | AgenrecScalarFieldEnum[];
  };

  /**
   * recurso.avaliado
   */
  export type recurso$avaliadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the avaliado
     */
    select?: avaliadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the avaliado
     */
    omit?: avaliadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: avaliadoInclude<ExtArgs> | null;
    where?: avaliadoWhereInput;
    orderBy?:
      | avaliadoOrderByWithRelationInput
      | avaliadoOrderByWithRelationInput[];
    cursor?: avaliadoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AvaliadoScalarFieldEnum | AvaliadoScalarFieldEnum[];
  };

  /**
   * recurso.projeto
   */
  export type recurso$projetoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the projeto
     */
    omit?: projetoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null;
    where?: projetoWhereInput;
    orderBy?:
      | projetoOrderByWithRelationInput
      | projetoOrderByWithRelationInput[];
    cursor?: projetoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[];
  };

  /**
   * recurso.tarefa_tarefa_codrecresp_tarefaTorecurso
   */
  export type recurso$tarefa_tarefa_codrecresp_tarefaTorecursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    where?: tarefaWhereInput;
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    cursor?: tarefaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * recurso.tarefa_tarefa_codrec_tarefaTorecurso
   */
  export type recurso$tarefa_tarefa_codrec_tarefaTorecursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    where?: tarefaWhereInput;
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    cursor?: tarefaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * recurso.chamado
   */
  export type recurso$chamadoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the chamado
     */
    select?: chamadoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the chamado
     */
    omit?: chamadoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chamadoInclude<ExtArgs> | null;
    where?: chamadoWhereInput;
    orderBy?:
      | chamadoOrderByWithRelationInput
      | chamadoOrderByWithRelationInput[];
    cursor?: chamadoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ChamadoScalarFieldEnum | ChamadoScalarFieldEnum[];
  };

  /**
   * recurso without action
   */
  export type recursoDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
  };

  /**
   * Model rescon
   */

  export type AggregateRescon = {
    _count: ResconCountAggregateOutputType | null;
    _avg: ResconAvgAggregateOutputType | null;
    _sum: ResconSumAggregateOutputType | null;
    _min: ResconMinAggregateOutputType | null;
    _max: ResconMaxAggregateOutputType | null;
  };

  export type ResconAvgAggregateOutputType = {
    cod_rescon: number | null;
    cod_fatura: number | null;
    cod_recurso: number | null;
    hrfat_rescon: Decimal | null;
    hrnfat_rescon: Decimal | null;
    vrfat_rescon: Decimal | null;
    vrnfat_rescon: Decimal | null;
    realizado_rescon: Decimal | null;
    disponivel_rescon: Decimal | null;
    perc1_rescon: Decimal | null;
    perc2_rescon: Decimal | null;
    perc3_rescon: Decimal | null;
    custo_rescon: Decimal | null;
    contrib_rescon: Decimal | null;
    perccontrib_rescon: Decimal | null;
    hrbase_rescon: Decimal | null;
    mo_rescon: Decimal | null;
    desp_rescon: Decimal | null;
  };

  export type ResconSumAggregateOutputType = {
    cod_rescon: number | null;
    cod_fatura: number | null;
    cod_recurso: number | null;
    hrfat_rescon: Decimal | null;
    hrnfat_rescon: Decimal | null;
    vrfat_rescon: Decimal | null;
    vrnfat_rescon: Decimal | null;
    realizado_rescon: Decimal | null;
    disponivel_rescon: Decimal | null;
    perc1_rescon: Decimal | null;
    perc2_rescon: Decimal | null;
    perc3_rescon: Decimal | null;
    custo_rescon: Decimal | null;
    contrib_rescon: Decimal | null;
    perccontrib_rescon: Decimal | null;
    hrbase_rescon: Decimal | null;
    mo_rescon: Decimal | null;
    desp_rescon: Decimal | null;
  };

  export type ResconMinAggregateOutputType = {
    cod_rescon: number | null;
    cod_fatura: number | null;
    cod_recurso: number | null;
    hrfat_rescon: Decimal | null;
    hrnfat_rescon: Decimal | null;
    vrfat_rescon: Decimal | null;
    vrnfat_rescon: Decimal | null;
    realizado_rescon: Decimal | null;
    disponivel_rescon: Decimal | null;
    perc1_rescon: Decimal | null;
    perc2_rescon: Decimal | null;
    perc3_rescon: Decimal | null;
    custo_rescon: Decimal | null;
    contrib_rescon: Decimal | null;
    perccontrib_rescon: Decimal | null;
    hrbase_rescon: Decimal | null;
    mo_rescon: Decimal | null;
    desp_rescon: Decimal | null;
  };

  export type ResconMaxAggregateOutputType = {
    cod_rescon: number | null;
    cod_fatura: number | null;
    cod_recurso: number | null;
    hrfat_rescon: Decimal | null;
    hrnfat_rescon: Decimal | null;
    vrfat_rescon: Decimal | null;
    vrnfat_rescon: Decimal | null;
    realizado_rescon: Decimal | null;
    disponivel_rescon: Decimal | null;
    perc1_rescon: Decimal | null;
    perc2_rescon: Decimal | null;
    perc3_rescon: Decimal | null;
    custo_rescon: Decimal | null;
    contrib_rescon: Decimal | null;
    perccontrib_rescon: Decimal | null;
    hrbase_rescon: Decimal | null;
    mo_rescon: Decimal | null;
    desp_rescon: Decimal | null;
  };

  export type ResconCountAggregateOutputType = {
    cod_rescon: number;
    cod_fatura: number;
    cod_recurso: number;
    hrfat_rescon: number;
    hrnfat_rescon: number;
    vrfat_rescon: number;
    vrnfat_rescon: number;
    realizado_rescon: number;
    disponivel_rescon: number;
    perc1_rescon: number;
    perc2_rescon: number;
    perc3_rescon: number;
    custo_rescon: number;
    contrib_rescon: number;
    perccontrib_rescon: number;
    hrbase_rescon: number;
    mo_rescon: number;
    desp_rescon: number;
    _all: number;
  };

  export type ResconAvgAggregateInputType = {
    cod_rescon?: true;
    cod_fatura?: true;
    cod_recurso?: true;
    hrfat_rescon?: true;
    hrnfat_rescon?: true;
    vrfat_rescon?: true;
    vrnfat_rescon?: true;
    realizado_rescon?: true;
    disponivel_rescon?: true;
    perc1_rescon?: true;
    perc2_rescon?: true;
    perc3_rescon?: true;
    custo_rescon?: true;
    contrib_rescon?: true;
    perccontrib_rescon?: true;
    hrbase_rescon?: true;
    mo_rescon?: true;
    desp_rescon?: true;
  };

  export type ResconSumAggregateInputType = {
    cod_rescon?: true;
    cod_fatura?: true;
    cod_recurso?: true;
    hrfat_rescon?: true;
    hrnfat_rescon?: true;
    vrfat_rescon?: true;
    vrnfat_rescon?: true;
    realizado_rescon?: true;
    disponivel_rescon?: true;
    perc1_rescon?: true;
    perc2_rescon?: true;
    perc3_rescon?: true;
    custo_rescon?: true;
    contrib_rescon?: true;
    perccontrib_rescon?: true;
    hrbase_rescon?: true;
    mo_rescon?: true;
    desp_rescon?: true;
  };

  export type ResconMinAggregateInputType = {
    cod_rescon?: true;
    cod_fatura?: true;
    cod_recurso?: true;
    hrfat_rescon?: true;
    hrnfat_rescon?: true;
    vrfat_rescon?: true;
    vrnfat_rescon?: true;
    realizado_rescon?: true;
    disponivel_rescon?: true;
    perc1_rescon?: true;
    perc2_rescon?: true;
    perc3_rescon?: true;
    custo_rescon?: true;
    contrib_rescon?: true;
    perccontrib_rescon?: true;
    hrbase_rescon?: true;
    mo_rescon?: true;
    desp_rescon?: true;
  };

  export type ResconMaxAggregateInputType = {
    cod_rescon?: true;
    cod_fatura?: true;
    cod_recurso?: true;
    hrfat_rescon?: true;
    hrnfat_rescon?: true;
    vrfat_rescon?: true;
    vrnfat_rescon?: true;
    realizado_rescon?: true;
    disponivel_rescon?: true;
    perc1_rescon?: true;
    perc2_rescon?: true;
    perc3_rescon?: true;
    custo_rescon?: true;
    contrib_rescon?: true;
    perccontrib_rescon?: true;
    hrbase_rescon?: true;
    mo_rescon?: true;
    desp_rescon?: true;
  };

  export type ResconCountAggregateInputType = {
    cod_rescon?: true;
    cod_fatura?: true;
    cod_recurso?: true;
    hrfat_rescon?: true;
    hrnfat_rescon?: true;
    vrfat_rescon?: true;
    vrnfat_rescon?: true;
    realizado_rescon?: true;
    disponivel_rescon?: true;
    perc1_rescon?: true;
    perc2_rescon?: true;
    perc3_rescon?: true;
    custo_rescon?: true;
    contrib_rescon?: true;
    perccontrib_rescon?: true;
    hrbase_rescon?: true;
    mo_rescon?: true;
    desp_rescon?: true;
    _all?: true;
  };

  export type ResconAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which rescon to aggregate.
     */
    where?: resconWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rescons to fetch.
     */
    orderBy?: resconOrderByWithRelationInput | resconOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: resconWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rescons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rescons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned rescons
     **/
    _count?: true | ResconCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ResconAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ResconSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ResconMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ResconMaxAggregateInputType;
  };

  export type GetResconAggregateType<T extends ResconAggregateArgs> = {
    [P in keyof T & keyof AggregateRescon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRescon[P]>
      : GetScalarType<T[P], AggregateRescon[P]>;
  };

  export type resconGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: resconWhereInput;
    orderBy?:
      | resconOrderByWithAggregationInput
      | resconOrderByWithAggregationInput[];
    by: ResconScalarFieldEnum[] | ResconScalarFieldEnum;
    having?: resconScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ResconCountAggregateInputType | true;
    _avg?: ResconAvgAggregateInputType;
    _sum?: ResconSumAggregateInputType;
    _min?: ResconMinAggregateInputType;
    _max?: ResconMaxAggregateInputType;
  };

  export type ResconGroupByOutputType = {
    cod_rescon: number;
    cod_fatura: number;
    cod_recurso: number;
    hrfat_rescon: Decimal | null;
    hrnfat_rescon: Decimal | null;
    vrfat_rescon: Decimal | null;
    vrnfat_rescon: Decimal | null;
    realizado_rescon: Decimal | null;
    disponivel_rescon: Decimal | null;
    perc1_rescon: Decimal | null;
    perc2_rescon: Decimal | null;
    perc3_rescon: Decimal | null;
    custo_rescon: Decimal | null;
    contrib_rescon: Decimal | null;
    perccontrib_rescon: Decimal | null;
    hrbase_rescon: Decimal | null;
    mo_rescon: Decimal | null;
    desp_rescon: Decimal | null;
    _count: ResconCountAggregateOutputType | null;
    _avg: ResconAvgAggregateOutputType | null;
    _sum: ResconSumAggregateOutputType | null;
    _min: ResconMinAggregateOutputType | null;
    _max: ResconMaxAggregateOutputType | null;
  };

  type GetResconGroupByPayload<T extends resconGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ResconGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ResconGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResconGroupByOutputType[P]>
            : GetScalarType<T[P], ResconGroupByOutputType[P]>;
        }
      >
    >;

  export type resconSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_rescon?: boolean;
      cod_fatura?: boolean;
      cod_recurso?: boolean;
      hrfat_rescon?: boolean;
      hrnfat_rescon?: boolean;
      vrfat_rescon?: boolean;
      vrnfat_rescon?: boolean;
      realizado_rescon?: boolean;
      disponivel_rescon?: boolean;
      perc1_rescon?: boolean;
      perc2_rescon?: boolean;
      perc3_rescon?: boolean;
      custo_rescon?: boolean;
      contrib_rescon?: boolean;
      perccontrib_rescon?: boolean;
      hrbase_rescon?: boolean;
      mo_rescon?: boolean;
      desp_rescon?: boolean;
    },
    ExtArgs['result']['rescon']
  >;

  export type resconSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_rescon?: boolean;
      cod_fatura?: boolean;
      cod_recurso?: boolean;
      hrfat_rescon?: boolean;
      hrnfat_rescon?: boolean;
      vrfat_rescon?: boolean;
      vrnfat_rescon?: boolean;
      realizado_rescon?: boolean;
      disponivel_rescon?: boolean;
      perc1_rescon?: boolean;
      perc2_rescon?: boolean;
      perc3_rescon?: boolean;
      custo_rescon?: boolean;
      contrib_rescon?: boolean;
      perccontrib_rescon?: boolean;
      hrbase_rescon?: boolean;
      mo_rescon?: boolean;
      desp_rescon?: boolean;
    },
    ExtArgs['result']['rescon']
  >;

  export type resconSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_rescon?: boolean;
      cod_fatura?: boolean;
      cod_recurso?: boolean;
      hrfat_rescon?: boolean;
      hrnfat_rescon?: boolean;
      vrfat_rescon?: boolean;
      vrnfat_rescon?: boolean;
      realizado_rescon?: boolean;
      disponivel_rescon?: boolean;
      perc1_rescon?: boolean;
      perc2_rescon?: boolean;
      perc3_rescon?: boolean;
      custo_rescon?: boolean;
      contrib_rescon?: boolean;
      perccontrib_rescon?: boolean;
      hrbase_rescon?: boolean;
      mo_rescon?: boolean;
      desp_rescon?: boolean;
    },
    ExtArgs['result']['rescon']
  >;

  export type resconSelectScalar = {
    cod_rescon?: boolean;
    cod_fatura?: boolean;
    cod_recurso?: boolean;
    hrfat_rescon?: boolean;
    hrnfat_rescon?: boolean;
    vrfat_rescon?: boolean;
    vrnfat_rescon?: boolean;
    realizado_rescon?: boolean;
    disponivel_rescon?: boolean;
    perc1_rescon?: boolean;
    perc2_rescon?: boolean;
    perc3_rescon?: boolean;
    custo_rescon?: boolean;
    contrib_rescon?: boolean;
    perccontrib_rescon?: boolean;
    hrbase_rescon?: boolean;
    mo_rescon?: boolean;
    desp_rescon?: boolean;
  };

  export type resconOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_rescon'
    | 'cod_fatura'
    | 'cod_recurso'
    | 'hrfat_rescon'
    | 'hrnfat_rescon'
    | 'vrfat_rescon'
    | 'vrnfat_rescon'
    | 'realizado_rescon'
    | 'disponivel_rescon'
    | 'perc1_rescon'
    | 'perc2_rescon'
    | 'perc3_rescon'
    | 'custo_rescon'
    | 'contrib_rescon'
    | 'perccontrib_rescon'
    | 'hrbase_rescon'
    | 'mo_rescon'
    | 'desp_rescon',
    ExtArgs['result']['rescon']
  >;

  export type $resconPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'rescon';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_rescon: number;
        cod_fatura: number;
        cod_recurso: number;
        hrfat_rescon: Prisma.Decimal | null;
        hrnfat_rescon: Prisma.Decimal | null;
        vrfat_rescon: Prisma.Decimal | null;
        vrnfat_rescon: Prisma.Decimal | null;
        realizado_rescon: Prisma.Decimal | null;
        disponivel_rescon: Prisma.Decimal | null;
        perc1_rescon: Prisma.Decimal | null;
        perc2_rescon: Prisma.Decimal | null;
        perc3_rescon: Prisma.Decimal | null;
        custo_rescon: Prisma.Decimal | null;
        contrib_rescon: Prisma.Decimal | null;
        perccontrib_rescon: Prisma.Decimal | null;
        hrbase_rescon: Prisma.Decimal | null;
        mo_rescon: Prisma.Decimal | null;
        desp_rescon: Prisma.Decimal | null;
      },
      ExtArgs['result']['rescon']
    >;
    composites: {};
  };

  type resconGetPayload<
    S extends boolean | null | undefined | resconDefaultArgs,
  > = $Result.GetResult<Prisma.$resconPayload, S>;

  type resconCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<resconFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ResconCountAggregateInputType | true;
  };

  export interface resconDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['rescon'];
      meta: { name: 'rescon' };
    };
    /**
     * Find zero or one Rescon that matches the filter.
     * @param {resconFindUniqueArgs} args - Arguments to find a Rescon
     * @example
     * // Get one Rescon
     * const rescon = await prisma.rescon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends resconFindUniqueArgs>(
      args: SelectSubset<T, resconFindUniqueArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Rescon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {resconFindUniqueOrThrowArgs} args - Arguments to find a Rescon
     * @example
     * // Get one Rescon
     * const rescon = await prisma.rescon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends resconFindUniqueOrThrowArgs>(
      args: SelectSubset<T, resconFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Rescon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resconFindFirstArgs} args - Arguments to find a Rescon
     * @example
     * // Get one Rescon
     * const rescon = await prisma.rescon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends resconFindFirstArgs>(
      args?: SelectSubset<T, resconFindFirstArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Rescon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resconFindFirstOrThrowArgs} args - Arguments to find a Rescon
     * @example
     * // Get one Rescon
     * const rescon = await prisma.rescon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends resconFindFirstOrThrowArgs>(
      args?: SelectSubset<T, resconFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Rescons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resconFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rescons
     * const rescons = await prisma.rescon.findMany()
     *
     * // Get first 10 Rescons
     * const rescons = await prisma.rescon.findMany({ take: 10 })
     *
     * // Only select the `cod_rescon`
     * const resconWithCod_resconOnly = await prisma.rescon.findMany({ select: { cod_rescon: true } })
     *
     */
    findMany<T extends resconFindManyArgs>(
      args?: SelectSubset<T, resconFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Rescon.
     * @param {resconCreateArgs} args - Arguments to create a Rescon.
     * @example
     * // Create one Rescon
     * const Rescon = await prisma.rescon.create({
     *   data: {
     *     // ... data to create a Rescon
     *   }
     * })
     *
     */
    create<T extends resconCreateArgs>(
      args: SelectSubset<T, resconCreateArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Rescons.
     * @param {resconCreateManyArgs} args - Arguments to create many Rescons.
     * @example
     * // Create many Rescons
     * const rescon = await prisma.rescon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends resconCreateManyArgs>(
      args?: SelectSubset<T, resconCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Rescons and returns the data saved in the database.
     * @param {resconCreateManyAndReturnArgs} args - Arguments to create many Rescons.
     * @example
     * // Create many Rescons
     * const rescon = await prisma.rescon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Rescons and only return the `cod_rescon`
     * const resconWithCod_resconOnly = await prisma.rescon.createManyAndReturn({
     *   select: { cod_rescon: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends resconCreateManyAndReturnArgs>(
      args?: SelectSubset<T, resconCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Rescon.
     * @param {resconDeleteArgs} args - Arguments to delete one Rescon.
     * @example
     * // Delete one Rescon
     * const Rescon = await prisma.rescon.delete({
     *   where: {
     *     // ... filter to delete one Rescon
     *   }
     * })
     *
     */
    delete<T extends resconDeleteArgs>(
      args: SelectSubset<T, resconDeleteArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Rescon.
     * @param {resconUpdateArgs} args - Arguments to update one Rescon.
     * @example
     * // Update one Rescon
     * const rescon = await prisma.rescon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends resconUpdateArgs>(
      args: SelectSubset<T, resconUpdateArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Rescons.
     * @param {resconDeleteManyArgs} args - Arguments to filter Rescons to delete.
     * @example
     * // Delete a few Rescons
     * const { count } = await prisma.rescon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends resconDeleteManyArgs>(
      args?: SelectSubset<T, resconDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Rescons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resconUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rescons
     * const rescon = await prisma.rescon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends resconUpdateManyArgs>(
      args: SelectSubset<T, resconUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Rescons and returns the data updated in the database.
     * @param {resconUpdateManyAndReturnArgs} args - Arguments to update many Rescons.
     * @example
     * // Update many Rescons
     * const rescon = await prisma.rescon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Rescons and only return the `cod_rescon`
     * const resconWithCod_resconOnly = await prisma.rescon.updateManyAndReturn({
     *   select: { cod_rescon: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends resconUpdateManyAndReturnArgs>(
      args: SelectSubset<T, resconUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Rescon.
     * @param {resconUpsertArgs} args - Arguments to update or create a Rescon.
     * @example
     * // Update or create a Rescon
     * const rescon = await prisma.rescon.upsert({
     *   create: {
     *     // ... data to create a Rescon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rescon we want to update
     *   }
     * })
     */
    upsert<T extends resconUpsertArgs>(
      args: SelectSubset<T, resconUpsertArgs<ExtArgs>>,
    ): Prisma__resconClient<
      $Result.GetResult<
        Prisma.$resconPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Rescons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resconCountArgs} args - Arguments to filter Rescons to count.
     * @example
     * // Count the number of Rescons
     * const count = await prisma.rescon.count({
     *   where: {
     *     // ... the filter for the Rescons we want to count
     *   }
     * })
     **/
    count<T extends resconCountArgs>(
      args?: Subset<T, resconCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResconCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Rescon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResconAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ResconAggregateArgs>(
      args: Subset<T, ResconAggregateArgs>,
    ): Prisma.PrismaPromise<GetResconAggregateType<T>>;

    /**
     * Group by Rescon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {resconGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends resconGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: resconGroupByArgs['orderBy'] }
        : { orderBy?: resconGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, resconGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetResconGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the rescon model
     */
    readonly fields: resconFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rescon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__resconClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the rescon model
   */
  interface resconFieldRefs {
    readonly cod_rescon: FieldRef<'rescon', 'Int'>;
    readonly cod_fatura: FieldRef<'rescon', 'Int'>;
    readonly cod_recurso: FieldRef<'rescon', 'Int'>;
    readonly hrfat_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly hrnfat_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly vrfat_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly vrnfat_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly realizado_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly disponivel_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly perc1_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly perc2_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly perc3_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly custo_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly contrib_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly perccontrib_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly hrbase_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly mo_rescon: FieldRef<'rescon', 'Decimal'>;
    readonly desp_rescon: FieldRef<'rescon', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * rescon findUnique
   */
  export type resconFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * Filter, which rescon to fetch.
     */
    where: resconWhereUniqueInput;
  };

  /**
   * rescon findUniqueOrThrow
   */
  export type resconFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * Filter, which rescon to fetch.
     */
    where: resconWhereUniqueInput;
  };

  /**
   * rescon findFirst
   */
  export type resconFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * Filter, which rescon to fetch.
     */
    where?: resconWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rescons to fetch.
     */
    orderBy?: resconOrderByWithRelationInput | resconOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for rescons.
     */
    cursor?: resconWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rescons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rescons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of rescons.
     */
    distinct?: ResconScalarFieldEnum | ResconScalarFieldEnum[];
  };

  /**
   * rescon findFirstOrThrow
   */
  export type resconFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * Filter, which rescon to fetch.
     */
    where?: resconWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rescons to fetch.
     */
    orderBy?: resconOrderByWithRelationInput | resconOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for rescons.
     */
    cursor?: resconWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rescons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rescons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of rescons.
     */
    distinct?: ResconScalarFieldEnum | ResconScalarFieldEnum[];
  };

  /**
   * rescon findMany
   */
  export type resconFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * Filter, which rescons to fetch.
     */
    where?: resconWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rescons to fetch.
     */
    orderBy?: resconOrderByWithRelationInput | resconOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing rescons.
     */
    cursor?: resconWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rescons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rescons.
     */
    skip?: number;
    distinct?: ResconScalarFieldEnum | ResconScalarFieldEnum[];
  };

  /**
   * rescon create
   */
  export type resconCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * The data needed to create a rescon.
     */
    data: XOR<resconCreateInput, resconUncheckedCreateInput>;
  };

  /**
   * rescon createMany
   */
  export type resconCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many rescons.
     */
    data: resconCreateManyInput | resconCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * rescon createManyAndReturn
   */
  export type resconCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * The data used to create many rescons.
     */
    data: resconCreateManyInput | resconCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * rescon update
   */
  export type resconUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * The data needed to update a rescon.
     */
    data: XOR<resconUpdateInput, resconUncheckedUpdateInput>;
    /**
     * Choose, which rescon to update.
     */
    where: resconWhereUniqueInput;
  };

  /**
   * rescon updateMany
   */
  export type resconUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update rescons.
     */
    data: XOR<resconUpdateManyMutationInput, resconUncheckedUpdateManyInput>;
    /**
     * Filter which rescons to update
     */
    where?: resconWhereInput;
    /**
     * Limit how many rescons to update.
     */
    limit?: number;
  };

  /**
   * rescon updateManyAndReturn
   */
  export type resconUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * The data used to update rescons.
     */
    data: XOR<resconUpdateManyMutationInput, resconUncheckedUpdateManyInput>;
    /**
     * Filter which rescons to update
     */
    where?: resconWhereInput;
    /**
     * Limit how many rescons to update.
     */
    limit?: number;
  };

  /**
   * rescon upsert
   */
  export type resconUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * The filter to search for the rescon to update in case it exists.
     */
    where: resconWhereUniqueInput;
    /**
     * In case the rescon found by the `where` argument doesn't exist, create a new rescon with this data.
     */
    create: XOR<resconCreateInput, resconUncheckedCreateInput>;
    /**
     * In case the rescon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<resconUpdateInput, resconUncheckedUpdateInput>;
  };

  /**
   * rescon delete
   */
  export type resconDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
    /**
     * Filter which rescon to delete.
     */
    where: resconWhereUniqueInput;
  };

  /**
   * rescon deleteMany
   */
  export type resconDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which rescons to delete
     */
    where?: resconWhereInput;
    /**
     * Limit how many rescons to delete.
     */
    limit?: number;
  };

  /**
   * rescon without action
   */
  export type resconDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the rescon
     */
    select?: resconSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rescon
     */
    omit?: resconOmit<ExtArgs> | null;
  };

  /**
   * Model status
   */

  export type AggregateStatus = {
    _count: StatusCountAggregateOutputType | null;
    _avg: StatusAvgAggregateOutputType | null;
    _sum: StatusSumAggregateOutputType | null;
    _min: StatusMinAggregateOutputType | null;
    _max: StatusMaxAggregateOutputType | null;
  };

  export type StatusAvgAggregateOutputType = {
    cod_status: number | null;
  };

  export type StatusSumAggregateOutputType = {
    cod_status: number | null;
  };

  export type StatusMinAggregateOutputType = {
    cod_status: number | null;
    desc_status: string | null;
  };

  export type StatusMaxAggregateOutputType = {
    cod_status: number | null;
    desc_status: string | null;
  };

  export type StatusCountAggregateOutputType = {
    cod_status: number;
    desc_status: number;
    _all: number;
  };

  export type StatusAvgAggregateInputType = {
    cod_status?: true;
  };

  export type StatusSumAggregateInputType = {
    cod_status?: true;
  };

  export type StatusMinAggregateInputType = {
    cod_status?: true;
    desc_status?: true;
  };

  export type StatusMaxAggregateInputType = {
    cod_status?: true;
    desc_status?: true;
  };

  export type StatusCountAggregateInputType = {
    cod_status?: true;
    desc_status?: true;
    _all?: true;
  };

  export type StatusAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which status to aggregate.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned statuses
     **/
    _count?: true | StatusCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: StatusAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: StatusSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StatusMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StatusMaxAggregateInputType;
  };

  export type GetStatusAggregateType<T extends StatusAggregateArgs> = {
    [P in keyof T & keyof AggregateStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus[P]>
      : GetScalarType<T[P], AggregateStatus[P]>;
  };

  export type statusGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: statusWhereInput;
    orderBy?:
      | statusOrderByWithAggregationInput
      | statusOrderByWithAggregationInput[];
    by: StatusScalarFieldEnum[] | StatusScalarFieldEnum;
    having?: statusScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StatusCountAggregateInputType | true;
    _avg?: StatusAvgAggregateInputType;
    _sum?: StatusSumAggregateInputType;
    _min?: StatusMinAggregateInputType;
    _max?: StatusMaxAggregateInputType;
  };

  export type StatusGroupByOutputType = {
    cod_status: number;
    desc_status: string;
    _count: StatusCountAggregateOutputType | null;
    _avg: StatusAvgAggregateOutputType | null;
    _sum: StatusSumAggregateOutputType | null;
    _min: StatusMinAggregateOutputType | null;
    _max: StatusMaxAggregateOutputType | null;
  };

  type GetStatusGroupByPayload<T extends statusGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StatusGroupByOutputType, T['by']> & {
          [P in keyof T & keyof StatusGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusGroupByOutputType[P]>
            : GetScalarType<T[P], StatusGroupByOutputType[P]>;
        }
      >
    >;

  export type statusSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_status?: boolean;
      desc_status?: boolean;
    },
    ExtArgs['result']['status']
  >;

  export type statusSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_status?: boolean;
      desc_status?: boolean;
    },
    ExtArgs['result']['status']
  >;

  export type statusSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_status?: boolean;
      desc_status?: boolean;
    },
    ExtArgs['result']['status']
  >;

  export type statusSelectScalar = {
    cod_status?: boolean;
    desc_status?: boolean;
  };

  export type statusOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_status' | 'desc_status',
    ExtArgs['result']['status']
  >;

  export type $statusPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'status';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_status: number;
        desc_status: string;
      },
      ExtArgs['result']['status']
    >;
    composites: {};
  };

  type statusGetPayload<
    S extends boolean | null | undefined | statusDefaultArgs,
  > = $Result.GetResult<Prisma.$statusPayload, S>;

  type statusCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: StatusCountAggregateInputType | true;
  };

  export interface statusDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['status'];
      meta: { name: 'status' };
    };
    /**
     * Find zero or one Status that matches the filter.
     * @param {statusFindUniqueArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statusFindUniqueArgs>(
      args: SelectSubset<T, statusFindUniqueArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statusFindUniqueOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statusFindUniqueOrThrowArgs>(
      args: SelectSubset<T, statusFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindFirstArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statusFindFirstArgs>(
      args?: SelectSubset<T, statusFindFirstArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindFirstOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, statusFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statuses
     * const statuses = await prisma.status.findMany()
     *
     * // Get first 10 Statuses
     * const statuses = await prisma.status.findMany({ take: 10 })
     *
     * // Only select the `cod_status`
     * const statusWithCod_statusOnly = await prisma.status.findMany({ select: { cod_status: true } })
     *
     */
    findMany<T extends statusFindManyArgs>(
      args?: SelectSubset<T, statusFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Status.
     * @param {statusCreateArgs} args - Arguments to create a Status.
     * @example
     * // Create one Status
     * const Status = await prisma.status.create({
     *   data: {
     *     // ... data to create a Status
     *   }
     * })
     *
     */
    create<T extends statusCreateArgs>(
      args: SelectSubset<T, statusCreateArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Statuses.
     * @param {statusCreateManyArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends statusCreateManyArgs>(
      args?: SelectSubset<T, statusCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Statuses and returns the data saved in the database.
     * @param {statusCreateManyAndReturnArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Statuses and only return the `cod_status`
     * const statusWithCod_statusOnly = await prisma.status.createManyAndReturn({
     *   select: { cod_status: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends statusCreateManyAndReturnArgs>(
      args?: SelectSubset<T, statusCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Status.
     * @param {statusDeleteArgs} args - Arguments to delete one Status.
     * @example
     * // Delete one Status
     * const Status = await prisma.status.delete({
     *   where: {
     *     // ... filter to delete one Status
     *   }
     * })
     *
     */
    delete<T extends statusDeleteArgs>(
      args: SelectSubset<T, statusDeleteArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Status.
     * @param {statusUpdateArgs} args - Arguments to update one Status.
     * @example
     * // Update one Status
     * const status = await prisma.status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends statusUpdateArgs>(
      args: SelectSubset<T, statusUpdateArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Statuses.
     * @param {statusDeleteManyArgs} args - Arguments to filter Statuses to delete.
     * @example
     * // Delete a few Statuses
     * const { count } = await prisma.status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends statusDeleteManyArgs>(
      args?: SelectSubset<T, statusDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends statusUpdateManyArgs>(
      args: SelectSubset<T, statusUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Statuses and returns the data updated in the database.
     * @param {statusUpdateManyAndReturnArgs} args - Arguments to update many Statuses.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Statuses and only return the `cod_status`
     * const statusWithCod_statusOnly = await prisma.status.updateManyAndReturn({
     *   select: { cod_status: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends statusUpdateManyAndReturnArgs>(
      args: SelectSubset<T, statusUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Status.
     * @param {statusUpsertArgs} args - Arguments to update or create a Status.
     * @example
     * // Update or create a Status
     * const status = await prisma.status.upsert({
     *   create: {
     *     // ... data to create a Status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status we want to update
     *   }
     * })
     */
    upsert<T extends statusUpsertArgs>(
      args: SelectSubset<T, statusUpsertArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusCountArgs} args - Arguments to filter Statuses to count.
     * @example
     * // Count the number of Statuses
     * const count = await prisma.status.count({
     *   where: {
     *     // ... the filter for the Statuses we want to count
     *   }
     * })
     **/
    count<T extends statusCountArgs>(
      args?: Subset<T, statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StatusAggregateArgs>(
      args: Subset<T, StatusAggregateArgs>,
    ): Prisma.PrismaPromise<GetStatusAggregateType<T>>;

    /**
     * Group by Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statusGroupByArgs['orderBy'] }
        : { orderBy?: statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, statusGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetStatusGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the status model
     */
    readonly fields: statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statusClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the status model
   */
  interface statusFieldRefs {
    readonly cod_status: FieldRef<'status', 'Int'>;
    readonly desc_status: FieldRef<'status', 'String'>;
  }

  // Custom InputTypes
  /**
   * status findUnique
   */
  export type statusFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status findUniqueOrThrow
   */
  export type statusFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status findFirst
   */
  export type statusFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for statuses.
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[];
  };

  /**
   * status findFirstOrThrow
   */
  export type statusFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for statuses.
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[];
  };

  /**
   * status findMany
   */
  export type statusFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Filter, which statuses to fetch.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing statuses.
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[];
  };

  /**
   * status create
   */
  export type statusCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * The data needed to create a status.
     */
    data: XOR<statusCreateInput, statusUncheckedCreateInput>;
  };

  /**
   * status createMany
   */
  export type statusCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many statuses.
     */
    data: statusCreateManyInput | statusCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * status createManyAndReturn
   */
  export type statusCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * The data used to create many statuses.
     */
    data: statusCreateManyInput | statusCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * status update
   */
  export type statusUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * The data needed to update a status.
     */
    data: XOR<statusUpdateInput, statusUncheckedUpdateInput>;
    /**
     * Choose, which status to update.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status updateMany
   */
  export type statusUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update statuses.
     */
    data: XOR<statusUpdateManyMutationInput, statusUncheckedUpdateManyInput>;
    /**
     * Filter which statuses to update
     */
    where?: statusWhereInput;
    /**
     * Limit how many statuses to update.
     */
    limit?: number;
  };

  /**
   * status updateManyAndReturn
   */
  export type statusUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * The data used to update statuses.
     */
    data: XOR<statusUpdateManyMutationInput, statusUncheckedUpdateManyInput>;
    /**
     * Filter which statuses to update
     */
    where?: statusWhereInput;
    /**
     * Limit how many statuses to update.
     */
    limit?: number;
  };

  /**
   * status upsert
   */
  export type statusUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * The filter to search for the status to update in case it exists.
     */
    where: statusWhereUniqueInput;
    /**
     * In case the status found by the `where` argument doesn't exist, create a new status with this data.
     */
    create: XOR<statusCreateInput, statusUncheckedCreateInput>;
    /**
     * In case the status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statusUpdateInput, statusUncheckedUpdateInput>;
  };

  /**
   * status delete
   */
  export type statusDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Filter which status to delete.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status deleteMany
   */
  export type statusDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which statuses to delete
     */
    where?: statusWhereInput;
    /**
     * Limit how many statuses to delete.
     */
    limit?: number;
  };

  /**
   * status without action
   */
  export type statusDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
  };

  /**
   * Model tarefa
   */

  export type AggregateTarefa = {
    _count: TarefaCountAggregateOutputType | null;
    _avg: TarefaAvgAggregateOutputType | null;
    _sum: TarefaSumAggregateOutputType | null;
    _min: TarefaMinAggregateOutputType | null;
    _max: TarefaMaxAggregateOutputType | null;
  };

  export type TarefaAvgAggregateOutputType = {
    cod_tarefa: number | null;
    codpro_tarefa: number | null;
    codrec_tarefa: number | null;
    hrest_tarefa: Decimal | null;
    hratesc_tarefa: Decimal | null;
    status_tarefa: number | null;
    ordem_tarefa: number | null;
    cod_area: number | null;
    cod_tipotrf: number | null;
    codrecresp_tarefa: number | null;
    hrreal_tarefa: Decimal | null;
    cod_fase: number | null;
    perc_tarefa: number | null;
    valida_tarefa: number | null;
    vrhr_tarefa: Decimal | null;
    limmes_tarefa: number | null;
    exibecham_tarefa: number | null;
  };

  export type TarefaSumAggregateOutputType = {
    cod_tarefa: number | null;
    codpro_tarefa: number | null;
    codrec_tarefa: number | null;
    hrest_tarefa: Decimal | null;
    hratesc_tarefa: Decimal | null;
    status_tarefa: number | null;
    ordem_tarefa: number | null;
    cod_area: number | null;
    cod_tipotrf: number | null;
    codrecresp_tarefa: number | null;
    hrreal_tarefa: Decimal | null;
    cod_fase: number | null;
    perc_tarefa: number | null;
    valida_tarefa: number | null;
    vrhr_tarefa: Decimal | null;
    limmes_tarefa: number | null;
    exibecham_tarefa: number | null;
  };

  export type TarefaMinAggregateOutputType = {
    cod_tarefa: number | null;
    nome_tarefa: string | null;
    codpro_tarefa: number | null;
    codrec_tarefa: number | null;
    dtsol_tarefa: Date | null;
    dtaprov_tarefa: Date | null;
    dtprevent_tarefa: Date | null;
    hrest_tarefa: Decimal | null;
    hratesc_tarefa: Decimal | null;
    margem_tarefa: string | null;
    status_tarefa: number | null;
    ordem_tarefa: number | null;
    cod_area: number | null;
    estimado_tarefa: string | null;
    cod_tipotrf: number | null;
    codrecresp_tarefa: number | null;
    hrreal_tarefa: Decimal | null;
    fatest_tarefa: string | null;
    cod_fase: number | null;
    valini_tarefa: Date | null;
    valfim_tarefa: Date | null;
    perimp_tarefa: string | null;
    dtinc_tarefa: Date | null;
    perc_tarefa: number | null;
    fatura_tarefa: string | null;
    valida_tarefa: number | null;
    vrhr_tarefa: Decimal | null;
    obs_tarefa: Uint8Array | null;
    limmes_tarefa: number | null;
    exibecham_tarefa: number | null;
  };

  export type TarefaMaxAggregateOutputType = {
    cod_tarefa: number | null;
    nome_tarefa: string | null;
    codpro_tarefa: number | null;
    codrec_tarefa: number | null;
    dtsol_tarefa: Date | null;
    dtaprov_tarefa: Date | null;
    dtprevent_tarefa: Date | null;
    hrest_tarefa: Decimal | null;
    hratesc_tarefa: Decimal | null;
    margem_tarefa: string | null;
    status_tarefa: number | null;
    ordem_tarefa: number | null;
    cod_area: number | null;
    estimado_tarefa: string | null;
    cod_tipotrf: number | null;
    codrecresp_tarefa: number | null;
    hrreal_tarefa: Decimal | null;
    fatest_tarefa: string | null;
    cod_fase: number | null;
    valini_tarefa: Date | null;
    valfim_tarefa: Date | null;
    perimp_tarefa: string | null;
    dtinc_tarefa: Date | null;
    perc_tarefa: number | null;
    fatura_tarefa: string | null;
    valida_tarefa: number | null;
    vrhr_tarefa: Decimal | null;
    obs_tarefa: Uint8Array | null;
    limmes_tarefa: number | null;
    exibecham_tarefa: number | null;
  };

  export type TarefaCountAggregateOutputType = {
    cod_tarefa: number;
    nome_tarefa: number;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa: number;
    dtaprov_tarefa: number;
    dtprevent_tarefa: number;
    hrest_tarefa: number;
    hratesc_tarefa: number;
    margem_tarefa: number;
    status_tarefa: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa: number;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa: number;
    fatest_tarefa: number;
    cod_fase: number;
    valini_tarefa: number;
    valfim_tarefa: number;
    perimp_tarefa: number;
    dtinc_tarefa: number;
    perc_tarefa: number;
    fatura_tarefa: number;
    valida_tarefa: number;
    vrhr_tarefa: number;
    obs_tarefa: number;
    limmes_tarefa: number;
    exibecham_tarefa: number;
    _all: number;
  };

  export type TarefaAvgAggregateInputType = {
    cod_tarefa?: true;
    codpro_tarefa?: true;
    codrec_tarefa?: true;
    hrest_tarefa?: true;
    hratesc_tarefa?: true;
    status_tarefa?: true;
    ordem_tarefa?: true;
    cod_area?: true;
    cod_tipotrf?: true;
    codrecresp_tarefa?: true;
    hrreal_tarefa?: true;
    cod_fase?: true;
    perc_tarefa?: true;
    valida_tarefa?: true;
    vrhr_tarefa?: true;
    limmes_tarefa?: true;
    exibecham_tarefa?: true;
  };

  export type TarefaSumAggregateInputType = {
    cod_tarefa?: true;
    codpro_tarefa?: true;
    codrec_tarefa?: true;
    hrest_tarefa?: true;
    hratesc_tarefa?: true;
    status_tarefa?: true;
    ordem_tarefa?: true;
    cod_area?: true;
    cod_tipotrf?: true;
    codrecresp_tarefa?: true;
    hrreal_tarefa?: true;
    cod_fase?: true;
    perc_tarefa?: true;
    valida_tarefa?: true;
    vrhr_tarefa?: true;
    limmes_tarefa?: true;
    exibecham_tarefa?: true;
  };

  export type TarefaMinAggregateInputType = {
    cod_tarefa?: true;
    nome_tarefa?: true;
    codpro_tarefa?: true;
    codrec_tarefa?: true;
    dtsol_tarefa?: true;
    dtaprov_tarefa?: true;
    dtprevent_tarefa?: true;
    hrest_tarefa?: true;
    hratesc_tarefa?: true;
    margem_tarefa?: true;
    status_tarefa?: true;
    ordem_tarefa?: true;
    cod_area?: true;
    estimado_tarefa?: true;
    cod_tipotrf?: true;
    codrecresp_tarefa?: true;
    hrreal_tarefa?: true;
    fatest_tarefa?: true;
    cod_fase?: true;
    valini_tarefa?: true;
    valfim_tarefa?: true;
    perimp_tarefa?: true;
    dtinc_tarefa?: true;
    perc_tarefa?: true;
    fatura_tarefa?: true;
    valida_tarefa?: true;
    vrhr_tarefa?: true;
    obs_tarefa?: true;
    limmes_tarefa?: true;
    exibecham_tarefa?: true;
  };

  export type TarefaMaxAggregateInputType = {
    cod_tarefa?: true;
    nome_tarefa?: true;
    codpro_tarefa?: true;
    codrec_tarefa?: true;
    dtsol_tarefa?: true;
    dtaprov_tarefa?: true;
    dtprevent_tarefa?: true;
    hrest_tarefa?: true;
    hratesc_tarefa?: true;
    margem_tarefa?: true;
    status_tarefa?: true;
    ordem_tarefa?: true;
    cod_area?: true;
    estimado_tarefa?: true;
    cod_tipotrf?: true;
    codrecresp_tarefa?: true;
    hrreal_tarefa?: true;
    fatest_tarefa?: true;
    cod_fase?: true;
    valini_tarefa?: true;
    valfim_tarefa?: true;
    perimp_tarefa?: true;
    dtinc_tarefa?: true;
    perc_tarefa?: true;
    fatura_tarefa?: true;
    valida_tarefa?: true;
    vrhr_tarefa?: true;
    obs_tarefa?: true;
    limmes_tarefa?: true;
    exibecham_tarefa?: true;
  };

  export type TarefaCountAggregateInputType = {
    cod_tarefa?: true;
    nome_tarefa?: true;
    codpro_tarefa?: true;
    codrec_tarefa?: true;
    dtsol_tarefa?: true;
    dtaprov_tarefa?: true;
    dtprevent_tarefa?: true;
    hrest_tarefa?: true;
    hratesc_tarefa?: true;
    margem_tarefa?: true;
    status_tarefa?: true;
    ordem_tarefa?: true;
    cod_area?: true;
    estimado_tarefa?: true;
    cod_tipotrf?: true;
    codrecresp_tarefa?: true;
    hrreal_tarefa?: true;
    fatest_tarefa?: true;
    cod_fase?: true;
    valini_tarefa?: true;
    valfim_tarefa?: true;
    perimp_tarefa?: true;
    dtinc_tarefa?: true;
    perc_tarefa?: true;
    fatura_tarefa?: true;
    valida_tarefa?: true;
    vrhr_tarefa?: true;
    obs_tarefa?: true;
    limmes_tarefa?: true;
    exibecham_tarefa?: true;
    _all?: true;
  };

  export type TarefaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tarefa to aggregate.
     */
    where?: tarefaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: tarefaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tarefas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned tarefas
     **/
    _count?: true | TarefaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TarefaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TarefaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TarefaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TarefaMaxAggregateInputType;
  };

  export type GetTarefaAggregateType<T extends TarefaAggregateArgs> = {
    [P in keyof T & keyof AggregateTarefa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarefa[P]>
      : GetScalarType<T[P], AggregateTarefa[P]>;
  };

  export type tarefaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tarefaWhereInput;
    orderBy?:
      | tarefaOrderByWithAggregationInput
      | tarefaOrderByWithAggregationInput[];
    by: TarefaScalarFieldEnum[] | TarefaScalarFieldEnum;
    having?: tarefaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TarefaCountAggregateInputType | true;
    _avg?: TarefaAvgAggregateInputType;
    _sum?: TarefaSumAggregateInputType;
    _min?: TarefaMinAggregateInputType;
    _max?: TarefaMaxAggregateInputType;
  };

  export type TarefaGroupByOutputType = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa: Date | null;
    dtaprov_tarefa: Date | null;
    dtprevent_tarefa: Date | null;
    hrest_tarefa: Decimal | null;
    hratesc_tarefa: Decimal | null;
    margem_tarefa: string;
    status_tarefa: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa: Decimal | null;
    fatest_tarefa: string;
    cod_fase: number;
    valini_tarefa: Date;
    valfim_tarefa: Date;
    perimp_tarefa: string;
    dtinc_tarefa: Date;
    perc_tarefa: number;
    fatura_tarefa: string;
    valida_tarefa: number;
    vrhr_tarefa: Decimal;
    obs_tarefa: Uint8Array | null;
    limmes_tarefa: number | null;
    exibecham_tarefa: number | null;
    _count: TarefaCountAggregateOutputType | null;
    _avg: TarefaAvgAggregateOutputType | null;
    _sum: TarefaSumAggregateOutputType | null;
    _min: TarefaMinAggregateOutputType | null;
    _max: TarefaMaxAggregateOutputType | null;
  };

  type GetTarefaGroupByPayload<T extends tarefaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TarefaGroupByOutputType, T['by']> & {
          [P in keyof T & keyof TarefaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TarefaGroupByOutputType[P]>
            : GetScalarType<T[P], TarefaGroupByOutputType[P]>;
        }
      >
    >;

  export type tarefaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tarefa?: boolean;
      nome_tarefa?: boolean;
      codpro_tarefa?: boolean;
      codrec_tarefa?: boolean;
      dtsol_tarefa?: boolean;
      dtaprov_tarefa?: boolean;
      dtprevent_tarefa?: boolean;
      hrest_tarefa?: boolean;
      hratesc_tarefa?: boolean;
      margem_tarefa?: boolean;
      status_tarefa?: boolean;
      ordem_tarefa?: boolean;
      cod_area?: boolean;
      estimado_tarefa?: boolean;
      cod_tipotrf?: boolean;
      codrecresp_tarefa?: boolean;
      hrreal_tarefa?: boolean;
      fatest_tarefa?: boolean;
      cod_fase?: boolean;
      valini_tarefa?: boolean;
      valfim_tarefa?: boolean;
      perimp_tarefa?: boolean;
      dtinc_tarefa?: boolean;
      perc_tarefa?: boolean;
      fatura_tarefa?: boolean;
      valida_tarefa?: boolean;
      vrhr_tarefa?: boolean;
      obs_tarefa?: boolean;
      limmes_tarefa?: boolean;
      exibecham_tarefa?: boolean;
      os?: boolean | tarefa$osArgs<ExtArgs>;
      area?: boolean | areaDefaultArgs<ExtArgs>;
      fase?: boolean | faseDefaultArgs<ExtArgs>;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
      recurso_tarefa_codrecresp_tarefaTorecurso?:
        | boolean
        | recursoDefaultArgs<ExtArgs>;
      recurso_tarefa_codrec_tarefaTorecurso?:
        | boolean
        | recursoDefaultArgs<ExtArgs>;
      _count?: boolean | TarefaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tarefa']
  >;

  export type tarefaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tarefa?: boolean;
      nome_tarefa?: boolean;
      codpro_tarefa?: boolean;
      codrec_tarefa?: boolean;
      dtsol_tarefa?: boolean;
      dtaprov_tarefa?: boolean;
      dtprevent_tarefa?: boolean;
      hrest_tarefa?: boolean;
      hratesc_tarefa?: boolean;
      margem_tarefa?: boolean;
      status_tarefa?: boolean;
      ordem_tarefa?: boolean;
      cod_area?: boolean;
      estimado_tarefa?: boolean;
      cod_tipotrf?: boolean;
      codrecresp_tarefa?: boolean;
      hrreal_tarefa?: boolean;
      fatest_tarefa?: boolean;
      cod_fase?: boolean;
      valini_tarefa?: boolean;
      valfim_tarefa?: boolean;
      perimp_tarefa?: boolean;
      dtinc_tarefa?: boolean;
      perc_tarefa?: boolean;
      fatura_tarefa?: boolean;
      valida_tarefa?: boolean;
      vrhr_tarefa?: boolean;
      obs_tarefa?: boolean;
      limmes_tarefa?: boolean;
      exibecham_tarefa?: boolean;
      area?: boolean | areaDefaultArgs<ExtArgs>;
      fase?: boolean | faseDefaultArgs<ExtArgs>;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
      recurso_tarefa_codrecresp_tarefaTorecurso?:
        | boolean
        | recursoDefaultArgs<ExtArgs>;
      recurso_tarefa_codrec_tarefaTorecurso?:
        | boolean
        | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tarefa']
  >;

  export type tarefaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tarefa?: boolean;
      nome_tarefa?: boolean;
      codpro_tarefa?: boolean;
      codrec_tarefa?: boolean;
      dtsol_tarefa?: boolean;
      dtaprov_tarefa?: boolean;
      dtprevent_tarefa?: boolean;
      hrest_tarefa?: boolean;
      hratesc_tarefa?: boolean;
      margem_tarefa?: boolean;
      status_tarefa?: boolean;
      ordem_tarefa?: boolean;
      cod_area?: boolean;
      estimado_tarefa?: boolean;
      cod_tipotrf?: boolean;
      codrecresp_tarefa?: boolean;
      hrreal_tarefa?: boolean;
      fatest_tarefa?: boolean;
      cod_fase?: boolean;
      valini_tarefa?: boolean;
      valfim_tarefa?: boolean;
      perimp_tarefa?: boolean;
      dtinc_tarefa?: boolean;
      perc_tarefa?: boolean;
      fatura_tarefa?: boolean;
      valida_tarefa?: boolean;
      vrhr_tarefa?: boolean;
      obs_tarefa?: boolean;
      limmes_tarefa?: boolean;
      exibecham_tarefa?: boolean;
      area?: boolean | areaDefaultArgs<ExtArgs>;
      fase?: boolean | faseDefaultArgs<ExtArgs>;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
      recurso_tarefa_codrecresp_tarefaTorecurso?:
        | boolean
        | recursoDefaultArgs<ExtArgs>;
      recurso_tarefa_codrec_tarefaTorecurso?:
        | boolean
        | recursoDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tarefa']
  >;

  export type tarefaSelectScalar = {
    cod_tarefa?: boolean;
    nome_tarefa?: boolean;
    codpro_tarefa?: boolean;
    codrec_tarefa?: boolean;
    dtsol_tarefa?: boolean;
    dtaprov_tarefa?: boolean;
    dtprevent_tarefa?: boolean;
    hrest_tarefa?: boolean;
    hratesc_tarefa?: boolean;
    margem_tarefa?: boolean;
    status_tarefa?: boolean;
    ordem_tarefa?: boolean;
    cod_area?: boolean;
    estimado_tarefa?: boolean;
    cod_tipotrf?: boolean;
    codrecresp_tarefa?: boolean;
    hrreal_tarefa?: boolean;
    fatest_tarefa?: boolean;
    cod_fase?: boolean;
    valini_tarefa?: boolean;
    valfim_tarefa?: boolean;
    perimp_tarefa?: boolean;
    dtinc_tarefa?: boolean;
    perc_tarefa?: boolean;
    fatura_tarefa?: boolean;
    valida_tarefa?: boolean;
    vrhr_tarefa?: boolean;
    obs_tarefa?: boolean;
    limmes_tarefa?: boolean;
    exibecham_tarefa?: boolean;
  };

  export type tarefaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_tarefa'
    | 'nome_tarefa'
    | 'codpro_tarefa'
    | 'codrec_tarefa'
    | 'dtsol_tarefa'
    | 'dtaprov_tarefa'
    | 'dtprevent_tarefa'
    | 'hrest_tarefa'
    | 'hratesc_tarefa'
    | 'margem_tarefa'
    | 'status_tarefa'
    | 'ordem_tarefa'
    | 'cod_area'
    | 'estimado_tarefa'
    | 'cod_tipotrf'
    | 'codrecresp_tarefa'
    | 'hrreal_tarefa'
    | 'fatest_tarefa'
    | 'cod_fase'
    | 'valini_tarefa'
    | 'valfim_tarefa'
    | 'perimp_tarefa'
    | 'dtinc_tarefa'
    | 'perc_tarefa'
    | 'fatura_tarefa'
    | 'valida_tarefa'
    | 'vrhr_tarefa'
    | 'obs_tarefa'
    | 'limmes_tarefa'
    | 'exibecham_tarefa',
    ExtArgs['result']['tarefa']
  >;
  export type tarefaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    os?: boolean | tarefa$osArgs<ExtArgs>;
    area?: boolean | areaDefaultArgs<ExtArgs>;
    fase?: boolean | faseDefaultArgs<ExtArgs>;
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    recurso_tarefa_codrecresp_tarefaTorecurso?:
      | boolean
      | recursoDefaultArgs<ExtArgs>;
    recurso_tarefa_codrec_tarefaTorecurso?:
      | boolean
      | recursoDefaultArgs<ExtArgs>;
    _count?: boolean | TarefaCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type tarefaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    area?: boolean | areaDefaultArgs<ExtArgs>;
    fase?: boolean | faseDefaultArgs<ExtArgs>;
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    recurso_tarefa_codrecresp_tarefaTorecurso?:
      | boolean
      | recursoDefaultArgs<ExtArgs>;
    recurso_tarefa_codrec_tarefaTorecurso?:
      | boolean
      | recursoDefaultArgs<ExtArgs>;
  };
  export type tarefaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    area?: boolean | areaDefaultArgs<ExtArgs>;
    fase?: boolean | faseDefaultArgs<ExtArgs>;
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    recurso_tarefa_codrecresp_tarefaTorecurso?:
      | boolean
      | recursoDefaultArgs<ExtArgs>;
    recurso_tarefa_codrec_tarefaTorecurso?:
      | boolean
      | recursoDefaultArgs<ExtArgs>;
  };

  export type $tarefaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'tarefa';
    objects: {
      os: Prisma.$osPayload<ExtArgs>[];
      area: Prisma.$areaPayload<ExtArgs>;
      fase: Prisma.$fasePayload<ExtArgs>;
      projeto: Prisma.$projetoPayload<ExtArgs>;
      recurso_tarefa_codrecresp_tarefaTorecurso: Prisma.$recursoPayload<ExtArgs>;
      recurso_tarefa_codrec_tarefaTorecurso: Prisma.$recursoPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_tarefa: number;
        nome_tarefa: string;
        codpro_tarefa: number;
        codrec_tarefa: number;
        dtsol_tarefa: Date | null;
        dtaprov_tarefa: Date | null;
        dtprevent_tarefa: Date | null;
        hrest_tarefa: Prisma.Decimal | null;
        hratesc_tarefa: Prisma.Decimal | null;
        margem_tarefa: string;
        status_tarefa: number;
        ordem_tarefa: number;
        cod_area: number;
        estimado_tarefa: string;
        cod_tipotrf: number;
        codrecresp_tarefa: number;
        hrreal_tarefa: Prisma.Decimal | null;
        fatest_tarefa: string;
        cod_fase: number;
        valini_tarefa: Date;
        valfim_tarefa: Date;
        perimp_tarefa: string;
        dtinc_tarefa: Date;
        perc_tarefa: number;
        fatura_tarefa: string;
        valida_tarefa: number;
        vrhr_tarefa: Prisma.Decimal;
        obs_tarefa: Uint8Array | null;
        limmes_tarefa: number | null;
        exibecham_tarefa: number | null;
      },
      ExtArgs['result']['tarefa']
    >;
    composites: {};
  };

  type tarefaGetPayload<
    S extends boolean | null | undefined | tarefaDefaultArgs,
  > = $Result.GetResult<Prisma.$tarefaPayload, S>;

  type tarefaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<tarefaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TarefaCountAggregateInputType | true;
  };

  export interface tarefaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['tarefa'];
      meta: { name: 'tarefa' };
    };
    /**
     * Find zero or one Tarefa that matches the filter.
     * @param {tarefaFindUniqueArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tarefaFindUniqueArgs>(
      args: SelectSubset<T, tarefaFindUniqueArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Tarefa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tarefaFindUniqueOrThrowArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tarefaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, tarefaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tarefa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindFirstArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tarefaFindFirstArgs>(
      args?: SelectSubset<T, tarefaFindFirstArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tarefa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindFirstOrThrowArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tarefaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tarefaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tarefas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tarefas
     * const tarefas = await prisma.tarefa.findMany()
     *
     * // Get first 10 Tarefas
     * const tarefas = await prisma.tarefa.findMany({ take: 10 })
     *
     * // Only select the `cod_tarefa`
     * const tarefaWithCod_tarefaOnly = await prisma.tarefa.findMany({ select: { cod_tarefa: true } })
     *
     */
    findMany<T extends tarefaFindManyArgs>(
      args?: SelectSubset<T, tarefaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Tarefa.
     * @param {tarefaCreateArgs} args - Arguments to create a Tarefa.
     * @example
     * // Create one Tarefa
     * const Tarefa = await prisma.tarefa.create({
     *   data: {
     *     // ... data to create a Tarefa
     *   }
     * })
     *
     */
    create<T extends tarefaCreateArgs>(
      args: SelectSubset<T, tarefaCreateArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tarefas.
     * @param {tarefaCreateManyArgs} args - Arguments to create many Tarefas.
     * @example
     * // Create many Tarefas
     * const tarefa = await prisma.tarefa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends tarefaCreateManyArgs>(
      args?: SelectSubset<T, tarefaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Tarefas and returns the data saved in the database.
     * @param {tarefaCreateManyAndReturnArgs} args - Arguments to create many Tarefas.
     * @example
     * // Create many Tarefas
     * const tarefa = await prisma.tarefa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Tarefas and only return the `cod_tarefa`
     * const tarefaWithCod_tarefaOnly = await prisma.tarefa.createManyAndReturn({
     *   select: { cod_tarefa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends tarefaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, tarefaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Tarefa.
     * @param {tarefaDeleteArgs} args - Arguments to delete one Tarefa.
     * @example
     * // Delete one Tarefa
     * const Tarefa = await prisma.tarefa.delete({
     *   where: {
     *     // ... filter to delete one Tarefa
     *   }
     * })
     *
     */
    delete<T extends tarefaDeleteArgs>(
      args: SelectSubset<T, tarefaDeleteArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Tarefa.
     * @param {tarefaUpdateArgs} args - Arguments to update one Tarefa.
     * @example
     * // Update one Tarefa
     * const tarefa = await prisma.tarefa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends tarefaUpdateArgs>(
      args: SelectSubset<T, tarefaUpdateArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tarefas.
     * @param {tarefaDeleteManyArgs} args - Arguments to filter Tarefas to delete.
     * @example
     * // Delete a few Tarefas
     * const { count } = await prisma.tarefa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends tarefaDeleteManyArgs>(
      args?: SelectSubset<T, tarefaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tarefas
     * const tarefa = await prisma.tarefa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends tarefaUpdateManyArgs>(
      args: SelectSubset<T, tarefaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tarefas and returns the data updated in the database.
     * @param {tarefaUpdateManyAndReturnArgs} args - Arguments to update many Tarefas.
     * @example
     * // Update many Tarefas
     * const tarefa = await prisma.tarefa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Tarefas and only return the `cod_tarefa`
     * const tarefaWithCod_tarefaOnly = await prisma.tarefa.updateManyAndReturn({
     *   select: { cod_tarefa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends tarefaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, tarefaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Tarefa.
     * @param {tarefaUpsertArgs} args - Arguments to update or create a Tarefa.
     * @example
     * // Update or create a Tarefa
     * const tarefa = await prisma.tarefa.upsert({
     *   create: {
     *     // ... data to create a Tarefa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tarefa we want to update
     *   }
     * })
     */
    upsert<T extends tarefaUpsertArgs>(
      args: SelectSubset<T, tarefaUpsertArgs<ExtArgs>>,
    ): Prisma__tarefaClient<
      $Result.GetResult<
        Prisma.$tarefaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaCountArgs} args - Arguments to filter Tarefas to count.
     * @example
     * // Count the number of Tarefas
     * const count = await prisma.tarefa.count({
     *   where: {
     *     // ... the filter for the Tarefas we want to count
     *   }
     * })
     **/
    count<T extends tarefaCountArgs>(
      args?: Subset<T, tarefaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TarefaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarefaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TarefaAggregateArgs>(
      args: Subset<T, TarefaAggregateArgs>,
    ): Prisma.PrismaPromise<GetTarefaAggregateType<T>>;

    /**
     * Group by Tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends tarefaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tarefaGroupByArgs['orderBy'] }
        : { orderBy?: tarefaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, tarefaGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTarefaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the tarefa model
     */
    readonly fields: tarefaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tarefa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tarefaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    os<T extends tarefa$osArgs<ExtArgs> = {}>(
      args?: Subset<T, tarefa$osArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$osPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    area<T extends areaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, areaDefaultArgs<ExtArgs>>,
    ): Prisma__areaClient<
      | $Result.GetResult<
          Prisma.$areaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    fase<T extends faseDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, faseDefaultArgs<ExtArgs>>,
    ): Prisma__faseClient<
      | $Result.GetResult<
          Prisma.$fasePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, projetoDefaultArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      | $Result.GetResult<
          Prisma.$projetoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    recurso_tarefa_codrecresp_tarefaTorecurso<
      T extends recursoDefaultArgs<ExtArgs> = {},
    >(
      args?: Subset<T, recursoDefaultArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      | $Result.GetResult<
          Prisma.$recursoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    recurso_tarefa_codrec_tarefaTorecurso<
      T extends recursoDefaultArgs<ExtArgs> = {},
    >(
      args?: Subset<T, recursoDefaultArgs<ExtArgs>>,
    ): Prisma__recursoClient<
      | $Result.GetResult<
          Prisma.$recursoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the tarefa model
   */
  interface tarefaFieldRefs {
    readonly cod_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly nome_tarefa: FieldRef<'tarefa', 'String'>;
    readonly codpro_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly codrec_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly dtsol_tarefa: FieldRef<'tarefa', 'DateTime'>;
    readonly dtaprov_tarefa: FieldRef<'tarefa', 'DateTime'>;
    readonly dtprevent_tarefa: FieldRef<'tarefa', 'DateTime'>;
    readonly hrest_tarefa: FieldRef<'tarefa', 'Decimal'>;
    readonly hratesc_tarefa: FieldRef<'tarefa', 'Decimal'>;
    readonly margem_tarefa: FieldRef<'tarefa', 'String'>;
    readonly status_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly ordem_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly cod_area: FieldRef<'tarefa', 'Int'>;
    readonly estimado_tarefa: FieldRef<'tarefa', 'String'>;
    readonly cod_tipotrf: FieldRef<'tarefa', 'Int'>;
    readonly codrecresp_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly hrreal_tarefa: FieldRef<'tarefa', 'Decimal'>;
    readonly fatest_tarefa: FieldRef<'tarefa', 'String'>;
    readonly cod_fase: FieldRef<'tarefa', 'Int'>;
    readonly valini_tarefa: FieldRef<'tarefa', 'DateTime'>;
    readonly valfim_tarefa: FieldRef<'tarefa', 'DateTime'>;
    readonly perimp_tarefa: FieldRef<'tarefa', 'String'>;
    readonly dtinc_tarefa: FieldRef<'tarefa', 'DateTime'>;
    readonly perc_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly fatura_tarefa: FieldRef<'tarefa', 'String'>;
    readonly valida_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly vrhr_tarefa: FieldRef<'tarefa', 'Decimal'>;
    readonly obs_tarefa: FieldRef<'tarefa', 'Bytes'>;
    readonly limmes_tarefa: FieldRef<'tarefa', 'Int'>;
    readonly exibecham_tarefa: FieldRef<'tarefa', 'Int'>;
  }

  // Custom InputTypes
  /**
   * tarefa findUnique
   */
  export type tarefaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * Filter, which tarefa to fetch.
     */
    where: tarefaWhereUniqueInput;
  };

  /**
   * tarefa findUniqueOrThrow
   */
  export type tarefaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * Filter, which tarefa to fetch.
     */
    where: tarefaWhereUniqueInput;
  };

  /**
   * tarefa findFirst
   */
  export type tarefaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * Filter, which tarefa to fetch.
     */
    where?: tarefaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tarefas.
     */
    cursor?: tarefaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tarefas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tarefas.
     */
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * tarefa findFirstOrThrow
   */
  export type tarefaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * Filter, which tarefa to fetch.
     */
    where?: tarefaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tarefas.
     */
    cursor?: tarefaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tarefas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tarefas.
     */
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * tarefa findMany
   */
  export type tarefaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * Filter, which tarefas to fetch.
     */
    where?: tarefaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing tarefas.
     */
    cursor?: tarefaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tarefas.
     */
    skip?: number;
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[];
  };

  /**
   * tarefa create
   */
  export type tarefaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * The data needed to create a tarefa.
     */
    data: XOR<tarefaCreateInput, tarefaUncheckedCreateInput>;
  };

  /**
   * tarefa createMany
   */
  export type tarefaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many tarefas.
     */
    data: tarefaCreateManyInput | tarefaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * tarefa createManyAndReturn
   */
  export type tarefaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * The data used to create many tarefas.
     */
    data: tarefaCreateManyInput | tarefaCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * tarefa update
   */
  export type tarefaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * The data needed to update a tarefa.
     */
    data: XOR<tarefaUpdateInput, tarefaUncheckedUpdateInput>;
    /**
     * Choose, which tarefa to update.
     */
    where: tarefaWhereUniqueInput;
  };

  /**
   * tarefa updateMany
   */
  export type tarefaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update tarefas.
     */
    data: XOR<tarefaUpdateManyMutationInput, tarefaUncheckedUpdateManyInput>;
    /**
     * Filter which tarefas to update
     */
    where?: tarefaWhereInput;
    /**
     * Limit how many tarefas to update.
     */
    limit?: number;
  };

  /**
   * tarefa updateManyAndReturn
   */
  export type tarefaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * The data used to update tarefas.
     */
    data: XOR<tarefaUpdateManyMutationInput, tarefaUncheckedUpdateManyInput>;
    /**
     * Filter which tarefas to update
     */
    where?: tarefaWhereInput;
    /**
     * Limit how many tarefas to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * tarefa upsert
   */
  export type tarefaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * The filter to search for the tarefa to update in case it exists.
     */
    where: tarefaWhereUniqueInput;
    /**
     * In case the tarefa found by the `where` argument doesn't exist, create a new tarefa with this data.
     */
    create: XOR<tarefaCreateInput, tarefaUncheckedCreateInput>;
    /**
     * In case the tarefa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tarefaUpdateInput, tarefaUncheckedUpdateInput>;
  };

  /**
   * tarefa delete
   */
  export type tarefaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
    /**
     * Filter which tarefa to delete.
     */
    where: tarefaWhereUniqueInput;
  };

  /**
   * tarefa deleteMany
   */
  export type tarefaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tarefas to delete
     */
    where?: tarefaWhereInput;
    /**
     * Limit how many tarefas to delete.
     */
    limit?: number;
  };

  /**
   * tarefa.os
   */
  export type tarefa$osArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the os
     */
    select?: osSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the os
     */
    omit?: osOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: osInclude<ExtArgs> | null;
    where?: osWhereInput;
    orderBy?: osOrderByWithRelationInput | osOrderByWithRelationInput[];
    cursor?: osWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OsScalarFieldEnum | OsScalarFieldEnum[];
  };

  /**
   * tarefa without action
   */
  export type tarefaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tarefa
     */
    omit?: tarefaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null;
  };

  /**
   * Model tela_sistema
   */

  export type AggregateTela_sistema = {
    _count: Tela_sistemaCountAggregateOutputType | null;
    _avg: Tela_sistemaAvgAggregateOutputType | null;
    _sum: Tela_sistemaSumAggregateOutputType | null;
    _min: Tela_sistemaMinAggregateOutputType | null;
    _max: Tela_sistemaMaxAggregateOutputType | null;
  };

  export type Tela_sistemaAvgAggregateOutputType = {
    cod_tela: number | null;
    cod_modulo: number | null;
  };

  export type Tela_sistemaSumAggregateOutputType = {
    cod_tela: number | null;
    cod_modulo: number | null;
  };

  export type Tela_sistemaMinAggregateOutputType = {
    cod_tela: number | null;
    cod_modulo: number | null;
    desc_tela: string | null;
  };

  export type Tela_sistemaMaxAggregateOutputType = {
    cod_tela: number | null;
    cod_modulo: number | null;
    desc_tela: string | null;
  };

  export type Tela_sistemaCountAggregateOutputType = {
    cod_tela: number;
    cod_modulo: number;
    desc_tela: number;
    _all: number;
  };

  export type Tela_sistemaAvgAggregateInputType = {
    cod_tela?: true;
    cod_modulo?: true;
  };

  export type Tela_sistemaSumAggregateInputType = {
    cod_tela?: true;
    cod_modulo?: true;
  };

  export type Tela_sistemaMinAggregateInputType = {
    cod_tela?: true;
    cod_modulo?: true;
    desc_tela?: true;
  };

  export type Tela_sistemaMaxAggregateInputType = {
    cod_tela?: true;
    cod_modulo?: true;
    desc_tela?: true;
  };

  export type Tela_sistemaCountAggregateInputType = {
    cod_tela?: true;
    cod_modulo?: true;
    desc_tela?: true;
    _all?: true;
  };

  export type Tela_sistemaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tela_sistema to aggregate.
     */
    where?: tela_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tela_sistemas to fetch.
     */
    orderBy?:
      | tela_sistemaOrderByWithRelationInput
      | tela_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: tela_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tela_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tela_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned tela_sistemas
     **/
    _count?: true | Tela_sistemaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Tela_sistemaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Tela_sistemaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Tela_sistemaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Tela_sistemaMaxAggregateInputType;
  };

  export type GetTela_sistemaAggregateType<
    T extends Tela_sistemaAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateTela_sistema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTela_sistema[P]>
      : GetScalarType<T[P], AggregateTela_sistema[P]>;
  };

  export type tela_sistemaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tela_sistemaWhereInput;
    orderBy?:
      | tela_sistemaOrderByWithAggregationInput
      | tela_sistemaOrderByWithAggregationInput[];
    by: Tela_sistemaScalarFieldEnum[] | Tela_sistemaScalarFieldEnum;
    having?: tela_sistemaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Tela_sistemaCountAggregateInputType | true;
    _avg?: Tela_sistemaAvgAggregateInputType;
    _sum?: Tela_sistemaSumAggregateInputType;
    _min?: Tela_sistemaMinAggregateInputType;
    _max?: Tela_sistemaMaxAggregateInputType;
  };

  export type Tela_sistemaGroupByOutputType = {
    cod_tela: number;
    cod_modulo: number;
    desc_tela: string;
    _count: Tela_sistemaCountAggregateOutputType | null;
    _avg: Tela_sistemaAvgAggregateOutputType | null;
    _sum: Tela_sistemaSumAggregateOutputType | null;
    _min: Tela_sistemaMinAggregateOutputType | null;
    _max: Tela_sistemaMaxAggregateOutputType | null;
  };

  type GetTela_sistemaGroupByPayload<T extends tela_sistemaGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<Tela_sistemaGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof Tela_sistemaGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tela_sistemaGroupByOutputType[P]>
            : GetScalarType<T[P], Tela_sistemaGroupByOutputType[P]>;
        }
      >
    >;

  export type tela_sistemaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tela?: boolean;
      cod_modulo?: boolean;
      desc_tela?: boolean;
      acesso_sistema?: boolean | tela_sistema$acesso_sistemaArgs<ExtArgs>;
      modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
      _count?: boolean | Tela_sistemaCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tela_sistema']
  >;

  export type tela_sistemaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tela?: boolean;
      cod_modulo?: boolean;
      desc_tela?: boolean;
      modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tela_sistema']
  >;

  export type tela_sistemaSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tela?: boolean;
      cod_modulo?: boolean;
      desc_tela?: boolean;
      modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tela_sistema']
  >;

  export type tela_sistemaSelectScalar = {
    cod_tela?: boolean;
    cod_modulo?: boolean;
    desc_tela?: boolean;
  };

  export type tela_sistemaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_tela' | 'cod_modulo' | 'desc_tela',
    ExtArgs['result']['tela_sistema']
  >;
  export type tela_sistemaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acesso_sistema?: boolean | tela_sistema$acesso_sistemaArgs<ExtArgs>;
    modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
    _count?: boolean | Tela_sistemaCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type tela_sistemaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
  };
  export type tela_sistemaIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    modulo_sistema?: boolean | modulo_sistemaDefaultArgs<ExtArgs>;
  };

  export type $tela_sistemaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'tela_sistema';
    objects: {
      acesso_sistema: Prisma.$acesso_sistemaPayload<ExtArgs>[];
      modulo_sistema: Prisma.$modulo_sistemaPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_tela: number;
        cod_modulo: number;
        desc_tela: string;
      },
      ExtArgs['result']['tela_sistema']
    >;
    composites: {};
  };

  type tela_sistemaGetPayload<
    S extends boolean | null | undefined | tela_sistemaDefaultArgs,
  > = $Result.GetResult<Prisma.$tela_sistemaPayload, S>;

  type tela_sistemaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    tela_sistemaFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: Tela_sistemaCountAggregateInputType | true;
  };

  export interface tela_sistemaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['tela_sistema'];
      meta: { name: 'tela_sistema' };
    };
    /**
     * Find zero or one Tela_sistema that matches the filter.
     * @param {tela_sistemaFindUniqueArgs} args - Arguments to find a Tela_sistema
     * @example
     * // Get one Tela_sistema
     * const tela_sistema = await prisma.tela_sistema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tela_sistemaFindUniqueArgs>(
      args: SelectSubset<T, tela_sistemaFindUniqueArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Tela_sistema that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tela_sistemaFindUniqueOrThrowArgs} args - Arguments to find a Tela_sistema
     * @example
     * // Get one Tela_sistema
     * const tela_sistema = await prisma.tela_sistema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tela_sistemaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, tela_sistemaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tela_sistema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tela_sistemaFindFirstArgs} args - Arguments to find a Tela_sistema
     * @example
     * // Get one Tela_sistema
     * const tela_sistema = await prisma.tela_sistema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tela_sistemaFindFirstArgs>(
      args?: SelectSubset<T, tela_sistemaFindFirstArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tela_sistema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tela_sistemaFindFirstOrThrowArgs} args - Arguments to find a Tela_sistema
     * @example
     * // Get one Tela_sistema
     * const tela_sistema = await prisma.tela_sistema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tela_sistemaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tela_sistemaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tela_sistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tela_sistemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tela_sistemas
     * const tela_sistemas = await prisma.tela_sistema.findMany()
     *
     * // Get first 10 Tela_sistemas
     * const tela_sistemas = await prisma.tela_sistema.findMany({ take: 10 })
     *
     * // Only select the `cod_tela`
     * const tela_sistemaWithCod_telaOnly = await prisma.tela_sistema.findMany({ select: { cod_tela: true } })
     *
     */
    findMany<T extends tela_sistemaFindManyArgs>(
      args?: SelectSubset<T, tela_sistemaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Tela_sistema.
     * @param {tela_sistemaCreateArgs} args - Arguments to create a Tela_sistema.
     * @example
     * // Create one Tela_sistema
     * const Tela_sistema = await prisma.tela_sistema.create({
     *   data: {
     *     // ... data to create a Tela_sistema
     *   }
     * })
     *
     */
    create<T extends tela_sistemaCreateArgs>(
      args: SelectSubset<T, tela_sistemaCreateArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tela_sistemas.
     * @param {tela_sistemaCreateManyArgs} args - Arguments to create many Tela_sistemas.
     * @example
     * // Create many Tela_sistemas
     * const tela_sistema = await prisma.tela_sistema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends tela_sistemaCreateManyArgs>(
      args?: SelectSubset<T, tela_sistemaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Tela_sistemas and returns the data saved in the database.
     * @param {tela_sistemaCreateManyAndReturnArgs} args - Arguments to create many Tela_sistemas.
     * @example
     * // Create many Tela_sistemas
     * const tela_sistema = await prisma.tela_sistema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Tela_sistemas and only return the `cod_tela`
     * const tela_sistemaWithCod_telaOnly = await prisma.tela_sistema.createManyAndReturn({
     *   select: { cod_tela: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends tela_sistemaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, tela_sistemaCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Tela_sistema.
     * @param {tela_sistemaDeleteArgs} args - Arguments to delete one Tela_sistema.
     * @example
     * // Delete one Tela_sistema
     * const Tela_sistema = await prisma.tela_sistema.delete({
     *   where: {
     *     // ... filter to delete one Tela_sistema
     *   }
     * })
     *
     */
    delete<T extends tela_sistemaDeleteArgs>(
      args: SelectSubset<T, tela_sistemaDeleteArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Tela_sistema.
     * @param {tela_sistemaUpdateArgs} args - Arguments to update one Tela_sistema.
     * @example
     * // Update one Tela_sistema
     * const tela_sistema = await prisma.tela_sistema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends tela_sistemaUpdateArgs>(
      args: SelectSubset<T, tela_sistemaUpdateArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tela_sistemas.
     * @param {tela_sistemaDeleteManyArgs} args - Arguments to filter Tela_sistemas to delete.
     * @example
     * // Delete a few Tela_sistemas
     * const { count } = await prisma.tela_sistema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends tela_sistemaDeleteManyArgs>(
      args?: SelectSubset<T, tela_sistemaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tela_sistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tela_sistemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tela_sistemas
     * const tela_sistema = await prisma.tela_sistema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends tela_sistemaUpdateManyArgs>(
      args: SelectSubset<T, tela_sistemaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tela_sistemas and returns the data updated in the database.
     * @param {tela_sistemaUpdateManyAndReturnArgs} args - Arguments to update many Tela_sistemas.
     * @example
     * // Update many Tela_sistemas
     * const tela_sistema = await prisma.tela_sistema.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Tela_sistemas and only return the `cod_tela`
     * const tela_sistemaWithCod_telaOnly = await prisma.tela_sistema.updateManyAndReturn({
     *   select: { cod_tela: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends tela_sistemaUpdateManyAndReturnArgs>(
      args: SelectSubset<T, tela_sistemaUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Tela_sistema.
     * @param {tela_sistemaUpsertArgs} args - Arguments to update or create a Tela_sistema.
     * @example
     * // Update or create a Tela_sistema
     * const tela_sistema = await prisma.tela_sistema.upsert({
     *   create: {
     *     // ... data to create a Tela_sistema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tela_sistema we want to update
     *   }
     * })
     */
    upsert<T extends tela_sistemaUpsertArgs>(
      args: SelectSubset<T, tela_sistemaUpsertArgs<ExtArgs>>,
    ): Prisma__tela_sistemaClient<
      $Result.GetResult<
        Prisma.$tela_sistemaPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Tela_sistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tela_sistemaCountArgs} args - Arguments to filter Tela_sistemas to count.
     * @example
     * // Count the number of Tela_sistemas
     * const count = await prisma.tela_sistema.count({
     *   where: {
     *     // ... the filter for the Tela_sistemas we want to count
     *   }
     * })
     **/
    count<T extends tela_sistemaCountArgs>(
      args?: Subset<T, tela_sistemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tela_sistemaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Tela_sistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tela_sistemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Tela_sistemaAggregateArgs>(
      args: Subset<T, Tela_sistemaAggregateArgs>,
    ): Prisma.PrismaPromise<GetTela_sistemaAggregateType<T>>;

    /**
     * Group by Tela_sistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tela_sistemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends tela_sistemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tela_sistemaGroupByArgs['orderBy'] }
        : { orderBy?: tela_sistemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, tela_sistemaGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTela_sistemaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the tela_sistema model
     */
    readonly fields: tela_sistemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tela_sistema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tela_sistemaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    acesso_sistema<T extends tela_sistema$acesso_sistemaArgs<ExtArgs> = {}>(
      args?: Subset<T, tela_sistema$acesso_sistemaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$acesso_sistemaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    modulo_sistema<T extends modulo_sistemaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, modulo_sistemaDefaultArgs<ExtArgs>>,
    ): Prisma__modulo_sistemaClient<
      | $Result.GetResult<
          Prisma.$modulo_sistemaPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the tela_sistema model
   */
  interface tela_sistemaFieldRefs {
    readonly cod_tela: FieldRef<'tela_sistema', 'Int'>;
    readonly cod_modulo: FieldRef<'tela_sistema', 'Int'>;
    readonly desc_tela: FieldRef<'tela_sistema', 'String'>;
  }

  // Custom InputTypes
  /**
   * tela_sistema findUnique
   */
  export type tela_sistemaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which tela_sistema to fetch.
     */
    where: tela_sistemaWhereUniqueInput;
  };

  /**
   * tela_sistema findUniqueOrThrow
   */
  export type tela_sistemaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which tela_sistema to fetch.
     */
    where: tela_sistemaWhereUniqueInput;
  };

  /**
   * tela_sistema findFirst
   */
  export type tela_sistemaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which tela_sistema to fetch.
     */
    where?: tela_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tela_sistemas to fetch.
     */
    orderBy?:
      | tela_sistemaOrderByWithRelationInput
      | tela_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tela_sistemas.
     */
    cursor?: tela_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tela_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tela_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tela_sistemas.
     */
    distinct?: Tela_sistemaScalarFieldEnum | Tela_sistemaScalarFieldEnum[];
  };

  /**
   * tela_sistema findFirstOrThrow
   */
  export type tela_sistemaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which tela_sistema to fetch.
     */
    where?: tela_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tela_sistemas to fetch.
     */
    orderBy?:
      | tela_sistemaOrderByWithRelationInput
      | tela_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tela_sistemas.
     */
    cursor?: tela_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tela_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tela_sistemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tela_sistemas.
     */
    distinct?: Tela_sistemaScalarFieldEnum | Tela_sistemaScalarFieldEnum[];
  };

  /**
   * tela_sistema findMany
   */
  export type tela_sistemaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * Filter, which tela_sistemas to fetch.
     */
    where?: tela_sistemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tela_sistemas to fetch.
     */
    orderBy?:
      | tela_sistemaOrderByWithRelationInput
      | tela_sistemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing tela_sistemas.
     */
    cursor?: tela_sistemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tela_sistemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tela_sistemas.
     */
    skip?: number;
    distinct?: Tela_sistemaScalarFieldEnum | Tela_sistemaScalarFieldEnum[];
  };

  /**
   * tela_sistema create
   */
  export type tela_sistemaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * The data needed to create a tela_sistema.
     */
    data: XOR<tela_sistemaCreateInput, tela_sistemaUncheckedCreateInput>;
  };

  /**
   * tela_sistema createMany
   */
  export type tela_sistemaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many tela_sistemas.
     */
    data: tela_sistemaCreateManyInput | tela_sistemaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * tela_sistema createManyAndReturn
   */
  export type tela_sistemaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * The data used to create many tela_sistemas.
     */
    data: tela_sistemaCreateManyInput | tela_sistemaCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * tela_sistema update
   */
  export type tela_sistemaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * The data needed to update a tela_sistema.
     */
    data: XOR<tela_sistemaUpdateInput, tela_sistemaUncheckedUpdateInput>;
    /**
     * Choose, which tela_sistema to update.
     */
    where: tela_sistemaWhereUniqueInput;
  };

  /**
   * tela_sistema updateMany
   */
  export type tela_sistemaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update tela_sistemas.
     */
    data: XOR<
      tela_sistemaUpdateManyMutationInput,
      tela_sistemaUncheckedUpdateManyInput
    >;
    /**
     * Filter which tela_sistemas to update
     */
    where?: tela_sistemaWhereInput;
    /**
     * Limit how many tela_sistemas to update.
     */
    limit?: number;
  };

  /**
   * tela_sistema updateManyAndReturn
   */
  export type tela_sistemaUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * The data used to update tela_sistemas.
     */
    data: XOR<
      tela_sistemaUpdateManyMutationInput,
      tela_sistemaUncheckedUpdateManyInput
    >;
    /**
     * Filter which tela_sistemas to update
     */
    where?: tela_sistemaWhereInput;
    /**
     * Limit how many tela_sistemas to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * tela_sistema upsert
   */
  export type tela_sistemaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * The filter to search for the tela_sistema to update in case it exists.
     */
    where: tela_sistemaWhereUniqueInput;
    /**
     * In case the tela_sistema found by the `where` argument doesn't exist, create a new tela_sistema with this data.
     */
    create: XOR<tela_sistemaCreateInput, tela_sistemaUncheckedCreateInput>;
    /**
     * In case the tela_sistema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tela_sistemaUpdateInput, tela_sistemaUncheckedUpdateInput>;
  };

  /**
   * tela_sistema delete
   */
  export type tela_sistemaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
    /**
     * Filter which tela_sistema to delete.
     */
    where: tela_sistemaWhereUniqueInput;
  };

  /**
   * tela_sistema deleteMany
   */
  export type tela_sistemaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tela_sistemas to delete
     */
    where?: tela_sistemaWhereInput;
    /**
     * Limit how many tela_sistemas to delete.
     */
    limit?: number;
  };

  /**
   * tela_sistema.acesso_sistema
   */
  export type tela_sistema$acesso_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    where?: acesso_sistemaWhereInput;
    orderBy?:
      | acesso_sistemaOrderByWithRelationInput
      | acesso_sistemaOrderByWithRelationInput[];
    cursor?: acesso_sistemaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Acesso_sistemaScalarFieldEnum | Acesso_sistemaScalarFieldEnum[];
  };

  /**
   * tela_sistema without action
   */
  export type tela_sistemaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tela_sistema
     */
    select?: tela_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tela_sistema
     */
    omit?: tela_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tela_sistemaInclude<ExtArgs> | null;
  };

  /**
   * Model telefone
   */

  export type AggregateTelefone = {
    _count: TelefoneCountAggregateOutputType | null;
    _avg: TelefoneAvgAggregateOutputType | null;
    _sum: TelefoneSumAggregateOutputType | null;
    _min: TelefoneMinAggregateOutputType | null;
    _max: TelefoneMaxAggregateOutputType | null;
  };

  export type TelefoneAvgAggregateOutputType = {
    cod_telefone: number | null;
    cod_lista: number | null;
  };

  export type TelefoneSumAggregateOutputType = {
    cod_telefone: number | null;
    cod_lista: number | null;
  };

  export type TelefoneMinAggregateOutputType = {
    cod_telefone: number | null;
    cod_lista: number | null;
    ddd_telefone: string | null;
    numero_telefone: string | null;
    desc_telefone: string | null;
  };

  export type TelefoneMaxAggregateOutputType = {
    cod_telefone: number | null;
    cod_lista: number | null;
    ddd_telefone: string | null;
    numero_telefone: string | null;
    desc_telefone: string | null;
  };

  export type TelefoneCountAggregateOutputType = {
    cod_telefone: number;
    cod_lista: number;
    ddd_telefone: number;
    numero_telefone: number;
    desc_telefone: number;
    _all: number;
  };

  export type TelefoneAvgAggregateInputType = {
    cod_telefone?: true;
    cod_lista?: true;
  };

  export type TelefoneSumAggregateInputType = {
    cod_telefone?: true;
    cod_lista?: true;
  };

  export type TelefoneMinAggregateInputType = {
    cod_telefone?: true;
    cod_lista?: true;
    ddd_telefone?: true;
    numero_telefone?: true;
    desc_telefone?: true;
  };

  export type TelefoneMaxAggregateInputType = {
    cod_telefone?: true;
    cod_lista?: true;
    ddd_telefone?: true;
    numero_telefone?: true;
    desc_telefone?: true;
  };

  export type TelefoneCountAggregateInputType = {
    cod_telefone?: true;
    cod_lista?: true;
    ddd_telefone?: true;
    numero_telefone?: true;
    desc_telefone?: true;
    _all?: true;
  };

  export type TelefoneAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which telefone to aggregate.
     */
    where?: telefoneWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of telefones to fetch.
     */
    orderBy?:
      | telefoneOrderByWithRelationInput
      | telefoneOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: telefoneWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` telefones from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` telefones.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned telefones
     **/
    _count?: true | TelefoneCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TelefoneAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TelefoneSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TelefoneMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TelefoneMaxAggregateInputType;
  };

  export type GetTelefoneAggregateType<T extends TelefoneAggregateArgs> = {
    [P in keyof T & keyof AggregateTelefone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelefone[P]>
      : GetScalarType<T[P], AggregateTelefone[P]>;
  };

  export type telefoneGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: telefoneWhereInput;
    orderBy?:
      | telefoneOrderByWithAggregationInput
      | telefoneOrderByWithAggregationInput[];
    by: TelefoneScalarFieldEnum[] | TelefoneScalarFieldEnum;
    having?: telefoneScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TelefoneCountAggregateInputType | true;
    _avg?: TelefoneAvgAggregateInputType;
    _sum?: TelefoneSumAggregateInputType;
    _min?: TelefoneMinAggregateInputType;
    _max?: TelefoneMaxAggregateInputType;
  };

  export type TelefoneGroupByOutputType = {
    cod_telefone: number;
    cod_lista: number;
    ddd_telefone: string | null;
    numero_telefone: string;
    desc_telefone: string | null;
    _count: TelefoneCountAggregateOutputType | null;
    _avg: TelefoneAvgAggregateOutputType | null;
    _sum: TelefoneSumAggregateOutputType | null;
    _min: TelefoneMinAggregateOutputType | null;
    _max: TelefoneMaxAggregateOutputType | null;
  };

  type GetTelefoneGroupByPayload<T extends telefoneGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TelefoneGroupByOutputType, T['by']> & {
          [P in keyof T & keyof TelefoneGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelefoneGroupByOutputType[P]>
            : GetScalarType<T[P], TelefoneGroupByOutputType[P]>;
        }
      >
    >;

  export type telefoneSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_telefone?: boolean;
      cod_lista?: boolean;
      ddd_telefone?: boolean;
      numero_telefone?: boolean;
      desc_telefone?: boolean;
    },
    ExtArgs['result']['telefone']
  >;

  export type telefoneSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_telefone?: boolean;
      cod_lista?: boolean;
      ddd_telefone?: boolean;
      numero_telefone?: boolean;
      desc_telefone?: boolean;
    },
    ExtArgs['result']['telefone']
  >;

  export type telefoneSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_telefone?: boolean;
      cod_lista?: boolean;
      ddd_telefone?: boolean;
      numero_telefone?: boolean;
      desc_telefone?: boolean;
    },
    ExtArgs['result']['telefone']
  >;

  export type telefoneSelectScalar = {
    cod_telefone?: boolean;
    cod_lista?: boolean;
    ddd_telefone?: boolean;
    numero_telefone?: boolean;
    desc_telefone?: boolean;
  };

  export type telefoneOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_telefone'
    | 'cod_lista'
    | 'ddd_telefone'
    | 'numero_telefone'
    | 'desc_telefone',
    ExtArgs['result']['telefone']
  >;

  export type $telefonePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'telefone';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_telefone: number;
        cod_lista: number;
        ddd_telefone: string | null;
        numero_telefone: string;
        desc_telefone: string | null;
      },
      ExtArgs['result']['telefone']
    >;
    composites: {};
  };

  type telefoneGetPayload<
    S extends boolean | null | undefined | telefoneDefaultArgs,
  > = $Result.GetResult<Prisma.$telefonePayload, S>;

  type telefoneCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<telefoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TelefoneCountAggregateInputType | true;
  };

  export interface telefoneDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['telefone'];
      meta: { name: 'telefone' };
    };
    /**
     * Find zero or one Telefone that matches the filter.
     * @param {telefoneFindUniqueArgs} args - Arguments to find a Telefone
     * @example
     * // Get one Telefone
     * const telefone = await prisma.telefone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends telefoneFindUniqueArgs>(
      args: SelectSubset<T, telefoneFindUniqueArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Telefone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {telefoneFindUniqueOrThrowArgs} args - Arguments to find a Telefone
     * @example
     * // Get one Telefone
     * const telefone = await prisma.telefone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends telefoneFindUniqueOrThrowArgs>(
      args: SelectSubset<T, telefoneFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Telefone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefoneFindFirstArgs} args - Arguments to find a Telefone
     * @example
     * // Get one Telefone
     * const telefone = await prisma.telefone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends telefoneFindFirstArgs>(
      args?: SelectSubset<T, telefoneFindFirstArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Telefone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefoneFindFirstOrThrowArgs} args - Arguments to find a Telefone
     * @example
     * // Get one Telefone
     * const telefone = await prisma.telefone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends telefoneFindFirstOrThrowArgs>(
      args?: SelectSubset<T, telefoneFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Telefones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Telefones
     * const telefones = await prisma.telefone.findMany()
     *
     * // Get first 10 Telefones
     * const telefones = await prisma.telefone.findMany({ take: 10 })
     *
     * // Only select the `cod_telefone`
     * const telefoneWithCod_telefoneOnly = await prisma.telefone.findMany({ select: { cod_telefone: true } })
     *
     */
    findMany<T extends telefoneFindManyArgs>(
      args?: SelectSubset<T, telefoneFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Telefone.
     * @param {telefoneCreateArgs} args - Arguments to create a Telefone.
     * @example
     * // Create one Telefone
     * const Telefone = await prisma.telefone.create({
     *   data: {
     *     // ... data to create a Telefone
     *   }
     * })
     *
     */
    create<T extends telefoneCreateArgs>(
      args: SelectSubset<T, telefoneCreateArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Telefones.
     * @param {telefoneCreateManyArgs} args - Arguments to create many Telefones.
     * @example
     * // Create many Telefones
     * const telefone = await prisma.telefone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends telefoneCreateManyArgs>(
      args?: SelectSubset<T, telefoneCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Telefones and returns the data saved in the database.
     * @param {telefoneCreateManyAndReturnArgs} args - Arguments to create many Telefones.
     * @example
     * // Create many Telefones
     * const telefone = await prisma.telefone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Telefones and only return the `cod_telefone`
     * const telefoneWithCod_telefoneOnly = await prisma.telefone.createManyAndReturn({
     *   select: { cod_telefone: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends telefoneCreateManyAndReturnArgs>(
      args?: SelectSubset<T, telefoneCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Telefone.
     * @param {telefoneDeleteArgs} args - Arguments to delete one Telefone.
     * @example
     * // Delete one Telefone
     * const Telefone = await prisma.telefone.delete({
     *   where: {
     *     // ... filter to delete one Telefone
     *   }
     * })
     *
     */
    delete<T extends telefoneDeleteArgs>(
      args: SelectSubset<T, telefoneDeleteArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Telefone.
     * @param {telefoneUpdateArgs} args - Arguments to update one Telefone.
     * @example
     * // Update one Telefone
     * const telefone = await prisma.telefone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends telefoneUpdateArgs>(
      args: SelectSubset<T, telefoneUpdateArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Telefones.
     * @param {telefoneDeleteManyArgs} args - Arguments to filter Telefones to delete.
     * @example
     * // Delete a few Telefones
     * const { count } = await prisma.telefone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends telefoneDeleteManyArgs>(
      args?: SelectSubset<T, telefoneDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Telefones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Telefones
     * const telefone = await prisma.telefone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends telefoneUpdateManyArgs>(
      args: SelectSubset<T, telefoneUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Telefones and returns the data updated in the database.
     * @param {telefoneUpdateManyAndReturnArgs} args - Arguments to update many Telefones.
     * @example
     * // Update many Telefones
     * const telefone = await prisma.telefone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Telefones and only return the `cod_telefone`
     * const telefoneWithCod_telefoneOnly = await prisma.telefone.updateManyAndReturn({
     *   select: { cod_telefone: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends telefoneUpdateManyAndReturnArgs>(
      args: SelectSubset<T, telefoneUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Telefone.
     * @param {telefoneUpsertArgs} args - Arguments to update or create a Telefone.
     * @example
     * // Update or create a Telefone
     * const telefone = await prisma.telefone.upsert({
     *   create: {
     *     // ... data to create a Telefone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Telefone we want to update
     *   }
     * })
     */
    upsert<T extends telefoneUpsertArgs>(
      args: SelectSubset<T, telefoneUpsertArgs<ExtArgs>>,
    ): Prisma__telefoneClient<
      $Result.GetResult<
        Prisma.$telefonePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Telefones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefoneCountArgs} args - Arguments to filter Telefones to count.
     * @example
     * // Count the number of Telefones
     * const count = await prisma.telefone.count({
     *   where: {
     *     // ... the filter for the Telefones we want to count
     *   }
     * })
     **/
    count<T extends telefoneCountArgs>(
      args?: Subset<T, telefoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelefoneCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Telefone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelefoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TelefoneAggregateArgs>(
      args: Subset<T, TelefoneAggregateArgs>,
    ): Prisma.PrismaPromise<GetTelefoneAggregateType<T>>;

    /**
     * Group by Telefone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {telefoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends telefoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: telefoneGroupByArgs['orderBy'] }
        : { orderBy?: telefoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, telefoneGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTelefoneGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the telefone model
     */
    readonly fields: telefoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for telefone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__telefoneClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the telefone model
   */
  interface telefoneFieldRefs {
    readonly cod_telefone: FieldRef<'telefone', 'Int'>;
    readonly cod_lista: FieldRef<'telefone', 'Int'>;
    readonly ddd_telefone: FieldRef<'telefone', 'String'>;
    readonly numero_telefone: FieldRef<'telefone', 'String'>;
    readonly desc_telefone: FieldRef<'telefone', 'String'>;
  }

  // Custom InputTypes
  /**
   * telefone findUnique
   */
  export type telefoneFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * Filter, which telefone to fetch.
     */
    where: telefoneWhereUniqueInput;
  };

  /**
   * telefone findUniqueOrThrow
   */
  export type telefoneFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * Filter, which telefone to fetch.
     */
    where: telefoneWhereUniqueInput;
  };

  /**
   * telefone findFirst
   */
  export type telefoneFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * Filter, which telefone to fetch.
     */
    where?: telefoneWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of telefones to fetch.
     */
    orderBy?:
      | telefoneOrderByWithRelationInput
      | telefoneOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for telefones.
     */
    cursor?: telefoneWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` telefones from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` telefones.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of telefones.
     */
    distinct?: TelefoneScalarFieldEnum | TelefoneScalarFieldEnum[];
  };

  /**
   * telefone findFirstOrThrow
   */
  export type telefoneFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * Filter, which telefone to fetch.
     */
    where?: telefoneWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of telefones to fetch.
     */
    orderBy?:
      | telefoneOrderByWithRelationInput
      | telefoneOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for telefones.
     */
    cursor?: telefoneWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` telefones from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` telefones.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of telefones.
     */
    distinct?: TelefoneScalarFieldEnum | TelefoneScalarFieldEnum[];
  };

  /**
   * telefone findMany
   */
  export type telefoneFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * Filter, which telefones to fetch.
     */
    where?: telefoneWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of telefones to fetch.
     */
    orderBy?:
      | telefoneOrderByWithRelationInput
      | telefoneOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing telefones.
     */
    cursor?: telefoneWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` telefones from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` telefones.
     */
    skip?: number;
    distinct?: TelefoneScalarFieldEnum | TelefoneScalarFieldEnum[];
  };

  /**
   * telefone create
   */
  export type telefoneCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * The data needed to create a telefone.
     */
    data: XOR<telefoneCreateInput, telefoneUncheckedCreateInput>;
  };

  /**
   * telefone createMany
   */
  export type telefoneCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many telefones.
     */
    data: telefoneCreateManyInput | telefoneCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * telefone createManyAndReturn
   */
  export type telefoneCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * The data used to create many telefones.
     */
    data: telefoneCreateManyInput | telefoneCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * telefone update
   */
  export type telefoneUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * The data needed to update a telefone.
     */
    data: XOR<telefoneUpdateInput, telefoneUncheckedUpdateInput>;
    /**
     * Choose, which telefone to update.
     */
    where: telefoneWhereUniqueInput;
  };

  /**
   * telefone updateMany
   */
  export type telefoneUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update telefones.
     */
    data: XOR<
      telefoneUpdateManyMutationInput,
      telefoneUncheckedUpdateManyInput
    >;
    /**
     * Filter which telefones to update
     */
    where?: telefoneWhereInput;
    /**
     * Limit how many telefones to update.
     */
    limit?: number;
  };

  /**
   * telefone updateManyAndReturn
   */
  export type telefoneUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * The data used to update telefones.
     */
    data: XOR<
      telefoneUpdateManyMutationInput,
      telefoneUncheckedUpdateManyInput
    >;
    /**
     * Filter which telefones to update
     */
    where?: telefoneWhereInput;
    /**
     * Limit how many telefones to update.
     */
    limit?: number;
  };

  /**
   * telefone upsert
   */
  export type telefoneUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * The filter to search for the telefone to update in case it exists.
     */
    where: telefoneWhereUniqueInput;
    /**
     * In case the telefone found by the `where` argument doesn't exist, create a new telefone with this data.
     */
    create: XOR<telefoneCreateInput, telefoneUncheckedCreateInput>;
    /**
     * In case the telefone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<telefoneUpdateInput, telefoneUncheckedUpdateInput>;
  };

  /**
   * telefone delete
   */
  export type telefoneDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
    /**
     * Filter which telefone to delete.
     */
    where: telefoneWhereUniqueInput;
  };

  /**
   * telefone deleteMany
   */
  export type telefoneDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which telefones to delete
     */
    where?: telefoneWhereInput;
    /**
     * Limit how many telefones to delete.
     */
    limit?: number;
  };

  /**
   * telefone without action
   */
  export type telefoneDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the telefone
     */
    select?: telefoneSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the telefone
     */
    omit?: telefoneOmit<ExtArgs> | null;
  };

  /**
   * Model tipotrf
   */

  export type AggregateTipotrf = {
    _count: TipotrfCountAggregateOutputType | null;
    _avg: TipotrfAvgAggregateOutputType | null;
    _sum: TipotrfSumAggregateOutputType | null;
    _min: TipotrfMinAggregateOutputType | null;
    _max: TipotrfMaxAggregateOutputType | null;
  };

  export type TipotrfAvgAggregateOutputType = {
    cod_tipotrf: number | null;
  };

  export type TipotrfSumAggregateOutputType = {
    cod_tipotrf: number | null;
  };

  export type TipotrfMinAggregateOutputType = {
    cod_tipotrf: number | null;
    nome_tipotrf: string | null;
  };

  export type TipotrfMaxAggregateOutputType = {
    cod_tipotrf: number | null;
    nome_tipotrf: string | null;
  };

  export type TipotrfCountAggregateOutputType = {
    cod_tipotrf: number;
    nome_tipotrf: number;
    _all: number;
  };

  export type TipotrfAvgAggregateInputType = {
    cod_tipotrf?: true;
  };

  export type TipotrfSumAggregateInputType = {
    cod_tipotrf?: true;
  };

  export type TipotrfMinAggregateInputType = {
    cod_tipotrf?: true;
    nome_tipotrf?: true;
  };

  export type TipotrfMaxAggregateInputType = {
    cod_tipotrf?: true;
    nome_tipotrf?: true;
  };

  export type TipotrfCountAggregateInputType = {
    cod_tipotrf?: true;
    nome_tipotrf?: true;
    _all?: true;
  };

  export type TipotrfAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tipotrf to aggregate.
     */
    where?: tipotrfWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tipotrfs to fetch.
     */
    orderBy?:
      | tipotrfOrderByWithRelationInput
      | tipotrfOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: tipotrfWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tipotrfs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tipotrfs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned tipotrfs
     **/
    _count?: true | TipotrfCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TipotrfAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TipotrfSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TipotrfMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TipotrfMaxAggregateInputType;
  };

  export type GetTipotrfAggregateType<T extends TipotrfAggregateArgs> = {
    [P in keyof T & keyof AggregateTipotrf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipotrf[P]>
      : GetScalarType<T[P], AggregateTipotrf[P]>;
  };

  export type tipotrfGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tipotrfWhereInput;
    orderBy?:
      | tipotrfOrderByWithAggregationInput
      | tipotrfOrderByWithAggregationInput[];
    by: TipotrfScalarFieldEnum[] | TipotrfScalarFieldEnum;
    having?: tipotrfScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TipotrfCountAggregateInputType | true;
    _avg?: TipotrfAvgAggregateInputType;
    _sum?: TipotrfSumAggregateInputType;
    _min?: TipotrfMinAggregateInputType;
    _max?: TipotrfMaxAggregateInputType;
  };

  export type TipotrfGroupByOutputType = {
    cod_tipotrf: number;
    nome_tipotrf: string;
    _count: TipotrfCountAggregateOutputType | null;
    _avg: TipotrfAvgAggregateOutputType | null;
    _sum: TipotrfSumAggregateOutputType | null;
    _min: TipotrfMinAggregateOutputType | null;
    _max: TipotrfMaxAggregateOutputType | null;
  };

  type GetTipotrfGroupByPayload<T extends tipotrfGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TipotrfGroupByOutputType, T['by']> & {
          [P in keyof T & keyof TipotrfGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipotrfGroupByOutputType[P]>
            : GetScalarType<T[P], TipotrfGroupByOutputType[P]>;
        }
      >
    >;

  export type tipotrfSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tipotrf?: boolean;
      nome_tipotrf?: boolean;
      valor?: boolean | tipotrf$valorArgs<ExtArgs>;
      _count?: boolean | TipotrfCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['tipotrf']
  >;

  export type tipotrfSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tipotrf?: boolean;
      nome_tipotrf?: boolean;
    },
    ExtArgs['result']['tipotrf']
  >;

  export type tipotrfSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tipotrf?: boolean;
      nome_tipotrf?: boolean;
    },
    ExtArgs['result']['tipotrf']
  >;

  export type tipotrfSelectScalar = {
    cod_tipotrf?: boolean;
    nome_tipotrf?: boolean;
  };

  export type tipotrfOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_tipotrf' | 'nome_tipotrf',
    ExtArgs['result']['tipotrf']
  >;
  export type tipotrfInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    valor?: boolean | tipotrf$valorArgs<ExtArgs>;
    _count?: boolean | TipotrfCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type tipotrfIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type tipotrfIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $tipotrfPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'tipotrf';
    objects: {
      valor: Prisma.$valorPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_tipotrf: number;
        nome_tipotrf: string;
      },
      ExtArgs['result']['tipotrf']
    >;
    composites: {};
  };

  type tipotrfGetPayload<
    S extends boolean | null | undefined | tipotrfDefaultArgs,
  > = $Result.GetResult<Prisma.$tipotrfPayload, S>;

  type tipotrfCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<tipotrfFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TipotrfCountAggregateInputType | true;
  };

  export interface tipotrfDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['tipotrf'];
      meta: { name: 'tipotrf' };
    };
    /**
     * Find zero or one Tipotrf that matches the filter.
     * @param {tipotrfFindUniqueArgs} args - Arguments to find a Tipotrf
     * @example
     * // Get one Tipotrf
     * const tipotrf = await prisma.tipotrf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipotrfFindUniqueArgs>(
      args: SelectSubset<T, tipotrfFindUniqueArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Tipotrf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipotrfFindUniqueOrThrowArgs} args - Arguments to find a Tipotrf
     * @example
     * // Get one Tipotrf
     * const tipotrf = await prisma.tipotrf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipotrfFindUniqueOrThrowArgs>(
      args: SelectSubset<T, tipotrfFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tipotrf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipotrfFindFirstArgs} args - Arguments to find a Tipotrf
     * @example
     * // Get one Tipotrf
     * const tipotrf = await prisma.tipotrf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipotrfFindFirstArgs>(
      args?: SelectSubset<T, tipotrfFindFirstArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tipotrf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipotrfFindFirstOrThrowArgs} args - Arguments to find a Tipotrf
     * @example
     * // Get one Tipotrf
     * const tipotrf = await prisma.tipotrf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipotrfFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tipotrfFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tipotrfs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipotrfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipotrfs
     * const tipotrfs = await prisma.tipotrf.findMany()
     *
     * // Get first 10 Tipotrfs
     * const tipotrfs = await prisma.tipotrf.findMany({ take: 10 })
     *
     * // Only select the `cod_tipotrf`
     * const tipotrfWithCod_tipotrfOnly = await prisma.tipotrf.findMany({ select: { cod_tipotrf: true } })
     *
     */
    findMany<T extends tipotrfFindManyArgs>(
      args?: SelectSubset<T, tipotrfFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Tipotrf.
     * @param {tipotrfCreateArgs} args - Arguments to create a Tipotrf.
     * @example
     * // Create one Tipotrf
     * const Tipotrf = await prisma.tipotrf.create({
     *   data: {
     *     // ... data to create a Tipotrf
     *   }
     * })
     *
     */
    create<T extends tipotrfCreateArgs>(
      args: SelectSubset<T, tipotrfCreateArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tipotrfs.
     * @param {tipotrfCreateManyArgs} args - Arguments to create many Tipotrfs.
     * @example
     * // Create many Tipotrfs
     * const tipotrf = await prisma.tipotrf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends tipotrfCreateManyArgs>(
      args?: SelectSubset<T, tipotrfCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Tipotrfs and returns the data saved in the database.
     * @param {tipotrfCreateManyAndReturnArgs} args - Arguments to create many Tipotrfs.
     * @example
     * // Create many Tipotrfs
     * const tipotrf = await prisma.tipotrf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Tipotrfs and only return the `cod_tipotrf`
     * const tipotrfWithCod_tipotrfOnly = await prisma.tipotrf.createManyAndReturn({
     *   select: { cod_tipotrf: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends tipotrfCreateManyAndReturnArgs>(
      args?: SelectSubset<T, tipotrfCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Tipotrf.
     * @param {tipotrfDeleteArgs} args - Arguments to delete one Tipotrf.
     * @example
     * // Delete one Tipotrf
     * const Tipotrf = await prisma.tipotrf.delete({
     *   where: {
     *     // ... filter to delete one Tipotrf
     *   }
     * })
     *
     */
    delete<T extends tipotrfDeleteArgs>(
      args: SelectSubset<T, tipotrfDeleteArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Tipotrf.
     * @param {tipotrfUpdateArgs} args - Arguments to update one Tipotrf.
     * @example
     * // Update one Tipotrf
     * const tipotrf = await prisma.tipotrf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends tipotrfUpdateArgs>(
      args: SelectSubset<T, tipotrfUpdateArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tipotrfs.
     * @param {tipotrfDeleteManyArgs} args - Arguments to filter Tipotrfs to delete.
     * @example
     * // Delete a few Tipotrfs
     * const { count } = await prisma.tipotrf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends tipotrfDeleteManyArgs>(
      args?: SelectSubset<T, tipotrfDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tipotrfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipotrfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipotrfs
     * const tipotrf = await prisma.tipotrf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends tipotrfUpdateManyArgs>(
      args: SelectSubset<T, tipotrfUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tipotrfs and returns the data updated in the database.
     * @param {tipotrfUpdateManyAndReturnArgs} args - Arguments to update many Tipotrfs.
     * @example
     * // Update many Tipotrfs
     * const tipotrf = await prisma.tipotrf.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Tipotrfs and only return the `cod_tipotrf`
     * const tipotrfWithCod_tipotrfOnly = await prisma.tipotrf.updateManyAndReturn({
     *   select: { cod_tipotrf: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends tipotrfUpdateManyAndReturnArgs>(
      args: SelectSubset<T, tipotrfUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Tipotrf.
     * @param {tipotrfUpsertArgs} args - Arguments to update or create a Tipotrf.
     * @example
     * // Update or create a Tipotrf
     * const tipotrf = await prisma.tipotrf.upsert({
     *   create: {
     *     // ... data to create a Tipotrf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipotrf we want to update
     *   }
     * })
     */
    upsert<T extends tipotrfUpsertArgs>(
      args: SelectSubset<T, tipotrfUpsertArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      $Result.GetResult<
        Prisma.$tipotrfPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Tipotrfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipotrfCountArgs} args - Arguments to filter Tipotrfs to count.
     * @example
     * // Count the number of Tipotrfs
     * const count = await prisma.tipotrf.count({
     *   where: {
     *     // ... the filter for the Tipotrfs we want to count
     *   }
     * })
     **/
    count<T extends tipotrfCountArgs>(
      args?: Subset<T, tipotrfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipotrfCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Tipotrf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipotrfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TipotrfAggregateArgs>(
      args: Subset<T, TipotrfAggregateArgs>,
    ): Prisma.PrismaPromise<GetTipotrfAggregateType<T>>;

    /**
     * Group by Tipotrf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipotrfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends tipotrfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipotrfGroupByArgs['orderBy'] }
        : { orderBy?: tipotrfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, tipotrfGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTipotrfGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the tipotrf model
     */
    readonly fields: tipotrfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipotrf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipotrfClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    valor<T extends tipotrf$valorArgs<ExtArgs> = {}>(
      args?: Subset<T, tipotrf$valorArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$valorPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the tipotrf model
   */
  interface tipotrfFieldRefs {
    readonly cod_tipotrf: FieldRef<'tipotrf', 'Int'>;
    readonly nome_tipotrf: FieldRef<'tipotrf', 'String'>;
  }

  // Custom InputTypes
  /**
   * tipotrf findUnique
   */
  export type tipotrfFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * Filter, which tipotrf to fetch.
     */
    where: tipotrfWhereUniqueInput;
  };

  /**
   * tipotrf findUniqueOrThrow
   */
  export type tipotrfFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * Filter, which tipotrf to fetch.
     */
    where: tipotrfWhereUniqueInput;
  };

  /**
   * tipotrf findFirst
   */
  export type tipotrfFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * Filter, which tipotrf to fetch.
     */
    where?: tipotrfWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tipotrfs to fetch.
     */
    orderBy?:
      | tipotrfOrderByWithRelationInput
      | tipotrfOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tipotrfs.
     */
    cursor?: tipotrfWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tipotrfs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tipotrfs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tipotrfs.
     */
    distinct?: TipotrfScalarFieldEnum | TipotrfScalarFieldEnum[];
  };

  /**
   * tipotrf findFirstOrThrow
   */
  export type tipotrfFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * Filter, which tipotrf to fetch.
     */
    where?: tipotrfWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tipotrfs to fetch.
     */
    orderBy?:
      | tipotrfOrderByWithRelationInput
      | tipotrfOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tipotrfs.
     */
    cursor?: tipotrfWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tipotrfs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tipotrfs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tipotrfs.
     */
    distinct?: TipotrfScalarFieldEnum | TipotrfScalarFieldEnum[];
  };

  /**
   * tipotrf findMany
   */
  export type tipotrfFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * Filter, which tipotrfs to fetch.
     */
    where?: tipotrfWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tipotrfs to fetch.
     */
    orderBy?:
      | tipotrfOrderByWithRelationInput
      | tipotrfOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing tipotrfs.
     */
    cursor?: tipotrfWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tipotrfs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tipotrfs.
     */
    skip?: number;
    distinct?: TipotrfScalarFieldEnum | TipotrfScalarFieldEnum[];
  };

  /**
   * tipotrf create
   */
  export type tipotrfCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * The data needed to create a tipotrf.
     */
    data: XOR<tipotrfCreateInput, tipotrfUncheckedCreateInput>;
  };

  /**
   * tipotrf createMany
   */
  export type tipotrfCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many tipotrfs.
     */
    data: tipotrfCreateManyInput | tipotrfCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * tipotrf createManyAndReturn
   */
  export type tipotrfCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * The data used to create many tipotrfs.
     */
    data: tipotrfCreateManyInput | tipotrfCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * tipotrf update
   */
  export type tipotrfUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * The data needed to update a tipotrf.
     */
    data: XOR<tipotrfUpdateInput, tipotrfUncheckedUpdateInput>;
    /**
     * Choose, which tipotrf to update.
     */
    where: tipotrfWhereUniqueInput;
  };

  /**
   * tipotrf updateMany
   */
  export type tipotrfUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update tipotrfs.
     */
    data: XOR<tipotrfUpdateManyMutationInput, tipotrfUncheckedUpdateManyInput>;
    /**
     * Filter which tipotrfs to update
     */
    where?: tipotrfWhereInput;
    /**
     * Limit how many tipotrfs to update.
     */
    limit?: number;
  };

  /**
   * tipotrf updateManyAndReturn
   */
  export type tipotrfUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * The data used to update tipotrfs.
     */
    data: XOR<tipotrfUpdateManyMutationInput, tipotrfUncheckedUpdateManyInput>;
    /**
     * Filter which tipotrfs to update
     */
    where?: tipotrfWhereInput;
    /**
     * Limit how many tipotrfs to update.
     */
    limit?: number;
  };

  /**
   * tipotrf upsert
   */
  export type tipotrfUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * The filter to search for the tipotrf to update in case it exists.
     */
    where: tipotrfWhereUniqueInput;
    /**
     * In case the tipotrf found by the `where` argument doesn't exist, create a new tipotrf with this data.
     */
    create: XOR<tipotrfCreateInput, tipotrfUncheckedCreateInput>;
    /**
     * In case the tipotrf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipotrfUpdateInput, tipotrfUncheckedUpdateInput>;
  };

  /**
   * tipotrf delete
   */
  export type tipotrfDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
    /**
     * Filter which tipotrf to delete.
     */
    where: tipotrfWhereUniqueInput;
  };

  /**
   * tipotrf deleteMany
   */
  export type tipotrfDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tipotrfs to delete
     */
    where?: tipotrfWhereInput;
    /**
     * Limit how many tipotrfs to delete.
     */
    limit?: number;
  };

  /**
   * tipotrf.valor
   */
  export type tipotrf$valorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    where?: valorWhereInput;
    orderBy?: valorOrderByWithRelationInput | valorOrderByWithRelationInput[];
    cursor?: valorWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ValorScalarFieldEnum | ValorScalarFieldEnum[];
  };

  /**
   * tipotrf without action
   */
  export type tipotrfDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tipotrf
     */
    select?: tipotrfSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tipotrf
     */
    omit?: tipotrfOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipotrfInclude<ExtArgs> | null;
  };

  /**
   * Model tpdesp
   */

  export type AggregateTpdesp = {
    _count: TpdespCountAggregateOutputType | null;
    _avg: TpdespAvgAggregateOutputType | null;
    _sum: TpdespSumAggregateOutputType | null;
    _min: TpdespMinAggregateOutputType | null;
    _max: TpdespMaxAggregateOutputType | null;
  };

  export type TpdespAvgAggregateOutputType = {
    cod_tpdesp: number | null;
  };

  export type TpdespSumAggregateOutputType = {
    cod_tpdesp: number | null;
  };

  export type TpdespMinAggregateOutputType = {
    cod_tpdesp: number | null;
    nome_tpdesp: string | null;
  };

  export type TpdespMaxAggregateOutputType = {
    cod_tpdesp: number | null;
    nome_tpdesp: string | null;
  };

  export type TpdespCountAggregateOutputType = {
    cod_tpdesp: number;
    nome_tpdesp: number;
    _all: number;
  };

  export type TpdespAvgAggregateInputType = {
    cod_tpdesp?: true;
  };

  export type TpdespSumAggregateInputType = {
    cod_tpdesp?: true;
  };

  export type TpdespMinAggregateInputType = {
    cod_tpdesp?: true;
    nome_tpdesp?: true;
  };

  export type TpdespMaxAggregateInputType = {
    cod_tpdesp?: true;
    nome_tpdesp?: true;
  };

  export type TpdespCountAggregateInputType = {
    cod_tpdesp?: true;
    nome_tpdesp?: true;
    _all?: true;
  };

  export type TpdespAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tpdesp to aggregate.
     */
    where?: tpdespWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tpdesps to fetch.
     */
    orderBy?: tpdespOrderByWithRelationInput | tpdespOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: tpdespWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tpdesps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tpdesps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned tpdesps
     **/
    _count?: true | TpdespCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TpdespAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TpdespSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TpdespMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TpdespMaxAggregateInputType;
  };

  export type GetTpdespAggregateType<T extends TpdespAggregateArgs> = {
    [P in keyof T & keyof AggregateTpdesp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTpdesp[P]>
      : GetScalarType<T[P], AggregateTpdesp[P]>;
  };

  export type tpdespGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: tpdespWhereInput;
    orderBy?:
      | tpdespOrderByWithAggregationInput
      | tpdespOrderByWithAggregationInput[];
    by: TpdespScalarFieldEnum[] | TpdespScalarFieldEnum;
    having?: tpdespScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TpdespCountAggregateInputType | true;
    _avg?: TpdespAvgAggregateInputType;
    _sum?: TpdespSumAggregateInputType;
    _min?: TpdespMinAggregateInputType;
    _max?: TpdespMaxAggregateInputType;
  };

  export type TpdespGroupByOutputType = {
    cod_tpdesp: number;
    nome_tpdesp: string;
    _count: TpdespCountAggregateOutputType | null;
    _avg: TpdespAvgAggregateOutputType | null;
    _sum: TpdespSumAggregateOutputType | null;
    _min: TpdespMinAggregateOutputType | null;
    _max: TpdespMaxAggregateOutputType | null;
  };

  type GetTpdespGroupByPayload<T extends tpdespGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TpdespGroupByOutputType, T['by']> & {
          [P in keyof T & keyof TpdespGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TpdespGroupByOutputType[P]>
            : GetScalarType<T[P], TpdespGroupByOutputType[P]>;
        }
      >
    >;

  export type tpdespSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tpdesp?: boolean;
      nome_tpdesp?: boolean;
    },
    ExtArgs['result']['tpdesp']
  >;

  export type tpdespSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tpdesp?: boolean;
      nome_tpdesp?: boolean;
    },
    ExtArgs['result']['tpdesp']
  >;

  export type tpdespSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_tpdesp?: boolean;
      nome_tpdesp?: boolean;
    },
    ExtArgs['result']['tpdesp']
  >;

  export type tpdespSelectScalar = {
    cod_tpdesp?: boolean;
    nome_tpdesp?: boolean;
  };

  export type tpdespOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'cod_tpdesp' | 'nome_tpdesp',
    ExtArgs['result']['tpdesp']
  >;

  export type $tpdespPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'tpdesp';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        cod_tpdesp: number;
        nome_tpdesp: string;
      },
      ExtArgs['result']['tpdesp']
    >;
    composites: {};
  };

  type tpdespGetPayload<
    S extends boolean | null | undefined | tpdespDefaultArgs,
  > = $Result.GetResult<Prisma.$tpdespPayload, S>;

  type tpdespCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<tpdespFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: TpdespCountAggregateInputType | true;
  };

  export interface tpdespDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['tpdesp'];
      meta: { name: 'tpdesp' };
    };
    /**
     * Find zero or one Tpdesp that matches the filter.
     * @param {tpdespFindUniqueArgs} args - Arguments to find a Tpdesp
     * @example
     * // Get one Tpdesp
     * const tpdesp = await prisma.tpdesp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tpdespFindUniqueArgs>(
      args: SelectSubset<T, tpdespFindUniqueArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Tpdesp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tpdespFindUniqueOrThrowArgs} args - Arguments to find a Tpdesp
     * @example
     * // Get one Tpdesp
     * const tpdesp = await prisma.tpdesp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tpdespFindUniqueOrThrowArgs>(
      args: SelectSubset<T, tpdespFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tpdesp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tpdespFindFirstArgs} args - Arguments to find a Tpdesp
     * @example
     * // Get one Tpdesp
     * const tpdesp = await prisma.tpdesp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tpdespFindFirstArgs>(
      args?: SelectSubset<T, tpdespFindFirstArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Tpdesp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tpdespFindFirstOrThrowArgs} args - Arguments to find a Tpdesp
     * @example
     * // Get one Tpdesp
     * const tpdesp = await prisma.tpdesp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tpdespFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tpdespFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Tpdesps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tpdespFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tpdesps
     * const tpdesps = await prisma.tpdesp.findMany()
     *
     * // Get first 10 Tpdesps
     * const tpdesps = await prisma.tpdesp.findMany({ take: 10 })
     *
     * // Only select the `cod_tpdesp`
     * const tpdespWithCod_tpdespOnly = await prisma.tpdesp.findMany({ select: { cod_tpdesp: true } })
     *
     */
    findMany<T extends tpdespFindManyArgs>(
      args?: SelectSubset<T, tpdespFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Tpdesp.
     * @param {tpdespCreateArgs} args - Arguments to create a Tpdesp.
     * @example
     * // Create one Tpdesp
     * const Tpdesp = await prisma.tpdesp.create({
     *   data: {
     *     // ... data to create a Tpdesp
     *   }
     * })
     *
     */
    create<T extends tpdespCreateArgs>(
      args: SelectSubset<T, tpdespCreateArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Tpdesps.
     * @param {tpdespCreateManyArgs} args - Arguments to create many Tpdesps.
     * @example
     * // Create many Tpdesps
     * const tpdesp = await prisma.tpdesp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends tpdespCreateManyArgs>(
      args?: SelectSubset<T, tpdespCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Tpdesps and returns the data saved in the database.
     * @param {tpdespCreateManyAndReturnArgs} args - Arguments to create many Tpdesps.
     * @example
     * // Create many Tpdesps
     * const tpdesp = await prisma.tpdesp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Tpdesps and only return the `cod_tpdesp`
     * const tpdespWithCod_tpdespOnly = await prisma.tpdesp.createManyAndReturn({
     *   select: { cod_tpdesp: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends tpdespCreateManyAndReturnArgs>(
      args?: SelectSubset<T, tpdespCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Tpdesp.
     * @param {tpdespDeleteArgs} args - Arguments to delete one Tpdesp.
     * @example
     * // Delete one Tpdesp
     * const Tpdesp = await prisma.tpdesp.delete({
     *   where: {
     *     // ... filter to delete one Tpdesp
     *   }
     * })
     *
     */
    delete<T extends tpdespDeleteArgs>(
      args: SelectSubset<T, tpdespDeleteArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Tpdesp.
     * @param {tpdespUpdateArgs} args - Arguments to update one Tpdesp.
     * @example
     * // Update one Tpdesp
     * const tpdesp = await prisma.tpdesp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends tpdespUpdateArgs>(
      args: SelectSubset<T, tpdespUpdateArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Tpdesps.
     * @param {tpdespDeleteManyArgs} args - Arguments to filter Tpdesps to delete.
     * @example
     * // Delete a few Tpdesps
     * const { count } = await prisma.tpdesp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends tpdespDeleteManyArgs>(
      args?: SelectSubset<T, tpdespDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tpdesps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tpdespUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tpdesps
     * const tpdesp = await prisma.tpdesp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends tpdespUpdateManyArgs>(
      args: SelectSubset<T, tpdespUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tpdesps and returns the data updated in the database.
     * @param {tpdespUpdateManyAndReturnArgs} args - Arguments to update many Tpdesps.
     * @example
     * // Update many Tpdesps
     * const tpdesp = await prisma.tpdesp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Tpdesps and only return the `cod_tpdesp`
     * const tpdespWithCod_tpdespOnly = await prisma.tpdesp.updateManyAndReturn({
     *   select: { cod_tpdesp: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends tpdespUpdateManyAndReturnArgs>(
      args: SelectSubset<T, tpdespUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Tpdesp.
     * @param {tpdespUpsertArgs} args - Arguments to update or create a Tpdesp.
     * @example
     * // Update or create a Tpdesp
     * const tpdesp = await prisma.tpdesp.upsert({
     *   create: {
     *     // ... data to create a Tpdesp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tpdesp we want to update
     *   }
     * })
     */
    upsert<T extends tpdespUpsertArgs>(
      args: SelectSubset<T, tpdespUpsertArgs<ExtArgs>>,
    ): Prisma__tpdespClient<
      $Result.GetResult<
        Prisma.$tpdespPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Tpdesps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tpdespCountArgs} args - Arguments to filter Tpdesps to count.
     * @example
     * // Count the number of Tpdesps
     * const count = await prisma.tpdesp.count({
     *   where: {
     *     // ... the filter for the Tpdesps we want to count
     *   }
     * })
     **/
    count<T extends tpdespCountArgs>(
      args?: Subset<T, tpdespCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TpdespCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Tpdesp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TpdespAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TpdespAggregateArgs>(
      args: Subset<T, TpdespAggregateArgs>,
    ): Prisma.PrismaPromise<GetTpdespAggregateType<T>>;

    /**
     * Group by Tpdesp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tpdespGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends tpdespGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tpdespGroupByArgs['orderBy'] }
        : { orderBy?: tpdespGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, tpdespGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTpdespGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the tpdesp model
     */
    readonly fields: tpdespFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tpdesp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tpdespClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the tpdesp model
   */
  interface tpdespFieldRefs {
    readonly cod_tpdesp: FieldRef<'tpdesp', 'Int'>;
    readonly nome_tpdesp: FieldRef<'tpdesp', 'String'>;
  }

  // Custom InputTypes
  /**
   * tpdesp findUnique
   */
  export type tpdespFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * Filter, which tpdesp to fetch.
     */
    where: tpdespWhereUniqueInput;
  };

  /**
   * tpdesp findUniqueOrThrow
   */
  export type tpdespFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * Filter, which tpdesp to fetch.
     */
    where: tpdespWhereUniqueInput;
  };

  /**
   * tpdesp findFirst
   */
  export type tpdespFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * Filter, which tpdesp to fetch.
     */
    where?: tpdespWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tpdesps to fetch.
     */
    orderBy?: tpdespOrderByWithRelationInput | tpdespOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tpdesps.
     */
    cursor?: tpdespWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tpdesps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tpdesps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tpdesps.
     */
    distinct?: TpdespScalarFieldEnum | TpdespScalarFieldEnum[];
  };

  /**
   * tpdesp findFirstOrThrow
   */
  export type tpdespFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * Filter, which tpdesp to fetch.
     */
    where?: tpdespWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tpdesps to fetch.
     */
    orderBy?: tpdespOrderByWithRelationInput | tpdespOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for tpdesps.
     */
    cursor?: tpdespWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tpdesps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tpdesps.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of tpdesps.
     */
    distinct?: TpdespScalarFieldEnum | TpdespScalarFieldEnum[];
  };

  /**
   * tpdesp findMany
   */
  export type tpdespFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * Filter, which tpdesps to fetch.
     */
    where?: tpdespWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of tpdesps to fetch.
     */
    orderBy?: tpdespOrderByWithRelationInput | tpdespOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing tpdesps.
     */
    cursor?: tpdespWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` tpdesps from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` tpdesps.
     */
    skip?: number;
    distinct?: TpdespScalarFieldEnum | TpdespScalarFieldEnum[];
  };

  /**
   * tpdesp create
   */
  export type tpdespCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * The data needed to create a tpdesp.
     */
    data: XOR<tpdespCreateInput, tpdespUncheckedCreateInput>;
  };

  /**
   * tpdesp createMany
   */
  export type tpdespCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many tpdesps.
     */
    data: tpdespCreateManyInput | tpdespCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * tpdesp createManyAndReturn
   */
  export type tpdespCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * The data used to create many tpdesps.
     */
    data: tpdespCreateManyInput | tpdespCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * tpdesp update
   */
  export type tpdespUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * The data needed to update a tpdesp.
     */
    data: XOR<tpdespUpdateInput, tpdespUncheckedUpdateInput>;
    /**
     * Choose, which tpdesp to update.
     */
    where: tpdespWhereUniqueInput;
  };

  /**
   * tpdesp updateMany
   */
  export type tpdespUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update tpdesps.
     */
    data: XOR<tpdespUpdateManyMutationInput, tpdespUncheckedUpdateManyInput>;
    /**
     * Filter which tpdesps to update
     */
    where?: tpdespWhereInput;
    /**
     * Limit how many tpdesps to update.
     */
    limit?: number;
  };

  /**
   * tpdesp updateManyAndReturn
   */
  export type tpdespUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * The data used to update tpdesps.
     */
    data: XOR<tpdespUpdateManyMutationInput, tpdespUncheckedUpdateManyInput>;
    /**
     * Filter which tpdesps to update
     */
    where?: tpdespWhereInput;
    /**
     * Limit how many tpdesps to update.
     */
    limit?: number;
  };

  /**
   * tpdesp upsert
   */
  export type tpdespUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * The filter to search for the tpdesp to update in case it exists.
     */
    where: tpdespWhereUniqueInput;
    /**
     * In case the tpdesp found by the `where` argument doesn't exist, create a new tpdesp with this data.
     */
    create: XOR<tpdespCreateInput, tpdespUncheckedCreateInput>;
    /**
     * In case the tpdesp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tpdespUpdateInput, tpdespUncheckedUpdateInput>;
  };

  /**
   * tpdesp delete
   */
  export type tpdespDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
    /**
     * Filter which tpdesp to delete.
     */
    where: tpdespWhereUniqueInput;
  };

  /**
   * tpdesp deleteMany
   */
  export type tpdespDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which tpdesps to delete
     */
    where?: tpdespWhereInput;
    /**
     * Limit how many tpdesps to delete.
     */
    limit?: number;
  };

  /**
   * tpdesp without action
   */
  export type tpdespDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the tpdesp
     */
    select?: tpdespSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the tpdesp
     */
    omit?: tpdespOmit<ExtArgs> | null;
  };

  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null;
    _avg: UsuarioAvgAggregateOutputType | null;
    _sum: UsuarioSumAggregateOutputType | null;
    _min: UsuarioMinAggregateOutputType | null;
    _max: UsuarioMaxAggregateOutputType | null;
  };

  export type UsuarioAvgAggregateOutputType = {
    cod_usuario: number | null;
    altsen_usuario: number | null;
    tela1_usuario: number | null;
    tela2_usuario: number | null;
    tela3_usuario: number | null;
    tela4_usuario: number | null;
  };

  export type UsuarioSumAggregateOutputType = {
    cod_usuario: number | null;
    altsen_usuario: number | null;
    tela1_usuario: number | null;
    tela2_usuario: number | null;
    tela3_usuario: number | null;
    tela4_usuario: number | null;
  };

  export type UsuarioMinAggregateOutputType = {
    cod_usuario: number | null;
    nome_usuario: string | null;
    id_usuario: string | null;
    senha: string | null;
    tipo_usuario: string | null;
    permtar_usuario: string | null;
    altsen_usuario: number | null;
    perproj1_usuario: string | null;
    perproj2_usuario: string | null;
    tela1_usuario: number | null;
    tela2_usuario: number | null;
    tela3_usuario: number | null;
    tela4_usuario: number | null;
  };

  export type UsuarioMaxAggregateOutputType = {
    cod_usuario: number | null;
    nome_usuario: string | null;
    id_usuario: string | null;
    senha: string | null;
    tipo_usuario: string | null;
    permtar_usuario: string | null;
    altsen_usuario: number | null;
    perproj1_usuario: string | null;
    perproj2_usuario: string | null;
    tela1_usuario: number | null;
    tela2_usuario: number | null;
    tela3_usuario: number | null;
    tela4_usuario: number | null;
  };

  export type UsuarioCountAggregateOutputType = {
    cod_usuario: number;
    nome_usuario: number;
    id_usuario: number;
    senha: number;
    tipo_usuario: number;
    permtar_usuario: number;
    altsen_usuario: number;
    perproj1_usuario: number;
    perproj2_usuario: number;
    tela1_usuario: number;
    tela2_usuario: number;
    tela3_usuario: number;
    tela4_usuario: number;
    _all: number;
  };

  export type UsuarioAvgAggregateInputType = {
    cod_usuario?: true;
    altsen_usuario?: true;
    tela1_usuario?: true;
    tela2_usuario?: true;
    tela3_usuario?: true;
    tela4_usuario?: true;
  };

  export type UsuarioSumAggregateInputType = {
    cod_usuario?: true;
    altsen_usuario?: true;
    tela1_usuario?: true;
    tela2_usuario?: true;
    tela3_usuario?: true;
    tela4_usuario?: true;
  };

  export type UsuarioMinAggregateInputType = {
    cod_usuario?: true;
    nome_usuario?: true;
    id_usuario?: true;
    senha?: true;
    tipo_usuario?: true;
    permtar_usuario?: true;
    altsen_usuario?: true;
    perproj1_usuario?: true;
    perproj2_usuario?: true;
    tela1_usuario?: true;
    tela2_usuario?: true;
    tela3_usuario?: true;
    tela4_usuario?: true;
  };

  export type UsuarioMaxAggregateInputType = {
    cod_usuario?: true;
    nome_usuario?: true;
    id_usuario?: true;
    senha?: true;
    tipo_usuario?: true;
    permtar_usuario?: true;
    altsen_usuario?: true;
    perproj1_usuario?: true;
    perproj2_usuario?: true;
    tela1_usuario?: true;
    tela2_usuario?: true;
    tela3_usuario?: true;
    tela4_usuario?: true;
  };

  export type UsuarioCountAggregateInputType = {
    cod_usuario?: true;
    nome_usuario?: true;
    id_usuario?: true;
    senha?: true;
    tipo_usuario?: true;
    permtar_usuario?: true;
    altsen_usuario?: true;
    perproj1_usuario?: true;
    perproj2_usuario?: true;
    tela1_usuario?: true;
    tela2_usuario?: true;
    tela3_usuario?: true;
    tela4_usuario?: true;
    _all?: true;
  };

  export type UsuarioAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of usuarios to fetch.
     */
    orderBy?:
      | usuarioOrderByWithRelationInput
      | usuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` usuarios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned usuarios
     **/
    _count?: true | UsuarioCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UsuarioAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UsuarioSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UsuarioMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UsuarioMaxAggregateInputType;
  };

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
    [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>;
  };

  export type usuarioGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: usuarioWhereInput;
    orderBy?:
      | usuarioOrderByWithAggregationInput
      | usuarioOrderByWithAggregationInput[];
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum;
    having?: usuarioScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UsuarioCountAggregateInputType | true;
    _avg?: UsuarioAvgAggregateInputType;
    _sum?: UsuarioSumAggregateInputType;
    _min?: UsuarioMinAggregateInputType;
    _max?: UsuarioMaxAggregateInputType;
  };

  export type UsuarioGroupByOutputType = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha: string | null;
    tipo_usuario: string;
    permtar_usuario: string;
    altsen_usuario: number;
    perproj1_usuario: string;
    perproj2_usuario: string;
    tela1_usuario: number | null;
    tela2_usuario: number | null;
    tela3_usuario: number | null;
    tela4_usuario: number | null;
    _count: UsuarioCountAggregateOutputType | null;
    _avg: UsuarioAvgAggregateOutputType | null;
    _sum: UsuarioSumAggregateOutputType | null;
    _min: UsuarioMinAggregateOutputType | null;
    _max: UsuarioMaxAggregateOutputType | null;
  };

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UsuarioGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UsuarioGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>;
        }
      >
    >;

  export type usuarioSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_usuario?: boolean;
      nome_usuario?: boolean;
      id_usuario?: boolean;
      senha?: boolean;
      tipo_usuario?: boolean;
      permtar_usuario?: boolean;
      altsen_usuario?: boolean;
      perproj1_usuario?: boolean;
      perproj2_usuario?: boolean;
      tela1_usuario?: boolean;
      tela2_usuario?: boolean;
      tela3_usuario?: boolean;
      tela4_usuario?: boolean;
      acesso_sistema?: boolean | usuario$acesso_sistemaArgs<ExtArgs>;
      recurso?: boolean | usuario$recursoArgs<ExtArgs>;
      _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['usuario']
  >;

  export type usuarioSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_usuario?: boolean;
      nome_usuario?: boolean;
      id_usuario?: boolean;
      senha?: boolean;
      tipo_usuario?: boolean;
      permtar_usuario?: boolean;
      altsen_usuario?: boolean;
      perproj1_usuario?: boolean;
      perproj2_usuario?: boolean;
      tela1_usuario?: boolean;
      tela2_usuario?: boolean;
      tela3_usuario?: boolean;
      tela4_usuario?: boolean;
    },
    ExtArgs['result']['usuario']
  >;

  export type usuarioSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      cod_usuario?: boolean;
      nome_usuario?: boolean;
      id_usuario?: boolean;
      senha?: boolean;
      tipo_usuario?: boolean;
      permtar_usuario?: boolean;
      altsen_usuario?: boolean;
      perproj1_usuario?: boolean;
      perproj2_usuario?: boolean;
      tela1_usuario?: boolean;
      tela2_usuario?: boolean;
      tela3_usuario?: boolean;
      tela4_usuario?: boolean;
    },
    ExtArgs['result']['usuario']
  >;

  export type usuarioSelectScalar = {
    cod_usuario?: boolean;
    nome_usuario?: boolean;
    id_usuario?: boolean;
    senha?: boolean;
    tipo_usuario?: boolean;
    permtar_usuario?: boolean;
    altsen_usuario?: boolean;
    perproj1_usuario?: boolean;
    perproj2_usuario?: boolean;
    tela1_usuario?: boolean;
    tela2_usuario?: boolean;
    tela3_usuario?: boolean;
    tela4_usuario?: boolean;
  };

  export type usuarioOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'cod_usuario'
    | 'nome_usuario'
    | 'id_usuario'
    | 'senha'
    | 'tipo_usuario'
    | 'permtar_usuario'
    | 'altsen_usuario'
    | 'perproj1_usuario'
    | 'perproj2_usuario'
    | 'tela1_usuario'
    | 'tela2_usuario'
    | 'tela3_usuario'
    | 'tela4_usuario',
    ExtArgs['result']['usuario']
  >;
  export type usuarioInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    acesso_sistema?: boolean | usuario$acesso_sistemaArgs<ExtArgs>;
    recurso?: boolean | usuario$recursoArgs<ExtArgs>;
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type usuarioIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type usuarioIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $usuarioPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'usuario';
    objects: {
      acesso_sistema: Prisma.$acesso_sistemaPayload<ExtArgs>[];
      recurso: Prisma.$recursoPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        cod_usuario: number;
        nome_usuario: string;
        id_usuario: string;
        senha: string | null;
        tipo_usuario: string;
        permtar_usuario: string;
        altsen_usuario: number;
        perproj1_usuario: string;
        perproj2_usuario: string;
        tela1_usuario: number | null;
        tela2_usuario: number | null;
        tela3_usuario: number | null;
        tela4_usuario: number | null;
      },
      ExtArgs['result']['usuario']
    >;
    composites: {};
  };

  type usuarioGetPayload<
    S extends boolean | null | undefined | usuarioDefaultArgs,
  > = $Result.GetResult<Prisma.$usuarioPayload, S>;

  type usuarioCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UsuarioCountAggregateInputType | true;
  };

  export interface usuarioDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['usuario'];
      meta: { name: 'usuario' };
    };
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarioFindUniqueArgs>(
      args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(
      args: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarioFindFirstArgs>(
      args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     *
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     *
     * // Only select the `cod_usuario`
     * const usuarioWithCod_usuarioOnly = await prisma.usuario.findMany({ select: { cod_usuario: true } })
     *
     */
    findMany<T extends usuarioFindManyArgs>(
      args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     *
     */
    create<T extends usuarioCreateArgs>(
      args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Usuarios.
     * @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends usuarioCreateManyArgs>(
      args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {usuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Usuarios and only return the `cod_usuario`
     * const usuarioWithCod_usuarioOnly = await prisma.usuario.createManyAndReturn({
     *   select: { cod_usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends usuarioCreateManyAndReturnArgs>(
      args?: SelectSubset<T, usuarioCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     *
     */
    delete<T extends usuarioDeleteArgs>(
      args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends usuarioUpdateArgs>(
      args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends usuarioDeleteManyArgs>(
      args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends usuarioUpdateManyArgs>(
      args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {usuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Usuarios and only return the `cod_usuario`
     * const usuarioWithCod_usuarioOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { cod_usuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends usuarioUpdateManyAndReturnArgs>(
      args: SelectSubset<T, usuarioUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends usuarioUpsertArgs>(
      args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>,
    ): Prisma__usuarioClient<
      $Result.GetResult<
        Prisma.$usuarioPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
     **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UsuarioAggregateArgs>(
      args: Subset<T, UsuarioAggregateArgs>,
    ): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>;

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUsuarioGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the usuario model
     */
    readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    acesso_sistema<T extends usuario$acesso_sistemaArgs<ExtArgs> = {}>(
      args?: Subset<T, usuario$acesso_sistemaArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$acesso_sistemaPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    recurso<T extends usuario$recursoArgs<ExtArgs> = {}>(
      args?: Subset<T, usuario$recursoArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$recursoPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the usuario model
   */
  interface usuarioFieldRefs {
    readonly cod_usuario: FieldRef<'usuario', 'Int'>;
    readonly nome_usuario: FieldRef<'usuario', 'String'>;
    readonly id_usuario: FieldRef<'usuario', 'String'>;
    readonly senha: FieldRef<'usuario', 'String'>;
    readonly tipo_usuario: FieldRef<'usuario', 'String'>;
    readonly permtar_usuario: FieldRef<'usuario', 'String'>;
    readonly altsen_usuario: FieldRef<'usuario', 'Int'>;
    readonly perproj1_usuario: FieldRef<'usuario', 'String'>;
    readonly perproj2_usuario: FieldRef<'usuario', 'String'>;
    readonly tela1_usuario: FieldRef<'usuario', 'Int'>;
    readonly tela2_usuario: FieldRef<'usuario', 'Int'>;
    readonly tela3_usuario: FieldRef<'usuario', 'Int'>;
    readonly tela4_usuario: FieldRef<'usuario', 'Int'>;
  }

  // Custom InputTypes
  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput;
  };

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput;
  };

  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of usuarios to fetch.
     */
    orderBy?:
      | usuarioOrderByWithRelationInput
      | usuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` usuarios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[];
  };

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of usuarios to fetch.
     */
    orderBy?:
      | usuarioOrderByWithRelationInput
      | usuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` usuarios.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[];
  };

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of usuarios to fetch.
     */
    orderBy?:
      | usuarioOrderByWithRelationInput
      | usuarioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` usuarios.
     */
    skip?: number;
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[];
  };

  /**
   * usuario create
   */
  export type usuarioCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>;
  };

  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * usuario createManyAndReturn
   */
  export type usuarioCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * usuario update
   */
  export type usuarioUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>;
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput;
  };

  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>;
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput;
    /**
     * Limit how many usuarios to update.
     */
    limit?: number;
  };

  /**
   * usuario updateManyAndReturn
   */
  export type usuarioUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>;
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput;
    /**
     * Limit how many usuarios to update.
     */
    limit?: number;
  };

  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput;
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>;
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>;
  };

  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput;
  };

  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput;
    /**
     * Limit how many usuarios to delete.
     */
    limit?: number;
  };

  /**
   * usuario.acesso_sistema
   */
  export type usuario$acesso_sistemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the acesso_sistema
     */
    select?: acesso_sistemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the acesso_sistema
     */
    omit?: acesso_sistemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: acesso_sistemaInclude<ExtArgs> | null;
    where?: acesso_sistemaWhereInput;
    orderBy?:
      | acesso_sistemaOrderByWithRelationInput
      | acesso_sistemaOrderByWithRelationInput[];
    cursor?: acesso_sistemaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Acesso_sistemaScalarFieldEnum | Acesso_sistemaScalarFieldEnum[];
  };

  /**
   * usuario.recurso
   */
  export type usuario$recursoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the recurso
     */
    omit?: recursoOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null;
    where?: recursoWhereInput;
    orderBy?:
      | recursoOrderByWithRelationInput
      | recursoOrderByWithRelationInput[];
    cursor?: recursoWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[];
  };

  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null;
  };

  /**
   * Model valor
   */

  export type AggregateValor = {
    _count: ValorCountAggregateOutputType | null;
    _avg: ValorAvgAggregateOutputType | null;
    _sum: ValorSumAggregateOutputType | null;
    _min: ValorMinAggregateOutputType | null;
    _max: ValorMaxAggregateOutputType | null;
  };

  export type ValorAvgAggregateOutputType = {
    codproj_valor: number | null;
    codtipo_valor: number | null;
    preco_valor: Decimal | null;
  };

  export type ValorSumAggregateOutputType = {
    codproj_valor: number | null;
    codtipo_valor: number | null;
    preco_valor: Decimal | null;
  };

  export type ValorMinAggregateOutputType = {
    codproj_valor: number | null;
    codtipo_valor: number | null;
    preco_valor: Decimal | null;
  };

  export type ValorMaxAggregateOutputType = {
    codproj_valor: number | null;
    codtipo_valor: number | null;
    preco_valor: Decimal | null;
  };

  export type ValorCountAggregateOutputType = {
    codproj_valor: number;
    codtipo_valor: number;
    preco_valor: number;
    _all: number;
  };

  export type ValorAvgAggregateInputType = {
    codproj_valor?: true;
    codtipo_valor?: true;
    preco_valor?: true;
  };

  export type ValorSumAggregateInputType = {
    codproj_valor?: true;
    codtipo_valor?: true;
    preco_valor?: true;
  };

  export type ValorMinAggregateInputType = {
    codproj_valor?: true;
    codtipo_valor?: true;
    preco_valor?: true;
  };

  export type ValorMaxAggregateInputType = {
    codproj_valor?: true;
    codtipo_valor?: true;
    preco_valor?: true;
  };

  export type ValorCountAggregateInputType = {
    codproj_valor?: true;
    codtipo_valor?: true;
    preco_valor?: true;
    _all?: true;
  };

  export type ValorAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which valor to aggregate.
     */
    where?: valorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of valors to fetch.
     */
    orderBy?: valorOrderByWithRelationInput | valorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: valorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` valors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` valors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned valors
     **/
    _count?: true | ValorCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ValorAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ValorSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ValorMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ValorMaxAggregateInputType;
  };

  export type GetValorAggregateType<T extends ValorAggregateArgs> = {
    [P in keyof T & keyof AggregateValor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValor[P]>
      : GetScalarType<T[P], AggregateValor[P]>;
  };

  export type valorGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: valorWhereInput;
    orderBy?:
      | valorOrderByWithAggregationInput
      | valorOrderByWithAggregationInput[];
    by: ValorScalarFieldEnum[] | ValorScalarFieldEnum;
    having?: valorScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ValorCountAggregateInputType | true;
    _avg?: ValorAvgAggregateInputType;
    _sum?: ValorSumAggregateInputType;
    _min?: ValorMinAggregateInputType;
    _max?: ValorMaxAggregateInputType;
  };

  export type ValorGroupByOutputType = {
    codproj_valor: number;
    codtipo_valor: number;
    preco_valor: Decimal;
    _count: ValorCountAggregateOutputType | null;
    _avg: ValorAvgAggregateOutputType | null;
    _sum: ValorSumAggregateOutputType | null;
    _min: ValorMinAggregateOutputType | null;
    _max: ValorMaxAggregateOutputType | null;
  };

  type GetValorGroupByPayload<T extends valorGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ValorGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ValorGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValorGroupByOutputType[P]>
            : GetScalarType<T[P], ValorGroupByOutputType[P]>;
        }
      >
    >;

  export type valorSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codproj_valor?: boolean;
      codtipo_valor?: boolean;
      preco_valor?: boolean;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
      tipotrf?: boolean | tipotrfDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['valor']
  >;

  export type valorSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codproj_valor?: boolean;
      codtipo_valor?: boolean;
      preco_valor?: boolean;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
      tipotrf?: boolean | tipotrfDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['valor']
  >;

  export type valorSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      codproj_valor?: boolean;
      codtipo_valor?: boolean;
      preco_valor?: boolean;
      projeto?: boolean | projetoDefaultArgs<ExtArgs>;
      tipotrf?: boolean | tipotrfDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['valor']
  >;

  export type valorSelectScalar = {
    codproj_valor?: boolean;
    codtipo_valor?: boolean;
    preco_valor?: boolean;
  };

  export type valorOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'codproj_valor' | 'codtipo_valor' | 'preco_valor',
    ExtArgs['result']['valor']
  >;
  export type valorInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    tipotrf?: boolean | tipotrfDefaultArgs<ExtArgs>;
  };
  export type valorIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    tipotrf?: boolean | tipotrfDefaultArgs<ExtArgs>;
  };
  export type valorIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>;
    tipotrf?: boolean | tipotrfDefaultArgs<ExtArgs>;
  };

  export type $valorPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'valor';
    objects: {
      projeto: Prisma.$projetoPayload<ExtArgs>;
      tipotrf: Prisma.$tipotrfPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        codproj_valor: number;
        codtipo_valor: number;
        preco_valor: Prisma.Decimal;
      },
      ExtArgs['result']['valor']
    >;
    composites: {};
  };

  type valorGetPayload<
    S extends boolean | null | undefined | valorDefaultArgs,
  > = $Result.GetResult<Prisma.$valorPayload, S>;

  type valorCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<valorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ValorCountAggregateInputType | true;
  };

  export interface valorDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['valor'];
      meta: { name: 'valor' };
    };
    /**
     * Find zero or one Valor that matches the filter.
     * @param {valorFindUniqueArgs} args - Arguments to find a Valor
     * @example
     * // Get one Valor
     * const valor = await prisma.valor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends valorFindUniqueArgs>(
      args: SelectSubset<T, valorFindUniqueArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Valor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {valorFindUniqueOrThrowArgs} args - Arguments to find a Valor
     * @example
     * // Get one Valor
     * const valor = await prisma.valor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends valorFindUniqueOrThrowArgs>(
      args: SelectSubset<T, valorFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Valor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valorFindFirstArgs} args - Arguments to find a Valor
     * @example
     * // Get one Valor
     * const valor = await prisma.valor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends valorFindFirstArgs>(
      args?: SelectSubset<T, valorFindFirstArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Valor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valorFindFirstOrThrowArgs} args - Arguments to find a Valor
     * @example
     * // Get one Valor
     * const valor = await prisma.valor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends valorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, valorFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Valors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Valors
     * const valors = await prisma.valor.findMany()
     *
     * // Get first 10 Valors
     * const valors = await prisma.valor.findMany({ take: 10 })
     *
     * // Only select the `codproj_valor`
     * const valorWithCodproj_valorOnly = await prisma.valor.findMany({ select: { codproj_valor: true } })
     *
     */
    findMany<T extends valorFindManyArgs>(
      args?: SelectSubset<T, valorFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Valor.
     * @param {valorCreateArgs} args - Arguments to create a Valor.
     * @example
     * // Create one Valor
     * const Valor = await prisma.valor.create({
     *   data: {
     *     // ... data to create a Valor
     *   }
     * })
     *
     */
    create<T extends valorCreateArgs>(
      args: SelectSubset<T, valorCreateArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Valors.
     * @param {valorCreateManyArgs} args - Arguments to create many Valors.
     * @example
     * // Create many Valors
     * const valor = await prisma.valor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends valorCreateManyArgs>(
      args?: SelectSubset<T, valorCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Valors and returns the data saved in the database.
     * @param {valorCreateManyAndReturnArgs} args - Arguments to create many Valors.
     * @example
     * // Create many Valors
     * const valor = await prisma.valor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Valors and only return the `codproj_valor`
     * const valorWithCodproj_valorOnly = await prisma.valor.createManyAndReturn({
     *   select: { codproj_valor: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends valorCreateManyAndReturnArgs>(
      args?: SelectSubset<T, valorCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Valor.
     * @param {valorDeleteArgs} args - Arguments to delete one Valor.
     * @example
     * // Delete one Valor
     * const Valor = await prisma.valor.delete({
     *   where: {
     *     // ... filter to delete one Valor
     *   }
     * })
     *
     */
    delete<T extends valorDeleteArgs>(
      args: SelectSubset<T, valorDeleteArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Valor.
     * @param {valorUpdateArgs} args - Arguments to update one Valor.
     * @example
     * // Update one Valor
     * const valor = await prisma.valor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends valorUpdateArgs>(
      args: SelectSubset<T, valorUpdateArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Valors.
     * @param {valorDeleteManyArgs} args - Arguments to filter Valors to delete.
     * @example
     * // Delete a few Valors
     * const { count } = await prisma.valor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends valorDeleteManyArgs>(
      args?: SelectSubset<T, valorDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Valors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Valors
     * const valor = await prisma.valor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends valorUpdateManyArgs>(
      args: SelectSubset<T, valorUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Valors and returns the data updated in the database.
     * @param {valorUpdateManyAndReturnArgs} args - Arguments to update many Valors.
     * @example
     * // Update many Valors
     * const valor = await prisma.valor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Valors and only return the `codproj_valor`
     * const valorWithCodproj_valorOnly = await prisma.valor.updateManyAndReturn({
     *   select: { codproj_valor: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends valorUpdateManyAndReturnArgs>(
      args: SelectSubset<T, valorUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Valor.
     * @param {valorUpsertArgs} args - Arguments to update or create a Valor.
     * @example
     * // Update or create a Valor
     * const valor = await prisma.valor.upsert({
     *   create: {
     *     // ... data to create a Valor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Valor we want to update
     *   }
     * })
     */
    upsert<T extends valorUpsertArgs>(
      args: SelectSubset<T, valorUpsertArgs<ExtArgs>>,
    ): Prisma__valorClient<
      $Result.GetResult<
        Prisma.$valorPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Valors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valorCountArgs} args - Arguments to filter Valors to count.
     * @example
     * // Count the number of Valors
     * const count = await prisma.valor.count({
     *   where: {
     *     // ... the filter for the Valors we want to count
     *   }
     * })
     **/
    count<T extends valorCountArgs>(
      args?: Subset<T, valorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValorCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Valor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ValorAggregateArgs>(
      args: Subset<T, ValorAggregateArgs>,
    ): Prisma.PrismaPromise<GetValorAggregateType<T>>;

    /**
     * Group by Valor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends valorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: valorGroupByArgs['orderBy'] }
        : { orderBy?: valorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, valorGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetValorGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the valor model
     */
    readonly fields: valorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for valor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__valorClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, projetoDefaultArgs<ExtArgs>>,
    ): Prisma__projetoClient<
      | $Result.GetResult<
          Prisma.$projetoPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    tipotrf<T extends tipotrfDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, tipotrfDefaultArgs<ExtArgs>>,
    ): Prisma__tipotrfClient<
      | $Result.GetResult<
          Prisma.$tipotrfPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the valor model
   */
  interface valorFieldRefs {
    readonly codproj_valor: FieldRef<'valor', 'Int'>;
    readonly codtipo_valor: FieldRef<'valor', 'Int'>;
    readonly preco_valor: FieldRef<'valor', 'Decimal'>;
  }

  // Custom InputTypes
  /**
   * valor findUnique
   */
  export type valorFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * Filter, which valor to fetch.
     */
    where: valorWhereUniqueInput;
  };

  /**
   * valor findUniqueOrThrow
   */
  export type valorFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * Filter, which valor to fetch.
     */
    where: valorWhereUniqueInput;
  };

  /**
   * valor findFirst
   */
  export type valorFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * Filter, which valor to fetch.
     */
    where?: valorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of valors to fetch.
     */
    orderBy?: valorOrderByWithRelationInput | valorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for valors.
     */
    cursor?: valorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` valors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` valors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of valors.
     */
    distinct?: ValorScalarFieldEnum | ValorScalarFieldEnum[];
  };

  /**
   * valor findFirstOrThrow
   */
  export type valorFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * Filter, which valor to fetch.
     */
    where?: valorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of valors to fetch.
     */
    orderBy?: valorOrderByWithRelationInput | valorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for valors.
     */
    cursor?: valorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` valors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` valors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of valors.
     */
    distinct?: ValorScalarFieldEnum | ValorScalarFieldEnum[];
  };

  /**
   * valor findMany
   */
  export type valorFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * Filter, which valors to fetch.
     */
    where?: valorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of valors to fetch.
     */
    orderBy?: valorOrderByWithRelationInput | valorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing valors.
     */
    cursor?: valorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` valors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` valors.
     */
    skip?: number;
    distinct?: ValorScalarFieldEnum | ValorScalarFieldEnum[];
  };

  /**
   * valor create
   */
  export type valorCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * The data needed to create a valor.
     */
    data: XOR<valorCreateInput, valorUncheckedCreateInput>;
  };

  /**
   * valor createMany
   */
  export type valorCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many valors.
     */
    data: valorCreateManyInput | valorCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * valor createManyAndReturn
   */
  export type valorCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * The data used to create many valors.
     */
    data: valorCreateManyInput | valorCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * valor update
   */
  export type valorUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * The data needed to update a valor.
     */
    data: XOR<valorUpdateInput, valorUncheckedUpdateInput>;
    /**
     * Choose, which valor to update.
     */
    where: valorWhereUniqueInput;
  };

  /**
   * valor updateMany
   */
  export type valorUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update valors.
     */
    data: XOR<valorUpdateManyMutationInput, valorUncheckedUpdateManyInput>;
    /**
     * Filter which valors to update
     */
    where?: valorWhereInput;
    /**
     * Limit how many valors to update.
     */
    limit?: number;
  };

  /**
   * valor updateManyAndReturn
   */
  export type valorUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * The data used to update valors.
     */
    data: XOR<valorUpdateManyMutationInput, valorUncheckedUpdateManyInput>;
    /**
     * Filter which valors to update
     */
    where?: valorWhereInput;
    /**
     * Limit how many valors to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * valor upsert
   */
  export type valorUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * The filter to search for the valor to update in case it exists.
     */
    where: valorWhereUniqueInput;
    /**
     * In case the valor found by the `where` argument doesn't exist, create a new valor with this data.
     */
    create: XOR<valorCreateInput, valorUncheckedCreateInput>;
    /**
     * In case the valor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<valorUpdateInput, valorUncheckedUpdateInput>;
  };

  /**
   * valor delete
   */
  export type valorDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
    /**
     * Filter which valor to delete.
     */
    where: valorWhereUniqueInput;
  };

  /**
   * valor deleteMany
   */
  export type valorDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which valors to delete
     */
    where?: valorWhereInput;
    /**
     * Limit how many valors to delete.
     */
    limit?: number;
  };

  /**
   * valor without action
   */
  export type valorDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the valor
     */
    select?: valorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the valor
     */
    omit?: valorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: valorInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const Acesso_sistemaScalarFieldEnum: {
    cod_usuario: 'cod_usuario';
    cod_modulo: 'cod_modulo';
    cod_tela: 'cod_tela';
    incluir: 'incluir';
    modificar: 'modificar';
    eliminar: 'eliminar';
  };

  export type Acesso_sistemaScalarFieldEnum =
    (typeof Acesso_sistemaScalarFieldEnum)[keyof typeof Acesso_sistemaScalarFieldEnum];

  export const AgenrecScalarFieldEnum: {
    cod_agenrec: 'cod_agenrec';
    cod_recurso: 'cod_recurso';
    data_agenrec: 'data_agenrec';
    hrini_agenrec: 'hrini_agenrec';
    hrfim_agenrec: 'hrfim_agenrec';
    status_agenrec: 'status_agenrec';
    obs_agenrec: 'obs_agenrec';
    custo_agenrec: 'custo_agenrec';
    receita_agenrec: 'receita_agenrec';
    tpcusto_agenrec: 'tpcusto_agenrec';
  };

  export type AgenrecScalarFieldEnum =
    (typeof AgenrecScalarFieldEnum)[keyof typeof AgenrecScalarFieldEnum];

  export const AreaScalarFieldEnum: {
    cod_area: 'cod_area';
    nome_area: 'nome_area';
  };

  export type AreaScalarFieldEnum =
    (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum];

  export const AvaliacaoScalarFieldEnum: {
    cod_avaliacao: 'cod_avaliacao';
    anomes_avaliacao: 'anomes_avaliacao';
    data_avaliacao: 'data_avaliacao';
    codrec_avaliacao: 'codrec_avaliacao';
    status_avaliacao: 'status_avaliacao';
    codpro_avaliacao: 'codpro_avaliacao';
  };

  export type AvaliacaoScalarFieldEnum =
    (typeof AvaliacaoScalarFieldEnum)[keyof typeof AvaliacaoScalarFieldEnum];

  export const AvaliadoScalarFieldEnum: {
    codaval_avaliado: 'codaval_avaliado';
    codrec_avaliado: 'codrec_avaliado';
    status_avaliado: 'status_avaliado';
    data_avaliado: 'data_avaliado';
    hora_avaliado: 'hora_avaliado';
    usuario_avaliado: 'usuario_avaliado';
  };

  export type AvaliadoScalarFieldEnum =
    (typeof AvaliadoScalarFieldEnum)[keyof typeof AvaliadoScalarFieldEnum];

  export const ChamadoScalarFieldEnum: {
    cod_chamado: 'cod_chamado';
    data_chamado: 'data_chamado';
    hora_chamado: 'hora_chamado';
    solicitacao_chamado: 'solicitacao_chamado';
    conclusao_chamado: 'conclusao_chamado';
    status_chamado: 'status_chamado';
    dtenvio_chamado: 'dtenvio_chamado';
    cod_recurso: 'cod_recurso';
    cliente_chamado: 'cliente_chamado';
    codtrf_chamado: 'codtrf_chamado';
    cod_cliente: 'cod_cliente';
    solicitacao2_chamado: 'solicitacao2_chamado';
    assunto_chamado: 'assunto_chamado';
    email_chamado: 'email_chamado';
    prior_chamado: 'prior_chamado';
    cod_classificacao: 'cod_classificacao';
  };

  export type ChamadoScalarFieldEnum =
    (typeof ChamadoScalarFieldEnum)[keyof typeof ChamadoScalarFieldEnum];

  export const CidadeScalarFieldEnum: {
    cod_cidade: 'cod_cidade';
    nome_cidade: 'nome_cidade';
    codibge_cidade: 'codibge_cidade';
    uf_cidade: 'uf_cidade';
  };

  export type CidadeScalarFieldEnum =
    (typeof CidadeScalarFieldEnum)[keyof typeof CidadeScalarFieldEnum];

  export const ClassificacaoScalarFieldEnum: {
    cod_classificacao: 'cod_classificacao';
    nome_classificacao: 'nome_classificacao';
    ativo_classificacao: 'ativo_classificacao';
  };

  export type ClassificacaoScalarFieldEnum =
    (typeof ClassificacaoScalarFieldEnum)[keyof typeof ClassificacaoScalarFieldEnum];

  export const ClienteScalarFieldEnum: {
    cod_cliente: 'cod_cliente';
    nome_cliente: 'nome_cliente';
    razao_cliente: 'razao_cliente';
    end_cliente: 'end_cliente';
    bairro_cliente: 'bairro_cliente';
    cep_cliente: 'cep_cliente';
    fone_cliente: 'fone_cliente';
    cnpj_cliente: 'cnpj_cliente';
    ie_cliente: 'ie_cliente';
    uf_cliente: 'uf_cliente';
    fax_cliente: 'fax_cliente';
    contato_cliente: 'contato_cliente';
    funccontato_cliente: 'funccontato_cliente';
    endcob_cliente: 'endcob_cliente';
    bairrocob_cliente: 'bairrocob_cliente';
    cepcob_cliente: 'cepcob_cliente';
    cidadecob_cliente: 'cidadecob_cliente';
    ufcob_cliente: 'ufcob_cliente';
    ativo_cliente: 'ativo_cliente';
    obs_cliente: 'obs_cliente';
    im_cliente: 'im_cliente';
    cod_cidade: 'cod_cidade';
    numend_cliente: 'numend_cliente';
    comend_cliente: 'comend_cliente';
    email_cliente: 'email_cliente';
    codbanco_cliente: 'codbanco_cliente';
    sla_cliente: 'sla_cliente';
  };

  export type ClienteScalarFieldEnum =
    (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum];

  export const ComposicaoScalarFieldEnum: {
    cod_composicao: 'cod_composicao';
    cod_fatura: 'cod_fatura';
    cod_cliente: 'cod_cliente';
    cod_projeto: 'cod_projeto';
    cod_tarefa: 'cod_tarefa';
    cod_recurso: 'cod_recurso';
    hrfat_composicao: 'hrfat_composicao';
    hrnfat_composicao: 'hrnfat_composicao';
    vrhr_composicao: 'vrhr_composicao';
    vrfat_composicao: 'vrfat_composicao';
  };

  export type ComposicaoScalarFieldEnum =
    (typeof ComposicaoScalarFieldEnum)[keyof typeof ComposicaoScalarFieldEnum];

  export const ContatoScalarFieldEnum: {
    cod_contato: 'cod_contato';
    data_contato: 'data_contato';
    hora_contato: 'hora_contato';
    nomeusuario_contato: 'nomeusuario_contato';
    desc_contato: 'desc_contato';
    cod_lista: 'cod_lista';
  };

  export type ContatoScalarFieldEnum =
    (typeof ContatoScalarFieldEnum)[keyof typeof ContatoScalarFieldEnum];

  export const CtissScalarFieldEnum: {
    cod_ctiss: 'cod_ctiss';
    num_ctiss: 'num_ctiss';
    subitem_ctiss: 'subitem_ctiss';
    descr_ctiss: 'descr_ctiss';
    csll_ctiss: 'csll_ctiss';
    pis_ctiss: 'pis_ctiss';
    cofins_ctiss: 'cofins_ctiss';
    irrf_ctiss: 'irrf_ctiss';
    aliq_ctiss: 'aliq_ctiss';
    aliqret_ctiss: 'aliqret_ctiss';
  };

  export type CtissScalarFieldEnum =
    (typeof CtissScalarFieldEnum)[keyof typeof CtissScalarFieldEnum];

  export const DespesaScalarFieldEnum: {
    cod_despesa: 'cod_despesa';
    cod_recurso: 'cod_recurso';
    cod_tpdesp: 'cod_tpdesp';
    valor_despesa: 'valor_despesa';
    mesano_despesa: 'mesano_despesa';
  };

  export type DespesaScalarFieldEnum =
    (typeof DespesaScalarFieldEnum)[keyof typeof DespesaScalarFieldEnum];

  export const DesprecScalarFieldEnum: {
    cod_desprec: 'cod_desprec';
    cod_recurso: 'cod_recurso';
    cod_tpdesp: 'cod_tpdesp';
    valor_desprec: 'valor_desprec';
  };

  export type DesprecScalarFieldEnum =
    (typeof DesprecScalarFieldEnum)[keyof typeof DesprecScalarFieldEnum];

  export const EmpresaScalarFieldEnum: {
    cod_empresa: 'cod_empresa';
    nome_empresa: 'nome_empresa';
    razao_empresa: 'razao_empresa';
    end_empresa: 'end_empresa';
    bairro_empresa: 'bairro_empresa';
    cep_empresa: 'cep_empresa';
    ddd_empresa: 'ddd_empresa';
    fone_empresa: 'fone_empresa';
    cnpj_empresa: 'cnpj_empresa';
    ie_empresa: 'ie_empresa';
    im_empresa: 'im_empresa';
    cod_cidade: 'cod_cidade';
    certificado_empresa: 'certificado_empresa';
    email_empresa: 'email_empresa';
  };

  export type EmpresaScalarFieldEnum =
    (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum];

  export const FaseScalarFieldEnum: {
    cod_fase: 'cod_fase';
    nome_fase: 'nome_fase';
  };

  export type FaseScalarFieldEnum =
    (typeof FaseScalarFieldEnum)[keyof typeof FaseScalarFieldEnum];

  export const FatdesScalarFieldEnum: {
    cod_fatdes: 'cod_fatdes';
    mesano_fatdes: 'mesano_fatdes';
    desc_fatdes: 'desc_fatdes';
    vrdesp_fatdes: 'vrdesp_fatdes';
    dtpag_fatdes: 'dtpag_fatdes';
    obs_fatdes: 'obs_fatdes';
    dtven_fatdes: 'dtven_fatdes';
  };

  export type FatdesScalarFieldEnum =
    (typeof FatdesScalarFieldEnum)[keyof typeof FatdesScalarFieldEnum];

  export const FatfunScalarFieldEnum: {
    cod_fatfun: 'cod_fatfun';
    mesano_fatfun: 'mesano_fatfun';
    nome_fatfun: 'nome_fatfun';
    vrdesl_fatfun: 'vrdesl_fatfun';
    vralm_fatfun: 'vralm_fatfun';
    vrsal_fatfun: 'vrsal_fatfun';
    dtpag_fatfun: 'dtpag_fatfun';
    obs_fatfun: 'obs_fatfun';
    dtpag1_fatfun: 'dtpag1_fatfun';
    dtpag2_fatfun: 'dtpag2_fatfun';
    cod_recurso: 'cod_recurso';
  };

  export type FatfunScalarFieldEnum =
    (typeof FatfunScalarFieldEnum)[keyof typeof FatfunScalarFieldEnum];

  export const FatrecScalarFieldEnum: {
    cod_fatrec: 'cod_fatrec';
    cod_cliente: 'cod_cliente';
    desc_fatrec: 'desc_fatrec';
    qtdhora_fatrec: 'qtdhora_fatrec';
    vrhora_fatrec: 'vrhora_fatrec';
    vrtot_fatrec: 'vrtot_fatrec';
    dtvenc_fatrec: 'dtvenc_fatrec';
    dtnf_fatrec: 'dtnf_fatrec';
    dtcob_fatrec: 'dtcob_fatrec';
    dtpag_fatrec: 'dtpag_fatrec';
    vrpag_fatrec: 'vrpag_fatrec';
    imp_fatrec: 'imp_fatrec';
    mesano_fatrec: 'mesano_fatrec';
    obs_fatrec: 'obs_fatrec';
    cod_recurso: 'cod_recurso';
    perccom_fatrec: 'perccom_fatrec';
    dtpgcom_fatrec: 'dtpgcom_fatrec';
    cod_empresa: 'cod_empresa';
    nf_fatrec: 'nf_fatrec';
  };

  export type FatrecScalarFieldEnum =
    (typeof FatrecScalarFieldEnum)[keyof typeof FatrecScalarFieldEnum];

  export const FaturaScalarFieldEnum: {
    cod_fatura: 'cod_fatura';
    mesano_fatura: 'mesano_fatura';
    desp_fatura: 'desp_fatura';
    imp_fatura: 'imp_fatura';
    lucro_fatura: 'lucro_fatura';
  };

  export type FaturaScalarFieldEnum =
    (typeof FaturaScalarFieldEnum)[keyof typeof FaturaScalarFieldEnum];

  export const FaturamentoScalarFieldEnum: {
    cod_faturamento: 'cod_faturamento';
    data_faturamento: 'data_faturamento';
    hora_faturamento: 'hora_faturamento';
    usu_faturamento: 'usu_faturamento';
    ini_faturamento: 'ini_faturamento';
    fim_faturamento: 'fim_faturamento';
    status_faturamento: 'status_faturamento';
    mesano_faturamento: 'mesano_faturamento';
  };

  export type FaturamentoScalarFieldEnum =
    (typeof FaturamentoScalarFieldEnum)[keyof typeof FaturamentoScalarFieldEnum];

  export const GrupoScalarFieldEnum: {
    cod_grupo: 'cod_grupo';
    desc_grupo: 'desc_grupo';
  };

  export type GrupoScalarFieldEnum =
    (typeof GrupoScalarFieldEnum)[keyof typeof GrupoScalarFieldEnum];

  export const HistchamadoScalarFieldEnum: {
    cod_histchamado: 'cod_histchamado';
    cod_chamado: 'cod_chamado';
    data_histchamado: 'data_histchamado';
    hora_histchamado: 'hora_histchamado';
    desc_histchamado: 'desc_histchamado';
  };

  export type HistchamadoScalarFieldEnum =
    (typeof HistchamadoScalarFieldEnum)[keyof typeof HistchamadoScalarFieldEnum];

  export const ItavaliadoScalarFieldEnum: {
    codaval_itavaliado: 'codaval_itavaliado';
    codrec_itavaliado: 'codrec_itavaliado';
    codmat_itavaliado: 'codmat_itavaliado';
    coditmat_itavaliado: 'coditmat_itavaliado';
    ptoger_itavaliado: 'ptoger_itavaliado';
    ptorec_itavaliado: 'ptorec_itavaliado';
    obs_itavaliado: 'obs_itavaliado';
    nota1_itavaliado: 'nota1_itavaliado';
    nota2_itavaliado: 'nota2_itavaliado';
    nota3_itavaliado: 'nota3_itavaliado';
  };

  export type ItavaliadoScalarFieldEnum =
    (typeof ItavaliadoScalarFieldEnum)[keyof typeof ItavaliadoScalarFieldEnum];

  export const ItmatrizScalarFieldEnum: {
    codmat_itmatriz: 'codmat_itmatriz';
    cod_itmatriz: 'cod_itmatriz';
    nota1_itmatriz: 'nota1_itmatriz';
    nota2_itmatriz: 'nota2_itmatriz';
    nota3_itmatriz: 'nota3_itmatriz';
    questao_itmatriz: 'questao_itmatriz';
  };

  export type ItmatrizScalarFieldEnum =
    (typeof ItmatrizScalarFieldEnum)[keyof typeof ItmatrizScalarFieldEnum];

  export const LayoutScalarFieldEnum: {
    cod_layout: 'cod_layout';
    tabela_layout: 'tabela_layout';
    campo_layout: 'campo_layout';
    posicao_layout: 'posicao_layout';
  };

  export type LayoutScalarFieldEnum =
    (typeof LayoutScalarFieldEnum)[keyof typeof LayoutScalarFieldEnum];

  export const ListaScalarFieldEnum: {
    cod_lista: 'cod_lista';
    cod_grupo: 'cod_grupo';
    cod_status: 'cod_status';
    cgccpf_lista: 'cgccpf_lista';
    id_lista: 'id_lista';
    nome_lista: 'nome_lista';
    end_lista: 'end_lista';
    num_lista: 'num_lista';
    comp_lista: 'comp_lista';
    cep_lista: 'cep_lista';
    bairro_lista: 'bairro_lista';
    cidade_lista: 'cidade_lista';
    uf_lista: 'uf_lista';
    email_lista: 'email_lista';
    dtcontactar_lista: 'dtcontactar_lista';
    dtcad_lista: 'dtcad_lista';
    obs_lista: 'obs_lista';
  };

  export type ListaScalarFieldEnum =
    (typeof ListaScalarFieldEnum)[keyof typeof ListaScalarFieldEnum];

  export const MatrizScalarFieldEnum: {
    cod_matriz: 'cod_matriz';
    desc_matriz: 'desc_matriz';
    status_matriz: 'status_matriz';
  };

  export type MatrizScalarFieldEnum =
    (typeof MatrizScalarFieldEnum)[keyof typeof MatrizScalarFieldEnum];

  export const MensagemScalarFieldEnum: {
    cod_mensagem: 'cod_mensagem';
    desc_mensagem: 'desc_mensagem';
  };

  export type MensagemScalarFieldEnum =
    (typeof MensagemScalarFieldEnum)[keyof typeof MensagemScalarFieldEnum];

  export const MetaScalarFieldEnum: {
    codproj_meta: 'codproj_meta';
    codarea_meta: 'codarea_meta';
    codfase_meta: 'codfase_meta';
    tempo_meta: 'tempo_meta';
    altesc_meta: 'altesc_meta';
  };

  export type MetaScalarFieldEnum =
    (typeof MetaScalarFieldEnum)[keyof typeof MetaScalarFieldEnum];

  export const Modulo_sistemaScalarFieldEnum: {
    cod_modulo: 'cod_modulo';
    desc_modulo: 'desc_modulo';
  };

  export type Modulo_sistemaScalarFieldEnum =
    (typeof Modulo_sistemaScalarFieldEnum)[keyof typeof Modulo_sistemaScalarFieldEnum];

  export const NfseScalarFieldEnum: {
    cod_nfse: 'cod_nfse';
    num_nfse: 'num_nfse';
    dtemissao_nfse: 'dtemissao_nfse';
    hremissao_nfse: 'hremissao_nfse';
    cod_empresa: 'cod_empresa';
    cod_cliente: 'cod_cliente';
    discr_nfse: 'discr_nfse';
    cod_ctiss: 'cod_ctiss';
    natoper_nfse: 'natoper_nfse';
    regtrib_nfse: 'regtrib_nfse';
    vrtot_nfse: 'vrtot_nfse';
    vrded_nfse: 'vrded_nfse';
    vrdesc1_nfse: 'vrdesc1_nfse';
    vrdesc2_nfse: 'vrdesc2_nfse';
    vrir_nfse: 'vrir_nfse';
    vrpis_nfse: 'vrpis_nfse';
    vrcofins_nfse: 'vrcofins_nfse';
    vrcsll_nfse: 'vrcsll_nfse';
    vrout_nfse: 'vrout_nfse';
    issret_nfse: 'issret_nfse';
    aliqiss_nfse: 'aliqiss_nfse';
    vrinss_nfse: 'vrinss_nfse';
    doc_nfse: 'doc_nfse';
    aliqissret_nfse: 'aliqissret_nfse';
    xml_nfse: 'xml_nfse';
    codver_nfse: 'codver_nfse';
    logtrans_nfse: 'logtrans_nfse';
    logcan_nfse: 'logcan_nfse';
    xmlformat_nfse: 'xmlformat_nfse';
    prot_nfse: 'prot_nfse';
    chvcan_nfse: 'chvcan_nfse';
    dtcanc_nfse: 'dtcanc_nfse';
    tipoper_nfse: 'tipoper_nfse';
    opsimnac_nfse: 'opsimnac_nfse';
    csll_nfse: 'csll_nfse';
    pis_nfse: 'pis_nfse';
    cofins_nfse: 'cofins_nfse';
    irrf_nfse: 'irrf_nfse';
  };

  export type NfseScalarFieldEnum =
    (typeof NfseScalarFieldEnum)[keyof typeof NfseScalarFieldEnum];

  export const NivelScalarFieldEnum: {
    cod_nivel: 'cod_nivel';
    nome_nivel: 'nome_nivel';
    perc_nivel: 'perc_nivel';
  };

  export type NivelScalarFieldEnum =
    (typeof NivelScalarFieldEnum)[keyof typeof NivelScalarFieldEnum];

  export const OsScalarFieldEnum: {
    cod_os: 'cod_os';
    codtrf_os: 'codtrf_os';
    dtini_os: 'dtini_os';
    hrini_os: 'hrini_os';
    hrfim_os: 'hrfim_os';
    obs_os: 'obs_os';
    status_os: 'status_os';
    produtivo_os: 'produtivo_os';
    codrec_os: 'codrec_os';
    produtivo2_os: 'produtivo2_os';
    respcli_os: 'respcli_os';
    remdes_os: 'remdes_os';
    abono_os: 'abono_os';
    desloc_os: 'desloc_os';
    obs: 'obs';
    dtinc_os: 'dtinc_os';
    faturado_os: 'faturado_os';
    perc_os: 'perc_os';
    cod_faturamento: 'cod_faturamento';
    comp_os: 'comp_os';
    valid_os: 'valid_os';
    vrhr_os: 'vrhr_os';
    num_os: 'num_os';
    chamado_os: 'chamado_os';
  };

  export type OsScalarFieldEnum =
    (typeof OsScalarFieldEnum)[keyof typeof OsScalarFieldEnum];

  export const ParametrosScalarFieldEnum: {
    cod_parametro: 'cod_parametro';
    descr_parametro: 'descr_parametro';
    valor_parametro: 'valor_parametro';
  };

  export type ParametrosScalarFieldEnum =
    (typeof ParametrosScalarFieldEnum)[keyof typeof ParametrosScalarFieldEnum];

  export const ParcelaScalarFieldEnum: {
    cod_parcela: 'cod_parcela';
    cod_lista: 'cod_lista';
    data_parcela: 'data_parcela';
    venc_parcela: 'venc_parcela';
    pag_parcela: 'pag_parcela';
    valor_parcela: 'valor_parcela';
    juros_parcela: 'juros_parcela';
    multa_parcela: 'multa_parcela';
    desconto_parcela: 'desconto_parcela';
    status_parcela: 'status_parcela';
    id_parcela: 'id_parcela';
  };

  export type ParcelaScalarFieldEnum =
    (typeof ParcelaScalarFieldEnum)[keyof typeof ParcelaScalarFieldEnum];

  export const PautaScalarFieldEnum: {
    cod_pauta: 'cod_pauta';
    cod_recurso: 'cod_recurso';
    data_pauta: 'data_pauta';
    prazo_pauta: 'prazo_pauta';
    concl_pauta: 'concl_pauta';
    desc_pauta: 'desc_pauta';
    obs_pauta: 'obs_pauta';
  };

  export type PautaScalarFieldEnum =
    (typeof PautaScalarFieldEnum)[keyof typeof PautaScalarFieldEnum];

  export const PontoScalarFieldEnum: {
    cod_ponto: 'cod_ponto';
    entrada_ponto: 'entrada_ponto';
    saida_ponto: 'saida_ponto';
    cod_recurso: 'cod_recurso';
  };

  export type PontoScalarFieldEnum =
    (typeof PontoScalarFieldEnum)[keyof typeof PontoScalarFieldEnum];

  export const ProjetoScalarFieldEnum: {
    cod_projeto: 'cod_projeto';
    nome_projeto: 'nome_projeto';
    codcli_projeto: 'codcli_projeto';
    respcli_projeto: 'respcli_projeto';
    proposta_projeto: 'proposta_projeto';
    codrec_projeto: 'codrec_projeto';
    perc_projeto: 'perc_projeto';
    loginc_projeto: 'loginc_projeto';
    logalt_projeto: 'logalt_projeto';
    qtdhoras_projeto: 'qtdhoras_projeto';
    status_projeto: 'status_projeto';
  };

  export type ProjetoScalarFieldEnum =
    (typeof ProjetoScalarFieldEnum)[keyof typeof ProjetoScalarFieldEnum];

  export const RecursoScalarFieldEnum: {
    cod_recurso: 'cod_recurso';
    nome_recurso: 'nome_recurso';
    fone_recurso: 'fone_recurso';
    ativo_recurso: 'ativo_recurso';
    codusr_recurso: 'codusr_recurso';
    cod_nivel: 'cod_nivel';
    hrdia_recurso: 'hrdia_recurso';
    percprod_recurso: 'percprod_recurso';
    email_recurso: 'email_recurso';
    dtlimite_recurso: 'dtlimite_recurso';
    permapo_recurso: 'permapo_recurso';
    matr_recurso: 'matr_recurso';
    obs_recurso: 'obs_recurso';
    custo_recurso: 'custo_recurso';
    receita_recurso: 'receita_recurso';
    tpcusto_recurso: 'tpcusto_recurso';
  };

  export type RecursoScalarFieldEnum =
    (typeof RecursoScalarFieldEnum)[keyof typeof RecursoScalarFieldEnum];

  export const ResconScalarFieldEnum: {
    cod_rescon: 'cod_rescon';
    cod_fatura: 'cod_fatura';
    cod_recurso: 'cod_recurso';
    hrfat_rescon: 'hrfat_rescon';
    hrnfat_rescon: 'hrnfat_rescon';
    vrfat_rescon: 'vrfat_rescon';
    vrnfat_rescon: 'vrnfat_rescon';
    realizado_rescon: 'realizado_rescon';
    disponivel_rescon: 'disponivel_rescon';
    perc1_rescon: 'perc1_rescon';
    perc2_rescon: 'perc2_rescon';
    perc3_rescon: 'perc3_rescon';
    custo_rescon: 'custo_rescon';
    contrib_rescon: 'contrib_rescon';
    perccontrib_rescon: 'perccontrib_rescon';
    hrbase_rescon: 'hrbase_rescon';
    mo_rescon: 'mo_rescon';
    desp_rescon: 'desp_rescon';
  };

  export type ResconScalarFieldEnum =
    (typeof ResconScalarFieldEnum)[keyof typeof ResconScalarFieldEnum];

  export const StatusScalarFieldEnum: {
    cod_status: 'cod_status';
    desc_status: 'desc_status';
  };

  export type StatusScalarFieldEnum =
    (typeof StatusScalarFieldEnum)[keyof typeof StatusScalarFieldEnum];

  export const TarefaScalarFieldEnum: {
    cod_tarefa: 'cod_tarefa';
    nome_tarefa: 'nome_tarefa';
    codpro_tarefa: 'codpro_tarefa';
    codrec_tarefa: 'codrec_tarefa';
    dtsol_tarefa: 'dtsol_tarefa';
    dtaprov_tarefa: 'dtaprov_tarefa';
    dtprevent_tarefa: 'dtprevent_tarefa';
    hrest_tarefa: 'hrest_tarefa';
    hratesc_tarefa: 'hratesc_tarefa';
    margem_tarefa: 'margem_tarefa';
    status_tarefa: 'status_tarefa';
    ordem_tarefa: 'ordem_tarefa';
    cod_area: 'cod_area';
    estimado_tarefa: 'estimado_tarefa';
    cod_tipotrf: 'cod_tipotrf';
    codrecresp_tarefa: 'codrecresp_tarefa';
    hrreal_tarefa: 'hrreal_tarefa';
    fatest_tarefa: 'fatest_tarefa';
    cod_fase: 'cod_fase';
    valini_tarefa: 'valini_tarefa';
    valfim_tarefa: 'valfim_tarefa';
    perimp_tarefa: 'perimp_tarefa';
    dtinc_tarefa: 'dtinc_tarefa';
    perc_tarefa: 'perc_tarefa';
    fatura_tarefa: 'fatura_tarefa';
    valida_tarefa: 'valida_tarefa';
    vrhr_tarefa: 'vrhr_tarefa';
    obs_tarefa: 'obs_tarefa';
    limmes_tarefa: 'limmes_tarefa';
    exibecham_tarefa: 'exibecham_tarefa';
  };

  export type TarefaScalarFieldEnum =
    (typeof TarefaScalarFieldEnum)[keyof typeof TarefaScalarFieldEnum];

  export const Tela_sistemaScalarFieldEnum: {
    cod_tela: 'cod_tela';
    cod_modulo: 'cod_modulo';
    desc_tela: 'desc_tela';
  };

  export type Tela_sistemaScalarFieldEnum =
    (typeof Tela_sistemaScalarFieldEnum)[keyof typeof Tela_sistemaScalarFieldEnum];

  export const TelefoneScalarFieldEnum: {
    cod_telefone: 'cod_telefone';
    cod_lista: 'cod_lista';
    ddd_telefone: 'ddd_telefone';
    numero_telefone: 'numero_telefone';
    desc_telefone: 'desc_telefone';
  };

  export type TelefoneScalarFieldEnum =
    (typeof TelefoneScalarFieldEnum)[keyof typeof TelefoneScalarFieldEnum];

  export const TipotrfScalarFieldEnum: {
    cod_tipotrf: 'cod_tipotrf';
    nome_tipotrf: 'nome_tipotrf';
  };

  export type TipotrfScalarFieldEnum =
    (typeof TipotrfScalarFieldEnum)[keyof typeof TipotrfScalarFieldEnum];

  export const TpdespScalarFieldEnum: {
    cod_tpdesp: 'cod_tpdesp';
    nome_tpdesp: 'nome_tpdesp';
  };

  export type TpdespScalarFieldEnum =
    (typeof TpdespScalarFieldEnum)[keyof typeof TpdespScalarFieldEnum];

  export const UsuarioScalarFieldEnum: {
    cod_usuario: 'cod_usuario';
    nome_usuario: 'nome_usuario';
    id_usuario: 'id_usuario';
    senha: 'senha';
    tipo_usuario: 'tipo_usuario';
    permtar_usuario: 'permtar_usuario';
    altsen_usuario: 'altsen_usuario';
    perproj1_usuario: 'perproj1_usuario';
    perproj2_usuario: 'perproj2_usuario';
    tela1_usuario: 'tela1_usuario';
    tela2_usuario: 'tela2_usuario';
    tela3_usuario: 'tela3_usuario';
    tela4_usuario: 'tela4_usuario';
  };

  export type UsuarioScalarFieldEnum =
    (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum];

  export const ValorScalarFieldEnum: {
    codproj_valor: 'codproj_valor';
    codtipo_valor: 'codtipo_valor';
    preco_valor: 'preco_valor';
  };

  export type ValorScalarFieldEnum =
    (typeof ValorScalarFieldEnum)[keyof typeof ValorScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
  >;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal[]'
  >;

  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Bytes'
  >;

  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Bytes[]'
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Deep Input Types
   */

  export type acesso_sistemaWhereInput = {
    AND?: acesso_sistemaWhereInput | acesso_sistemaWhereInput[];
    OR?: acesso_sistemaWhereInput[];
    NOT?: acesso_sistemaWhereInput | acesso_sistemaWhereInput[];
    cod_usuario?: IntFilter<'acesso_sistema'> | number;
    cod_modulo?: IntFilter<'acesso_sistema'> | number;
    cod_tela?: IntFilter<'acesso_sistema'> | number;
    incluir?: StringFilter<'acesso_sistema'> | string;
    modificar?: StringFilter<'acesso_sistema'> | string;
    eliminar?: StringFilter<'acesso_sistema'> | string;
    modulo_sistema?: XOR<
      Modulo_sistemaScalarRelationFilter,
      modulo_sistemaWhereInput
    >;
    tela_sistema?: XOR<
      Tela_sistemaScalarRelationFilter,
      tela_sistemaWhereInput
    >;
    usuario?: XOR<UsuarioScalarRelationFilter, usuarioWhereInput>;
  };

  export type acesso_sistemaOrderByWithRelationInput = {
    cod_usuario?: SortOrder;
    cod_modulo?: SortOrder;
    cod_tela?: SortOrder;
    incluir?: SortOrder;
    modificar?: SortOrder;
    eliminar?: SortOrder;
    modulo_sistema?: modulo_sistemaOrderByWithRelationInput;
    tela_sistema?: tela_sistemaOrderByWithRelationInput;
    usuario?: usuarioOrderByWithRelationInput;
  };

  export type acesso_sistemaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_usuario_cod_modulo_cod_tela?: acesso_sistemaCod_usuarioCod_moduloCod_telaCompoundUniqueInput;
      AND?: acesso_sistemaWhereInput | acesso_sistemaWhereInput[];
      OR?: acesso_sistemaWhereInput[];
      NOT?: acesso_sistemaWhereInput | acesso_sistemaWhereInput[];
      cod_usuario?: IntFilter<'acesso_sistema'> | number;
      cod_modulo?: IntFilter<'acesso_sistema'> | number;
      cod_tela?: IntFilter<'acesso_sistema'> | number;
      incluir?: StringFilter<'acesso_sistema'> | string;
      modificar?: StringFilter<'acesso_sistema'> | string;
      eliminar?: StringFilter<'acesso_sistema'> | string;
      modulo_sistema?: XOR<
        Modulo_sistemaScalarRelationFilter,
        modulo_sistemaWhereInput
      >;
      tela_sistema?: XOR<
        Tela_sistemaScalarRelationFilter,
        tela_sistemaWhereInput
      >;
      usuario?: XOR<UsuarioScalarRelationFilter, usuarioWhereInput>;
    },
    'cod_usuario_cod_modulo_cod_tela'
  >;

  export type acesso_sistemaOrderByWithAggregationInput = {
    cod_usuario?: SortOrder;
    cod_modulo?: SortOrder;
    cod_tela?: SortOrder;
    incluir?: SortOrder;
    modificar?: SortOrder;
    eliminar?: SortOrder;
    _count?: acesso_sistemaCountOrderByAggregateInput;
    _avg?: acesso_sistemaAvgOrderByAggregateInput;
    _max?: acesso_sistemaMaxOrderByAggregateInput;
    _min?: acesso_sistemaMinOrderByAggregateInput;
    _sum?: acesso_sistemaSumOrderByAggregateInput;
  };

  export type acesso_sistemaScalarWhereWithAggregatesInput = {
    AND?:
      | acesso_sistemaScalarWhereWithAggregatesInput
      | acesso_sistemaScalarWhereWithAggregatesInput[];
    OR?: acesso_sistemaScalarWhereWithAggregatesInput[];
    NOT?:
      | acesso_sistemaScalarWhereWithAggregatesInput
      | acesso_sistemaScalarWhereWithAggregatesInput[];
    cod_usuario?: IntWithAggregatesFilter<'acesso_sistema'> | number;
    cod_modulo?: IntWithAggregatesFilter<'acesso_sistema'> | number;
    cod_tela?: IntWithAggregatesFilter<'acesso_sistema'> | number;
    incluir?: StringWithAggregatesFilter<'acesso_sistema'> | string;
    modificar?: StringWithAggregatesFilter<'acesso_sistema'> | string;
    eliminar?: StringWithAggregatesFilter<'acesso_sistema'> | string;
  };

  export type agenrecWhereInput = {
    AND?: agenrecWhereInput | agenrecWhereInput[];
    OR?: agenrecWhereInput[];
    NOT?: agenrecWhereInput | agenrecWhereInput[];
    cod_agenrec?: IntFilter<'agenrec'> | number;
    cod_recurso?: IntFilter<'agenrec'> | number;
    data_agenrec?: DateTimeFilter<'agenrec'> | Date | string;
    hrini_agenrec?: StringFilter<'agenrec'> | string;
    hrfim_agenrec?: StringFilter<'agenrec'> | string;
    status_agenrec?: IntFilter<'agenrec'> | number;
    obs_agenrec?: StringNullableFilter<'agenrec'> | string | null;
    custo_agenrec?:
      | DecimalNullableFilter<'agenrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | DecimalNullableFilter<'agenrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: IntNullableFilter<'agenrec'> | number | null;
    recurso?: XOR<RecursoScalarRelationFilter, recursoWhereInput>;
  };

  export type agenrecOrderByWithRelationInput = {
    cod_agenrec?: SortOrder;
    cod_recurso?: SortOrder;
    data_agenrec?: SortOrder;
    hrini_agenrec?: SortOrder;
    hrfim_agenrec?: SortOrder;
    status_agenrec?: SortOrder;
    obs_agenrec?: SortOrderInput | SortOrder;
    custo_agenrec?: SortOrderInput | SortOrder;
    receita_agenrec?: SortOrderInput | SortOrder;
    tpcusto_agenrec?: SortOrderInput | SortOrder;
    recurso?: recursoOrderByWithRelationInput;
  };

  export type agenrecWhereUniqueInput = Prisma.AtLeast<
    {
      cod_agenrec?: number;
      AND?: agenrecWhereInput | agenrecWhereInput[];
      OR?: agenrecWhereInput[];
      NOT?: agenrecWhereInput | agenrecWhereInput[];
      cod_recurso?: IntFilter<'agenrec'> | number;
      data_agenrec?: DateTimeFilter<'agenrec'> | Date | string;
      hrini_agenrec?: StringFilter<'agenrec'> | string;
      hrfim_agenrec?: StringFilter<'agenrec'> | string;
      status_agenrec?: IntFilter<'agenrec'> | number;
      obs_agenrec?: StringNullableFilter<'agenrec'> | string | null;
      custo_agenrec?:
        | DecimalNullableFilter<'agenrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      receita_agenrec?:
        | DecimalNullableFilter<'agenrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      tpcusto_agenrec?: IntNullableFilter<'agenrec'> | number | null;
      recurso?: XOR<RecursoScalarRelationFilter, recursoWhereInput>;
    },
    'cod_agenrec'
  >;

  export type agenrecOrderByWithAggregationInput = {
    cod_agenrec?: SortOrder;
    cod_recurso?: SortOrder;
    data_agenrec?: SortOrder;
    hrini_agenrec?: SortOrder;
    hrfim_agenrec?: SortOrder;
    status_agenrec?: SortOrder;
    obs_agenrec?: SortOrderInput | SortOrder;
    custo_agenrec?: SortOrderInput | SortOrder;
    receita_agenrec?: SortOrderInput | SortOrder;
    tpcusto_agenrec?: SortOrderInput | SortOrder;
    _count?: agenrecCountOrderByAggregateInput;
    _avg?: agenrecAvgOrderByAggregateInput;
    _max?: agenrecMaxOrderByAggregateInput;
    _min?: agenrecMinOrderByAggregateInput;
    _sum?: agenrecSumOrderByAggregateInput;
  };

  export type agenrecScalarWhereWithAggregatesInput = {
    AND?:
      | agenrecScalarWhereWithAggregatesInput
      | agenrecScalarWhereWithAggregatesInput[];
    OR?: agenrecScalarWhereWithAggregatesInput[];
    NOT?:
      | agenrecScalarWhereWithAggregatesInput
      | agenrecScalarWhereWithAggregatesInput[];
    cod_agenrec?: IntWithAggregatesFilter<'agenrec'> | number;
    cod_recurso?: IntWithAggregatesFilter<'agenrec'> | number;
    data_agenrec?: DateTimeWithAggregatesFilter<'agenrec'> | Date | string;
    hrini_agenrec?: StringWithAggregatesFilter<'agenrec'> | string;
    hrfim_agenrec?: StringWithAggregatesFilter<'agenrec'> | string;
    status_agenrec?: IntWithAggregatesFilter<'agenrec'> | number;
    obs_agenrec?: StringNullableWithAggregatesFilter<'agenrec'> | string | null;
    custo_agenrec?:
      | DecimalNullableWithAggregatesFilter<'agenrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | DecimalNullableWithAggregatesFilter<'agenrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?:
      | IntNullableWithAggregatesFilter<'agenrec'>
      | number
      | null;
  };

  export type areaWhereInput = {
    AND?: areaWhereInput | areaWhereInput[];
    OR?: areaWhereInput[];
    NOT?: areaWhereInput | areaWhereInput[];
    cod_area?: IntFilter<'area'> | number;
    nome_area?: StringFilter<'area'> | string;
    meta?: MetaListRelationFilter;
    tarefa?: TarefaListRelationFilter;
  };

  export type areaOrderByWithRelationInput = {
    cod_area?: SortOrder;
    nome_area?: SortOrder;
    meta?: metaOrderByRelationAggregateInput;
    tarefa?: tarefaOrderByRelationAggregateInput;
  };

  export type areaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_area?: number;
      AND?: areaWhereInput | areaWhereInput[];
      OR?: areaWhereInput[];
      NOT?: areaWhereInput | areaWhereInput[];
      nome_area?: StringFilter<'area'> | string;
      meta?: MetaListRelationFilter;
      tarefa?: TarefaListRelationFilter;
    },
    'cod_area'
  >;

  export type areaOrderByWithAggregationInput = {
    cod_area?: SortOrder;
    nome_area?: SortOrder;
    _count?: areaCountOrderByAggregateInput;
    _avg?: areaAvgOrderByAggregateInput;
    _max?: areaMaxOrderByAggregateInput;
    _min?: areaMinOrderByAggregateInput;
    _sum?: areaSumOrderByAggregateInput;
  };

  export type areaScalarWhereWithAggregatesInput = {
    AND?:
      | areaScalarWhereWithAggregatesInput
      | areaScalarWhereWithAggregatesInput[];
    OR?: areaScalarWhereWithAggregatesInput[];
    NOT?:
      | areaScalarWhereWithAggregatesInput
      | areaScalarWhereWithAggregatesInput[];
    cod_area?: IntWithAggregatesFilter<'area'> | number;
    nome_area?: StringWithAggregatesFilter<'area'> | string;
  };

  export type avaliacaoWhereInput = {
    AND?: avaliacaoWhereInput | avaliacaoWhereInput[];
    OR?: avaliacaoWhereInput[];
    NOT?: avaliacaoWhereInput | avaliacaoWhereInput[];
    cod_avaliacao?: IntFilter<'avaliacao'> | number;
    anomes_avaliacao?: StringFilter<'avaliacao'> | string;
    data_avaliacao?: DateTimeFilter<'avaliacao'> | Date | string;
    codrec_avaliacao?: IntFilter<'avaliacao'> | number;
    status_avaliacao?: StringFilter<'avaliacao'> | string;
    codpro_avaliacao?: IntFilter<'avaliacao'> | number;
    projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
    avaliado?: AvaliadoListRelationFilter;
  };

  export type avaliacaoOrderByWithRelationInput = {
    cod_avaliacao?: SortOrder;
    anomes_avaliacao?: SortOrder;
    data_avaliacao?: SortOrder;
    codrec_avaliacao?: SortOrder;
    status_avaliacao?: SortOrder;
    codpro_avaliacao?: SortOrder;
    projeto?: projetoOrderByWithRelationInput;
    avaliado?: avaliadoOrderByRelationAggregateInput;
  };

  export type avaliacaoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_avaliacao?: number;
      AND?: avaliacaoWhereInput | avaliacaoWhereInput[];
      OR?: avaliacaoWhereInput[];
      NOT?: avaliacaoWhereInput | avaliacaoWhereInput[];
      anomes_avaliacao?: StringFilter<'avaliacao'> | string;
      data_avaliacao?: DateTimeFilter<'avaliacao'> | Date | string;
      codrec_avaliacao?: IntFilter<'avaliacao'> | number;
      status_avaliacao?: StringFilter<'avaliacao'> | string;
      codpro_avaliacao?: IntFilter<'avaliacao'> | number;
      projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
      avaliado?: AvaliadoListRelationFilter;
    },
    'cod_avaliacao'
  >;

  export type avaliacaoOrderByWithAggregationInput = {
    cod_avaliacao?: SortOrder;
    anomes_avaliacao?: SortOrder;
    data_avaliacao?: SortOrder;
    codrec_avaliacao?: SortOrder;
    status_avaliacao?: SortOrder;
    codpro_avaliacao?: SortOrder;
    _count?: avaliacaoCountOrderByAggregateInput;
    _avg?: avaliacaoAvgOrderByAggregateInput;
    _max?: avaliacaoMaxOrderByAggregateInput;
    _min?: avaliacaoMinOrderByAggregateInput;
    _sum?: avaliacaoSumOrderByAggregateInput;
  };

  export type avaliacaoScalarWhereWithAggregatesInput = {
    AND?:
      | avaliacaoScalarWhereWithAggregatesInput
      | avaliacaoScalarWhereWithAggregatesInput[];
    OR?: avaliacaoScalarWhereWithAggregatesInput[];
    NOT?:
      | avaliacaoScalarWhereWithAggregatesInput
      | avaliacaoScalarWhereWithAggregatesInput[];
    cod_avaliacao?: IntWithAggregatesFilter<'avaliacao'> | number;
    anomes_avaliacao?: StringWithAggregatesFilter<'avaliacao'> | string;
    data_avaliacao?: DateTimeWithAggregatesFilter<'avaliacao'> | Date | string;
    codrec_avaliacao?: IntWithAggregatesFilter<'avaliacao'> | number;
    status_avaliacao?: StringWithAggregatesFilter<'avaliacao'> | string;
    codpro_avaliacao?: IntWithAggregatesFilter<'avaliacao'> | number;
  };

  export type avaliadoWhereInput = {
    AND?: avaliadoWhereInput | avaliadoWhereInput[];
    OR?: avaliadoWhereInput[];
    NOT?: avaliadoWhereInput | avaliadoWhereInput[];
    codaval_avaliado?: IntFilter<'avaliado'> | number;
    codrec_avaliado?: IntFilter<'avaliado'> | number;
    status_avaliado?: StringFilter<'avaliado'> | string;
    data_avaliado?: DateTimeNullableFilter<'avaliado'> | Date | string | null;
    hora_avaliado?: StringNullableFilter<'avaliado'> | string | null;
    usuario_avaliado?: StringNullableFilter<'avaliado'> | string | null;
    avaliacao?: XOR<AvaliacaoScalarRelationFilter, avaliacaoWhereInput>;
    recurso?: XOR<RecursoScalarRelationFilter, recursoWhereInput>;
    itavaliado?: ItavaliadoListRelationFilter;
  };

  export type avaliadoOrderByWithRelationInput = {
    codaval_avaliado?: SortOrder;
    codrec_avaliado?: SortOrder;
    status_avaliado?: SortOrder;
    data_avaliado?: SortOrderInput | SortOrder;
    hora_avaliado?: SortOrderInput | SortOrder;
    usuario_avaliado?: SortOrderInput | SortOrder;
    avaliacao?: avaliacaoOrderByWithRelationInput;
    recurso?: recursoOrderByWithRelationInput;
    itavaliado?: itavaliadoOrderByRelationAggregateInput;
  };

  export type avaliadoWhereUniqueInput = Prisma.AtLeast<
    {
      codaval_avaliado_codrec_avaliado?: avaliadoCodaval_avaliadoCodrec_avaliadoCompoundUniqueInput;
      AND?: avaliadoWhereInput | avaliadoWhereInput[];
      OR?: avaliadoWhereInput[];
      NOT?: avaliadoWhereInput | avaliadoWhereInput[];
      codaval_avaliado?: IntFilter<'avaliado'> | number;
      codrec_avaliado?: IntFilter<'avaliado'> | number;
      status_avaliado?: StringFilter<'avaliado'> | string;
      data_avaliado?: DateTimeNullableFilter<'avaliado'> | Date | string | null;
      hora_avaliado?: StringNullableFilter<'avaliado'> | string | null;
      usuario_avaliado?: StringNullableFilter<'avaliado'> | string | null;
      avaliacao?: XOR<AvaliacaoScalarRelationFilter, avaliacaoWhereInput>;
      recurso?: XOR<RecursoScalarRelationFilter, recursoWhereInput>;
      itavaliado?: ItavaliadoListRelationFilter;
    },
    'codaval_avaliado_codrec_avaliado'
  >;

  export type avaliadoOrderByWithAggregationInput = {
    codaval_avaliado?: SortOrder;
    codrec_avaliado?: SortOrder;
    status_avaliado?: SortOrder;
    data_avaliado?: SortOrderInput | SortOrder;
    hora_avaliado?: SortOrderInput | SortOrder;
    usuario_avaliado?: SortOrderInput | SortOrder;
    _count?: avaliadoCountOrderByAggregateInput;
    _avg?: avaliadoAvgOrderByAggregateInput;
    _max?: avaliadoMaxOrderByAggregateInput;
    _min?: avaliadoMinOrderByAggregateInput;
    _sum?: avaliadoSumOrderByAggregateInput;
  };

  export type avaliadoScalarWhereWithAggregatesInput = {
    AND?:
      | avaliadoScalarWhereWithAggregatesInput
      | avaliadoScalarWhereWithAggregatesInput[];
    OR?: avaliadoScalarWhereWithAggregatesInput[];
    NOT?:
      | avaliadoScalarWhereWithAggregatesInput
      | avaliadoScalarWhereWithAggregatesInput[];
    codaval_avaliado?: IntWithAggregatesFilter<'avaliado'> | number;
    codrec_avaliado?: IntWithAggregatesFilter<'avaliado'> | number;
    status_avaliado?: StringWithAggregatesFilter<'avaliado'> | string;
    data_avaliado?:
      | DateTimeNullableWithAggregatesFilter<'avaliado'>
      | Date
      | string
      | null;
    hora_avaliado?:
      | StringNullableWithAggregatesFilter<'avaliado'>
      | string
      | null;
    usuario_avaliado?:
      | StringNullableWithAggregatesFilter<'avaliado'>
      | string
      | null;
  };

  export type chamadoWhereInput = {
    AND?: chamadoWhereInput | chamadoWhereInput[];
    OR?: chamadoWhereInput[];
    NOT?: chamadoWhereInput | chamadoWhereInput[];
    cod_chamado?: IntFilter<'chamado'> | number;
    data_chamado?: DateTimeFilter<'chamado'> | Date | string;
    hora_chamado?: StringFilter<'chamado'> | string;
    solicitacao_chamado?: BytesNullableFilter<'chamado'> | Uint8Array | null;
    conclusao_chamado?:
      | DateTimeNullableFilter<'chamado'>
      | Date
      | string
      | null;
    status_chamado?: StringFilter<'chamado'> | string;
    dtenvio_chamado?: StringNullableFilter<'chamado'> | string | null;
    cod_recurso?: IntNullableFilter<'chamado'> | number | null;
    cliente_chamado?: StringNullableFilter<'chamado'> | string | null;
    codtrf_chamado?: IntNullableFilter<'chamado'> | number | null;
    cod_cliente?: IntNullableFilter<'chamado'> | number | null;
    solicitacao2_chamado?: BytesNullableFilter<'chamado'> | Uint8Array | null;
    assunto_chamado?: StringNullableFilter<'chamado'> | string | null;
    email_chamado?: StringNullableFilter<'chamado'> | string | null;
    prior_chamado?: IntNullableFilter<'chamado'> | number | null;
    cod_classificacao?: IntNullableFilter<'chamado'> | number | null;
    cliente?: XOR<
      ClienteNullableScalarRelationFilter,
      clienteWhereInput
    > | null;
    recurso?: XOR<
      RecursoNullableScalarRelationFilter,
      recursoWhereInput
    > | null;
  };

  export type chamadoOrderByWithRelationInput = {
    cod_chamado?: SortOrder;
    data_chamado?: SortOrder;
    hora_chamado?: SortOrder;
    solicitacao_chamado?: SortOrderInput | SortOrder;
    conclusao_chamado?: SortOrderInput | SortOrder;
    status_chamado?: SortOrder;
    dtenvio_chamado?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrderInput | SortOrder;
    cliente_chamado?: SortOrderInput | SortOrder;
    codtrf_chamado?: SortOrderInput | SortOrder;
    cod_cliente?: SortOrderInput | SortOrder;
    solicitacao2_chamado?: SortOrderInput | SortOrder;
    assunto_chamado?: SortOrderInput | SortOrder;
    email_chamado?: SortOrderInput | SortOrder;
    prior_chamado?: SortOrderInput | SortOrder;
    cod_classificacao?: SortOrderInput | SortOrder;
    cliente?: clienteOrderByWithRelationInput;
    recurso?: recursoOrderByWithRelationInput;
  };

  export type chamadoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_chamado?: number;
      AND?: chamadoWhereInput | chamadoWhereInput[];
      OR?: chamadoWhereInput[];
      NOT?: chamadoWhereInput | chamadoWhereInput[];
      data_chamado?: DateTimeFilter<'chamado'> | Date | string;
      hora_chamado?: StringFilter<'chamado'> | string;
      solicitacao_chamado?: BytesNullableFilter<'chamado'> | Uint8Array | null;
      conclusao_chamado?:
        | DateTimeNullableFilter<'chamado'>
        | Date
        | string
        | null;
      status_chamado?: StringFilter<'chamado'> | string;
      dtenvio_chamado?: StringNullableFilter<'chamado'> | string | null;
      cod_recurso?: IntNullableFilter<'chamado'> | number | null;
      cliente_chamado?: StringNullableFilter<'chamado'> | string | null;
      codtrf_chamado?: IntNullableFilter<'chamado'> | number | null;
      cod_cliente?: IntNullableFilter<'chamado'> | number | null;
      solicitacao2_chamado?: BytesNullableFilter<'chamado'> | Uint8Array | null;
      assunto_chamado?: StringNullableFilter<'chamado'> | string | null;
      email_chamado?: StringNullableFilter<'chamado'> | string | null;
      prior_chamado?: IntNullableFilter<'chamado'> | number | null;
      cod_classificacao?: IntNullableFilter<'chamado'> | number | null;
      cliente?: XOR<
        ClienteNullableScalarRelationFilter,
        clienteWhereInput
      > | null;
      recurso?: XOR<
        RecursoNullableScalarRelationFilter,
        recursoWhereInput
      > | null;
    },
    'cod_chamado'
  >;

  export type chamadoOrderByWithAggregationInput = {
    cod_chamado?: SortOrder;
    data_chamado?: SortOrder;
    hora_chamado?: SortOrder;
    solicitacao_chamado?: SortOrderInput | SortOrder;
    conclusao_chamado?: SortOrderInput | SortOrder;
    status_chamado?: SortOrder;
    dtenvio_chamado?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrderInput | SortOrder;
    cliente_chamado?: SortOrderInput | SortOrder;
    codtrf_chamado?: SortOrderInput | SortOrder;
    cod_cliente?: SortOrderInput | SortOrder;
    solicitacao2_chamado?: SortOrderInput | SortOrder;
    assunto_chamado?: SortOrderInput | SortOrder;
    email_chamado?: SortOrderInput | SortOrder;
    prior_chamado?: SortOrderInput | SortOrder;
    cod_classificacao?: SortOrderInput | SortOrder;
    _count?: chamadoCountOrderByAggregateInput;
    _avg?: chamadoAvgOrderByAggregateInput;
    _max?: chamadoMaxOrderByAggregateInput;
    _min?: chamadoMinOrderByAggregateInput;
    _sum?: chamadoSumOrderByAggregateInput;
  };

  export type chamadoScalarWhereWithAggregatesInput = {
    AND?:
      | chamadoScalarWhereWithAggregatesInput
      | chamadoScalarWhereWithAggregatesInput[];
    OR?: chamadoScalarWhereWithAggregatesInput[];
    NOT?:
      | chamadoScalarWhereWithAggregatesInput
      | chamadoScalarWhereWithAggregatesInput[];
    cod_chamado?: IntWithAggregatesFilter<'chamado'> | number;
    data_chamado?: DateTimeWithAggregatesFilter<'chamado'> | Date | string;
    hora_chamado?: StringWithAggregatesFilter<'chamado'> | string;
    solicitacao_chamado?:
      | BytesNullableWithAggregatesFilter<'chamado'>
      | Uint8Array
      | null;
    conclusao_chamado?:
      | DateTimeNullableWithAggregatesFilter<'chamado'>
      | Date
      | string
      | null;
    status_chamado?: StringWithAggregatesFilter<'chamado'> | string;
    dtenvio_chamado?:
      | StringNullableWithAggregatesFilter<'chamado'>
      | string
      | null;
    cod_recurso?: IntNullableWithAggregatesFilter<'chamado'> | number | null;
    cliente_chamado?:
      | StringNullableWithAggregatesFilter<'chamado'>
      | string
      | null;
    codtrf_chamado?: IntNullableWithAggregatesFilter<'chamado'> | number | null;
    cod_cliente?: IntNullableWithAggregatesFilter<'chamado'> | number | null;
    solicitacao2_chamado?:
      | BytesNullableWithAggregatesFilter<'chamado'>
      | Uint8Array
      | null;
    assunto_chamado?:
      | StringNullableWithAggregatesFilter<'chamado'>
      | string
      | null;
    email_chamado?:
      | StringNullableWithAggregatesFilter<'chamado'>
      | string
      | null;
    prior_chamado?: IntNullableWithAggregatesFilter<'chamado'> | number | null;
    cod_classificacao?:
      | IntNullableWithAggregatesFilter<'chamado'>
      | number
      | null;
  };

  export type cidadeWhereInput = {
    AND?: cidadeWhereInput | cidadeWhereInput[];
    OR?: cidadeWhereInput[];
    NOT?: cidadeWhereInput | cidadeWhereInput[];
    cod_cidade?: IntFilter<'cidade'> | number;
    nome_cidade?: StringFilter<'cidade'> | string;
    codibge_cidade?: StringNullableFilter<'cidade'> | string | null;
    uf_cidade?: StringNullableFilter<'cidade'> | string | null;
  };

  export type cidadeOrderByWithRelationInput = {
    cod_cidade?: SortOrder;
    nome_cidade?: SortOrder;
    codibge_cidade?: SortOrderInput | SortOrder;
    uf_cidade?: SortOrderInput | SortOrder;
  };

  export type cidadeWhereUniqueInput = Prisma.AtLeast<
    {
      cod_cidade?: number;
      AND?: cidadeWhereInput | cidadeWhereInput[];
      OR?: cidadeWhereInput[];
      NOT?: cidadeWhereInput | cidadeWhereInput[];
      nome_cidade?: StringFilter<'cidade'> | string;
      codibge_cidade?: StringNullableFilter<'cidade'> | string | null;
      uf_cidade?: StringNullableFilter<'cidade'> | string | null;
    },
    'cod_cidade'
  >;

  export type cidadeOrderByWithAggregationInput = {
    cod_cidade?: SortOrder;
    nome_cidade?: SortOrder;
    codibge_cidade?: SortOrderInput | SortOrder;
    uf_cidade?: SortOrderInput | SortOrder;
    _count?: cidadeCountOrderByAggregateInput;
    _avg?: cidadeAvgOrderByAggregateInput;
    _max?: cidadeMaxOrderByAggregateInput;
    _min?: cidadeMinOrderByAggregateInput;
    _sum?: cidadeSumOrderByAggregateInput;
  };

  export type cidadeScalarWhereWithAggregatesInput = {
    AND?:
      | cidadeScalarWhereWithAggregatesInput
      | cidadeScalarWhereWithAggregatesInput[];
    OR?: cidadeScalarWhereWithAggregatesInput[];
    NOT?:
      | cidadeScalarWhereWithAggregatesInput
      | cidadeScalarWhereWithAggregatesInput[];
    cod_cidade?: IntWithAggregatesFilter<'cidade'> | number;
    nome_cidade?: StringWithAggregatesFilter<'cidade'> | string;
    codibge_cidade?:
      | StringNullableWithAggregatesFilter<'cidade'>
      | string
      | null;
    uf_cidade?: StringNullableWithAggregatesFilter<'cidade'> | string | null;
  };

  export type classificacaoWhereInput = {
    AND?: classificacaoWhereInput | classificacaoWhereInput[];
    OR?: classificacaoWhereInput[];
    NOT?: classificacaoWhereInput | classificacaoWhereInput[];
    cod_classificacao?: IntFilter<'classificacao'> | number;
    nome_classificacao?: StringFilter<'classificacao'> | string;
    ativo_classificacao?: StringNullableFilter<'classificacao'> | string | null;
  };

  export type classificacaoOrderByWithRelationInput = {
    cod_classificacao?: SortOrder;
    nome_classificacao?: SortOrder;
    ativo_classificacao?: SortOrderInput | SortOrder;
  };

  export type classificacaoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_classificacao?: number;
      AND?: classificacaoWhereInput | classificacaoWhereInput[];
      OR?: classificacaoWhereInput[];
      NOT?: classificacaoWhereInput | classificacaoWhereInput[];
      nome_classificacao?: StringFilter<'classificacao'> | string;
      ativo_classificacao?:
        | StringNullableFilter<'classificacao'>
        | string
        | null;
    },
    'cod_classificacao'
  >;

  export type classificacaoOrderByWithAggregationInput = {
    cod_classificacao?: SortOrder;
    nome_classificacao?: SortOrder;
    ativo_classificacao?: SortOrderInput | SortOrder;
    _count?: classificacaoCountOrderByAggregateInput;
    _avg?: classificacaoAvgOrderByAggregateInput;
    _max?: classificacaoMaxOrderByAggregateInput;
    _min?: classificacaoMinOrderByAggregateInput;
    _sum?: classificacaoSumOrderByAggregateInput;
  };

  export type classificacaoScalarWhereWithAggregatesInput = {
    AND?:
      | classificacaoScalarWhereWithAggregatesInput
      | classificacaoScalarWhereWithAggregatesInput[];
    OR?: classificacaoScalarWhereWithAggregatesInput[];
    NOT?:
      | classificacaoScalarWhereWithAggregatesInput
      | classificacaoScalarWhereWithAggregatesInput[];
    cod_classificacao?: IntWithAggregatesFilter<'classificacao'> | number;
    nome_classificacao?: StringWithAggregatesFilter<'classificacao'> | string;
    ativo_classificacao?:
      | StringNullableWithAggregatesFilter<'classificacao'>
      | string
      | null;
  };

  export type clienteWhereInput = {
    AND?: clienteWhereInput | clienteWhereInput[];
    OR?: clienteWhereInput[];
    NOT?: clienteWhereInput | clienteWhereInput[];
    cod_cliente?: IntFilter<'cliente'> | number;
    nome_cliente?: StringFilter<'cliente'> | string;
    razao_cliente?: StringNullableFilter<'cliente'> | string | null;
    end_cliente?: StringNullableFilter<'cliente'> | string | null;
    bairro_cliente?: StringNullableFilter<'cliente'> | string | null;
    cep_cliente?: StringNullableFilter<'cliente'> | string | null;
    fone_cliente?: StringNullableFilter<'cliente'> | string | null;
    cnpj_cliente?: StringNullableFilter<'cliente'> | string | null;
    ie_cliente?: StringNullableFilter<'cliente'> | string | null;
    uf_cliente?: StringNullableFilter<'cliente'> | string | null;
    fax_cliente?: StringNullableFilter<'cliente'> | string | null;
    contato_cliente?: StringNullableFilter<'cliente'> | string | null;
    funccontato_cliente?: StringNullableFilter<'cliente'> | string | null;
    endcob_cliente?: StringNullableFilter<'cliente'> | string | null;
    bairrocob_cliente?: StringNullableFilter<'cliente'> | string | null;
    cepcob_cliente?: StringNullableFilter<'cliente'> | string | null;
    cidadecob_cliente?: StringNullableFilter<'cliente'> | string | null;
    ufcob_cliente?: StringNullableFilter<'cliente'> | string | null;
    ativo_cliente?: IntFilter<'cliente'> | number;
    obs_cliente?: BytesNullableFilter<'cliente'> | Uint8Array | null;
    im_cliente?: StringNullableFilter<'cliente'> | string | null;
    cod_cidade?: IntNullableFilter<'cliente'> | number | null;
    numend_cliente?: StringNullableFilter<'cliente'> | string | null;
    comend_cliente?: StringNullableFilter<'cliente'> | string | null;
    email_cliente?: StringNullableFilter<'cliente'> | string | null;
    codbanco_cliente?: StringNullableFilter<'cliente'> | string | null;
    sla_cliente?: IntFilter<'cliente'> | number;
    chamados?: ChamadoListRelationFilter;
    fatrec?: FatrecListRelationFilter;
    projeto?: ProjetoListRelationFilter;
  };

  export type clienteOrderByWithRelationInput = {
    cod_cliente?: SortOrder;
    nome_cliente?: SortOrder;
    razao_cliente?: SortOrderInput | SortOrder;
    end_cliente?: SortOrderInput | SortOrder;
    bairro_cliente?: SortOrderInput | SortOrder;
    cep_cliente?: SortOrderInput | SortOrder;
    fone_cliente?: SortOrderInput | SortOrder;
    cnpj_cliente?: SortOrderInput | SortOrder;
    ie_cliente?: SortOrderInput | SortOrder;
    uf_cliente?: SortOrderInput | SortOrder;
    fax_cliente?: SortOrderInput | SortOrder;
    contato_cliente?: SortOrderInput | SortOrder;
    funccontato_cliente?: SortOrderInput | SortOrder;
    endcob_cliente?: SortOrderInput | SortOrder;
    bairrocob_cliente?: SortOrderInput | SortOrder;
    cepcob_cliente?: SortOrderInput | SortOrder;
    cidadecob_cliente?: SortOrderInput | SortOrder;
    ufcob_cliente?: SortOrderInput | SortOrder;
    ativo_cliente?: SortOrder;
    obs_cliente?: SortOrderInput | SortOrder;
    im_cliente?: SortOrderInput | SortOrder;
    cod_cidade?: SortOrderInput | SortOrder;
    numend_cliente?: SortOrderInput | SortOrder;
    comend_cliente?: SortOrderInput | SortOrder;
    email_cliente?: SortOrderInput | SortOrder;
    codbanco_cliente?: SortOrderInput | SortOrder;
    sla_cliente?: SortOrder;
    chamados?: chamadoOrderByRelationAggregateInput;
    fatrec?: fatrecOrderByRelationAggregateInput;
    projeto?: projetoOrderByRelationAggregateInput;
  };

  export type clienteWhereUniqueInput = Prisma.AtLeast<
    {
      cod_cliente?: number;
      AND?: clienteWhereInput | clienteWhereInput[];
      OR?: clienteWhereInput[];
      NOT?: clienteWhereInput | clienteWhereInput[];
      nome_cliente?: StringFilter<'cliente'> | string;
      razao_cliente?: StringNullableFilter<'cliente'> | string | null;
      end_cliente?: StringNullableFilter<'cliente'> | string | null;
      bairro_cliente?: StringNullableFilter<'cliente'> | string | null;
      cep_cliente?: StringNullableFilter<'cliente'> | string | null;
      fone_cliente?: StringNullableFilter<'cliente'> | string | null;
      cnpj_cliente?: StringNullableFilter<'cliente'> | string | null;
      ie_cliente?: StringNullableFilter<'cliente'> | string | null;
      uf_cliente?: StringNullableFilter<'cliente'> | string | null;
      fax_cliente?: StringNullableFilter<'cliente'> | string | null;
      contato_cliente?: StringNullableFilter<'cliente'> | string | null;
      funccontato_cliente?: StringNullableFilter<'cliente'> | string | null;
      endcob_cliente?: StringNullableFilter<'cliente'> | string | null;
      bairrocob_cliente?: StringNullableFilter<'cliente'> | string | null;
      cepcob_cliente?: StringNullableFilter<'cliente'> | string | null;
      cidadecob_cliente?: StringNullableFilter<'cliente'> | string | null;
      ufcob_cliente?: StringNullableFilter<'cliente'> | string | null;
      ativo_cliente?: IntFilter<'cliente'> | number;
      obs_cliente?: BytesNullableFilter<'cliente'> | Uint8Array | null;
      im_cliente?: StringNullableFilter<'cliente'> | string | null;
      cod_cidade?: IntNullableFilter<'cliente'> | number | null;
      numend_cliente?: StringNullableFilter<'cliente'> | string | null;
      comend_cliente?: StringNullableFilter<'cliente'> | string | null;
      email_cliente?: StringNullableFilter<'cliente'> | string | null;
      codbanco_cliente?: StringNullableFilter<'cliente'> | string | null;
      sla_cliente?: IntFilter<'cliente'> | number;
      chamados?: ChamadoListRelationFilter;
      fatrec?: FatrecListRelationFilter;
      projeto?: ProjetoListRelationFilter;
    },
    'cod_cliente'
  >;

  export type clienteOrderByWithAggregationInput = {
    cod_cliente?: SortOrder;
    nome_cliente?: SortOrder;
    razao_cliente?: SortOrderInput | SortOrder;
    end_cliente?: SortOrderInput | SortOrder;
    bairro_cliente?: SortOrderInput | SortOrder;
    cep_cliente?: SortOrderInput | SortOrder;
    fone_cliente?: SortOrderInput | SortOrder;
    cnpj_cliente?: SortOrderInput | SortOrder;
    ie_cliente?: SortOrderInput | SortOrder;
    uf_cliente?: SortOrderInput | SortOrder;
    fax_cliente?: SortOrderInput | SortOrder;
    contato_cliente?: SortOrderInput | SortOrder;
    funccontato_cliente?: SortOrderInput | SortOrder;
    endcob_cliente?: SortOrderInput | SortOrder;
    bairrocob_cliente?: SortOrderInput | SortOrder;
    cepcob_cliente?: SortOrderInput | SortOrder;
    cidadecob_cliente?: SortOrderInput | SortOrder;
    ufcob_cliente?: SortOrderInput | SortOrder;
    ativo_cliente?: SortOrder;
    obs_cliente?: SortOrderInput | SortOrder;
    im_cliente?: SortOrderInput | SortOrder;
    cod_cidade?: SortOrderInput | SortOrder;
    numend_cliente?: SortOrderInput | SortOrder;
    comend_cliente?: SortOrderInput | SortOrder;
    email_cliente?: SortOrderInput | SortOrder;
    codbanco_cliente?: SortOrderInput | SortOrder;
    sla_cliente?: SortOrder;
    _count?: clienteCountOrderByAggregateInput;
    _avg?: clienteAvgOrderByAggregateInput;
    _max?: clienteMaxOrderByAggregateInput;
    _min?: clienteMinOrderByAggregateInput;
    _sum?: clienteSumOrderByAggregateInput;
  };

  export type clienteScalarWhereWithAggregatesInput = {
    AND?:
      | clienteScalarWhereWithAggregatesInput
      | clienteScalarWhereWithAggregatesInput[];
    OR?: clienteScalarWhereWithAggregatesInput[];
    NOT?:
      | clienteScalarWhereWithAggregatesInput
      | clienteScalarWhereWithAggregatesInput[];
    cod_cliente?: IntWithAggregatesFilter<'cliente'> | number;
    nome_cliente?: StringWithAggregatesFilter<'cliente'> | string;
    razao_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    end_cliente?: StringNullableWithAggregatesFilter<'cliente'> | string | null;
    bairro_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    cep_cliente?: StringNullableWithAggregatesFilter<'cliente'> | string | null;
    fone_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    cnpj_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    ie_cliente?: StringNullableWithAggregatesFilter<'cliente'> | string | null;
    uf_cliente?: StringNullableWithAggregatesFilter<'cliente'> | string | null;
    fax_cliente?: StringNullableWithAggregatesFilter<'cliente'> | string | null;
    contato_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    funccontato_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    endcob_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    bairrocob_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    cepcob_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    cidadecob_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    ufcob_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    ativo_cliente?: IntWithAggregatesFilter<'cliente'> | number;
    obs_cliente?:
      | BytesNullableWithAggregatesFilter<'cliente'>
      | Uint8Array
      | null;
    im_cliente?: StringNullableWithAggregatesFilter<'cliente'> | string | null;
    cod_cidade?: IntNullableWithAggregatesFilter<'cliente'> | number | null;
    numend_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    comend_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    email_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    codbanco_cliente?:
      | StringNullableWithAggregatesFilter<'cliente'>
      | string
      | null;
    sla_cliente?: IntWithAggregatesFilter<'cliente'> | number;
  };

  export type composicaoWhereInput = {
    AND?: composicaoWhereInput | composicaoWhereInput[];
    OR?: composicaoWhereInput[];
    NOT?: composicaoWhereInput | composicaoWhereInput[];
    cod_composicao?: IntFilter<'composicao'> | number;
    cod_fatura?: IntFilter<'composicao'> | number;
    cod_cliente?: IntFilter<'composicao'> | number;
    cod_projeto?: IntFilter<'composicao'> | number;
    cod_tarefa?: IntFilter<'composicao'> | number;
    cod_recurso?: IntFilter<'composicao'> | number;
    hrfat_composicao?:
      | DecimalNullableFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_composicao?:
      | DecimalNullableFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrhr_composicao?:
      | DecimalNullableFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_composicao?:
      | DecimalNullableFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type composicaoOrderByWithRelationInput = {
    cod_composicao?: SortOrder;
    cod_fatura?: SortOrder;
    cod_cliente?: SortOrder;
    cod_projeto?: SortOrder;
    cod_tarefa?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_composicao?: SortOrderInput | SortOrder;
    hrnfat_composicao?: SortOrderInput | SortOrder;
    vrhr_composicao?: SortOrderInput | SortOrder;
    vrfat_composicao?: SortOrderInput | SortOrder;
  };

  export type composicaoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_composicao?: number;
      AND?: composicaoWhereInput | composicaoWhereInput[];
      OR?: composicaoWhereInput[];
      NOT?: composicaoWhereInput | composicaoWhereInput[];
      cod_fatura?: IntFilter<'composicao'> | number;
      cod_cliente?: IntFilter<'composicao'> | number;
      cod_projeto?: IntFilter<'composicao'> | number;
      cod_tarefa?: IntFilter<'composicao'> | number;
      cod_recurso?: IntFilter<'composicao'> | number;
      hrfat_composicao?:
        | DecimalNullableFilter<'composicao'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hrnfat_composicao?:
        | DecimalNullableFilter<'composicao'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      vrhr_composicao?:
        | DecimalNullableFilter<'composicao'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      vrfat_composicao?:
        | DecimalNullableFilter<'composicao'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    },
    'cod_composicao'
  >;

  export type composicaoOrderByWithAggregationInput = {
    cod_composicao?: SortOrder;
    cod_fatura?: SortOrder;
    cod_cliente?: SortOrder;
    cod_projeto?: SortOrder;
    cod_tarefa?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_composicao?: SortOrderInput | SortOrder;
    hrnfat_composicao?: SortOrderInput | SortOrder;
    vrhr_composicao?: SortOrderInput | SortOrder;
    vrfat_composicao?: SortOrderInput | SortOrder;
    _count?: composicaoCountOrderByAggregateInput;
    _avg?: composicaoAvgOrderByAggregateInput;
    _max?: composicaoMaxOrderByAggregateInput;
    _min?: composicaoMinOrderByAggregateInput;
    _sum?: composicaoSumOrderByAggregateInput;
  };

  export type composicaoScalarWhereWithAggregatesInput = {
    AND?:
      | composicaoScalarWhereWithAggregatesInput
      | composicaoScalarWhereWithAggregatesInput[];
    OR?: composicaoScalarWhereWithAggregatesInput[];
    NOT?:
      | composicaoScalarWhereWithAggregatesInput
      | composicaoScalarWhereWithAggregatesInput[];
    cod_composicao?: IntWithAggregatesFilter<'composicao'> | number;
    cod_fatura?: IntWithAggregatesFilter<'composicao'> | number;
    cod_cliente?: IntWithAggregatesFilter<'composicao'> | number;
    cod_projeto?: IntWithAggregatesFilter<'composicao'> | number;
    cod_tarefa?: IntWithAggregatesFilter<'composicao'> | number;
    cod_recurso?: IntWithAggregatesFilter<'composicao'> | number;
    hrfat_composicao?:
      | DecimalNullableWithAggregatesFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_composicao?:
      | DecimalNullableWithAggregatesFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrhr_composicao?:
      | DecimalNullableWithAggregatesFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_composicao?:
      | DecimalNullableWithAggregatesFilter<'composicao'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type contatoWhereInput = {
    AND?: contatoWhereInput | contatoWhereInput[];
    OR?: contatoWhereInput[];
    NOT?: contatoWhereInput | contatoWhereInput[];
    cod_contato?: IntFilter<'contato'> | number;
    data_contato?: DateTimeFilter<'contato'> | Date | string;
    hora_contato?: StringFilter<'contato'> | string;
    nomeusuario_contato?: StringFilter<'contato'> | string;
    desc_contato?: StringNullableFilter<'contato'> | string | null;
    cod_lista?: IntFilter<'contato'> | number;
  };

  export type contatoOrderByWithRelationInput = {
    cod_contato?: SortOrder;
    data_contato?: SortOrder;
    hora_contato?: SortOrder;
    nomeusuario_contato?: SortOrder;
    desc_contato?: SortOrderInput | SortOrder;
    cod_lista?: SortOrder;
  };

  export type contatoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_contato?: number;
      AND?: contatoWhereInput | contatoWhereInput[];
      OR?: contatoWhereInput[];
      NOT?: contatoWhereInput | contatoWhereInput[];
      data_contato?: DateTimeFilter<'contato'> | Date | string;
      hora_contato?: StringFilter<'contato'> | string;
      nomeusuario_contato?: StringFilter<'contato'> | string;
      desc_contato?: StringNullableFilter<'contato'> | string | null;
      cod_lista?: IntFilter<'contato'> | number;
    },
    'cod_contato'
  >;

  export type contatoOrderByWithAggregationInput = {
    cod_contato?: SortOrder;
    data_contato?: SortOrder;
    hora_contato?: SortOrder;
    nomeusuario_contato?: SortOrder;
    desc_contato?: SortOrderInput | SortOrder;
    cod_lista?: SortOrder;
    _count?: contatoCountOrderByAggregateInput;
    _avg?: contatoAvgOrderByAggregateInput;
    _max?: contatoMaxOrderByAggregateInput;
    _min?: contatoMinOrderByAggregateInput;
    _sum?: contatoSumOrderByAggregateInput;
  };

  export type contatoScalarWhereWithAggregatesInput = {
    AND?:
      | contatoScalarWhereWithAggregatesInput
      | contatoScalarWhereWithAggregatesInput[];
    OR?: contatoScalarWhereWithAggregatesInput[];
    NOT?:
      | contatoScalarWhereWithAggregatesInput
      | contatoScalarWhereWithAggregatesInput[];
    cod_contato?: IntWithAggregatesFilter<'contato'> | number;
    data_contato?: DateTimeWithAggregatesFilter<'contato'> | Date | string;
    hora_contato?: StringWithAggregatesFilter<'contato'> | string;
    nomeusuario_contato?: StringWithAggregatesFilter<'contato'> | string;
    desc_contato?:
      | StringNullableWithAggregatesFilter<'contato'>
      | string
      | null;
    cod_lista?: IntWithAggregatesFilter<'contato'> | number;
  };

  export type ctissWhereInput = {
    AND?: ctissWhereInput | ctissWhereInput[];
    OR?: ctissWhereInput[];
    NOT?: ctissWhereInput | ctissWhereInput[];
    cod_ctiss?: IntFilter<'ctiss'> | number;
    num_ctiss?: StringFilter<'ctiss'> | string;
    subitem_ctiss?: StringFilter<'ctiss'> | string;
    descr_ctiss?: StringNullableFilter<'ctiss'> | string | null;
    csll_ctiss?:
      | DecimalFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_ctiss?:
      | DecimalFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_ctiss?:
      | DecimalFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_ctiss?:
      | DecimalFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliq_ctiss?:
      | DecimalFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliqret_ctiss?:
      | DecimalFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type ctissOrderByWithRelationInput = {
    cod_ctiss?: SortOrder;
    num_ctiss?: SortOrder;
    subitem_ctiss?: SortOrder;
    descr_ctiss?: SortOrderInput | SortOrder;
    csll_ctiss?: SortOrder;
    pis_ctiss?: SortOrder;
    cofins_ctiss?: SortOrder;
    irrf_ctiss?: SortOrder;
    aliq_ctiss?: SortOrder;
    aliqret_ctiss?: SortOrder;
  };

  export type ctissWhereUniqueInput = Prisma.AtLeast<
    {
      cod_ctiss?: number;
      AND?: ctissWhereInput | ctissWhereInput[];
      OR?: ctissWhereInput[];
      NOT?: ctissWhereInput | ctissWhereInput[];
      num_ctiss?: StringFilter<'ctiss'> | string;
      subitem_ctiss?: StringFilter<'ctiss'> | string;
      descr_ctiss?: StringNullableFilter<'ctiss'> | string | null;
      csll_ctiss?:
        | DecimalFilter<'ctiss'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      pis_ctiss?:
        | DecimalFilter<'ctiss'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      cofins_ctiss?:
        | DecimalFilter<'ctiss'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      irrf_ctiss?:
        | DecimalFilter<'ctiss'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      aliq_ctiss?:
        | DecimalFilter<'ctiss'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      aliqret_ctiss?:
        | DecimalFilter<'ctiss'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
    },
    'cod_ctiss'
  >;

  export type ctissOrderByWithAggregationInput = {
    cod_ctiss?: SortOrder;
    num_ctiss?: SortOrder;
    subitem_ctiss?: SortOrder;
    descr_ctiss?: SortOrderInput | SortOrder;
    csll_ctiss?: SortOrder;
    pis_ctiss?: SortOrder;
    cofins_ctiss?: SortOrder;
    irrf_ctiss?: SortOrder;
    aliq_ctiss?: SortOrder;
    aliqret_ctiss?: SortOrder;
    _count?: ctissCountOrderByAggregateInput;
    _avg?: ctissAvgOrderByAggregateInput;
    _max?: ctissMaxOrderByAggregateInput;
    _min?: ctissMinOrderByAggregateInput;
    _sum?: ctissSumOrderByAggregateInput;
  };

  export type ctissScalarWhereWithAggregatesInput = {
    AND?:
      | ctissScalarWhereWithAggregatesInput
      | ctissScalarWhereWithAggregatesInput[];
    OR?: ctissScalarWhereWithAggregatesInput[];
    NOT?:
      | ctissScalarWhereWithAggregatesInput
      | ctissScalarWhereWithAggregatesInput[];
    cod_ctiss?: IntWithAggregatesFilter<'ctiss'> | number;
    num_ctiss?: StringWithAggregatesFilter<'ctiss'> | string;
    subitem_ctiss?: StringWithAggregatesFilter<'ctiss'> | string;
    descr_ctiss?: StringNullableWithAggregatesFilter<'ctiss'> | string | null;
    csll_ctiss?:
      | DecimalWithAggregatesFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_ctiss?:
      | DecimalWithAggregatesFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_ctiss?:
      | DecimalWithAggregatesFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_ctiss?:
      | DecimalWithAggregatesFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliq_ctiss?:
      | DecimalWithAggregatesFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliqret_ctiss?:
      | DecimalWithAggregatesFilter<'ctiss'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type despesaWhereInput = {
    AND?: despesaWhereInput | despesaWhereInput[];
    OR?: despesaWhereInput[];
    NOT?: despesaWhereInput | despesaWhereInput[];
    cod_despesa?: IntFilter<'despesa'> | number;
    cod_recurso?: IntFilter<'despesa'> | number;
    cod_tpdesp?: IntFilter<'despesa'> | number;
    valor_despesa?:
      | DecimalFilter<'despesa'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_despesa?: StringFilter<'despesa'> | string;
  };

  export type despesaOrderByWithRelationInput = {
    cod_despesa?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_despesa?: SortOrder;
    mesano_despesa?: SortOrder;
  };

  export type despesaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_despesa?: number;
      AND?: despesaWhereInput | despesaWhereInput[];
      OR?: despesaWhereInput[];
      NOT?: despesaWhereInput | despesaWhereInput[];
      cod_recurso?: IntFilter<'despesa'> | number;
      cod_tpdesp?: IntFilter<'despesa'> | number;
      valor_despesa?:
        | DecimalFilter<'despesa'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      mesano_despesa?: StringFilter<'despesa'> | string;
    },
    'cod_despesa'
  >;

  export type despesaOrderByWithAggregationInput = {
    cod_despesa?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_despesa?: SortOrder;
    mesano_despesa?: SortOrder;
    _count?: despesaCountOrderByAggregateInput;
    _avg?: despesaAvgOrderByAggregateInput;
    _max?: despesaMaxOrderByAggregateInput;
    _min?: despesaMinOrderByAggregateInput;
    _sum?: despesaSumOrderByAggregateInput;
  };

  export type despesaScalarWhereWithAggregatesInput = {
    AND?:
      | despesaScalarWhereWithAggregatesInput
      | despesaScalarWhereWithAggregatesInput[];
    OR?: despesaScalarWhereWithAggregatesInput[];
    NOT?:
      | despesaScalarWhereWithAggregatesInput
      | despesaScalarWhereWithAggregatesInput[];
    cod_despesa?: IntWithAggregatesFilter<'despesa'> | number;
    cod_recurso?: IntWithAggregatesFilter<'despesa'> | number;
    cod_tpdesp?: IntWithAggregatesFilter<'despesa'> | number;
    valor_despesa?:
      | DecimalWithAggregatesFilter<'despesa'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_despesa?: StringWithAggregatesFilter<'despesa'> | string;
  };

  export type desprecWhereInput = {
    AND?: desprecWhereInput | desprecWhereInput[];
    OR?: desprecWhereInput[];
    NOT?: desprecWhereInput | desprecWhereInput[];
    cod_desprec?: IntFilter<'desprec'> | number;
    cod_recurso?: IntFilter<'desprec'> | number;
    cod_tpdesp?: IntFilter<'desprec'> | number;
    valor_desprec?:
      | DecimalFilter<'desprec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type desprecOrderByWithRelationInput = {
    cod_desprec?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_desprec?: SortOrder;
  };

  export type desprecWhereUniqueInput = Prisma.AtLeast<
    {
      cod_desprec?: number;
      AND?: desprecWhereInput | desprecWhereInput[];
      OR?: desprecWhereInput[];
      NOT?: desprecWhereInput | desprecWhereInput[];
      cod_recurso?: IntFilter<'desprec'> | number;
      cod_tpdesp?: IntFilter<'desprec'> | number;
      valor_desprec?:
        | DecimalFilter<'desprec'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
    },
    'cod_desprec'
  >;

  export type desprecOrderByWithAggregationInput = {
    cod_desprec?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_desprec?: SortOrder;
    _count?: desprecCountOrderByAggregateInput;
    _avg?: desprecAvgOrderByAggregateInput;
    _max?: desprecMaxOrderByAggregateInput;
    _min?: desprecMinOrderByAggregateInput;
    _sum?: desprecSumOrderByAggregateInput;
  };

  export type desprecScalarWhereWithAggregatesInput = {
    AND?:
      | desprecScalarWhereWithAggregatesInput
      | desprecScalarWhereWithAggregatesInput[];
    OR?: desprecScalarWhereWithAggregatesInput[];
    NOT?:
      | desprecScalarWhereWithAggregatesInput
      | desprecScalarWhereWithAggregatesInput[];
    cod_desprec?: IntWithAggregatesFilter<'desprec'> | number;
    cod_recurso?: IntWithAggregatesFilter<'desprec'> | number;
    cod_tpdesp?: IntWithAggregatesFilter<'desprec'> | number;
    valor_desprec?:
      | DecimalWithAggregatesFilter<'desprec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type empresaWhereInput = {
    AND?: empresaWhereInput | empresaWhereInput[];
    OR?: empresaWhereInput[];
    NOT?: empresaWhereInput | empresaWhereInput[];
    cod_empresa?: IntFilter<'empresa'> | number;
    nome_empresa?: StringFilter<'empresa'> | string;
    razao_empresa?: StringNullableFilter<'empresa'> | string | null;
    end_empresa?: StringNullableFilter<'empresa'> | string | null;
    bairro_empresa?: StringNullableFilter<'empresa'> | string | null;
    cep_empresa?: StringNullableFilter<'empresa'> | string | null;
    ddd_empresa?: StringNullableFilter<'empresa'> | string | null;
    fone_empresa?: StringNullableFilter<'empresa'> | string | null;
    cnpj_empresa?: StringNullableFilter<'empresa'> | string | null;
    ie_empresa?: StringNullableFilter<'empresa'> | string | null;
    im_empresa?: StringNullableFilter<'empresa'> | string | null;
    cod_cidade?: IntNullableFilter<'empresa'> | number | null;
    certificado_empresa?: StringNullableFilter<'empresa'> | string | null;
    email_empresa?: StringNullableFilter<'empresa'> | string | null;
  };

  export type empresaOrderByWithRelationInput = {
    cod_empresa?: SortOrder;
    nome_empresa?: SortOrder;
    razao_empresa?: SortOrderInput | SortOrder;
    end_empresa?: SortOrderInput | SortOrder;
    bairro_empresa?: SortOrderInput | SortOrder;
    cep_empresa?: SortOrderInput | SortOrder;
    ddd_empresa?: SortOrderInput | SortOrder;
    fone_empresa?: SortOrderInput | SortOrder;
    cnpj_empresa?: SortOrderInput | SortOrder;
    ie_empresa?: SortOrderInput | SortOrder;
    im_empresa?: SortOrderInput | SortOrder;
    cod_cidade?: SortOrderInput | SortOrder;
    certificado_empresa?: SortOrderInput | SortOrder;
    email_empresa?: SortOrderInput | SortOrder;
  };

  export type empresaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_empresa?: number;
      AND?: empresaWhereInput | empresaWhereInput[];
      OR?: empresaWhereInput[];
      NOT?: empresaWhereInput | empresaWhereInput[];
      nome_empresa?: StringFilter<'empresa'> | string;
      razao_empresa?: StringNullableFilter<'empresa'> | string | null;
      end_empresa?: StringNullableFilter<'empresa'> | string | null;
      bairro_empresa?: StringNullableFilter<'empresa'> | string | null;
      cep_empresa?: StringNullableFilter<'empresa'> | string | null;
      ddd_empresa?: StringNullableFilter<'empresa'> | string | null;
      fone_empresa?: StringNullableFilter<'empresa'> | string | null;
      cnpj_empresa?: StringNullableFilter<'empresa'> | string | null;
      ie_empresa?: StringNullableFilter<'empresa'> | string | null;
      im_empresa?: StringNullableFilter<'empresa'> | string | null;
      cod_cidade?: IntNullableFilter<'empresa'> | number | null;
      certificado_empresa?: StringNullableFilter<'empresa'> | string | null;
      email_empresa?: StringNullableFilter<'empresa'> | string | null;
    },
    'cod_empresa'
  >;

  export type empresaOrderByWithAggregationInput = {
    cod_empresa?: SortOrder;
    nome_empresa?: SortOrder;
    razao_empresa?: SortOrderInput | SortOrder;
    end_empresa?: SortOrderInput | SortOrder;
    bairro_empresa?: SortOrderInput | SortOrder;
    cep_empresa?: SortOrderInput | SortOrder;
    ddd_empresa?: SortOrderInput | SortOrder;
    fone_empresa?: SortOrderInput | SortOrder;
    cnpj_empresa?: SortOrderInput | SortOrder;
    ie_empresa?: SortOrderInput | SortOrder;
    im_empresa?: SortOrderInput | SortOrder;
    cod_cidade?: SortOrderInput | SortOrder;
    certificado_empresa?: SortOrderInput | SortOrder;
    email_empresa?: SortOrderInput | SortOrder;
    _count?: empresaCountOrderByAggregateInput;
    _avg?: empresaAvgOrderByAggregateInput;
    _max?: empresaMaxOrderByAggregateInput;
    _min?: empresaMinOrderByAggregateInput;
    _sum?: empresaSumOrderByAggregateInput;
  };

  export type empresaScalarWhereWithAggregatesInput = {
    AND?:
      | empresaScalarWhereWithAggregatesInput
      | empresaScalarWhereWithAggregatesInput[];
    OR?: empresaScalarWhereWithAggregatesInput[];
    NOT?:
      | empresaScalarWhereWithAggregatesInput
      | empresaScalarWhereWithAggregatesInput[];
    cod_empresa?: IntWithAggregatesFilter<'empresa'> | number;
    nome_empresa?: StringWithAggregatesFilter<'empresa'> | string;
    razao_empresa?:
      | StringNullableWithAggregatesFilter<'empresa'>
      | string
      | null;
    end_empresa?: StringNullableWithAggregatesFilter<'empresa'> | string | null;
    bairro_empresa?:
      | StringNullableWithAggregatesFilter<'empresa'>
      | string
      | null;
    cep_empresa?: StringNullableWithAggregatesFilter<'empresa'> | string | null;
    ddd_empresa?: StringNullableWithAggregatesFilter<'empresa'> | string | null;
    fone_empresa?:
      | StringNullableWithAggregatesFilter<'empresa'>
      | string
      | null;
    cnpj_empresa?:
      | StringNullableWithAggregatesFilter<'empresa'>
      | string
      | null;
    ie_empresa?: StringNullableWithAggregatesFilter<'empresa'> | string | null;
    im_empresa?: StringNullableWithAggregatesFilter<'empresa'> | string | null;
    cod_cidade?: IntNullableWithAggregatesFilter<'empresa'> | number | null;
    certificado_empresa?:
      | StringNullableWithAggregatesFilter<'empresa'>
      | string
      | null;
    email_empresa?:
      | StringNullableWithAggregatesFilter<'empresa'>
      | string
      | null;
  };

  export type faseWhereInput = {
    AND?: faseWhereInput | faseWhereInput[];
    OR?: faseWhereInput[];
    NOT?: faseWhereInput | faseWhereInput[];
    cod_fase?: IntFilter<'fase'> | number;
    nome_fase?: StringFilter<'fase'> | string;
    meta?: MetaListRelationFilter;
    tarefa?: TarefaListRelationFilter;
  };

  export type faseOrderByWithRelationInput = {
    cod_fase?: SortOrder;
    nome_fase?: SortOrder;
    meta?: metaOrderByRelationAggregateInput;
    tarefa?: tarefaOrderByRelationAggregateInput;
  };

  export type faseWhereUniqueInput = Prisma.AtLeast<
    {
      cod_fase?: number;
      AND?: faseWhereInput | faseWhereInput[];
      OR?: faseWhereInput[];
      NOT?: faseWhereInput | faseWhereInput[];
      nome_fase?: StringFilter<'fase'> | string;
      meta?: MetaListRelationFilter;
      tarefa?: TarefaListRelationFilter;
    },
    'cod_fase'
  >;

  export type faseOrderByWithAggregationInput = {
    cod_fase?: SortOrder;
    nome_fase?: SortOrder;
    _count?: faseCountOrderByAggregateInput;
    _avg?: faseAvgOrderByAggregateInput;
    _max?: faseMaxOrderByAggregateInput;
    _min?: faseMinOrderByAggregateInput;
    _sum?: faseSumOrderByAggregateInput;
  };

  export type faseScalarWhereWithAggregatesInput = {
    AND?:
      | faseScalarWhereWithAggregatesInput
      | faseScalarWhereWithAggregatesInput[];
    OR?: faseScalarWhereWithAggregatesInput[];
    NOT?:
      | faseScalarWhereWithAggregatesInput
      | faseScalarWhereWithAggregatesInput[];
    cod_fase?: IntWithAggregatesFilter<'fase'> | number;
    nome_fase?: StringWithAggregatesFilter<'fase'> | string;
  };

  export type fatdesWhereInput = {
    AND?: fatdesWhereInput | fatdesWhereInput[];
    OR?: fatdesWhereInput[];
    NOT?: fatdesWhereInput | fatdesWhereInput[];
    cod_fatdes?: IntFilter<'fatdes'> | number;
    mesano_fatdes?: StringNullableFilter<'fatdes'> | string | null;
    desc_fatdes?: StringFilter<'fatdes'> | string;
    vrdesp_fatdes?:
      | DecimalFilter<'fatdes'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatdes?: DateTimeNullableFilter<'fatdes'> | Date | string | null;
    obs_fatdes?: BytesNullableFilter<'fatdes'> | Uint8Array | null;
    dtven_fatdes?: DateTimeNullableFilter<'fatdes'> | Date | string | null;
  };

  export type fatdesOrderByWithRelationInput = {
    cod_fatdes?: SortOrder;
    mesano_fatdes?: SortOrderInput | SortOrder;
    desc_fatdes?: SortOrder;
    vrdesp_fatdes?: SortOrder;
    dtpag_fatdes?: SortOrderInput | SortOrder;
    obs_fatdes?: SortOrderInput | SortOrder;
    dtven_fatdes?: SortOrderInput | SortOrder;
  };

  export type fatdesWhereUniqueInput = Prisma.AtLeast<
    {
      cod_fatdes?: number;
      AND?: fatdesWhereInput | fatdesWhereInput[];
      OR?: fatdesWhereInput[];
      NOT?: fatdesWhereInput | fatdesWhereInput[];
      mesano_fatdes?: StringNullableFilter<'fatdes'> | string | null;
      desc_fatdes?: StringFilter<'fatdes'> | string;
      vrdesp_fatdes?:
        | DecimalFilter<'fatdes'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      dtpag_fatdes?: DateTimeNullableFilter<'fatdes'> | Date | string | null;
      obs_fatdes?: BytesNullableFilter<'fatdes'> | Uint8Array | null;
      dtven_fatdes?: DateTimeNullableFilter<'fatdes'> | Date | string | null;
    },
    'cod_fatdes'
  >;

  export type fatdesOrderByWithAggregationInput = {
    cod_fatdes?: SortOrder;
    mesano_fatdes?: SortOrderInput | SortOrder;
    desc_fatdes?: SortOrder;
    vrdesp_fatdes?: SortOrder;
    dtpag_fatdes?: SortOrderInput | SortOrder;
    obs_fatdes?: SortOrderInput | SortOrder;
    dtven_fatdes?: SortOrderInput | SortOrder;
    _count?: fatdesCountOrderByAggregateInput;
    _avg?: fatdesAvgOrderByAggregateInput;
    _max?: fatdesMaxOrderByAggregateInput;
    _min?: fatdesMinOrderByAggregateInput;
    _sum?: fatdesSumOrderByAggregateInput;
  };

  export type fatdesScalarWhereWithAggregatesInput = {
    AND?:
      | fatdesScalarWhereWithAggregatesInput
      | fatdesScalarWhereWithAggregatesInput[];
    OR?: fatdesScalarWhereWithAggregatesInput[];
    NOT?:
      | fatdesScalarWhereWithAggregatesInput
      | fatdesScalarWhereWithAggregatesInput[];
    cod_fatdes?: IntWithAggregatesFilter<'fatdes'> | number;
    mesano_fatdes?:
      | StringNullableWithAggregatesFilter<'fatdes'>
      | string
      | null;
    desc_fatdes?: StringWithAggregatesFilter<'fatdes'> | string;
    vrdesp_fatdes?:
      | DecimalWithAggregatesFilter<'fatdes'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatdes?:
      | DateTimeNullableWithAggregatesFilter<'fatdes'>
      | Date
      | string
      | null;
    obs_fatdes?:
      | BytesNullableWithAggregatesFilter<'fatdes'>
      | Uint8Array
      | null;
    dtven_fatdes?:
      | DateTimeNullableWithAggregatesFilter<'fatdes'>
      | Date
      | string
      | null;
  };

  export type fatfunWhereInput = {
    AND?: fatfunWhereInput | fatfunWhereInput[];
    OR?: fatfunWhereInput[];
    NOT?: fatfunWhereInput | fatfunWhereInput[];
    cod_fatfun?: IntFilter<'fatfun'> | number;
    mesano_fatfun?: StringNullableFilter<'fatfun'> | string | null;
    nome_fatfun?: StringFilter<'fatfun'> | string;
    vrdesl_fatfun?:
      | DecimalFilter<'fatfun'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vralm_fatfun?:
      | DecimalFilter<'fatfun'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrsal_fatfun?:
      | DecimalFilter<'fatfun'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatfun?: DateTimeNullableFilter<'fatfun'> | Date | string | null;
    obs_fatfun?: BytesNullableFilter<'fatfun'> | Uint8Array | null;
    dtpag1_fatfun?: DateTimeNullableFilter<'fatfun'> | Date | string | null;
    dtpag2_fatfun?: DateTimeNullableFilter<'fatfun'> | Date | string | null;
    cod_recurso?: IntNullableFilter<'fatfun'> | number | null;
  };

  export type fatfunOrderByWithRelationInput = {
    cod_fatfun?: SortOrder;
    mesano_fatfun?: SortOrderInput | SortOrder;
    nome_fatfun?: SortOrder;
    vrdesl_fatfun?: SortOrder;
    vralm_fatfun?: SortOrder;
    vrsal_fatfun?: SortOrder;
    dtpag_fatfun?: SortOrderInput | SortOrder;
    obs_fatfun?: SortOrderInput | SortOrder;
    dtpag1_fatfun?: SortOrderInput | SortOrder;
    dtpag2_fatfun?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrderInput | SortOrder;
  };

  export type fatfunWhereUniqueInput = Prisma.AtLeast<
    {
      cod_fatfun?: number;
      AND?: fatfunWhereInput | fatfunWhereInput[];
      OR?: fatfunWhereInput[];
      NOT?: fatfunWhereInput | fatfunWhereInput[];
      mesano_fatfun?: StringNullableFilter<'fatfun'> | string | null;
      nome_fatfun?: StringFilter<'fatfun'> | string;
      vrdesl_fatfun?:
        | DecimalFilter<'fatfun'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vralm_fatfun?:
        | DecimalFilter<'fatfun'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrsal_fatfun?:
        | DecimalFilter<'fatfun'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      dtpag_fatfun?: DateTimeNullableFilter<'fatfun'> | Date | string | null;
      obs_fatfun?: BytesNullableFilter<'fatfun'> | Uint8Array | null;
      dtpag1_fatfun?: DateTimeNullableFilter<'fatfun'> | Date | string | null;
      dtpag2_fatfun?: DateTimeNullableFilter<'fatfun'> | Date | string | null;
      cod_recurso?: IntNullableFilter<'fatfun'> | number | null;
    },
    'cod_fatfun'
  >;

  export type fatfunOrderByWithAggregationInput = {
    cod_fatfun?: SortOrder;
    mesano_fatfun?: SortOrderInput | SortOrder;
    nome_fatfun?: SortOrder;
    vrdesl_fatfun?: SortOrder;
    vralm_fatfun?: SortOrder;
    vrsal_fatfun?: SortOrder;
    dtpag_fatfun?: SortOrderInput | SortOrder;
    obs_fatfun?: SortOrderInput | SortOrder;
    dtpag1_fatfun?: SortOrderInput | SortOrder;
    dtpag2_fatfun?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrderInput | SortOrder;
    _count?: fatfunCountOrderByAggregateInput;
    _avg?: fatfunAvgOrderByAggregateInput;
    _max?: fatfunMaxOrderByAggregateInput;
    _min?: fatfunMinOrderByAggregateInput;
    _sum?: fatfunSumOrderByAggregateInput;
  };

  export type fatfunScalarWhereWithAggregatesInput = {
    AND?:
      | fatfunScalarWhereWithAggregatesInput
      | fatfunScalarWhereWithAggregatesInput[];
    OR?: fatfunScalarWhereWithAggregatesInput[];
    NOT?:
      | fatfunScalarWhereWithAggregatesInput
      | fatfunScalarWhereWithAggregatesInput[];
    cod_fatfun?: IntWithAggregatesFilter<'fatfun'> | number;
    mesano_fatfun?:
      | StringNullableWithAggregatesFilter<'fatfun'>
      | string
      | null;
    nome_fatfun?: StringWithAggregatesFilter<'fatfun'> | string;
    vrdesl_fatfun?:
      | DecimalWithAggregatesFilter<'fatfun'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vralm_fatfun?:
      | DecimalWithAggregatesFilter<'fatfun'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrsal_fatfun?:
      | DecimalWithAggregatesFilter<'fatfun'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatfun?:
      | DateTimeNullableWithAggregatesFilter<'fatfun'>
      | Date
      | string
      | null;
    obs_fatfun?:
      | BytesNullableWithAggregatesFilter<'fatfun'>
      | Uint8Array
      | null;
    dtpag1_fatfun?:
      | DateTimeNullableWithAggregatesFilter<'fatfun'>
      | Date
      | string
      | null;
    dtpag2_fatfun?:
      | DateTimeNullableWithAggregatesFilter<'fatfun'>
      | Date
      | string
      | null;
    cod_recurso?: IntNullableWithAggregatesFilter<'fatfun'> | number | null;
  };

  export type fatrecWhereInput = {
    AND?: fatrecWhereInput | fatrecWhereInput[];
    OR?: fatrecWhereInput[];
    NOT?: fatrecWhereInput | fatrecWhereInput[];
    cod_fatrec?: IntFilter<'fatrec'> | number;
    cod_cliente?: IntFilter<'fatrec'> | number;
    desc_fatrec?: StringFilter<'fatrec'> | string;
    qtdhora_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    dtnf_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    dtcob_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    dtpag_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    vrpag_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: StringNullableFilter<'fatrec'> | string | null;
    obs_fatrec?: BytesNullableFilter<'fatrec'> | Uint8Array | null;
    cod_recurso?: IntNullableFilter<'fatrec'> | number | null;
    perccom_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    cod_empresa?: IntNullableFilter<'fatrec'> | number | null;
    nf_fatrec?: StringNullableFilter<'fatrec'> | string | null;
    cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>;
  };

  export type fatrecOrderByWithRelationInput = {
    cod_fatrec?: SortOrder;
    cod_cliente?: SortOrder;
    desc_fatrec?: SortOrder;
    qtdhora_fatrec?: SortOrder;
    vrhora_fatrec?: SortOrder;
    vrtot_fatrec?: SortOrder;
    dtvenc_fatrec?: SortOrderInput | SortOrder;
    dtnf_fatrec?: SortOrderInput | SortOrder;
    dtcob_fatrec?: SortOrderInput | SortOrder;
    dtpag_fatrec?: SortOrderInput | SortOrder;
    vrpag_fatrec?: SortOrder;
    imp_fatrec?: SortOrder;
    mesano_fatrec?: SortOrderInput | SortOrder;
    obs_fatrec?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrderInput | SortOrder;
    perccom_fatrec?: SortOrder;
    dtpgcom_fatrec?: SortOrderInput | SortOrder;
    cod_empresa?: SortOrderInput | SortOrder;
    nf_fatrec?: SortOrderInput | SortOrder;
    cliente?: clienteOrderByWithRelationInput;
  };

  export type fatrecWhereUniqueInput = Prisma.AtLeast<
    {
      cod_fatrec?: number;
      AND?: fatrecWhereInput | fatrecWhereInput[];
      OR?: fatrecWhereInput[];
      NOT?: fatrecWhereInput | fatrecWhereInput[];
      cod_cliente?: IntFilter<'fatrec'> | number;
      desc_fatrec?: StringFilter<'fatrec'> | string;
      qtdhora_fatrec?:
        | DecimalFilter<'fatrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrhora_fatrec?:
        | DecimalFilter<'fatrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrtot_fatrec?:
        | DecimalFilter<'fatrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      dtvenc_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
      dtnf_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
      dtcob_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
      dtpag_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
      vrpag_fatrec?:
        | DecimalFilter<'fatrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      imp_fatrec?:
        | DecimalFilter<'fatrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      mesano_fatrec?: StringNullableFilter<'fatrec'> | string | null;
      obs_fatrec?: BytesNullableFilter<'fatrec'> | Uint8Array | null;
      cod_recurso?: IntNullableFilter<'fatrec'> | number | null;
      perccom_fatrec?:
        | DecimalFilter<'fatrec'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      dtpgcom_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
      cod_empresa?: IntNullableFilter<'fatrec'> | number | null;
      nf_fatrec?: StringNullableFilter<'fatrec'> | string | null;
      cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>;
    },
    'cod_fatrec'
  >;

  export type fatrecOrderByWithAggregationInput = {
    cod_fatrec?: SortOrder;
    cod_cliente?: SortOrder;
    desc_fatrec?: SortOrder;
    qtdhora_fatrec?: SortOrder;
    vrhora_fatrec?: SortOrder;
    vrtot_fatrec?: SortOrder;
    dtvenc_fatrec?: SortOrderInput | SortOrder;
    dtnf_fatrec?: SortOrderInput | SortOrder;
    dtcob_fatrec?: SortOrderInput | SortOrder;
    dtpag_fatrec?: SortOrderInput | SortOrder;
    vrpag_fatrec?: SortOrder;
    imp_fatrec?: SortOrder;
    mesano_fatrec?: SortOrderInput | SortOrder;
    obs_fatrec?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrderInput | SortOrder;
    perccom_fatrec?: SortOrder;
    dtpgcom_fatrec?: SortOrderInput | SortOrder;
    cod_empresa?: SortOrderInput | SortOrder;
    nf_fatrec?: SortOrderInput | SortOrder;
    _count?: fatrecCountOrderByAggregateInput;
    _avg?: fatrecAvgOrderByAggregateInput;
    _max?: fatrecMaxOrderByAggregateInput;
    _min?: fatrecMinOrderByAggregateInput;
    _sum?: fatrecSumOrderByAggregateInput;
  };

  export type fatrecScalarWhereWithAggregatesInput = {
    AND?:
      | fatrecScalarWhereWithAggregatesInput
      | fatrecScalarWhereWithAggregatesInput[];
    OR?: fatrecScalarWhereWithAggregatesInput[];
    NOT?:
      | fatrecScalarWhereWithAggregatesInput
      | fatrecScalarWhereWithAggregatesInput[];
    cod_fatrec?: IntWithAggregatesFilter<'fatrec'> | number;
    cod_cliente?: IntWithAggregatesFilter<'fatrec'> | number;
    desc_fatrec?: StringWithAggregatesFilter<'fatrec'> | string;
    qtdhora_fatrec?:
      | DecimalWithAggregatesFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalWithAggregatesFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalWithAggregatesFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | DateTimeNullableWithAggregatesFilter<'fatrec'>
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | DateTimeNullableWithAggregatesFilter<'fatrec'>
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | DateTimeNullableWithAggregatesFilter<'fatrec'>
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | DateTimeNullableWithAggregatesFilter<'fatrec'>
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalWithAggregatesFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalWithAggregatesFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?:
      | StringNullableWithAggregatesFilter<'fatrec'>
      | string
      | null;
    obs_fatrec?:
      | BytesNullableWithAggregatesFilter<'fatrec'>
      | Uint8Array
      | null;
    cod_recurso?: IntNullableWithAggregatesFilter<'fatrec'> | number | null;
    perccom_fatrec?:
      | DecimalWithAggregatesFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | DateTimeNullableWithAggregatesFilter<'fatrec'>
      | Date
      | string
      | null;
    cod_empresa?: IntNullableWithAggregatesFilter<'fatrec'> | number | null;
    nf_fatrec?: StringNullableWithAggregatesFilter<'fatrec'> | string | null;
  };

  export type faturaWhereInput = {
    AND?: faturaWhereInput | faturaWhereInput[];
    OR?: faturaWhereInput[];
    NOT?: faturaWhereInput | faturaWhereInput[];
    cod_fatura?: IntFilter<'fatura'> | number;
    mesano_fatura?: StringFilter<'fatura'> | string;
    desp_fatura?:
      | DecimalNullableFilter<'fatura'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    imp_fatura?:
      | DecimalNullableFilter<'fatura'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    lucro_fatura?:
      | DecimalNullableFilter<'fatura'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type faturaOrderByWithRelationInput = {
    cod_fatura?: SortOrder;
    mesano_fatura?: SortOrder;
    desp_fatura?: SortOrderInput | SortOrder;
    imp_fatura?: SortOrderInput | SortOrder;
    lucro_fatura?: SortOrderInput | SortOrder;
  };

  export type faturaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_fatura?: number;
      AND?: faturaWhereInput | faturaWhereInput[];
      OR?: faturaWhereInput[];
      NOT?: faturaWhereInput | faturaWhereInput[];
      mesano_fatura?: StringFilter<'fatura'> | string;
      desp_fatura?:
        | DecimalNullableFilter<'fatura'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      imp_fatura?:
        | DecimalNullableFilter<'fatura'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      lucro_fatura?:
        | DecimalNullableFilter<'fatura'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    },
    'cod_fatura'
  >;

  export type faturaOrderByWithAggregationInput = {
    cod_fatura?: SortOrder;
    mesano_fatura?: SortOrder;
    desp_fatura?: SortOrderInput | SortOrder;
    imp_fatura?: SortOrderInput | SortOrder;
    lucro_fatura?: SortOrderInput | SortOrder;
    _count?: faturaCountOrderByAggregateInput;
    _avg?: faturaAvgOrderByAggregateInput;
    _max?: faturaMaxOrderByAggregateInput;
    _min?: faturaMinOrderByAggregateInput;
    _sum?: faturaSumOrderByAggregateInput;
  };

  export type faturaScalarWhereWithAggregatesInput = {
    AND?:
      | faturaScalarWhereWithAggregatesInput
      | faturaScalarWhereWithAggregatesInput[];
    OR?: faturaScalarWhereWithAggregatesInput[];
    NOT?:
      | faturaScalarWhereWithAggregatesInput
      | faturaScalarWhereWithAggregatesInput[];
    cod_fatura?: IntWithAggregatesFilter<'fatura'> | number;
    mesano_fatura?: StringWithAggregatesFilter<'fatura'> | string;
    desp_fatura?:
      | DecimalNullableWithAggregatesFilter<'fatura'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    imp_fatura?:
      | DecimalNullableWithAggregatesFilter<'fatura'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    lucro_fatura?:
      | DecimalNullableWithAggregatesFilter<'fatura'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type faturamentoWhereInput = {
    AND?: faturamentoWhereInput | faturamentoWhereInput[];
    OR?: faturamentoWhereInput[];
    NOT?: faturamentoWhereInput | faturamentoWhereInput[];
    cod_faturamento?: IntFilter<'faturamento'> | number;
    data_faturamento?: DateTimeFilter<'faturamento'> | Date | string;
    hora_faturamento?: StringFilter<'faturamento'> | string;
    usu_faturamento?: StringNullableFilter<'faturamento'> | string | null;
    ini_faturamento?: DateTimeFilter<'faturamento'> | Date | string;
    fim_faturamento?: DateTimeFilter<'faturamento'> | Date | string;
    status_faturamento?: StringFilter<'faturamento'> | string;
    mesano_faturamento?: StringNullableFilter<'faturamento'> | string | null;
  };

  export type faturamentoOrderByWithRelationInput = {
    cod_faturamento?: SortOrder;
    data_faturamento?: SortOrder;
    hora_faturamento?: SortOrder;
    usu_faturamento?: SortOrderInput | SortOrder;
    ini_faturamento?: SortOrder;
    fim_faturamento?: SortOrder;
    status_faturamento?: SortOrder;
    mesano_faturamento?: SortOrderInput | SortOrder;
  };

  export type faturamentoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_faturamento?: number;
      AND?: faturamentoWhereInput | faturamentoWhereInput[];
      OR?: faturamentoWhereInput[];
      NOT?: faturamentoWhereInput | faturamentoWhereInput[];
      data_faturamento?: DateTimeFilter<'faturamento'> | Date | string;
      hora_faturamento?: StringFilter<'faturamento'> | string;
      usu_faturamento?: StringNullableFilter<'faturamento'> | string | null;
      ini_faturamento?: DateTimeFilter<'faturamento'> | Date | string;
      fim_faturamento?: DateTimeFilter<'faturamento'> | Date | string;
      status_faturamento?: StringFilter<'faturamento'> | string;
      mesano_faturamento?: StringNullableFilter<'faturamento'> | string | null;
    },
    'cod_faturamento'
  >;

  export type faturamentoOrderByWithAggregationInput = {
    cod_faturamento?: SortOrder;
    data_faturamento?: SortOrder;
    hora_faturamento?: SortOrder;
    usu_faturamento?: SortOrderInput | SortOrder;
    ini_faturamento?: SortOrder;
    fim_faturamento?: SortOrder;
    status_faturamento?: SortOrder;
    mesano_faturamento?: SortOrderInput | SortOrder;
    _count?: faturamentoCountOrderByAggregateInput;
    _avg?: faturamentoAvgOrderByAggregateInput;
    _max?: faturamentoMaxOrderByAggregateInput;
    _min?: faturamentoMinOrderByAggregateInput;
    _sum?: faturamentoSumOrderByAggregateInput;
  };

  export type faturamentoScalarWhereWithAggregatesInput = {
    AND?:
      | faturamentoScalarWhereWithAggregatesInput
      | faturamentoScalarWhereWithAggregatesInput[];
    OR?: faturamentoScalarWhereWithAggregatesInput[];
    NOT?:
      | faturamentoScalarWhereWithAggregatesInput
      | faturamentoScalarWhereWithAggregatesInput[];
    cod_faturamento?: IntWithAggregatesFilter<'faturamento'> | number;
    data_faturamento?:
      | DateTimeWithAggregatesFilter<'faturamento'>
      | Date
      | string;
    hora_faturamento?: StringWithAggregatesFilter<'faturamento'> | string;
    usu_faturamento?:
      | StringNullableWithAggregatesFilter<'faturamento'>
      | string
      | null;
    ini_faturamento?:
      | DateTimeWithAggregatesFilter<'faturamento'>
      | Date
      | string;
    fim_faturamento?:
      | DateTimeWithAggregatesFilter<'faturamento'>
      | Date
      | string;
    status_faturamento?: StringWithAggregatesFilter<'faturamento'> | string;
    mesano_faturamento?:
      | StringNullableWithAggregatesFilter<'faturamento'>
      | string
      | null;
  };

  export type grupoWhereInput = {
    AND?: grupoWhereInput | grupoWhereInput[];
    OR?: grupoWhereInput[];
    NOT?: grupoWhereInput | grupoWhereInput[];
    cod_grupo?: IntFilter<'grupo'> | number;
    desc_grupo?: StringFilter<'grupo'> | string;
  };

  export type grupoOrderByWithRelationInput = {
    cod_grupo?: SortOrder;
    desc_grupo?: SortOrder;
  };

  export type grupoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_grupo?: number;
      AND?: grupoWhereInput | grupoWhereInput[];
      OR?: grupoWhereInput[];
      NOT?: grupoWhereInput | grupoWhereInput[];
      desc_grupo?: StringFilter<'grupo'> | string;
    },
    'cod_grupo'
  >;

  export type grupoOrderByWithAggregationInput = {
    cod_grupo?: SortOrder;
    desc_grupo?: SortOrder;
    _count?: grupoCountOrderByAggregateInput;
    _avg?: grupoAvgOrderByAggregateInput;
    _max?: grupoMaxOrderByAggregateInput;
    _min?: grupoMinOrderByAggregateInput;
    _sum?: grupoSumOrderByAggregateInput;
  };

  export type grupoScalarWhereWithAggregatesInput = {
    AND?:
      | grupoScalarWhereWithAggregatesInput
      | grupoScalarWhereWithAggregatesInput[];
    OR?: grupoScalarWhereWithAggregatesInput[];
    NOT?:
      | grupoScalarWhereWithAggregatesInput
      | grupoScalarWhereWithAggregatesInput[];
    cod_grupo?: IntWithAggregatesFilter<'grupo'> | number;
    desc_grupo?: StringWithAggregatesFilter<'grupo'> | string;
  };

  export type histchamadoWhereInput = {
    AND?: histchamadoWhereInput | histchamadoWhereInput[];
    OR?: histchamadoWhereInput[];
    NOT?: histchamadoWhereInput | histchamadoWhereInput[];
    cod_histchamado?: IntFilter<'histchamado'> | number;
    cod_chamado?: IntFilter<'histchamado'> | number;
    data_histchamado?: DateTimeFilter<'histchamado'> | Date | string;
    hora_histchamado?: StringFilter<'histchamado'> | string;
    desc_histchamado?: StringNullableFilter<'histchamado'> | string | null;
  };

  export type histchamadoOrderByWithRelationInput = {
    cod_histchamado?: SortOrder;
    cod_chamado?: SortOrder;
    data_histchamado?: SortOrder;
    hora_histchamado?: SortOrder;
    desc_histchamado?: SortOrderInput | SortOrder;
  };

  export type histchamadoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_histchamado?: number;
      AND?: histchamadoWhereInput | histchamadoWhereInput[];
      OR?: histchamadoWhereInput[];
      NOT?: histchamadoWhereInput | histchamadoWhereInput[];
      cod_chamado?: IntFilter<'histchamado'> | number;
      data_histchamado?: DateTimeFilter<'histchamado'> | Date | string;
      hora_histchamado?: StringFilter<'histchamado'> | string;
      desc_histchamado?: StringNullableFilter<'histchamado'> | string | null;
    },
    'cod_histchamado'
  >;

  export type histchamadoOrderByWithAggregationInput = {
    cod_histchamado?: SortOrder;
    cod_chamado?: SortOrder;
    data_histchamado?: SortOrder;
    hora_histchamado?: SortOrder;
    desc_histchamado?: SortOrderInput | SortOrder;
    _count?: histchamadoCountOrderByAggregateInput;
    _avg?: histchamadoAvgOrderByAggregateInput;
    _max?: histchamadoMaxOrderByAggregateInput;
    _min?: histchamadoMinOrderByAggregateInput;
    _sum?: histchamadoSumOrderByAggregateInput;
  };

  export type histchamadoScalarWhereWithAggregatesInput = {
    AND?:
      | histchamadoScalarWhereWithAggregatesInput
      | histchamadoScalarWhereWithAggregatesInput[];
    OR?: histchamadoScalarWhereWithAggregatesInput[];
    NOT?:
      | histchamadoScalarWhereWithAggregatesInput
      | histchamadoScalarWhereWithAggregatesInput[];
    cod_histchamado?: IntWithAggregatesFilter<'histchamado'> | number;
    cod_chamado?: IntWithAggregatesFilter<'histchamado'> | number;
    data_histchamado?:
      | DateTimeWithAggregatesFilter<'histchamado'>
      | Date
      | string;
    hora_histchamado?: StringWithAggregatesFilter<'histchamado'> | string;
    desc_histchamado?:
      | StringNullableWithAggregatesFilter<'histchamado'>
      | string
      | null;
  };

  export type itavaliadoWhereInput = {
    AND?: itavaliadoWhereInput | itavaliadoWhereInput[];
    OR?: itavaliadoWhereInput[];
    NOT?: itavaliadoWhereInput | itavaliadoWhereInput[];
    codaval_itavaliado?: IntFilter<'itavaliado'> | number;
    codrec_itavaliado?: IntFilter<'itavaliado'> | number;
    codmat_itavaliado?: IntFilter<'itavaliado'> | number;
    coditmat_itavaliado?: IntFilter<'itavaliado'> | number;
    ptoger_itavaliado?: IntFilter<'itavaliado'> | number;
    ptorec_itavaliado?: IntFilter<'itavaliado'> | number;
    obs_itavaliado?: StringNullableFilter<'itavaliado'> | string | null;
    nota1_itavaliado?:
      | DecimalFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    avaliado?: XOR<AvaliadoScalarRelationFilter, avaliadoWhereInput>;
    itmatriz?: XOR<ItmatrizScalarRelationFilter, itmatrizWhereInput>;
  };

  export type itavaliadoOrderByWithRelationInput = {
    codaval_itavaliado?: SortOrder;
    codrec_itavaliado?: SortOrder;
    codmat_itavaliado?: SortOrder;
    coditmat_itavaliado?: SortOrder;
    ptoger_itavaliado?: SortOrder;
    ptorec_itavaliado?: SortOrder;
    obs_itavaliado?: SortOrderInput | SortOrder;
    nota1_itavaliado?: SortOrder;
    nota2_itavaliado?: SortOrder;
    nota3_itavaliado?: SortOrder;
    avaliado?: avaliadoOrderByWithRelationInput;
    itmatriz?: itmatrizOrderByWithRelationInput;
  };

  export type itavaliadoWhereUniqueInput = Prisma.AtLeast<
    {
      codaval_itavaliado_codrec_itavaliado_codmat_itavaliado_coditmat_itavaliado?: itavaliadoCodaval_itavaliadoCodrec_itavaliadoCodmat_itavaliadoCoditmat_itavaliadoCompoundUniqueInput;
      AND?: itavaliadoWhereInput | itavaliadoWhereInput[];
      OR?: itavaliadoWhereInput[];
      NOT?: itavaliadoWhereInput | itavaliadoWhereInput[];
      codaval_itavaliado?: IntFilter<'itavaliado'> | number;
      codrec_itavaliado?: IntFilter<'itavaliado'> | number;
      codmat_itavaliado?: IntFilter<'itavaliado'> | number;
      coditmat_itavaliado?: IntFilter<'itavaliado'> | number;
      ptoger_itavaliado?: IntFilter<'itavaliado'> | number;
      ptorec_itavaliado?: IntFilter<'itavaliado'> | number;
      obs_itavaliado?: StringNullableFilter<'itavaliado'> | string | null;
      nota1_itavaliado?:
        | DecimalFilter<'itavaliado'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      nota2_itavaliado?:
        | DecimalFilter<'itavaliado'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      nota3_itavaliado?:
        | DecimalFilter<'itavaliado'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      avaliado?: XOR<AvaliadoScalarRelationFilter, avaliadoWhereInput>;
      itmatriz?: XOR<ItmatrizScalarRelationFilter, itmatrizWhereInput>;
    },
    'codaval_itavaliado_codrec_itavaliado_codmat_itavaliado_coditmat_itavaliado'
  >;

  export type itavaliadoOrderByWithAggregationInput = {
    codaval_itavaliado?: SortOrder;
    codrec_itavaliado?: SortOrder;
    codmat_itavaliado?: SortOrder;
    coditmat_itavaliado?: SortOrder;
    ptoger_itavaliado?: SortOrder;
    ptorec_itavaliado?: SortOrder;
    obs_itavaliado?: SortOrderInput | SortOrder;
    nota1_itavaliado?: SortOrder;
    nota2_itavaliado?: SortOrder;
    nota3_itavaliado?: SortOrder;
    _count?: itavaliadoCountOrderByAggregateInput;
    _avg?: itavaliadoAvgOrderByAggregateInput;
    _max?: itavaliadoMaxOrderByAggregateInput;
    _min?: itavaliadoMinOrderByAggregateInput;
    _sum?: itavaliadoSumOrderByAggregateInput;
  };

  export type itavaliadoScalarWhereWithAggregatesInput = {
    AND?:
      | itavaliadoScalarWhereWithAggregatesInput
      | itavaliadoScalarWhereWithAggregatesInput[];
    OR?: itavaliadoScalarWhereWithAggregatesInput[];
    NOT?:
      | itavaliadoScalarWhereWithAggregatesInput
      | itavaliadoScalarWhereWithAggregatesInput[];
    codaval_itavaliado?: IntWithAggregatesFilter<'itavaliado'> | number;
    codrec_itavaliado?: IntWithAggregatesFilter<'itavaliado'> | number;
    codmat_itavaliado?: IntWithAggregatesFilter<'itavaliado'> | number;
    coditmat_itavaliado?: IntWithAggregatesFilter<'itavaliado'> | number;
    ptoger_itavaliado?: IntWithAggregatesFilter<'itavaliado'> | number;
    ptorec_itavaliado?: IntWithAggregatesFilter<'itavaliado'> | number;
    obs_itavaliado?:
      | StringNullableWithAggregatesFilter<'itavaliado'>
      | string
      | null;
    nota1_itavaliado?:
      | DecimalWithAggregatesFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalWithAggregatesFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalWithAggregatesFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type itmatrizWhereInput = {
    AND?: itmatrizWhereInput | itmatrizWhereInput[];
    OR?: itmatrizWhereInput[];
    NOT?: itmatrizWhereInput | itmatrizWhereInput[];
    codmat_itmatriz?: IntFilter<'itmatriz'> | number;
    cod_itmatriz?: IntFilter<'itmatriz'> | number;
    nota1_itmatriz?:
      | DecimalFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?: BytesNullableFilter<'itmatriz'> | Uint8Array | null;
    itavaliado?: ItavaliadoListRelationFilter;
    matriz?: XOR<MatrizScalarRelationFilter, matrizWhereInput>;
  };

  export type itmatrizOrderByWithRelationInput = {
    codmat_itmatriz?: SortOrder;
    cod_itmatriz?: SortOrder;
    nota1_itmatriz?: SortOrder;
    nota2_itmatriz?: SortOrder;
    nota3_itmatriz?: SortOrder;
    questao_itmatriz?: SortOrderInput | SortOrder;
    itavaliado?: itavaliadoOrderByRelationAggregateInput;
    matriz?: matrizOrderByWithRelationInput;
  };

  export type itmatrizWhereUniqueInput = Prisma.AtLeast<
    {
      codmat_itmatriz_cod_itmatriz?: itmatrizCodmat_itmatrizCod_itmatrizCompoundUniqueInput;
      AND?: itmatrizWhereInput | itmatrizWhereInput[];
      OR?: itmatrizWhereInput[];
      NOT?: itmatrizWhereInput | itmatrizWhereInput[];
      codmat_itmatriz?: IntFilter<'itmatriz'> | number;
      cod_itmatriz?: IntFilter<'itmatriz'> | number;
      nota1_itmatriz?:
        | DecimalFilter<'itmatriz'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      nota2_itmatriz?:
        | DecimalFilter<'itmatriz'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      nota3_itmatriz?:
        | DecimalFilter<'itmatriz'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      questao_itmatriz?: BytesNullableFilter<'itmatriz'> | Uint8Array | null;
      itavaliado?: ItavaliadoListRelationFilter;
      matriz?: XOR<MatrizScalarRelationFilter, matrizWhereInput>;
    },
    'codmat_itmatriz_cod_itmatriz'
  >;

  export type itmatrizOrderByWithAggregationInput = {
    codmat_itmatriz?: SortOrder;
    cod_itmatriz?: SortOrder;
    nota1_itmatriz?: SortOrder;
    nota2_itmatriz?: SortOrder;
    nota3_itmatriz?: SortOrder;
    questao_itmatriz?: SortOrderInput | SortOrder;
    _count?: itmatrizCountOrderByAggregateInput;
    _avg?: itmatrizAvgOrderByAggregateInput;
    _max?: itmatrizMaxOrderByAggregateInput;
    _min?: itmatrizMinOrderByAggregateInput;
    _sum?: itmatrizSumOrderByAggregateInput;
  };

  export type itmatrizScalarWhereWithAggregatesInput = {
    AND?:
      | itmatrizScalarWhereWithAggregatesInput
      | itmatrizScalarWhereWithAggregatesInput[];
    OR?: itmatrizScalarWhereWithAggregatesInput[];
    NOT?:
      | itmatrizScalarWhereWithAggregatesInput
      | itmatrizScalarWhereWithAggregatesInput[];
    codmat_itmatriz?: IntWithAggregatesFilter<'itmatriz'> | number;
    cod_itmatriz?: IntWithAggregatesFilter<'itmatriz'> | number;
    nota1_itmatriz?:
      | DecimalWithAggregatesFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalWithAggregatesFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalWithAggregatesFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | BytesNullableWithAggregatesFilter<'itmatriz'>
      | Uint8Array
      | null;
  };

  export type layoutWhereInput = {
    AND?: layoutWhereInput | layoutWhereInput[];
    OR?: layoutWhereInput[];
    NOT?: layoutWhereInput | layoutWhereInput[];
    cod_layout?: IntFilter<'layout'> | number;
    tabela_layout?: StringNullableFilter<'layout'> | string | null;
    campo_layout?: StringNullableFilter<'layout'> | string | null;
    posicao_layout?: IntNullableFilter<'layout'> | number | null;
  };

  export type layoutOrderByWithRelationInput = {
    cod_layout?: SortOrder;
    tabela_layout?: SortOrderInput | SortOrder;
    campo_layout?: SortOrderInput | SortOrder;
    posicao_layout?: SortOrderInput | SortOrder;
  };

  export type layoutWhereUniqueInput = Prisma.AtLeast<
    {
      cod_layout?: number;
      AND?: layoutWhereInput | layoutWhereInput[];
      OR?: layoutWhereInput[];
      NOT?: layoutWhereInput | layoutWhereInput[];
      tabela_layout?: StringNullableFilter<'layout'> | string | null;
      campo_layout?: StringNullableFilter<'layout'> | string | null;
      posicao_layout?: IntNullableFilter<'layout'> | number | null;
    },
    'cod_layout'
  >;

  export type layoutOrderByWithAggregationInput = {
    cod_layout?: SortOrder;
    tabela_layout?: SortOrderInput | SortOrder;
    campo_layout?: SortOrderInput | SortOrder;
    posicao_layout?: SortOrderInput | SortOrder;
    _count?: layoutCountOrderByAggregateInput;
    _avg?: layoutAvgOrderByAggregateInput;
    _max?: layoutMaxOrderByAggregateInput;
    _min?: layoutMinOrderByAggregateInput;
    _sum?: layoutSumOrderByAggregateInput;
  };

  export type layoutScalarWhereWithAggregatesInput = {
    AND?:
      | layoutScalarWhereWithAggregatesInput
      | layoutScalarWhereWithAggregatesInput[];
    OR?: layoutScalarWhereWithAggregatesInput[];
    NOT?:
      | layoutScalarWhereWithAggregatesInput
      | layoutScalarWhereWithAggregatesInput[];
    cod_layout?: IntWithAggregatesFilter<'layout'> | number;
    tabela_layout?:
      | StringNullableWithAggregatesFilter<'layout'>
      | string
      | null;
    campo_layout?: StringNullableWithAggregatesFilter<'layout'> | string | null;
    posicao_layout?: IntNullableWithAggregatesFilter<'layout'> | number | null;
  };

  export type listaWhereInput = {
    AND?: listaWhereInput | listaWhereInput[];
    OR?: listaWhereInput[];
    NOT?: listaWhereInput | listaWhereInput[];
    cod_lista?: IntFilter<'lista'> | number;
    cod_grupo?: IntFilter<'lista'> | number;
    cod_status?: IntFilter<'lista'> | number;
    cgccpf_lista?: StringFilter<'lista'> | string;
    id_lista?: StringNullableFilter<'lista'> | string | null;
    nome_lista?: StringFilter<'lista'> | string;
    end_lista?: StringNullableFilter<'lista'> | string | null;
    num_lista?: StringNullableFilter<'lista'> | string | null;
    comp_lista?: StringNullableFilter<'lista'> | string | null;
    cep_lista?: StringNullableFilter<'lista'> | string | null;
    bairro_lista?: StringNullableFilter<'lista'> | string | null;
    cidade_lista?: StringNullableFilter<'lista'> | string | null;
    uf_lista?: StringNullableFilter<'lista'> | string | null;
    email_lista?: StringNullableFilter<'lista'> | string | null;
    dtcontactar_lista?: DateTimeFilter<'lista'> | Date | string;
    dtcad_lista?: DateTimeFilter<'lista'> | Date | string;
    obs_lista?: BytesNullableFilter<'lista'> | Uint8Array | null;
  };

  export type listaOrderByWithRelationInput = {
    cod_lista?: SortOrder;
    cod_grupo?: SortOrder;
    cod_status?: SortOrder;
    cgccpf_lista?: SortOrder;
    id_lista?: SortOrderInput | SortOrder;
    nome_lista?: SortOrder;
    end_lista?: SortOrderInput | SortOrder;
    num_lista?: SortOrderInput | SortOrder;
    comp_lista?: SortOrderInput | SortOrder;
    cep_lista?: SortOrderInput | SortOrder;
    bairro_lista?: SortOrderInput | SortOrder;
    cidade_lista?: SortOrderInput | SortOrder;
    uf_lista?: SortOrderInput | SortOrder;
    email_lista?: SortOrderInput | SortOrder;
    dtcontactar_lista?: SortOrder;
    dtcad_lista?: SortOrder;
    obs_lista?: SortOrderInput | SortOrder;
  };

  export type listaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_lista?: number;
      AND?: listaWhereInput | listaWhereInput[];
      OR?: listaWhereInput[];
      NOT?: listaWhereInput | listaWhereInput[];
      cod_grupo?: IntFilter<'lista'> | number;
      cod_status?: IntFilter<'lista'> | number;
      cgccpf_lista?: StringFilter<'lista'> | string;
      id_lista?: StringNullableFilter<'lista'> | string | null;
      nome_lista?: StringFilter<'lista'> | string;
      end_lista?: StringNullableFilter<'lista'> | string | null;
      num_lista?: StringNullableFilter<'lista'> | string | null;
      comp_lista?: StringNullableFilter<'lista'> | string | null;
      cep_lista?: StringNullableFilter<'lista'> | string | null;
      bairro_lista?: StringNullableFilter<'lista'> | string | null;
      cidade_lista?: StringNullableFilter<'lista'> | string | null;
      uf_lista?: StringNullableFilter<'lista'> | string | null;
      email_lista?: StringNullableFilter<'lista'> | string | null;
      dtcontactar_lista?: DateTimeFilter<'lista'> | Date | string;
      dtcad_lista?: DateTimeFilter<'lista'> | Date | string;
      obs_lista?: BytesNullableFilter<'lista'> | Uint8Array | null;
    },
    'cod_lista'
  >;

  export type listaOrderByWithAggregationInput = {
    cod_lista?: SortOrder;
    cod_grupo?: SortOrder;
    cod_status?: SortOrder;
    cgccpf_lista?: SortOrder;
    id_lista?: SortOrderInput | SortOrder;
    nome_lista?: SortOrder;
    end_lista?: SortOrderInput | SortOrder;
    num_lista?: SortOrderInput | SortOrder;
    comp_lista?: SortOrderInput | SortOrder;
    cep_lista?: SortOrderInput | SortOrder;
    bairro_lista?: SortOrderInput | SortOrder;
    cidade_lista?: SortOrderInput | SortOrder;
    uf_lista?: SortOrderInput | SortOrder;
    email_lista?: SortOrderInput | SortOrder;
    dtcontactar_lista?: SortOrder;
    dtcad_lista?: SortOrder;
    obs_lista?: SortOrderInput | SortOrder;
    _count?: listaCountOrderByAggregateInput;
    _avg?: listaAvgOrderByAggregateInput;
    _max?: listaMaxOrderByAggregateInput;
    _min?: listaMinOrderByAggregateInput;
    _sum?: listaSumOrderByAggregateInput;
  };

  export type listaScalarWhereWithAggregatesInput = {
    AND?:
      | listaScalarWhereWithAggregatesInput
      | listaScalarWhereWithAggregatesInput[];
    OR?: listaScalarWhereWithAggregatesInput[];
    NOT?:
      | listaScalarWhereWithAggregatesInput
      | listaScalarWhereWithAggregatesInput[];
    cod_lista?: IntWithAggregatesFilter<'lista'> | number;
    cod_grupo?: IntWithAggregatesFilter<'lista'> | number;
    cod_status?: IntWithAggregatesFilter<'lista'> | number;
    cgccpf_lista?: StringWithAggregatesFilter<'lista'> | string;
    id_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    nome_lista?: StringWithAggregatesFilter<'lista'> | string;
    end_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    num_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    comp_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    cep_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    bairro_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    cidade_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    uf_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    email_lista?: StringNullableWithAggregatesFilter<'lista'> | string | null;
    dtcontactar_lista?: DateTimeWithAggregatesFilter<'lista'> | Date | string;
    dtcad_lista?: DateTimeWithAggregatesFilter<'lista'> | Date | string;
    obs_lista?: BytesNullableWithAggregatesFilter<'lista'> | Uint8Array | null;
  };

  export type matrizWhereInput = {
    AND?: matrizWhereInput | matrizWhereInput[];
    OR?: matrizWhereInput[];
    NOT?: matrizWhereInput | matrizWhereInput[];
    cod_matriz?: IntFilter<'matriz'> | number;
    desc_matriz?: StringFilter<'matriz'> | string;
    status_matriz?: StringFilter<'matriz'> | string;
    itmatriz?: ItmatrizListRelationFilter;
  };

  export type matrizOrderByWithRelationInput = {
    cod_matriz?: SortOrder;
    desc_matriz?: SortOrder;
    status_matriz?: SortOrder;
    itmatriz?: itmatrizOrderByRelationAggregateInput;
  };

  export type matrizWhereUniqueInput = Prisma.AtLeast<
    {
      cod_matriz?: number;
      AND?: matrizWhereInput | matrizWhereInput[];
      OR?: matrizWhereInput[];
      NOT?: matrizWhereInput | matrizWhereInput[];
      desc_matriz?: StringFilter<'matriz'> | string;
      status_matriz?: StringFilter<'matriz'> | string;
      itmatriz?: ItmatrizListRelationFilter;
    },
    'cod_matriz'
  >;

  export type matrizOrderByWithAggregationInput = {
    cod_matriz?: SortOrder;
    desc_matriz?: SortOrder;
    status_matriz?: SortOrder;
    _count?: matrizCountOrderByAggregateInput;
    _avg?: matrizAvgOrderByAggregateInput;
    _max?: matrizMaxOrderByAggregateInput;
    _min?: matrizMinOrderByAggregateInput;
    _sum?: matrizSumOrderByAggregateInput;
  };

  export type matrizScalarWhereWithAggregatesInput = {
    AND?:
      | matrizScalarWhereWithAggregatesInput
      | matrizScalarWhereWithAggregatesInput[];
    OR?: matrizScalarWhereWithAggregatesInput[];
    NOT?:
      | matrizScalarWhereWithAggregatesInput
      | matrizScalarWhereWithAggregatesInput[];
    cod_matriz?: IntWithAggregatesFilter<'matriz'> | number;
    desc_matriz?: StringWithAggregatesFilter<'matriz'> | string;
    status_matriz?: StringWithAggregatesFilter<'matriz'> | string;
  };

  export type mensagemWhereInput = {
    AND?: mensagemWhereInput | mensagemWhereInput[];
    OR?: mensagemWhereInput[];
    NOT?: mensagemWhereInput | mensagemWhereInput[];
    cod_mensagem?: IntFilter<'mensagem'> | number;
    desc_mensagem?: StringFilter<'mensagem'> | string;
  };

  export type mensagemOrderByWithRelationInput = {
    cod_mensagem?: SortOrder;
    desc_mensagem?: SortOrder;
  };

  export type mensagemWhereUniqueInput = Prisma.AtLeast<
    {
      cod_mensagem?: number;
      AND?: mensagemWhereInput | mensagemWhereInput[];
      OR?: mensagemWhereInput[];
      NOT?: mensagemWhereInput | mensagemWhereInput[];
      desc_mensagem?: StringFilter<'mensagem'> | string;
    },
    'cod_mensagem'
  >;

  export type mensagemOrderByWithAggregationInput = {
    cod_mensagem?: SortOrder;
    desc_mensagem?: SortOrder;
    _count?: mensagemCountOrderByAggregateInput;
    _avg?: mensagemAvgOrderByAggregateInput;
    _max?: mensagemMaxOrderByAggregateInput;
    _min?: mensagemMinOrderByAggregateInput;
    _sum?: mensagemSumOrderByAggregateInput;
  };

  export type mensagemScalarWhereWithAggregatesInput = {
    AND?:
      | mensagemScalarWhereWithAggregatesInput
      | mensagemScalarWhereWithAggregatesInput[];
    OR?: mensagemScalarWhereWithAggregatesInput[];
    NOT?:
      | mensagemScalarWhereWithAggregatesInput
      | mensagemScalarWhereWithAggregatesInput[];
    cod_mensagem?: IntWithAggregatesFilter<'mensagem'> | number;
    desc_mensagem?: StringWithAggregatesFilter<'mensagem'> | string;
  };

  export type metaWhereInput = {
    AND?: metaWhereInput | metaWhereInput[];
    OR?: metaWhereInput[];
    NOT?: metaWhereInput | metaWhereInput[];
    codproj_meta?: IntFilter<'meta'> | number;
    codarea_meta?: IntFilter<'meta'> | number;
    codfase_meta?: IntFilter<'meta'> | number;
    tempo_meta?:
      | DecimalFilter<'meta'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFilter<'meta'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    area?: XOR<AreaScalarRelationFilter, areaWhereInput>;
    fase?: XOR<FaseScalarRelationFilter, faseWhereInput>;
    projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
  };

  export type metaOrderByWithRelationInput = {
    codproj_meta?: SortOrder;
    codarea_meta?: SortOrder;
    codfase_meta?: SortOrder;
    tempo_meta?: SortOrder;
    altesc_meta?: SortOrder;
    area?: areaOrderByWithRelationInput;
    fase?: faseOrderByWithRelationInput;
    projeto?: projetoOrderByWithRelationInput;
  };

  export type metaWhereUniqueInput = Prisma.AtLeast<
    {
      codproj_meta_codarea_meta_codfase_meta?: metaCodproj_metaCodarea_metaCodfase_metaCompoundUniqueInput;
      AND?: metaWhereInput | metaWhereInput[];
      OR?: metaWhereInput[];
      NOT?: metaWhereInput | metaWhereInput[];
      codproj_meta?: IntFilter<'meta'> | number;
      codarea_meta?: IntFilter<'meta'> | number;
      codfase_meta?: IntFilter<'meta'> | number;
      tempo_meta?:
        | DecimalFilter<'meta'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      altesc_meta?:
        | DecimalFilter<'meta'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      area?: XOR<AreaScalarRelationFilter, areaWhereInput>;
      fase?: XOR<FaseScalarRelationFilter, faseWhereInput>;
      projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
    },
    'codproj_meta_codarea_meta_codfase_meta'
  >;

  export type metaOrderByWithAggregationInput = {
    codproj_meta?: SortOrder;
    codarea_meta?: SortOrder;
    codfase_meta?: SortOrder;
    tempo_meta?: SortOrder;
    altesc_meta?: SortOrder;
    _count?: metaCountOrderByAggregateInput;
    _avg?: metaAvgOrderByAggregateInput;
    _max?: metaMaxOrderByAggregateInput;
    _min?: metaMinOrderByAggregateInput;
    _sum?: metaSumOrderByAggregateInput;
  };

  export type metaScalarWhereWithAggregatesInput = {
    AND?:
      | metaScalarWhereWithAggregatesInput
      | metaScalarWhereWithAggregatesInput[];
    OR?: metaScalarWhereWithAggregatesInput[];
    NOT?:
      | metaScalarWhereWithAggregatesInput
      | metaScalarWhereWithAggregatesInput[];
    codproj_meta?: IntWithAggregatesFilter<'meta'> | number;
    codarea_meta?: IntWithAggregatesFilter<'meta'> | number;
    codfase_meta?: IntWithAggregatesFilter<'meta'> | number;
    tempo_meta?:
      | DecimalWithAggregatesFilter<'meta'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalWithAggregatesFilter<'meta'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type modulo_sistemaWhereInput = {
    AND?: modulo_sistemaWhereInput | modulo_sistemaWhereInput[];
    OR?: modulo_sistemaWhereInput[];
    NOT?: modulo_sistemaWhereInput | modulo_sistemaWhereInput[];
    cod_modulo?: IntFilter<'modulo_sistema'> | number;
    desc_modulo?: StringFilter<'modulo_sistema'> | string;
    acesso_sistema?: Acesso_sistemaListRelationFilter;
    tela_sistema?: Tela_sistemaListRelationFilter;
  };

  export type modulo_sistemaOrderByWithRelationInput = {
    cod_modulo?: SortOrder;
    desc_modulo?: SortOrder;
    acesso_sistema?: acesso_sistemaOrderByRelationAggregateInput;
    tela_sistema?: tela_sistemaOrderByRelationAggregateInput;
  };

  export type modulo_sistemaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_modulo?: number;
      AND?: modulo_sistemaWhereInput | modulo_sistemaWhereInput[];
      OR?: modulo_sistemaWhereInput[];
      NOT?: modulo_sistemaWhereInput | modulo_sistemaWhereInput[];
      desc_modulo?: StringFilter<'modulo_sistema'> | string;
      acesso_sistema?: Acesso_sistemaListRelationFilter;
      tela_sistema?: Tela_sistemaListRelationFilter;
    },
    'cod_modulo'
  >;

  export type modulo_sistemaOrderByWithAggregationInput = {
    cod_modulo?: SortOrder;
    desc_modulo?: SortOrder;
    _count?: modulo_sistemaCountOrderByAggregateInput;
    _avg?: modulo_sistemaAvgOrderByAggregateInput;
    _max?: modulo_sistemaMaxOrderByAggregateInput;
    _min?: modulo_sistemaMinOrderByAggregateInput;
    _sum?: modulo_sistemaSumOrderByAggregateInput;
  };

  export type modulo_sistemaScalarWhereWithAggregatesInput = {
    AND?:
      | modulo_sistemaScalarWhereWithAggregatesInput
      | modulo_sistemaScalarWhereWithAggregatesInput[];
    OR?: modulo_sistemaScalarWhereWithAggregatesInput[];
    NOT?:
      | modulo_sistemaScalarWhereWithAggregatesInput
      | modulo_sistemaScalarWhereWithAggregatesInput[];
    cod_modulo?: IntWithAggregatesFilter<'modulo_sistema'> | number;
    desc_modulo?: StringWithAggregatesFilter<'modulo_sistema'> | string;
  };

  export type nfseWhereInput = {
    AND?: nfseWhereInput | nfseWhereInput[];
    OR?: nfseWhereInput[];
    NOT?: nfseWhereInput | nfseWhereInput[];
    cod_nfse?: IntFilter<'nfse'> | number;
    num_nfse?: StringNullableFilter<'nfse'> | string | null;
    dtemissao_nfse?: DateTimeFilter<'nfse'> | Date | string;
    hremissao_nfse?: StringFilter<'nfse'> | string;
    cod_empresa?: IntFilter<'nfse'> | number;
    cod_cliente?: IntFilter<'nfse'> | number;
    discr_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
    cod_ctiss?: IntFilter<'nfse'> | number;
    natoper_nfse?: IntFilter<'nfse'> | number;
    regtrib_nfse?: IntFilter<'nfse'> | number;
    vrtot_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrded_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc1_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc2_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrir_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrpis_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcofins_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcsll_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrout_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    issret_nfse?: IntFilter<'nfse'> | number;
    aliqiss_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrinss_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    doc_nfse?: StringNullableFilter<'nfse'> | string | null;
    aliqissret_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    xml_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
    codver_nfse?: StringNullableFilter<'nfse'> | string | null;
    logtrans_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
    logcan_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
    xmlformat_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
    prot_nfse?: StringNullableFilter<'nfse'> | string | null;
    chvcan_nfse?: StringNullableFilter<'nfse'> | string | null;
    dtcanc_nfse?: StringNullableFilter<'nfse'> | string | null;
    tipoper_nfse?: IntFilter<'nfse'> | number;
    opsimnac_nfse?: IntFilter<'nfse'> | number;
    csll_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_nfse?:
      | DecimalFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nfseOrderByWithRelationInput = {
    cod_nfse?: SortOrder;
    num_nfse?: SortOrderInput | SortOrder;
    dtemissao_nfse?: SortOrder;
    hremissao_nfse?: SortOrder;
    cod_empresa?: SortOrder;
    cod_cliente?: SortOrder;
    discr_nfse?: SortOrderInput | SortOrder;
    cod_ctiss?: SortOrder;
    natoper_nfse?: SortOrder;
    regtrib_nfse?: SortOrder;
    vrtot_nfse?: SortOrder;
    vrded_nfse?: SortOrder;
    vrdesc1_nfse?: SortOrder;
    vrdesc2_nfse?: SortOrder;
    vrir_nfse?: SortOrder;
    vrpis_nfse?: SortOrder;
    vrcofins_nfse?: SortOrder;
    vrcsll_nfse?: SortOrder;
    vrout_nfse?: SortOrder;
    issret_nfse?: SortOrder;
    aliqiss_nfse?: SortOrder;
    vrinss_nfse?: SortOrder;
    doc_nfse?: SortOrderInput | SortOrder;
    aliqissret_nfse?: SortOrder;
    xml_nfse?: SortOrderInput | SortOrder;
    codver_nfse?: SortOrderInput | SortOrder;
    logtrans_nfse?: SortOrderInput | SortOrder;
    logcan_nfse?: SortOrderInput | SortOrder;
    xmlformat_nfse?: SortOrderInput | SortOrder;
    prot_nfse?: SortOrderInput | SortOrder;
    chvcan_nfse?: SortOrderInput | SortOrder;
    dtcanc_nfse?: SortOrderInput | SortOrder;
    tipoper_nfse?: SortOrder;
    opsimnac_nfse?: SortOrder;
    csll_nfse?: SortOrder;
    pis_nfse?: SortOrder;
    cofins_nfse?: SortOrder;
    irrf_nfse?: SortOrder;
  };

  export type nfseWhereUniqueInput = Prisma.AtLeast<
    {
      cod_nfse?: number;
      AND?: nfseWhereInput | nfseWhereInput[];
      OR?: nfseWhereInput[];
      NOT?: nfseWhereInput | nfseWhereInput[];
      num_nfse?: StringNullableFilter<'nfse'> | string | null;
      dtemissao_nfse?: DateTimeFilter<'nfse'> | Date | string;
      hremissao_nfse?: StringFilter<'nfse'> | string;
      cod_empresa?: IntFilter<'nfse'> | number;
      cod_cliente?: IntFilter<'nfse'> | number;
      discr_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
      cod_ctiss?: IntFilter<'nfse'> | number;
      natoper_nfse?: IntFilter<'nfse'> | number;
      regtrib_nfse?: IntFilter<'nfse'> | number;
      vrtot_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrded_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrdesc1_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrdesc2_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrir_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrpis_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrcofins_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrcsll_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrout_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      issret_nfse?: IntFilter<'nfse'> | number;
      aliqiss_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      vrinss_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      doc_nfse?: StringNullableFilter<'nfse'> | string | null;
      aliqissret_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      xml_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
      codver_nfse?: StringNullableFilter<'nfse'> | string | null;
      logtrans_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
      logcan_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
      xmlformat_nfse?: BytesNullableFilter<'nfse'> | Uint8Array | null;
      prot_nfse?: StringNullableFilter<'nfse'> | string | null;
      chvcan_nfse?: StringNullableFilter<'nfse'> | string | null;
      dtcanc_nfse?: StringNullableFilter<'nfse'> | string | null;
      tipoper_nfse?: IntFilter<'nfse'> | number;
      opsimnac_nfse?: IntFilter<'nfse'> | number;
      csll_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      pis_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      cofins_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      irrf_nfse?:
        | DecimalFilter<'nfse'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
    },
    'cod_nfse'
  >;

  export type nfseOrderByWithAggregationInput = {
    cod_nfse?: SortOrder;
    num_nfse?: SortOrderInput | SortOrder;
    dtemissao_nfse?: SortOrder;
    hremissao_nfse?: SortOrder;
    cod_empresa?: SortOrder;
    cod_cliente?: SortOrder;
    discr_nfse?: SortOrderInput | SortOrder;
    cod_ctiss?: SortOrder;
    natoper_nfse?: SortOrder;
    regtrib_nfse?: SortOrder;
    vrtot_nfse?: SortOrder;
    vrded_nfse?: SortOrder;
    vrdesc1_nfse?: SortOrder;
    vrdesc2_nfse?: SortOrder;
    vrir_nfse?: SortOrder;
    vrpis_nfse?: SortOrder;
    vrcofins_nfse?: SortOrder;
    vrcsll_nfse?: SortOrder;
    vrout_nfse?: SortOrder;
    issret_nfse?: SortOrder;
    aliqiss_nfse?: SortOrder;
    vrinss_nfse?: SortOrder;
    doc_nfse?: SortOrderInput | SortOrder;
    aliqissret_nfse?: SortOrder;
    xml_nfse?: SortOrderInput | SortOrder;
    codver_nfse?: SortOrderInput | SortOrder;
    logtrans_nfse?: SortOrderInput | SortOrder;
    logcan_nfse?: SortOrderInput | SortOrder;
    xmlformat_nfse?: SortOrderInput | SortOrder;
    prot_nfse?: SortOrderInput | SortOrder;
    chvcan_nfse?: SortOrderInput | SortOrder;
    dtcanc_nfse?: SortOrderInput | SortOrder;
    tipoper_nfse?: SortOrder;
    opsimnac_nfse?: SortOrder;
    csll_nfse?: SortOrder;
    pis_nfse?: SortOrder;
    cofins_nfse?: SortOrder;
    irrf_nfse?: SortOrder;
    _count?: nfseCountOrderByAggregateInput;
    _avg?: nfseAvgOrderByAggregateInput;
    _max?: nfseMaxOrderByAggregateInput;
    _min?: nfseMinOrderByAggregateInput;
    _sum?: nfseSumOrderByAggregateInput;
  };

  export type nfseScalarWhereWithAggregatesInput = {
    AND?:
      | nfseScalarWhereWithAggregatesInput
      | nfseScalarWhereWithAggregatesInput[];
    OR?: nfseScalarWhereWithAggregatesInput[];
    NOT?:
      | nfseScalarWhereWithAggregatesInput
      | nfseScalarWhereWithAggregatesInput[];
    cod_nfse?: IntWithAggregatesFilter<'nfse'> | number;
    num_nfse?: StringNullableWithAggregatesFilter<'nfse'> | string | null;
    dtemissao_nfse?: DateTimeWithAggregatesFilter<'nfse'> | Date | string;
    hremissao_nfse?: StringWithAggregatesFilter<'nfse'> | string;
    cod_empresa?: IntWithAggregatesFilter<'nfse'> | number;
    cod_cliente?: IntWithAggregatesFilter<'nfse'> | number;
    discr_nfse?: BytesNullableWithAggregatesFilter<'nfse'> | Uint8Array | null;
    cod_ctiss?: IntWithAggregatesFilter<'nfse'> | number;
    natoper_nfse?: IntWithAggregatesFilter<'nfse'> | number;
    regtrib_nfse?: IntWithAggregatesFilter<'nfse'> | number;
    vrtot_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrded_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc1_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc2_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrir_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrpis_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcofins_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcsll_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrout_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    issret_nfse?: IntWithAggregatesFilter<'nfse'> | number;
    aliqiss_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrinss_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    doc_nfse?: StringNullableWithAggregatesFilter<'nfse'> | string | null;
    aliqissret_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    xml_nfse?: BytesNullableWithAggregatesFilter<'nfse'> | Uint8Array | null;
    codver_nfse?: StringNullableWithAggregatesFilter<'nfse'> | string | null;
    logtrans_nfse?:
      | BytesNullableWithAggregatesFilter<'nfse'>
      | Uint8Array
      | null;
    logcan_nfse?: BytesNullableWithAggregatesFilter<'nfse'> | Uint8Array | null;
    xmlformat_nfse?:
      | BytesNullableWithAggregatesFilter<'nfse'>
      | Uint8Array
      | null;
    prot_nfse?: StringNullableWithAggregatesFilter<'nfse'> | string | null;
    chvcan_nfse?: StringNullableWithAggregatesFilter<'nfse'> | string | null;
    dtcanc_nfse?: StringNullableWithAggregatesFilter<'nfse'> | string | null;
    tipoper_nfse?: IntWithAggregatesFilter<'nfse'> | number;
    opsimnac_nfse?: IntWithAggregatesFilter<'nfse'> | number;
    csll_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_nfse?:
      | DecimalWithAggregatesFilter<'nfse'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nivelWhereInput = {
    AND?: nivelWhereInput | nivelWhereInput[];
    OR?: nivelWhereInput[];
    NOT?: nivelWhereInput | nivelWhereInput[];
    cod_nivel?: IntFilter<'nivel'> | number;
    nome_nivel?: StringFilter<'nivel'> | string;
    perc_nivel?:
      | DecimalFilter<'nivel'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    recurso?: RecursoListRelationFilter;
  };

  export type nivelOrderByWithRelationInput = {
    cod_nivel?: SortOrder;
    nome_nivel?: SortOrder;
    perc_nivel?: SortOrder;
    recurso?: recursoOrderByRelationAggregateInput;
  };

  export type nivelWhereUniqueInput = Prisma.AtLeast<
    {
      cod_nivel?: number;
      AND?: nivelWhereInput | nivelWhereInput[];
      OR?: nivelWhereInput[];
      NOT?: nivelWhereInput | nivelWhereInput[];
      nome_nivel?: StringFilter<'nivel'> | string;
      perc_nivel?:
        | DecimalFilter<'nivel'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      recurso?: RecursoListRelationFilter;
    },
    'cod_nivel'
  >;

  export type nivelOrderByWithAggregationInput = {
    cod_nivel?: SortOrder;
    nome_nivel?: SortOrder;
    perc_nivel?: SortOrder;
    _count?: nivelCountOrderByAggregateInput;
    _avg?: nivelAvgOrderByAggregateInput;
    _max?: nivelMaxOrderByAggregateInput;
    _min?: nivelMinOrderByAggregateInput;
    _sum?: nivelSumOrderByAggregateInput;
  };

  export type nivelScalarWhereWithAggregatesInput = {
    AND?:
      | nivelScalarWhereWithAggregatesInput
      | nivelScalarWhereWithAggregatesInput[];
    OR?: nivelScalarWhereWithAggregatesInput[];
    NOT?:
      | nivelScalarWhereWithAggregatesInput
      | nivelScalarWhereWithAggregatesInput[];
    cod_nivel?: IntWithAggregatesFilter<'nivel'> | number;
    nome_nivel?: StringWithAggregatesFilter<'nivel'> | string;
    perc_nivel?:
      | DecimalWithAggregatesFilter<'nivel'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type osWhereInput = {
    AND?: osWhereInput | osWhereInput[];
    OR?: osWhereInput[];
    NOT?: osWhereInput | osWhereInput[];
    cod_os?: IntFilter<'os'> | number;
    codtrf_os?: IntFilter<'os'> | number;
    dtini_os?: DateTimeFilter<'os'> | Date | string;
    hrini_os?: StringFilter<'os'> | string;
    hrfim_os?: StringFilter<'os'> | string;
    obs_os?: StringNullableFilter<'os'> | string | null;
    status_os?: IntFilter<'os'> | number;
    produtivo_os?: StringFilter<'os'> | string;
    codrec_os?: IntFilter<'os'> | number;
    produtivo2_os?: StringFilter<'os'> | string;
    respcli_os?: StringFilter<'os'> | string;
    remdes_os?: StringFilter<'os'> | string;
    abono_os?: StringFilter<'os'> | string;
    desloc_os?: StringNullableFilter<'os'> | string | null;
    obs?: BytesNullableFilter<'os'> | Uint8Array | null;
    dtinc_os?: DateTimeFilter<'os'> | Date | string;
    faturado_os?: StringFilter<'os'> | string;
    perc_os?: IntFilter<'os'> | number;
    cod_faturamento?: IntNullableFilter<'os'> | number | null;
    comp_os?: StringNullableFilter<'os'> | string | null;
    valid_os?: StringFilter<'os'> | string;
    vrhr_os?: DecimalFilter<'os'> | Decimal | DecimalJsLike | number | string;
    num_os?: StringNullableFilter<'os'> | string | null;
    chamado_os?: StringNullableFilter<'os'> | string | null;
    tarefa?: XOR<TarefaScalarRelationFilter, tarefaWhereInput>;
  };

  export type osOrderByWithRelationInput = {
    cod_os?: SortOrder;
    codtrf_os?: SortOrder;
    dtini_os?: SortOrder;
    hrini_os?: SortOrder;
    hrfim_os?: SortOrder;
    obs_os?: SortOrderInput | SortOrder;
    status_os?: SortOrder;
    produtivo_os?: SortOrder;
    codrec_os?: SortOrder;
    produtivo2_os?: SortOrder;
    respcli_os?: SortOrder;
    remdes_os?: SortOrder;
    abono_os?: SortOrder;
    desloc_os?: SortOrderInput | SortOrder;
    obs?: SortOrderInput | SortOrder;
    dtinc_os?: SortOrder;
    faturado_os?: SortOrder;
    perc_os?: SortOrder;
    cod_faturamento?: SortOrderInput | SortOrder;
    comp_os?: SortOrderInput | SortOrder;
    valid_os?: SortOrder;
    vrhr_os?: SortOrder;
    num_os?: SortOrderInput | SortOrder;
    chamado_os?: SortOrderInput | SortOrder;
    tarefa?: tarefaOrderByWithRelationInput;
  };

  export type osWhereUniqueInput = Prisma.AtLeast<
    {
      cod_os?: number;
      AND?: osWhereInput | osWhereInput[];
      OR?: osWhereInput[];
      NOT?: osWhereInput | osWhereInput[];
      codtrf_os?: IntFilter<'os'> | number;
      dtini_os?: DateTimeFilter<'os'> | Date | string;
      hrini_os?: StringFilter<'os'> | string;
      hrfim_os?: StringFilter<'os'> | string;
      obs_os?: StringNullableFilter<'os'> | string | null;
      status_os?: IntFilter<'os'> | number;
      produtivo_os?: StringFilter<'os'> | string;
      codrec_os?: IntFilter<'os'> | number;
      produtivo2_os?: StringFilter<'os'> | string;
      respcli_os?: StringFilter<'os'> | string;
      remdes_os?: StringFilter<'os'> | string;
      abono_os?: StringFilter<'os'> | string;
      desloc_os?: StringNullableFilter<'os'> | string | null;
      obs?: BytesNullableFilter<'os'> | Uint8Array | null;
      dtinc_os?: DateTimeFilter<'os'> | Date | string;
      faturado_os?: StringFilter<'os'> | string;
      perc_os?: IntFilter<'os'> | number;
      cod_faturamento?: IntNullableFilter<'os'> | number | null;
      comp_os?: StringNullableFilter<'os'> | string | null;
      valid_os?: StringFilter<'os'> | string;
      vrhr_os?: DecimalFilter<'os'> | Decimal | DecimalJsLike | number | string;
      num_os?: StringNullableFilter<'os'> | string | null;
      chamado_os?: StringNullableFilter<'os'> | string | null;
      tarefa?: XOR<TarefaScalarRelationFilter, tarefaWhereInput>;
    },
    'cod_os'
  >;

  export type osOrderByWithAggregationInput = {
    cod_os?: SortOrder;
    codtrf_os?: SortOrder;
    dtini_os?: SortOrder;
    hrini_os?: SortOrder;
    hrfim_os?: SortOrder;
    obs_os?: SortOrderInput | SortOrder;
    status_os?: SortOrder;
    produtivo_os?: SortOrder;
    codrec_os?: SortOrder;
    produtivo2_os?: SortOrder;
    respcli_os?: SortOrder;
    remdes_os?: SortOrder;
    abono_os?: SortOrder;
    desloc_os?: SortOrderInput | SortOrder;
    obs?: SortOrderInput | SortOrder;
    dtinc_os?: SortOrder;
    faturado_os?: SortOrder;
    perc_os?: SortOrder;
    cod_faturamento?: SortOrderInput | SortOrder;
    comp_os?: SortOrderInput | SortOrder;
    valid_os?: SortOrder;
    vrhr_os?: SortOrder;
    num_os?: SortOrderInput | SortOrder;
    chamado_os?: SortOrderInput | SortOrder;
    _count?: osCountOrderByAggregateInput;
    _avg?: osAvgOrderByAggregateInput;
    _max?: osMaxOrderByAggregateInput;
    _min?: osMinOrderByAggregateInput;
    _sum?: osSumOrderByAggregateInput;
  };

  export type osScalarWhereWithAggregatesInput = {
    AND?: osScalarWhereWithAggregatesInput | osScalarWhereWithAggregatesInput[];
    OR?: osScalarWhereWithAggregatesInput[];
    NOT?: osScalarWhereWithAggregatesInput | osScalarWhereWithAggregatesInput[];
    cod_os?: IntWithAggregatesFilter<'os'> | number;
    codtrf_os?: IntWithAggregatesFilter<'os'> | number;
    dtini_os?: DateTimeWithAggregatesFilter<'os'> | Date | string;
    hrini_os?: StringWithAggregatesFilter<'os'> | string;
    hrfim_os?: StringWithAggregatesFilter<'os'> | string;
    obs_os?: StringNullableWithAggregatesFilter<'os'> | string | null;
    status_os?: IntWithAggregatesFilter<'os'> | number;
    produtivo_os?: StringWithAggregatesFilter<'os'> | string;
    codrec_os?: IntWithAggregatesFilter<'os'> | number;
    produtivo2_os?: StringWithAggregatesFilter<'os'> | string;
    respcli_os?: StringWithAggregatesFilter<'os'> | string;
    remdes_os?: StringWithAggregatesFilter<'os'> | string;
    abono_os?: StringWithAggregatesFilter<'os'> | string;
    desloc_os?: StringNullableWithAggregatesFilter<'os'> | string | null;
    obs?: BytesNullableWithAggregatesFilter<'os'> | Uint8Array | null;
    dtinc_os?: DateTimeWithAggregatesFilter<'os'> | Date | string;
    faturado_os?: StringWithAggregatesFilter<'os'> | string;
    perc_os?: IntWithAggregatesFilter<'os'> | number;
    cod_faturamento?: IntNullableWithAggregatesFilter<'os'> | number | null;
    comp_os?: StringNullableWithAggregatesFilter<'os'> | string | null;
    valid_os?: StringWithAggregatesFilter<'os'> | string;
    vrhr_os?:
      | DecimalWithAggregatesFilter<'os'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: StringNullableWithAggregatesFilter<'os'> | string | null;
    chamado_os?: StringNullableWithAggregatesFilter<'os'> | string | null;
  };

  export type parametrosWhereInput = {
    AND?: parametrosWhereInput | parametrosWhereInput[];
    OR?: parametrosWhereInput[];
    NOT?: parametrosWhereInput | parametrosWhereInput[];
    cod_parametro?: IntFilter<'parametros'> | number;
    descr_parametro?: StringFilter<'parametros'> | string;
    valor_parametro?: StringNullableFilter<'parametros'> | string | null;
  };

  export type parametrosOrderByWithRelationInput = {
    cod_parametro?: SortOrder;
    descr_parametro?: SortOrder;
    valor_parametro?: SortOrderInput | SortOrder;
  };

  export type parametrosWhereUniqueInput = Prisma.AtLeast<
    {
      cod_parametro?: number;
      AND?: parametrosWhereInput | parametrosWhereInput[];
      OR?: parametrosWhereInput[];
      NOT?: parametrosWhereInput | parametrosWhereInput[];
      descr_parametro?: StringFilter<'parametros'> | string;
      valor_parametro?: StringNullableFilter<'parametros'> | string | null;
    },
    'cod_parametro'
  >;

  export type parametrosOrderByWithAggregationInput = {
    cod_parametro?: SortOrder;
    descr_parametro?: SortOrder;
    valor_parametro?: SortOrderInput | SortOrder;
    _count?: parametrosCountOrderByAggregateInput;
    _avg?: parametrosAvgOrderByAggregateInput;
    _max?: parametrosMaxOrderByAggregateInput;
    _min?: parametrosMinOrderByAggregateInput;
    _sum?: parametrosSumOrderByAggregateInput;
  };

  export type parametrosScalarWhereWithAggregatesInput = {
    AND?:
      | parametrosScalarWhereWithAggregatesInput
      | parametrosScalarWhereWithAggregatesInput[];
    OR?: parametrosScalarWhereWithAggregatesInput[];
    NOT?:
      | parametrosScalarWhereWithAggregatesInput
      | parametrosScalarWhereWithAggregatesInput[];
    cod_parametro?: IntWithAggregatesFilter<'parametros'> | number;
    descr_parametro?: StringWithAggregatesFilter<'parametros'> | string;
    valor_parametro?:
      | StringNullableWithAggregatesFilter<'parametros'>
      | string
      | null;
  };

  export type parcelaWhereInput = {
    AND?: parcelaWhereInput | parcelaWhereInput[];
    OR?: parcelaWhereInput[];
    NOT?: parcelaWhereInput | parcelaWhereInput[];
    cod_parcela?: IntFilter<'parcela'> | number;
    cod_lista?: IntFilter<'parcela'> | number;
    data_parcela?: StringNullableFilter<'parcela'> | string | null;
    venc_parcela?: StringNullableFilter<'parcela'> | string | null;
    pag_parcela?: StringNullableFilter<'parcela'> | string | null;
    valor_parcela?:
      | DecimalNullableFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    juros_parcela?:
      | DecimalNullableFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    multa_parcela?:
      | DecimalNullableFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desconto_parcela?:
      | DecimalNullableFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    status_parcela?: StringFilter<'parcela'> | string;
    id_parcela?: StringNullableFilter<'parcela'> | string | null;
  };

  export type parcelaOrderByWithRelationInput = {
    cod_parcela?: SortOrder;
    cod_lista?: SortOrder;
    data_parcela?: SortOrderInput | SortOrder;
    venc_parcela?: SortOrderInput | SortOrder;
    pag_parcela?: SortOrderInput | SortOrder;
    valor_parcela?: SortOrderInput | SortOrder;
    juros_parcela?: SortOrderInput | SortOrder;
    multa_parcela?: SortOrderInput | SortOrder;
    desconto_parcela?: SortOrderInput | SortOrder;
    status_parcela?: SortOrder;
    id_parcela?: SortOrderInput | SortOrder;
  };

  export type parcelaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_parcela?: number;
      AND?: parcelaWhereInput | parcelaWhereInput[];
      OR?: parcelaWhereInput[];
      NOT?: parcelaWhereInput | parcelaWhereInput[];
      cod_lista?: IntFilter<'parcela'> | number;
      data_parcela?: StringNullableFilter<'parcela'> | string | null;
      venc_parcela?: StringNullableFilter<'parcela'> | string | null;
      pag_parcela?: StringNullableFilter<'parcela'> | string | null;
      valor_parcela?:
        | DecimalNullableFilter<'parcela'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      juros_parcela?:
        | DecimalNullableFilter<'parcela'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      multa_parcela?:
        | DecimalNullableFilter<'parcela'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      desconto_parcela?:
        | DecimalNullableFilter<'parcela'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      status_parcela?: StringFilter<'parcela'> | string;
      id_parcela?: StringNullableFilter<'parcela'> | string | null;
    },
    'cod_parcela'
  >;

  export type parcelaOrderByWithAggregationInput = {
    cod_parcela?: SortOrder;
    cod_lista?: SortOrder;
    data_parcela?: SortOrderInput | SortOrder;
    venc_parcela?: SortOrderInput | SortOrder;
    pag_parcela?: SortOrderInput | SortOrder;
    valor_parcela?: SortOrderInput | SortOrder;
    juros_parcela?: SortOrderInput | SortOrder;
    multa_parcela?: SortOrderInput | SortOrder;
    desconto_parcela?: SortOrderInput | SortOrder;
    status_parcela?: SortOrder;
    id_parcela?: SortOrderInput | SortOrder;
    _count?: parcelaCountOrderByAggregateInput;
    _avg?: parcelaAvgOrderByAggregateInput;
    _max?: parcelaMaxOrderByAggregateInput;
    _min?: parcelaMinOrderByAggregateInput;
    _sum?: parcelaSumOrderByAggregateInput;
  };

  export type parcelaScalarWhereWithAggregatesInput = {
    AND?:
      | parcelaScalarWhereWithAggregatesInput
      | parcelaScalarWhereWithAggregatesInput[];
    OR?: parcelaScalarWhereWithAggregatesInput[];
    NOT?:
      | parcelaScalarWhereWithAggregatesInput
      | parcelaScalarWhereWithAggregatesInput[];
    cod_parcela?: IntWithAggregatesFilter<'parcela'> | number;
    cod_lista?: IntWithAggregatesFilter<'parcela'> | number;
    data_parcela?:
      | StringNullableWithAggregatesFilter<'parcela'>
      | string
      | null;
    venc_parcela?:
      | StringNullableWithAggregatesFilter<'parcela'>
      | string
      | null;
    pag_parcela?: StringNullableWithAggregatesFilter<'parcela'> | string | null;
    valor_parcela?:
      | DecimalNullableWithAggregatesFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    juros_parcela?:
      | DecimalNullableWithAggregatesFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    multa_parcela?:
      | DecimalNullableWithAggregatesFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desconto_parcela?:
      | DecimalNullableWithAggregatesFilter<'parcela'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    status_parcela?: StringWithAggregatesFilter<'parcela'> | string;
    id_parcela?: StringNullableWithAggregatesFilter<'parcela'> | string | null;
  };

  export type pautaWhereInput = {
    AND?: pautaWhereInput | pautaWhereInput[];
    OR?: pautaWhereInput[];
    NOT?: pautaWhereInput | pautaWhereInput[];
    cod_pauta?: IntFilter<'pauta'> | number;
    cod_recurso?: IntFilter<'pauta'> | number;
    data_pauta?: DateTimeFilter<'pauta'> | Date | string;
    prazo_pauta?: DateTimeFilter<'pauta'> | Date | string;
    concl_pauta?: DateTimeNullableFilter<'pauta'> | Date | string | null;
    desc_pauta?: StringNullableFilter<'pauta'> | string | null;
    obs_pauta?: BytesNullableFilter<'pauta'> | Uint8Array | null;
  };

  export type pautaOrderByWithRelationInput = {
    cod_pauta?: SortOrder;
    cod_recurso?: SortOrder;
    data_pauta?: SortOrder;
    prazo_pauta?: SortOrder;
    concl_pauta?: SortOrderInput | SortOrder;
    desc_pauta?: SortOrderInput | SortOrder;
    obs_pauta?: SortOrderInput | SortOrder;
  };

  export type pautaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_pauta?: number;
      AND?: pautaWhereInput | pautaWhereInput[];
      OR?: pautaWhereInput[];
      NOT?: pautaWhereInput | pautaWhereInput[];
      cod_recurso?: IntFilter<'pauta'> | number;
      data_pauta?: DateTimeFilter<'pauta'> | Date | string;
      prazo_pauta?: DateTimeFilter<'pauta'> | Date | string;
      concl_pauta?: DateTimeNullableFilter<'pauta'> | Date | string | null;
      desc_pauta?: StringNullableFilter<'pauta'> | string | null;
      obs_pauta?: BytesNullableFilter<'pauta'> | Uint8Array | null;
    },
    'cod_pauta'
  >;

  export type pautaOrderByWithAggregationInput = {
    cod_pauta?: SortOrder;
    cod_recurso?: SortOrder;
    data_pauta?: SortOrder;
    prazo_pauta?: SortOrder;
    concl_pauta?: SortOrderInput | SortOrder;
    desc_pauta?: SortOrderInput | SortOrder;
    obs_pauta?: SortOrderInput | SortOrder;
    _count?: pautaCountOrderByAggregateInput;
    _avg?: pautaAvgOrderByAggregateInput;
    _max?: pautaMaxOrderByAggregateInput;
    _min?: pautaMinOrderByAggregateInput;
    _sum?: pautaSumOrderByAggregateInput;
  };

  export type pautaScalarWhereWithAggregatesInput = {
    AND?:
      | pautaScalarWhereWithAggregatesInput
      | pautaScalarWhereWithAggregatesInput[];
    OR?: pautaScalarWhereWithAggregatesInput[];
    NOT?:
      | pautaScalarWhereWithAggregatesInput
      | pautaScalarWhereWithAggregatesInput[];
    cod_pauta?: IntWithAggregatesFilter<'pauta'> | number;
    cod_recurso?: IntWithAggregatesFilter<'pauta'> | number;
    data_pauta?: DateTimeWithAggregatesFilter<'pauta'> | Date | string;
    prazo_pauta?: DateTimeWithAggregatesFilter<'pauta'> | Date | string;
    concl_pauta?:
      | DateTimeNullableWithAggregatesFilter<'pauta'>
      | Date
      | string
      | null;
    desc_pauta?: StringNullableWithAggregatesFilter<'pauta'> | string | null;
    obs_pauta?: BytesNullableWithAggregatesFilter<'pauta'> | Uint8Array | null;
  };

  export type pontoWhereInput = {
    AND?: pontoWhereInput | pontoWhereInput[];
    OR?: pontoWhereInput[];
    NOT?: pontoWhereInput | pontoWhereInput[];
    cod_ponto?: IntFilter<'ponto'> | number;
    entrada_ponto?: DateTimeFilter<'ponto'> | Date | string;
    saida_ponto?: DateTimeNullableFilter<'ponto'> | Date | string | null;
    cod_recurso?: IntFilter<'ponto'> | number;
  };

  export type pontoOrderByWithRelationInput = {
    cod_ponto?: SortOrder;
    entrada_ponto?: SortOrder;
    saida_ponto?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrder;
  };

  export type pontoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_ponto?: number;
      AND?: pontoWhereInput | pontoWhereInput[];
      OR?: pontoWhereInput[];
      NOT?: pontoWhereInput | pontoWhereInput[];
      entrada_ponto?: DateTimeFilter<'ponto'> | Date | string;
      saida_ponto?: DateTimeNullableFilter<'ponto'> | Date | string | null;
      cod_recurso?: IntFilter<'ponto'> | number;
    },
    'cod_ponto'
  >;

  export type pontoOrderByWithAggregationInput = {
    cod_ponto?: SortOrder;
    entrada_ponto?: SortOrder;
    saida_ponto?: SortOrderInput | SortOrder;
    cod_recurso?: SortOrder;
    _count?: pontoCountOrderByAggregateInput;
    _avg?: pontoAvgOrderByAggregateInput;
    _max?: pontoMaxOrderByAggregateInput;
    _min?: pontoMinOrderByAggregateInput;
    _sum?: pontoSumOrderByAggregateInput;
  };

  export type pontoScalarWhereWithAggregatesInput = {
    AND?:
      | pontoScalarWhereWithAggregatesInput
      | pontoScalarWhereWithAggregatesInput[];
    OR?: pontoScalarWhereWithAggregatesInput[];
    NOT?:
      | pontoScalarWhereWithAggregatesInput
      | pontoScalarWhereWithAggregatesInput[];
    cod_ponto?: IntWithAggregatesFilter<'ponto'> | number;
    entrada_ponto?: DateTimeWithAggregatesFilter<'ponto'> | Date | string;
    saida_ponto?:
      | DateTimeNullableWithAggregatesFilter<'ponto'>
      | Date
      | string
      | null;
    cod_recurso?: IntWithAggregatesFilter<'ponto'> | number;
  };

  export type projetoWhereInput = {
    AND?: projetoWhereInput | projetoWhereInput[];
    OR?: projetoWhereInput[];
    NOT?: projetoWhereInput | projetoWhereInput[];
    cod_projeto?: IntFilter<'projeto'> | number;
    nome_projeto?: StringFilter<'projeto'> | string;
    codcli_projeto?: IntFilter<'projeto'> | number;
    respcli_projeto?: StringFilter<'projeto'> | string;
    proposta_projeto?: StringNullableFilter<'projeto'> | string | null;
    codrec_projeto?: IntFilter<'projeto'> | number;
    perc_projeto?:
      | DecimalFilter<'projeto'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: StringNullableFilter<'projeto'> | string | null;
    logalt_projeto?: StringNullableFilter<'projeto'> | string | null;
    qtdhoras_projeto?:
      | DecimalFilter<'projeto'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFilter<'projeto'> | string;
    avaliacao?: AvaliacaoListRelationFilter;
    meta?: MetaListRelationFilter;
    cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>;
    recurso?: XOR<RecursoScalarRelationFilter, recursoWhereInput>;
    tarefa?: TarefaListRelationFilter;
    valor?: ValorListRelationFilter;
  };

  export type projetoOrderByWithRelationInput = {
    cod_projeto?: SortOrder;
    nome_projeto?: SortOrder;
    codcli_projeto?: SortOrder;
    respcli_projeto?: SortOrder;
    proposta_projeto?: SortOrderInput | SortOrder;
    codrec_projeto?: SortOrder;
    perc_projeto?: SortOrder;
    loginc_projeto?: SortOrderInput | SortOrder;
    logalt_projeto?: SortOrderInput | SortOrder;
    qtdhoras_projeto?: SortOrder;
    status_projeto?: SortOrder;
    avaliacao?: avaliacaoOrderByRelationAggregateInput;
    meta?: metaOrderByRelationAggregateInput;
    cliente?: clienteOrderByWithRelationInput;
    recurso?: recursoOrderByWithRelationInput;
    tarefa?: tarefaOrderByRelationAggregateInput;
    valor?: valorOrderByRelationAggregateInput;
  };

  export type projetoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_projeto?: number;
      AND?: projetoWhereInput | projetoWhereInput[];
      OR?: projetoWhereInput[];
      NOT?: projetoWhereInput | projetoWhereInput[];
      nome_projeto?: StringFilter<'projeto'> | string;
      codcli_projeto?: IntFilter<'projeto'> | number;
      respcli_projeto?: StringFilter<'projeto'> | string;
      proposta_projeto?: StringNullableFilter<'projeto'> | string | null;
      codrec_projeto?: IntFilter<'projeto'> | number;
      perc_projeto?:
        | DecimalFilter<'projeto'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      loginc_projeto?: StringNullableFilter<'projeto'> | string | null;
      logalt_projeto?: StringNullableFilter<'projeto'> | string | null;
      qtdhoras_projeto?:
        | DecimalFilter<'projeto'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      status_projeto?: StringFilter<'projeto'> | string;
      avaliacao?: AvaliacaoListRelationFilter;
      meta?: MetaListRelationFilter;
      cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>;
      recurso?: XOR<RecursoScalarRelationFilter, recursoWhereInput>;
      tarefa?: TarefaListRelationFilter;
      valor?: ValorListRelationFilter;
    },
    'cod_projeto'
  >;

  export type projetoOrderByWithAggregationInput = {
    cod_projeto?: SortOrder;
    nome_projeto?: SortOrder;
    codcli_projeto?: SortOrder;
    respcli_projeto?: SortOrder;
    proposta_projeto?: SortOrderInput | SortOrder;
    codrec_projeto?: SortOrder;
    perc_projeto?: SortOrder;
    loginc_projeto?: SortOrderInput | SortOrder;
    logalt_projeto?: SortOrderInput | SortOrder;
    qtdhoras_projeto?: SortOrder;
    status_projeto?: SortOrder;
    _count?: projetoCountOrderByAggregateInput;
    _avg?: projetoAvgOrderByAggregateInput;
    _max?: projetoMaxOrderByAggregateInput;
    _min?: projetoMinOrderByAggregateInput;
    _sum?: projetoSumOrderByAggregateInput;
  };

  export type projetoScalarWhereWithAggregatesInput = {
    AND?:
      | projetoScalarWhereWithAggregatesInput
      | projetoScalarWhereWithAggregatesInput[];
    OR?: projetoScalarWhereWithAggregatesInput[];
    NOT?:
      | projetoScalarWhereWithAggregatesInput
      | projetoScalarWhereWithAggregatesInput[];
    cod_projeto?: IntWithAggregatesFilter<'projeto'> | number;
    nome_projeto?: StringWithAggregatesFilter<'projeto'> | string;
    codcli_projeto?: IntWithAggregatesFilter<'projeto'> | number;
    respcli_projeto?: StringWithAggregatesFilter<'projeto'> | string;
    proposta_projeto?:
      | StringNullableWithAggregatesFilter<'projeto'>
      | string
      | null;
    codrec_projeto?: IntWithAggregatesFilter<'projeto'> | number;
    perc_projeto?:
      | DecimalWithAggregatesFilter<'projeto'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?:
      | StringNullableWithAggregatesFilter<'projeto'>
      | string
      | null;
    logalt_projeto?:
      | StringNullableWithAggregatesFilter<'projeto'>
      | string
      | null;
    qtdhoras_projeto?:
      | DecimalWithAggregatesFilter<'projeto'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringWithAggregatesFilter<'projeto'> | string;
  };

  export type recursoWhereInput = {
    AND?: recursoWhereInput | recursoWhereInput[];
    OR?: recursoWhereInput[];
    NOT?: recursoWhereInput | recursoWhereInput[];
    cod_recurso?: IntFilter<'recurso'> | number;
    nome_recurso?: StringFilter<'recurso'> | string;
    fone_recurso?: StringNullableFilter<'recurso'> | string | null;
    ativo_recurso?: IntFilter<'recurso'> | number;
    codusr_recurso?: IntFilter<'recurso'> | number;
    cod_nivel?: IntFilter<'recurso'> | number;
    hrdia_recurso?: StringNullableFilter<'recurso'> | string | null;
    percprod_recurso?:
      | DecimalNullableFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: StringNullableFilter<'recurso'> | string | null;
    dtlimite_recurso?: DateTimeNullableFilter<'recurso'> | Date | string | null;
    permapo_recurso?: StringFilter<'recurso'> | string;
    matr_recurso?: StringNullableFilter<'recurso'> | string | null;
    obs_recurso?: BytesNullableFilter<'recurso'> | Uint8Array | null;
    custo_recurso?:
      | DecimalNullableFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | DecimalNullableFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: IntNullableFilter<'recurso'> | number | null;
    agenrec?: AgenrecListRelationFilter;
    avaliado?: AvaliadoListRelationFilter;
    projeto?: ProjetoListRelationFilter;
    nivel?: XOR<NivelScalarRelationFilter, nivelWhereInput>;
    usuario?: XOR<UsuarioScalarRelationFilter, usuarioWhereInput>;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: TarefaListRelationFilter;
    tarefa_tarefa_codrec_tarefaTorecurso?: TarefaListRelationFilter;
    chamado?: ChamadoListRelationFilter;
  };

  export type recursoOrderByWithRelationInput = {
    cod_recurso?: SortOrder;
    nome_recurso?: SortOrder;
    fone_recurso?: SortOrderInput | SortOrder;
    ativo_recurso?: SortOrder;
    codusr_recurso?: SortOrder;
    cod_nivel?: SortOrder;
    hrdia_recurso?: SortOrderInput | SortOrder;
    percprod_recurso?: SortOrderInput | SortOrder;
    email_recurso?: SortOrderInput | SortOrder;
    dtlimite_recurso?: SortOrderInput | SortOrder;
    permapo_recurso?: SortOrder;
    matr_recurso?: SortOrderInput | SortOrder;
    obs_recurso?: SortOrderInput | SortOrder;
    custo_recurso?: SortOrderInput | SortOrder;
    receita_recurso?: SortOrderInput | SortOrder;
    tpcusto_recurso?: SortOrderInput | SortOrder;
    agenrec?: agenrecOrderByRelationAggregateInput;
    avaliado?: avaliadoOrderByRelationAggregateInput;
    projeto?: projetoOrderByRelationAggregateInput;
    nivel?: nivelOrderByWithRelationInput;
    usuario?: usuarioOrderByWithRelationInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaOrderByRelationAggregateInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaOrderByRelationAggregateInput;
    chamado?: chamadoOrderByRelationAggregateInput;
  };

  export type recursoWhereUniqueInput = Prisma.AtLeast<
    {
      cod_recurso?: number;
      AND?: recursoWhereInput | recursoWhereInput[];
      OR?: recursoWhereInput[];
      NOT?: recursoWhereInput | recursoWhereInput[];
      nome_recurso?: StringFilter<'recurso'> | string;
      fone_recurso?: StringNullableFilter<'recurso'> | string | null;
      ativo_recurso?: IntFilter<'recurso'> | number;
      codusr_recurso?: IntFilter<'recurso'> | number;
      cod_nivel?: IntFilter<'recurso'> | number;
      hrdia_recurso?: StringNullableFilter<'recurso'> | string | null;
      percprod_recurso?:
        | DecimalNullableFilter<'recurso'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      email_recurso?: StringNullableFilter<'recurso'> | string | null;
      dtlimite_recurso?:
        | DateTimeNullableFilter<'recurso'>
        | Date
        | string
        | null;
      permapo_recurso?: StringFilter<'recurso'> | string;
      matr_recurso?: StringNullableFilter<'recurso'> | string | null;
      obs_recurso?: BytesNullableFilter<'recurso'> | Uint8Array | null;
      custo_recurso?:
        | DecimalNullableFilter<'recurso'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      receita_recurso?:
        | DecimalNullableFilter<'recurso'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      tpcusto_recurso?: IntNullableFilter<'recurso'> | number | null;
      agenrec?: AgenrecListRelationFilter;
      avaliado?: AvaliadoListRelationFilter;
      projeto?: ProjetoListRelationFilter;
      nivel?: XOR<NivelScalarRelationFilter, nivelWhereInput>;
      usuario?: XOR<UsuarioScalarRelationFilter, usuarioWhereInput>;
      tarefa_tarefa_codrecresp_tarefaTorecurso?: TarefaListRelationFilter;
      tarefa_tarefa_codrec_tarefaTorecurso?: TarefaListRelationFilter;
      chamado?: ChamadoListRelationFilter;
    },
    'cod_recurso'
  >;

  export type recursoOrderByWithAggregationInput = {
    cod_recurso?: SortOrder;
    nome_recurso?: SortOrder;
    fone_recurso?: SortOrderInput | SortOrder;
    ativo_recurso?: SortOrder;
    codusr_recurso?: SortOrder;
    cod_nivel?: SortOrder;
    hrdia_recurso?: SortOrderInput | SortOrder;
    percprod_recurso?: SortOrderInput | SortOrder;
    email_recurso?: SortOrderInput | SortOrder;
    dtlimite_recurso?: SortOrderInput | SortOrder;
    permapo_recurso?: SortOrder;
    matr_recurso?: SortOrderInput | SortOrder;
    obs_recurso?: SortOrderInput | SortOrder;
    custo_recurso?: SortOrderInput | SortOrder;
    receita_recurso?: SortOrderInput | SortOrder;
    tpcusto_recurso?: SortOrderInput | SortOrder;
    _count?: recursoCountOrderByAggregateInput;
    _avg?: recursoAvgOrderByAggregateInput;
    _max?: recursoMaxOrderByAggregateInput;
    _min?: recursoMinOrderByAggregateInput;
    _sum?: recursoSumOrderByAggregateInput;
  };

  export type recursoScalarWhereWithAggregatesInput = {
    AND?:
      | recursoScalarWhereWithAggregatesInput
      | recursoScalarWhereWithAggregatesInput[];
    OR?: recursoScalarWhereWithAggregatesInput[];
    NOT?:
      | recursoScalarWhereWithAggregatesInput
      | recursoScalarWhereWithAggregatesInput[];
    cod_recurso?: IntWithAggregatesFilter<'recurso'> | number;
    nome_recurso?: StringWithAggregatesFilter<'recurso'> | string;
    fone_recurso?:
      | StringNullableWithAggregatesFilter<'recurso'>
      | string
      | null;
    ativo_recurso?: IntWithAggregatesFilter<'recurso'> | number;
    codusr_recurso?: IntWithAggregatesFilter<'recurso'> | number;
    cod_nivel?: IntWithAggregatesFilter<'recurso'> | number;
    hrdia_recurso?:
      | StringNullableWithAggregatesFilter<'recurso'>
      | string
      | null;
    percprod_recurso?:
      | DecimalNullableWithAggregatesFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?:
      | StringNullableWithAggregatesFilter<'recurso'>
      | string
      | null;
    dtlimite_recurso?:
      | DateTimeNullableWithAggregatesFilter<'recurso'>
      | Date
      | string
      | null;
    permapo_recurso?: StringWithAggregatesFilter<'recurso'> | string;
    matr_recurso?:
      | StringNullableWithAggregatesFilter<'recurso'>
      | string
      | null;
    obs_recurso?:
      | BytesNullableWithAggregatesFilter<'recurso'>
      | Uint8Array
      | null;
    custo_recurso?:
      | DecimalNullableWithAggregatesFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | DecimalNullableWithAggregatesFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?:
      | IntNullableWithAggregatesFilter<'recurso'>
      | number
      | null;
  };

  export type resconWhereInput = {
    AND?: resconWhereInput | resconWhereInput[];
    OR?: resconWhereInput[];
    NOT?: resconWhereInput | resconWhereInput[];
    cod_rescon?: IntFilter<'rescon'> | number;
    cod_fatura?: IntFilter<'rescon'> | number;
    cod_recurso?: IntFilter<'rescon'> | number;
    hrfat_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrnfat_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    realizado_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    disponivel_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc1_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc2_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc3_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    custo_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    contrib_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perccontrib_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrbase_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    mo_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desp_rescon?:
      | DecimalNullableFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type resconOrderByWithRelationInput = {
    cod_rescon?: SortOrder;
    cod_fatura?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_rescon?: SortOrderInput | SortOrder;
    hrnfat_rescon?: SortOrderInput | SortOrder;
    vrfat_rescon?: SortOrderInput | SortOrder;
    vrnfat_rescon?: SortOrderInput | SortOrder;
    realizado_rescon?: SortOrderInput | SortOrder;
    disponivel_rescon?: SortOrderInput | SortOrder;
    perc1_rescon?: SortOrderInput | SortOrder;
    perc2_rescon?: SortOrderInput | SortOrder;
    perc3_rescon?: SortOrderInput | SortOrder;
    custo_rescon?: SortOrderInput | SortOrder;
    contrib_rescon?: SortOrderInput | SortOrder;
    perccontrib_rescon?: SortOrderInput | SortOrder;
    hrbase_rescon?: SortOrderInput | SortOrder;
    mo_rescon?: SortOrderInput | SortOrder;
    desp_rescon?: SortOrderInput | SortOrder;
  };

  export type resconWhereUniqueInput = Prisma.AtLeast<
    {
      cod_rescon?: number;
      AND?: resconWhereInput | resconWhereInput[];
      OR?: resconWhereInput[];
      NOT?: resconWhereInput | resconWhereInput[];
      cod_fatura?: IntFilter<'rescon'> | number;
      cod_recurso?: IntFilter<'rescon'> | number;
      hrfat_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hrnfat_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      vrfat_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      vrnfat_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      realizado_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      disponivel_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      perc1_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      perc2_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      perc3_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      custo_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      contrib_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      perccontrib_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hrbase_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      mo_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      desp_rescon?:
        | DecimalNullableFilter<'rescon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
    },
    'cod_rescon'
  >;

  export type resconOrderByWithAggregationInput = {
    cod_rescon?: SortOrder;
    cod_fatura?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_rescon?: SortOrderInput | SortOrder;
    hrnfat_rescon?: SortOrderInput | SortOrder;
    vrfat_rescon?: SortOrderInput | SortOrder;
    vrnfat_rescon?: SortOrderInput | SortOrder;
    realizado_rescon?: SortOrderInput | SortOrder;
    disponivel_rescon?: SortOrderInput | SortOrder;
    perc1_rescon?: SortOrderInput | SortOrder;
    perc2_rescon?: SortOrderInput | SortOrder;
    perc3_rescon?: SortOrderInput | SortOrder;
    custo_rescon?: SortOrderInput | SortOrder;
    contrib_rescon?: SortOrderInput | SortOrder;
    perccontrib_rescon?: SortOrderInput | SortOrder;
    hrbase_rescon?: SortOrderInput | SortOrder;
    mo_rescon?: SortOrderInput | SortOrder;
    desp_rescon?: SortOrderInput | SortOrder;
    _count?: resconCountOrderByAggregateInput;
    _avg?: resconAvgOrderByAggregateInput;
    _max?: resconMaxOrderByAggregateInput;
    _min?: resconMinOrderByAggregateInput;
    _sum?: resconSumOrderByAggregateInput;
  };

  export type resconScalarWhereWithAggregatesInput = {
    AND?:
      | resconScalarWhereWithAggregatesInput
      | resconScalarWhereWithAggregatesInput[];
    OR?: resconScalarWhereWithAggregatesInput[];
    NOT?:
      | resconScalarWhereWithAggregatesInput
      | resconScalarWhereWithAggregatesInput[];
    cod_rescon?: IntWithAggregatesFilter<'rescon'> | number;
    cod_fatura?: IntWithAggregatesFilter<'rescon'> | number;
    cod_recurso?: IntWithAggregatesFilter<'rescon'> | number;
    hrfat_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrnfat_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    realizado_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    disponivel_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc1_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc2_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc3_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    custo_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    contrib_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perccontrib_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrbase_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    mo_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desp_rescon?:
      | DecimalNullableWithAggregatesFilter<'rescon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type statusWhereInput = {
    AND?: statusWhereInput | statusWhereInput[];
    OR?: statusWhereInput[];
    NOT?: statusWhereInput | statusWhereInput[];
    cod_status?: IntFilter<'status'> | number;
    desc_status?: StringFilter<'status'> | string;
  };

  export type statusOrderByWithRelationInput = {
    cod_status?: SortOrder;
    desc_status?: SortOrder;
  };

  export type statusWhereUniqueInput = Prisma.AtLeast<
    {
      cod_status?: number;
      AND?: statusWhereInput | statusWhereInput[];
      OR?: statusWhereInput[];
      NOT?: statusWhereInput | statusWhereInput[];
      desc_status?: StringFilter<'status'> | string;
    },
    'cod_status'
  >;

  export type statusOrderByWithAggregationInput = {
    cod_status?: SortOrder;
    desc_status?: SortOrder;
    _count?: statusCountOrderByAggregateInput;
    _avg?: statusAvgOrderByAggregateInput;
    _max?: statusMaxOrderByAggregateInput;
    _min?: statusMinOrderByAggregateInput;
    _sum?: statusSumOrderByAggregateInput;
  };

  export type statusScalarWhereWithAggregatesInput = {
    AND?:
      | statusScalarWhereWithAggregatesInput
      | statusScalarWhereWithAggregatesInput[];
    OR?: statusScalarWhereWithAggregatesInput[];
    NOT?:
      | statusScalarWhereWithAggregatesInput
      | statusScalarWhereWithAggregatesInput[];
    cod_status?: IntWithAggregatesFilter<'status'> | number;
    desc_status?: StringWithAggregatesFilter<'status'> | string;
  };

  export type tarefaWhereInput = {
    AND?: tarefaWhereInput | tarefaWhereInput[];
    OR?: tarefaWhereInput[];
    NOT?: tarefaWhereInput | tarefaWhereInput[];
    cod_tarefa?: IntFilter<'tarefa'> | number;
    nome_tarefa?: StringFilter<'tarefa'> | string;
    codpro_tarefa?: IntFilter<'tarefa'> | number;
    codrec_tarefa?: IntFilter<'tarefa'> | number;
    dtsol_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
    dtaprov_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
    dtprevent_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
    hrest_tarefa?:
      | DecimalNullableFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | DecimalNullableFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFilter<'tarefa'> | string;
    status_tarefa?: IntFilter<'tarefa'> | number;
    ordem_tarefa?: IntFilter<'tarefa'> | number;
    cod_area?: IntFilter<'tarefa'> | number;
    estimado_tarefa?: StringFilter<'tarefa'> | string;
    cod_tipotrf?: IntFilter<'tarefa'> | number;
    codrecresp_tarefa?: IntFilter<'tarefa'> | number;
    hrreal_tarefa?:
      | DecimalNullableFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFilter<'tarefa'> | string;
    cod_fase?: IntFilter<'tarefa'> | number;
    valini_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
    valfim_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
    perimp_tarefa?: StringFilter<'tarefa'> | string;
    dtinc_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
    perc_tarefa?: IntFilter<'tarefa'> | number;
    fatura_tarefa?: StringFilter<'tarefa'> | string;
    valida_tarefa?: IntFilter<'tarefa'> | number;
    vrhr_tarefa?:
      | DecimalFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: BytesNullableFilter<'tarefa'> | Uint8Array | null;
    limmes_tarefa?: IntNullableFilter<'tarefa'> | number | null;
    exibecham_tarefa?: IntNullableFilter<'tarefa'> | number | null;
    os?: OsListRelationFilter;
    area?: XOR<AreaScalarRelationFilter, areaWhereInput>;
    fase?: XOR<FaseScalarRelationFilter, faseWhereInput>;
    projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
    recurso_tarefa_codrecresp_tarefaTorecurso?: XOR<
      RecursoScalarRelationFilter,
      recursoWhereInput
    >;
    recurso_tarefa_codrec_tarefaTorecurso?: XOR<
      RecursoScalarRelationFilter,
      recursoWhereInput
    >;
  };

  export type tarefaOrderByWithRelationInput = {
    cod_tarefa?: SortOrder;
    nome_tarefa?: SortOrder;
    codpro_tarefa?: SortOrder;
    codrec_tarefa?: SortOrder;
    dtsol_tarefa?: SortOrderInput | SortOrder;
    dtaprov_tarefa?: SortOrderInput | SortOrder;
    dtprevent_tarefa?: SortOrderInput | SortOrder;
    hrest_tarefa?: SortOrderInput | SortOrder;
    hratesc_tarefa?: SortOrderInput | SortOrder;
    margem_tarefa?: SortOrder;
    status_tarefa?: SortOrder;
    ordem_tarefa?: SortOrder;
    cod_area?: SortOrder;
    estimado_tarefa?: SortOrder;
    cod_tipotrf?: SortOrder;
    codrecresp_tarefa?: SortOrder;
    hrreal_tarefa?: SortOrderInput | SortOrder;
    fatest_tarefa?: SortOrder;
    cod_fase?: SortOrder;
    valini_tarefa?: SortOrder;
    valfim_tarefa?: SortOrder;
    perimp_tarefa?: SortOrder;
    dtinc_tarefa?: SortOrder;
    perc_tarefa?: SortOrder;
    fatura_tarefa?: SortOrder;
    valida_tarefa?: SortOrder;
    vrhr_tarefa?: SortOrder;
    obs_tarefa?: SortOrderInput | SortOrder;
    limmes_tarefa?: SortOrderInput | SortOrder;
    exibecham_tarefa?: SortOrderInput | SortOrder;
    os?: osOrderByRelationAggregateInput;
    area?: areaOrderByWithRelationInput;
    fase?: faseOrderByWithRelationInput;
    projeto?: projetoOrderByWithRelationInput;
    recurso_tarefa_codrecresp_tarefaTorecurso?: recursoOrderByWithRelationInput;
    recurso_tarefa_codrec_tarefaTorecurso?: recursoOrderByWithRelationInput;
  };

  export type tarefaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_tarefa?: number;
      AND?: tarefaWhereInput | tarefaWhereInput[];
      OR?: tarefaWhereInput[];
      NOT?: tarefaWhereInput | tarefaWhereInput[];
      nome_tarefa?: StringFilter<'tarefa'> | string;
      codpro_tarefa?: IntFilter<'tarefa'> | number;
      codrec_tarefa?: IntFilter<'tarefa'> | number;
      dtsol_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
      dtaprov_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
      dtprevent_tarefa?:
        | DateTimeNullableFilter<'tarefa'>
        | Date
        | string
        | null;
      hrest_tarefa?:
        | DecimalNullableFilter<'tarefa'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hratesc_tarefa?:
        | DecimalNullableFilter<'tarefa'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      margem_tarefa?: StringFilter<'tarefa'> | string;
      status_tarefa?: IntFilter<'tarefa'> | number;
      ordem_tarefa?: IntFilter<'tarefa'> | number;
      cod_area?: IntFilter<'tarefa'> | number;
      estimado_tarefa?: StringFilter<'tarefa'> | string;
      cod_tipotrf?: IntFilter<'tarefa'> | number;
      codrecresp_tarefa?: IntFilter<'tarefa'> | number;
      hrreal_tarefa?:
        | DecimalNullableFilter<'tarefa'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      fatest_tarefa?: StringFilter<'tarefa'> | string;
      cod_fase?: IntFilter<'tarefa'> | number;
      valini_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
      valfim_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
      perimp_tarefa?: StringFilter<'tarefa'> | string;
      dtinc_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
      perc_tarefa?: IntFilter<'tarefa'> | number;
      fatura_tarefa?: StringFilter<'tarefa'> | string;
      valida_tarefa?: IntFilter<'tarefa'> | number;
      vrhr_tarefa?:
        | DecimalFilter<'tarefa'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      obs_tarefa?: BytesNullableFilter<'tarefa'> | Uint8Array | null;
      limmes_tarefa?: IntNullableFilter<'tarefa'> | number | null;
      exibecham_tarefa?: IntNullableFilter<'tarefa'> | number | null;
      os?: OsListRelationFilter;
      area?: XOR<AreaScalarRelationFilter, areaWhereInput>;
      fase?: XOR<FaseScalarRelationFilter, faseWhereInput>;
      projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
      recurso_tarefa_codrecresp_tarefaTorecurso?: XOR<
        RecursoScalarRelationFilter,
        recursoWhereInput
      >;
      recurso_tarefa_codrec_tarefaTorecurso?: XOR<
        RecursoScalarRelationFilter,
        recursoWhereInput
      >;
    },
    'cod_tarefa'
  >;

  export type tarefaOrderByWithAggregationInput = {
    cod_tarefa?: SortOrder;
    nome_tarefa?: SortOrder;
    codpro_tarefa?: SortOrder;
    codrec_tarefa?: SortOrder;
    dtsol_tarefa?: SortOrderInput | SortOrder;
    dtaprov_tarefa?: SortOrderInput | SortOrder;
    dtprevent_tarefa?: SortOrderInput | SortOrder;
    hrest_tarefa?: SortOrderInput | SortOrder;
    hratesc_tarefa?: SortOrderInput | SortOrder;
    margem_tarefa?: SortOrder;
    status_tarefa?: SortOrder;
    ordem_tarefa?: SortOrder;
    cod_area?: SortOrder;
    estimado_tarefa?: SortOrder;
    cod_tipotrf?: SortOrder;
    codrecresp_tarefa?: SortOrder;
    hrreal_tarefa?: SortOrderInput | SortOrder;
    fatest_tarefa?: SortOrder;
    cod_fase?: SortOrder;
    valini_tarefa?: SortOrder;
    valfim_tarefa?: SortOrder;
    perimp_tarefa?: SortOrder;
    dtinc_tarefa?: SortOrder;
    perc_tarefa?: SortOrder;
    fatura_tarefa?: SortOrder;
    valida_tarefa?: SortOrder;
    vrhr_tarefa?: SortOrder;
    obs_tarefa?: SortOrderInput | SortOrder;
    limmes_tarefa?: SortOrderInput | SortOrder;
    exibecham_tarefa?: SortOrderInput | SortOrder;
    _count?: tarefaCountOrderByAggregateInput;
    _avg?: tarefaAvgOrderByAggregateInput;
    _max?: tarefaMaxOrderByAggregateInput;
    _min?: tarefaMinOrderByAggregateInput;
    _sum?: tarefaSumOrderByAggregateInput;
  };

  export type tarefaScalarWhereWithAggregatesInput = {
    AND?:
      | tarefaScalarWhereWithAggregatesInput
      | tarefaScalarWhereWithAggregatesInput[];
    OR?: tarefaScalarWhereWithAggregatesInput[];
    NOT?:
      | tarefaScalarWhereWithAggregatesInput
      | tarefaScalarWhereWithAggregatesInput[];
    cod_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    nome_tarefa?: StringWithAggregatesFilter<'tarefa'> | string;
    codpro_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    codrec_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    dtsol_tarefa?:
      | DateTimeNullableWithAggregatesFilter<'tarefa'>
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | DateTimeNullableWithAggregatesFilter<'tarefa'>
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | DateTimeNullableWithAggregatesFilter<'tarefa'>
      | Date
      | string
      | null;
    hrest_tarefa?:
      | DecimalNullableWithAggregatesFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | DecimalNullableWithAggregatesFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringWithAggregatesFilter<'tarefa'> | string;
    status_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    ordem_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    cod_area?: IntWithAggregatesFilter<'tarefa'> | number;
    estimado_tarefa?: StringWithAggregatesFilter<'tarefa'> | string;
    cod_tipotrf?: IntWithAggregatesFilter<'tarefa'> | number;
    codrecresp_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    hrreal_tarefa?:
      | DecimalNullableWithAggregatesFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringWithAggregatesFilter<'tarefa'> | string;
    cod_fase?: IntWithAggregatesFilter<'tarefa'> | number;
    valini_tarefa?: DateTimeWithAggregatesFilter<'tarefa'> | Date | string;
    valfim_tarefa?: DateTimeWithAggregatesFilter<'tarefa'> | Date | string;
    perimp_tarefa?: StringWithAggregatesFilter<'tarefa'> | string;
    dtinc_tarefa?: DateTimeWithAggregatesFilter<'tarefa'> | Date | string;
    perc_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    fatura_tarefa?: StringWithAggregatesFilter<'tarefa'> | string;
    valida_tarefa?: IntWithAggregatesFilter<'tarefa'> | number;
    vrhr_tarefa?:
      | DecimalWithAggregatesFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?:
      | BytesNullableWithAggregatesFilter<'tarefa'>
      | Uint8Array
      | null;
    limmes_tarefa?: IntNullableWithAggregatesFilter<'tarefa'> | number | null;
    exibecham_tarefa?:
      | IntNullableWithAggregatesFilter<'tarefa'>
      | number
      | null;
  };

  export type tela_sistemaWhereInput = {
    AND?: tela_sistemaWhereInput | tela_sistemaWhereInput[];
    OR?: tela_sistemaWhereInput[];
    NOT?: tela_sistemaWhereInput | tela_sistemaWhereInput[];
    cod_tela?: IntFilter<'tela_sistema'> | number;
    cod_modulo?: IntFilter<'tela_sistema'> | number;
    desc_tela?: StringFilter<'tela_sistema'> | string;
    acesso_sistema?: Acesso_sistemaListRelationFilter;
    modulo_sistema?: XOR<
      Modulo_sistemaScalarRelationFilter,
      modulo_sistemaWhereInput
    >;
  };

  export type tela_sistemaOrderByWithRelationInput = {
    cod_tela?: SortOrder;
    cod_modulo?: SortOrder;
    desc_tela?: SortOrder;
    acesso_sistema?: acesso_sistemaOrderByRelationAggregateInput;
    modulo_sistema?: modulo_sistemaOrderByWithRelationInput;
  };

  export type tela_sistemaWhereUniqueInput = Prisma.AtLeast<
    {
      cod_tela_cod_modulo?: tela_sistemaCod_telaCod_moduloCompoundUniqueInput;
      AND?: tela_sistemaWhereInput | tela_sistemaWhereInput[];
      OR?: tela_sistemaWhereInput[];
      NOT?: tela_sistemaWhereInput | tela_sistemaWhereInput[];
      cod_tela?: IntFilter<'tela_sistema'> | number;
      cod_modulo?: IntFilter<'tela_sistema'> | number;
      desc_tela?: StringFilter<'tela_sistema'> | string;
      acesso_sistema?: Acesso_sistemaListRelationFilter;
      modulo_sistema?: XOR<
        Modulo_sistemaScalarRelationFilter,
        modulo_sistemaWhereInput
      >;
    },
    'cod_tela_cod_modulo'
  >;

  export type tela_sistemaOrderByWithAggregationInput = {
    cod_tela?: SortOrder;
    cod_modulo?: SortOrder;
    desc_tela?: SortOrder;
    _count?: tela_sistemaCountOrderByAggregateInput;
    _avg?: tela_sistemaAvgOrderByAggregateInput;
    _max?: tela_sistemaMaxOrderByAggregateInput;
    _min?: tela_sistemaMinOrderByAggregateInput;
    _sum?: tela_sistemaSumOrderByAggregateInput;
  };

  export type tela_sistemaScalarWhereWithAggregatesInput = {
    AND?:
      | tela_sistemaScalarWhereWithAggregatesInput
      | tela_sistemaScalarWhereWithAggregatesInput[];
    OR?: tela_sistemaScalarWhereWithAggregatesInput[];
    NOT?:
      | tela_sistemaScalarWhereWithAggregatesInput
      | tela_sistemaScalarWhereWithAggregatesInput[];
    cod_tela?: IntWithAggregatesFilter<'tela_sistema'> | number;
    cod_modulo?: IntWithAggregatesFilter<'tela_sistema'> | number;
    desc_tela?: StringWithAggregatesFilter<'tela_sistema'> | string;
  };

  export type telefoneWhereInput = {
    AND?: telefoneWhereInput | telefoneWhereInput[];
    OR?: telefoneWhereInput[];
    NOT?: telefoneWhereInput | telefoneWhereInput[];
    cod_telefone?: IntFilter<'telefone'> | number;
    cod_lista?: IntFilter<'telefone'> | number;
    ddd_telefone?: StringNullableFilter<'telefone'> | string | null;
    numero_telefone?: StringFilter<'telefone'> | string;
    desc_telefone?: StringNullableFilter<'telefone'> | string | null;
  };

  export type telefoneOrderByWithRelationInput = {
    cod_telefone?: SortOrder;
    cod_lista?: SortOrder;
    ddd_telefone?: SortOrderInput | SortOrder;
    numero_telefone?: SortOrder;
    desc_telefone?: SortOrderInput | SortOrder;
  };

  export type telefoneWhereUniqueInput = Prisma.AtLeast<
    {
      cod_telefone?: number;
      AND?: telefoneWhereInput | telefoneWhereInput[];
      OR?: telefoneWhereInput[];
      NOT?: telefoneWhereInput | telefoneWhereInput[];
      cod_lista?: IntFilter<'telefone'> | number;
      ddd_telefone?: StringNullableFilter<'telefone'> | string | null;
      numero_telefone?: StringFilter<'telefone'> | string;
      desc_telefone?: StringNullableFilter<'telefone'> | string | null;
    },
    'cod_telefone'
  >;

  export type telefoneOrderByWithAggregationInput = {
    cod_telefone?: SortOrder;
    cod_lista?: SortOrder;
    ddd_telefone?: SortOrderInput | SortOrder;
    numero_telefone?: SortOrder;
    desc_telefone?: SortOrderInput | SortOrder;
    _count?: telefoneCountOrderByAggregateInput;
    _avg?: telefoneAvgOrderByAggregateInput;
    _max?: telefoneMaxOrderByAggregateInput;
    _min?: telefoneMinOrderByAggregateInput;
    _sum?: telefoneSumOrderByAggregateInput;
  };

  export type telefoneScalarWhereWithAggregatesInput = {
    AND?:
      | telefoneScalarWhereWithAggregatesInput
      | telefoneScalarWhereWithAggregatesInput[];
    OR?: telefoneScalarWhereWithAggregatesInput[];
    NOT?:
      | telefoneScalarWhereWithAggregatesInput
      | telefoneScalarWhereWithAggregatesInput[];
    cod_telefone?: IntWithAggregatesFilter<'telefone'> | number;
    cod_lista?: IntWithAggregatesFilter<'telefone'> | number;
    ddd_telefone?:
      | StringNullableWithAggregatesFilter<'telefone'>
      | string
      | null;
    numero_telefone?: StringWithAggregatesFilter<'telefone'> | string;
    desc_telefone?:
      | StringNullableWithAggregatesFilter<'telefone'>
      | string
      | null;
  };

  export type tipotrfWhereInput = {
    AND?: tipotrfWhereInput | tipotrfWhereInput[];
    OR?: tipotrfWhereInput[];
    NOT?: tipotrfWhereInput | tipotrfWhereInput[];
    cod_tipotrf?: IntFilter<'tipotrf'> | number;
    nome_tipotrf?: StringFilter<'tipotrf'> | string;
    valor?: ValorListRelationFilter;
  };

  export type tipotrfOrderByWithRelationInput = {
    cod_tipotrf?: SortOrder;
    nome_tipotrf?: SortOrder;
    valor?: valorOrderByRelationAggregateInput;
  };

  export type tipotrfWhereUniqueInput = Prisma.AtLeast<
    {
      cod_tipotrf?: number;
      AND?: tipotrfWhereInput | tipotrfWhereInput[];
      OR?: tipotrfWhereInput[];
      NOT?: tipotrfWhereInput | tipotrfWhereInput[];
      nome_tipotrf?: StringFilter<'tipotrf'> | string;
      valor?: ValorListRelationFilter;
    },
    'cod_tipotrf'
  >;

  export type tipotrfOrderByWithAggregationInput = {
    cod_tipotrf?: SortOrder;
    nome_tipotrf?: SortOrder;
    _count?: tipotrfCountOrderByAggregateInput;
    _avg?: tipotrfAvgOrderByAggregateInput;
    _max?: tipotrfMaxOrderByAggregateInput;
    _min?: tipotrfMinOrderByAggregateInput;
    _sum?: tipotrfSumOrderByAggregateInput;
  };

  export type tipotrfScalarWhereWithAggregatesInput = {
    AND?:
      | tipotrfScalarWhereWithAggregatesInput
      | tipotrfScalarWhereWithAggregatesInput[];
    OR?: tipotrfScalarWhereWithAggregatesInput[];
    NOT?:
      | tipotrfScalarWhereWithAggregatesInput
      | tipotrfScalarWhereWithAggregatesInput[];
    cod_tipotrf?: IntWithAggregatesFilter<'tipotrf'> | number;
    nome_tipotrf?: StringWithAggregatesFilter<'tipotrf'> | string;
  };

  export type tpdespWhereInput = {
    AND?: tpdespWhereInput | tpdespWhereInput[];
    OR?: tpdespWhereInput[];
    NOT?: tpdespWhereInput | tpdespWhereInput[];
    cod_tpdesp?: IntFilter<'tpdesp'> | number;
    nome_tpdesp?: StringFilter<'tpdesp'> | string;
  };

  export type tpdespOrderByWithRelationInput = {
    cod_tpdesp?: SortOrder;
    nome_tpdesp?: SortOrder;
  };

  export type tpdespWhereUniqueInput = Prisma.AtLeast<
    {
      cod_tpdesp?: number;
      AND?: tpdespWhereInput | tpdespWhereInput[];
      OR?: tpdespWhereInput[];
      NOT?: tpdespWhereInput | tpdespWhereInput[];
      nome_tpdesp?: StringFilter<'tpdesp'> | string;
    },
    'cod_tpdesp'
  >;

  export type tpdespOrderByWithAggregationInput = {
    cod_tpdesp?: SortOrder;
    nome_tpdesp?: SortOrder;
    _count?: tpdespCountOrderByAggregateInput;
    _avg?: tpdespAvgOrderByAggregateInput;
    _max?: tpdespMaxOrderByAggregateInput;
    _min?: tpdespMinOrderByAggregateInput;
    _sum?: tpdespSumOrderByAggregateInput;
  };

  export type tpdespScalarWhereWithAggregatesInput = {
    AND?:
      | tpdespScalarWhereWithAggregatesInput
      | tpdespScalarWhereWithAggregatesInput[];
    OR?: tpdespScalarWhereWithAggregatesInput[];
    NOT?:
      | tpdespScalarWhereWithAggregatesInput
      | tpdespScalarWhereWithAggregatesInput[];
    cod_tpdesp?: IntWithAggregatesFilter<'tpdesp'> | number;
    nome_tpdesp?: StringWithAggregatesFilter<'tpdesp'> | string;
  };

  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[];
    OR?: usuarioWhereInput[];
    NOT?: usuarioWhereInput | usuarioWhereInput[];
    cod_usuario?: IntFilter<'usuario'> | number;
    nome_usuario?: StringFilter<'usuario'> | string;
    id_usuario?: StringFilter<'usuario'> | string;
    senha?: StringNullableFilter<'usuario'> | string | null;
    tipo_usuario?: StringFilter<'usuario'> | string;
    permtar_usuario?: StringFilter<'usuario'> | string;
    altsen_usuario?: IntFilter<'usuario'> | number;
    perproj1_usuario?: StringFilter<'usuario'> | string;
    perproj2_usuario?: StringFilter<'usuario'> | string;
    tela1_usuario?: IntNullableFilter<'usuario'> | number | null;
    tela2_usuario?: IntNullableFilter<'usuario'> | number | null;
    tela3_usuario?: IntNullableFilter<'usuario'> | number | null;
    tela4_usuario?: IntNullableFilter<'usuario'> | number | null;
    acesso_sistema?: Acesso_sistemaListRelationFilter;
    recurso?: RecursoListRelationFilter;
  };

  export type usuarioOrderByWithRelationInput = {
    cod_usuario?: SortOrder;
    nome_usuario?: SortOrder;
    id_usuario?: SortOrder;
    senha?: SortOrderInput | SortOrder;
    tipo_usuario?: SortOrder;
    permtar_usuario?: SortOrder;
    altsen_usuario?: SortOrder;
    perproj1_usuario?: SortOrder;
    perproj2_usuario?: SortOrder;
    tela1_usuario?: SortOrderInput | SortOrder;
    tela2_usuario?: SortOrderInput | SortOrder;
    tela3_usuario?: SortOrderInput | SortOrder;
    tela4_usuario?: SortOrderInput | SortOrder;
    acesso_sistema?: acesso_sistemaOrderByRelationAggregateInput;
    recurso?: recursoOrderByRelationAggregateInput;
  };

  export type usuarioWhereUniqueInput = Prisma.AtLeast<
    {
      cod_usuario?: number;
      AND?: usuarioWhereInput | usuarioWhereInput[];
      OR?: usuarioWhereInput[];
      NOT?: usuarioWhereInput | usuarioWhereInput[];
      nome_usuario?: StringFilter<'usuario'> | string;
      id_usuario?: StringFilter<'usuario'> | string;
      senha?: StringNullableFilter<'usuario'> | string | null;
      tipo_usuario?: StringFilter<'usuario'> | string;
      permtar_usuario?: StringFilter<'usuario'> | string;
      altsen_usuario?: IntFilter<'usuario'> | number;
      perproj1_usuario?: StringFilter<'usuario'> | string;
      perproj2_usuario?: StringFilter<'usuario'> | string;
      tela1_usuario?: IntNullableFilter<'usuario'> | number | null;
      tela2_usuario?: IntNullableFilter<'usuario'> | number | null;
      tela3_usuario?: IntNullableFilter<'usuario'> | number | null;
      tela4_usuario?: IntNullableFilter<'usuario'> | number | null;
      acesso_sistema?: Acesso_sistemaListRelationFilter;
      recurso?: RecursoListRelationFilter;
    },
    'cod_usuario'
  >;

  export type usuarioOrderByWithAggregationInput = {
    cod_usuario?: SortOrder;
    nome_usuario?: SortOrder;
    id_usuario?: SortOrder;
    senha?: SortOrderInput | SortOrder;
    tipo_usuario?: SortOrder;
    permtar_usuario?: SortOrder;
    altsen_usuario?: SortOrder;
    perproj1_usuario?: SortOrder;
    perproj2_usuario?: SortOrder;
    tela1_usuario?: SortOrderInput | SortOrder;
    tela2_usuario?: SortOrderInput | SortOrder;
    tela3_usuario?: SortOrderInput | SortOrder;
    tela4_usuario?: SortOrderInput | SortOrder;
    _count?: usuarioCountOrderByAggregateInput;
    _avg?: usuarioAvgOrderByAggregateInput;
    _max?: usuarioMaxOrderByAggregateInput;
    _min?: usuarioMinOrderByAggregateInput;
    _sum?: usuarioSumOrderByAggregateInput;
  };

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?:
      | usuarioScalarWhereWithAggregatesInput
      | usuarioScalarWhereWithAggregatesInput[];
    OR?: usuarioScalarWhereWithAggregatesInput[];
    NOT?:
      | usuarioScalarWhereWithAggregatesInput
      | usuarioScalarWhereWithAggregatesInput[];
    cod_usuario?: IntWithAggregatesFilter<'usuario'> | number;
    nome_usuario?: StringWithAggregatesFilter<'usuario'> | string;
    id_usuario?: StringWithAggregatesFilter<'usuario'> | string;
    senha?: StringNullableWithAggregatesFilter<'usuario'> | string | null;
    tipo_usuario?: StringWithAggregatesFilter<'usuario'> | string;
    permtar_usuario?: StringWithAggregatesFilter<'usuario'> | string;
    altsen_usuario?: IntWithAggregatesFilter<'usuario'> | number;
    perproj1_usuario?: StringWithAggregatesFilter<'usuario'> | string;
    perproj2_usuario?: StringWithAggregatesFilter<'usuario'> | string;
    tela1_usuario?: IntNullableWithAggregatesFilter<'usuario'> | number | null;
    tela2_usuario?: IntNullableWithAggregatesFilter<'usuario'> | number | null;
    tela3_usuario?: IntNullableWithAggregatesFilter<'usuario'> | number | null;
    tela4_usuario?: IntNullableWithAggregatesFilter<'usuario'> | number | null;
  };

  export type valorWhereInput = {
    AND?: valorWhereInput | valorWhereInput[];
    OR?: valorWhereInput[];
    NOT?: valorWhereInput | valorWhereInput[];
    codproj_valor?: IntFilter<'valor'> | number;
    codtipo_valor?: IntFilter<'valor'> | number;
    preco_valor?:
      | DecimalFilter<'valor'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
    tipotrf?: XOR<TipotrfScalarRelationFilter, tipotrfWhereInput>;
  };

  export type valorOrderByWithRelationInput = {
    codproj_valor?: SortOrder;
    codtipo_valor?: SortOrder;
    preco_valor?: SortOrder;
    projeto?: projetoOrderByWithRelationInput;
    tipotrf?: tipotrfOrderByWithRelationInput;
  };

  export type valorWhereUniqueInput = Prisma.AtLeast<
    {
      codproj_valor_codtipo_valor?: valorCodproj_valorCodtipo_valorCompoundUniqueInput;
      AND?: valorWhereInput | valorWhereInput[];
      OR?: valorWhereInput[];
      NOT?: valorWhereInput | valorWhereInput[];
      codproj_valor?: IntFilter<'valor'> | number;
      codtipo_valor?: IntFilter<'valor'> | number;
      preco_valor?:
        | DecimalFilter<'valor'>
        | Decimal
        | DecimalJsLike
        | number
        | string;
      projeto?: XOR<ProjetoScalarRelationFilter, projetoWhereInput>;
      tipotrf?: XOR<TipotrfScalarRelationFilter, tipotrfWhereInput>;
    },
    'codproj_valor_codtipo_valor'
  >;

  export type valorOrderByWithAggregationInput = {
    codproj_valor?: SortOrder;
    codtipo_valor?: SortOrder;
    preco_valor?: SortOrder;
    _count?: valorCountOrderByAggregateInput;
    _avg?: valorAvgOrderByAggregateInput;
    _max?: valorMaxOrderByAggregateInput;
    _min?: valorMinOrderByAggregateInput;
    _sum?: valorSumOrderByAggregateInput;
  };

  export type valorScalarWhereWithAggregatesInput = {
    AND?:
      | valorScalarWhereWithAggregatesInput
      | valorScalarWhereWithAggregatesInput[];
    OR?: valorScalarWhereWithAggregatesInput[];
    NOT?:
      | valorScalarWhereWithAggregatesInput
      | valorScalarWhereWithAggregatesInput[];
    codproj_valor?: IntWithAggregatesFilter<'valor'> | number;
    codtipo_valor?: IntWithAggregatesFilter<'valor'> | number;
    preco_valor?:
      | DecimalWithAggregatesFilter<'valor'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type acesso_sistemaCreateInput = {
    incluir?: string;
    modificar?: string;
    eliminar?: string;
    modulo_sistema: modulo_sistemaCreateNestedOneWithoutAcesso_sistemaInput;
    tela_sistema: tela_sistemaCreateNestedOneWithoutAcesso_sistemaInput;
    usuario: usuarioCreateNestedOneWithoutAcesso_sistemaInput;
  };

  export type acesso_sistemaUncheckedCreateInput = {
    cod_usuario: number;
    cod_modulo: number;
    cod_tela: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type acesso_sistemaUpdateInput = {
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
    modulo_sistema?: modulo_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
    tela_sistema?: tela_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
  };

  export type acesso_sistemaUncheckedUpdateInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    cod_tela?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type acesso_sistemaCreateManyInput = {
    cod_usuario: number;
    cod_modulo: number;
    cod_tela: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type acesso_sistemaUpdateManyMutationInput = {
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type acesso_sistemaUncheckedUpdateManyInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    cod_tela?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type agenrecCreateInput = {
    cod_agenrec: number;
    data_agenrec: Date | string;
    hrini_agenrec: string;
    hrfim_agenrec: string;
    status_agenrec?: number;
    obs_agenrec?: string | null;
    custo_agenrec?: Decimal | DecimalJsLike | number | string | null;
    receita_agenrec?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_agenrec?: number | null;
    recurso: recursoCreateNestedOneWithoutAgenrecInput;
  };

  export type agenrecUncheckedCreateInput = {
    cod_agenrec: number;
    cod_recurso: number;
    data_agenrec: Date | string;
    hrini_agenrec: string;
    hrfim_agenrec: string;
    status_agenrec?: number;
    obs_agenrec?: string | null;
    custo_agenrec?: Decimal | DecimalJsLike | number | string | null;
    receita_agenrec?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_agenrec?: number | null;
  };

  export type agenrecUpdateInput = {
    cod_agenrec?: IntFieldUpdateOperationsInput | number;
    data_agenrec?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_agenrec?: StringFieldUpdateOperationsInput | string;
    hrfim_agenrec?: StringFieldUpdateOperationsInput | string;
    status_agenrec?: IntFieldUpdateOperationsInput | number;
    obs_agenrec?: NullableStringFieldUpdateOperationsInput | string | null;
    custo_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: NullableIntFieldUpdateOperationsInput | number | null;
    recurso?: recursoUpdateOneRequiredWithoutAgenrecNestedInput;
  };

  export type agenrecUncheckedUpdateInput = {
    cod_agenrec?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    data_agenrec?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_agenrec?: StringFieldUpdateOperationsInput | string;
    hrfim_agenrec?: StringFieldUpdateOperationsInput | string;
    status_agenrec?: IntFieldUpdateOperationsInput | number;
    obs_agenrec?: NullableStringFieldUpdateOperationsInput | string | null;
    custo_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type agenrecCreateManyInput = {
    cod_agenrec: number;
    cod_recurso: number;
    data_agenrec: Date | string;
    hrini_agenrec: string;
    hrfim_agenrec: string;
    status_agenrec?: number;
    obs_agenrec?: string | null;
    custo_agenrec?: Decimal | DecimalJsLike | number | string | null;
    receita_agenrec?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_agenrec?: number | null;
  };

  export type agenrecUpdateManyMutationInput = {
    cod_agenrec?: IntFieldUpdateOperationsInput | number;
    data_agenrec?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_agenrec?: StringFieldUpdateOperationsInput | string;
    hrfim_agenrec?: StringFieldUpdateOperationsInput | string;
    status_agenrec?: IntFieldUpdateOperationsInput | number;
    obs_agenrec?: NullableStringFieldUpdateOperationsInput | string | null;
    custo_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type agenrecUncheckedUpdateManyInput = {
    cod_agenrec?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    data_agenrec?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_agenrec?: StringFieldUpdateOperationsInput | string;
    hrfim_agenrec?: StringFieldUpdateOperationsInput | string;
    status_agenrec?: IntFieldUpdateOperationsInput | number;
    obs_agenrec?: NullableStringFieldUpdateOperationsInput | string | null;
    custo_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type areaCreateInput = {
    cod_area: number;
    nome_area: string;
    meta?: metaCreateNestedManyWithoutAreaInput;
    tarefa?: tarefaCreateNestedManyWithoutAreaInput;
  };

  export type areaUncheckedCreateInput = {
    cod_area: number;
    nome_area: string;
    meta?: metaUncheckedCreateNestedManyWithoutAreaInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutAreaInput;
  };

  export type areaUpdateInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
    meta?: metaUpdateManyWithoutAreaNestedInput;
    tarefa?: tarefaUpdateManyWithoutAreaNestedInput;
  };

  export type areaUncheckedUpdateInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
    meta?: metaUncheckedUpdateManyWithoutAreaNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutAreaNestedInput;
  };

  export type areaCreateManyInput = {
    cod_area: number;
    nome_area: string;
  };

  export type areaUpdateManyMutationInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
  };

  export type areaUncheckedUpdateManyInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
  };

  export type avaliacaoCreateInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
    projeto: projetoCreateNestedOneWithoutAvaliacaoInput;
    avaliado?: avaliadoCreateNestedManyWithoutAvaliacaoInput;
  };

  export type avaliacaoUncheckedCreateInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
    codpro_avaliacao: number;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutAvaliacaoInput;
  };

  export type avaliacaoUpdateInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
    projeto?: projetoUpdateOneRequiredWithoutAvaliacaoNestedInput;
    avaliado?: avaliadoUpdateManyWithoutAvaliacaoNestedInput;
  };

  export type avaliacaoUncheckedUpdateInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
    codpro_avaliacao?: IntFieldUpdateOperationsInput | number;
    avaliado?: avaliadoUncheckedUpdateManyWithoutAvaliacaoNestedInput;
  };

  export type avaliacaoCreateManyInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
    codpro_avaliacao: number;
  };

  export type avaliacaoUpdateManyMutationInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
  };

  export type avaliacaoUncheckedUpdateManyInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
    codpro_avaliacao?: IntFieldUpdateOperationsInput | number;
  };

  export type avaliadoCreateInput = {
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
    avaliacao: avaliacaoCreateNestedOneWithoutAvaliadoInput;
    recurso: recursoCreateNestedOneWithoutAvaliadoInput;
    itavaliado?: itavaliadoCreateNestedManyWithoutAvaliadoInput;
  };

  export type avaliadoUncheckedCreateInput = {
    codaval_avaliado: number;
    codrec_avaliado: number;
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
    itavaliado?: itavaliadoUncheckedCreateNestedManyWithoutAvaliadoInput;
  };

  export type avaliadoUpdateInput = {
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    avaliacao?: avaliacaoUpdateOneRequiredWithoutAvaliadoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutAvaliadoNestedInput;
    itavaliado?: itavaliadoUpdateManyWithoutAvaliadoNestedInput;
  };

  export type avaliadoUncheckedUpdateInput = {
    codaval_avaliado?: IntFieldUpdateOperationsInput | number;
    codrec_avaliado?: IntFieldUpdateOperationsInput | number;
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    itavaliado?: itavaliadoUncheckedUpdateManyWithoutAvaliadoNestedInput;
  };

  export type avaliadoCreateManyInput = {
    codaval_avaliado: number;
    codrec_avaliado: number;
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
  };

  export type avaliadoUpdateManyMutationInput = {
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type avaliadoUncheckedUpdateManyInput = {
    codaval_avaliado?: IntFieldUpdateOperationsInput | number;
    codrec_avaliado?: IntFieldUpdateOperationsInput | number;
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type chamadoCreateInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
    cliente?: clienteCreateNestedOneWithoutChamadosInput;
    recurso?: recursoCreateNestedOneWithoutChamadoInput;
  };

  export type chamadoUncheckedCreateInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cod_recurso?: number | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    cod_cliente?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
  };

  export type chamadoUpdateInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
    cliente?: clienteUpdateOneWithoutChamadosNestedInput;
    recurso?: recursoUpdateOneWithoutChamadoNestedInput;
  };

  export type chamadoUncheckedUpdateInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_cliente?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type chamadoCreateManyInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cod_recurso?: number | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    cod_cliente?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
  };

  export type chamadoUpdateManyMutationInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type chamadoUncheckedUpdateManyInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_cliente?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type cidadeCreateInput = {
    cod_cidade: number;
    nome_cidade: string;
    codibge_cidade?: string | null;
    uf_cidade?: string | null;
  };

  export type cidadeUncheckedCreateInput = {
    cod_cidade: number;
    nome_cidade: string;
    codibge_cidade?: string | null;
    uf_cidade?: string | null;
  };

  export type cidadeUpdateInput = {
    cod_cidade?: IntFieldUpdateOperationsInput | number;
    nome_cidade?: StringFieldUpdateOperationsInput | string;
    codibge_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type cidadeUncheckedUpdateInput = {
    cod_cidade?: IntFieldUpdateOperationsInput | number;
    nome_cidade?: StringFieldUpdateOperationsInput | string;
    codibge_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type cidadeCreateManyInput = {
    cod_cidade: number;
    nome_cidade: string;
    codibge_cidade?: string | null;
    uf_cidade?: string | null;
  };

  export type cidadeUpdateManyMutationInput = {
    cod_cidade?: IntFieldUpdateOperationsInput | number;
    nome_cidade?: StringFieldUpdateOperationsInput | string;
    codibge_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type cidadeUncheckedUpdateManyInput = {
    cod_cidade?: IntFieldUpdateOperationsInput | number;
    nome_cidade?: StringFieldUpdateOperationsInput | string;
    codibge_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cidade?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type classificacaoCreateInput = {
    cod_classificacao: number;
    nome_classificacao: string;
    ativo_classificacao?: string | null;
  };

  export type classificacaoUncheckedCreateInput = {
    cod_classificacao: number;
    nome_classificacao: string;
    ativo_classificacao?: string | null;
  };

  export type classificacaoUpdateInput = {
    cod_classificacao?: IntFieldUpdateOperationsInput | number;
    nome_classificacao?: StringFieldUpdateOperationsInput | string;
    ativo_classificacao?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type classificacaoUncheckedUpdateInput = {
    cod_classificacao?: IntFieldUpdateOperationsInput | number;
    nome_classificacao?: StringFieldUpdateOperationsInput | string;
    ativo_classificacao?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type classificacaoCreateManyInput = {
    cod_classificacao: number;
    nome_classificacao: string;
    ativo_classificacao?: string | null;
  };

  export type classificacaoUpdateManyMutationInput = {
    cod_classificacao?: IntFieldUpdateOperationsInput | number;
    nome_classificacao?: StringFieldUpdateOperationsInput | string;
    ativo_classificacao?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type classificacaoUncheckedUpdateManyInput = {
    cod_classificacao?: IntFieldUpdateOperationsInput | number;
    nome_classificacao?: StringFieldUpdateOperationsInput | string;
    ativo_classificacao?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type clienteCreateInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    chamados?: chamadoCreateNestedManyWithoutClienteInput;
    fatrec?: fatrecCreateNestedManyWithoutClienteInput;
    projeto?: projetoCreateNestedManyWithoutClienteInput;
  };

  export type clienteUncheckedCreateInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    chamados?: chamadoUncheckedCreateNestedManyWithoutClienteInput;
    fatrec?: fatrecUncheckedCreateNestedManyWithoutClienteInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutClienteInput;
  };

  export type clienteUpdateInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    chamados?: chamadoUpdateManyWithoutClienteNestedInput;
    fatrec?: fatrecUpdateManyWithoutClienteNestedInput;
    projeto?: projetoUpdateManyWithoutClienteNestedInput;
  };

  export type clienteUncheckedUpdateInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    chamados?: chamadoUncheckedUpdateManyWithoutClienteNestedInput;
    fatrec?: fatrecUncheckedUpdateManyWithoutClienteNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutClienteNestedInput;
  };

  export type clienteCreateManyInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
  };

  export type clienteUpdateManyMutationInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
  };

  export type clienteUncheckedUpdateManyInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
  };

  export type composicaoCreateInput = {
    cod_composicao: number;
    cod_fatura: number;
    cod_cliente: number;
    cod_projeto: number;
    cod_tarefa: number;
    cod_recurso: number;
    hrfat_composicao?: Decimal | DecimalJsLike | number | string | null;
    hrnfat_composicao?: Decimal | DecimalJsLike | number | string | null;
    vrhr_composicao?: Decimal | DecimalJsLike | number | string | null;
    vrfat_composicao?: Decimal | DecimalJsLike | number | string | null;
  };

  export type composicaoUncheckedCreateInput = {
    cod_composicao: number;
    cod_fatura: number;
    cod_cliente: number;
    cod_projeto: number;
    cod_tarefa: number;
    cod_recurso: number;
    hrfat_composicao?: Decimal | DecimalJsLike | number | string | null;
    hrnfat_composicao?: Decimal | DecimalJsLike | number | string | null;
    vrhr_composicao?: Decimal | DecimalJsLike | number | string | null;
    vrfat_composicao?: Decimal | DecimalJsLike | number | string | null;
  };

  export type composicaoUpdateInput = {
    cod_composicao?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrhr_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type composicaoUncheckedUpdateInput = {
    cod_composicao?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrhr_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type composicaoCreateManyInput = {
    cod_composicao: number;
    cod_fatura: number;
    cod_cliente: number;
    cod_projeto: number;
    cod_tarefa: number;
    cod_recurso: number;
    hrfat_composicao?: Decimal | DecimalJsLike | number | string | null;
    hrnfat_composicao?: Decimal | DecimalJsLike | number | string | null;
    vrhr_composicao?: Decimal | DecimalJsLike | number | string | null;
    vrfat_composicao?: Decimal | DecimalJsLike | number | string | null;
  };

  export type composicaoUpdateManyMutationInput = {
    cod_composicao?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrhr_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type composicaoUncheckedUpdateManyInput = {
    cod_composicao?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrhr_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_composicao?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type contatoCreateInput = {
    cod_contato: number;
    data_contato: Date | string;
    hora_contato: string;
    nomeusuario_contato: string;
    desc_contato?: string | null;
    cod_lista: number;
  };

  export type contatoUncheckedCreateInput = {
    cod_contato: number;
    data_contato: Date | string;
    hora_contato: string;
    nomeusuario_contato: string;
    desc_contato?: string | null;
    cod_lista: number;
  };

  export type contatoUpdateInput = {
    cod_contato?: IntFieldUpdateOperationsInput | number;
    data_contato?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_contato?: StringFieldUpdateOperationsInput | string;
    nomeusuario_contato?: StringFieldUpdateOperationsInput | string;
    desc_contato?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_lista?: IntFieldUpdateOperationsInput | number;
  };

  export type contatoUncheckedUpdateInput = {
    cod_contato?: IntFieldUpdateOperationsInput | number;
    data_contato?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_contato?: StringFieldUpdateOperationsInput | string;
    nomeusuario_contato?: StringFieldUpdateOperationsInput | string;
    desc_contato?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_lista?: IntFieldUpdateOperationsInput | number;
  };

  export type contatoCreateManyInput = {
    cod_contato: number;
    data_contato: Date | string;
    hora_contato: string;
    nomeusuario_contato: string;
    desc_contato?: string | null;
    cod_lista: number;
  };

  export type contatoUpdateManyMutationInput = {
    cod_contato?: IntFieldUpdateOperationsInput | number;
    data_contato?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_contato?: StringFieldUpdateOperationsInput | string;
    nomeusuario_contato?: StringFieldUpdateOperationsInput | string;
    desc_contato?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_lista?: IntFieldUpdateOperationsInput | number;
  };

  export type contatoUncheckedUpdateManyInput = {
    cod_contato?: IntFieldUpdateOperationsInput | number;
    data_contato?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_contato?: StringFieldUpdateOperationsInput | string;
    nomeusuario_contato?: StringFieldUpdateOperationsInput | string;
    desc_contato?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_lista?: IntFieldUpdateOperationsInput | number;
  };

  export type ctissCreateInput = {
    cod_ctiss: number;
    num_ctiss: string;
    subitem_ctiss: string;
    descr_ctiss?: string | null;
    csll_ctiss: Decimal | DecimalJsLike | number | string;
    pis_ctiss: Decimal | DecimalJsLike | number | string;
    cofins_ctiss: Decimal | DecimalJsLike | number | string;
    irrf_ctiss: Decimal | DecimalJsLike | number | string;
    aliq_ctiss: Decimal | DecimalJsLike | number | string;
    aliqret_ctiss: Decimal | DecimalJsLike | number | string;
  };

  export type ctissUncheckedCreateInput = {
    cod_ctiss: number;
    num_ctiss: string;
    subitem_ctiss: string;
    descr_ctiss?: string | null;
    csll_ctiss: Decimal | DecimalJsLike | number | string;
    pis_ctiss: Decimal | DecimalJsLike | number | string;
    cofins_ctiss: Decimal | DecimalJsLike | number | string;
    irrf_ctiss: Decimal | DecimalJsLike | number | string;
    aliq_ctiss: Decimal | DecimalJsLike | number | string;
    aliqret_ctiss: Decimal | DecimalJsLike | number | string;
  };

  export type ctissUpdateInput = {
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    num_ctiss?: StringFieldUpdateOperationsInput | string;
    subitem_ctiss?: StringFieldUpdateOperationsInput | string;
    descr_ctiss?: NullableStringFieldUpdateOperationsInput | string | null;
    csll_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliq_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliqret_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type ctissUncheckedUpdateInput = {
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    num_ctiss?: StringFieldUpdateOperationsInput | string;
    subitem_ctiss?: StringFieldUpdateOperationsInput | string;
    descr_ctiss?: NullableStringFieldUpdateOperationsInput | string | null;
    csll_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliq_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliqret_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type ctissCreateManyInput = {
    cod_ctiss: number;
    num_ctiss: string;
    subitem_ctiss: string;
    descr_ctiss?: string | null;
    csll_ctiss: Decimal | DecimalJsLike | number | string;
    pis_ctiss: Decimal | DecimalJsLike | number | string;
    cofins_ctiss: Decimal | DecimalJsLike | number | string;
    irrf_ctiss: Decimal | DecimalJsLike | number | string;
    aliq_ctiss: Decimal | DecimalJsLike | number | string;
    aliqret_ctiss: Decimal | DecimalJsLike | number | string;
  };

  export type ctissUpdateManyMutationInput = {
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    num_ctiss?: StringFieldUpdateOperationsInput | string;
    subitem_ctiss?: StringFieldUpdateOperationsInput | string;
    descr_ctiss?: NullableStringFieldUpdateOperationsInput | string | null;
    csll_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliq_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliqret_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type ctissUncheckedUpdateManyInput = {
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    num_ctiss?: StringFieldUpdateOperationsInput | string;
    subitem_ctiss?: StringFieldUpdateOperationsInput | string;
    descr_ctiss?: NullableStringFieldUpdateOperationsInput | string | null;
    csll_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliq_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    aliqret_ctiss?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type despesaCreateInput = {
    cod_despesa: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_despesa?: Decimal | DecimalJsLike | number | string;
    mesano_despesa: string;
  };

  export type despesaUncheckedCreateInput = {
    cod_despesa: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_despesa?: Decimal | DecimalJsLike | number | string;
    mesano_despesa: string;
  };

  export type despesaUpdateInput = {
    cod_despesa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_despesa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_despesa?: StringFieldUpdateOperationsInput | string;
  };

  export type despesaUncheckedUpdateInput = {
    cod_despesa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_despesa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_despesa?: StringFieldUpdateOperationsInput | string;
  };

  export type despesaCreateManyInput = {
    cod_despesa: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_despesa?: Decimal | DecimalJsLike | number | string;
    mesano_despesa: string;
  };

  export type despesaUpdateManyMutationInput = {
    cod_despesa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_despesa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_despesa?: StringFieldUpdateOperationsInput | string;
  };

  export type despesaUncheckedUpdateManyInput = {
    cod_despesa?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_despesa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_despesa?: StringFieldUpdateOperationsInput | string;
  };

  export type desprecCreateInput = {
    cod_desprec: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_desprec?: Decimal | DecimalJsLike | number | string;
  };

  export type desprecUncheckedCreateInput = {
    cod_desprec: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_desprec?: Decimal | DecimalJsLike | number | string;
  };

  export type desprecUpdateInput = {
    cod_desprec?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_desprec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type desprecUncheckedUpdateInput = {
    cod_desprec?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_desprec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type desprecCreateManyInput = {
    cod_desprec: number;
    cod_recurso: number;
    cod_tpdesp: number;
    valor_desprec?: Decimal | DecimalJsLike | number | string;
  };

  export type desprecUpdateManyMutationInput = {
    cod_desprec?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_desprec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type desprecUncheckedUpdateManyInput = {
    cod_desprec?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    valor_desprec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type empresaCreateInput = {
    cod_empresa: number;
    nome_empresa: string;
    razao_empresa?: string | null;
    end_empresa?: string | null;
    bairro_empresa?: string | null;
    cep_empresa?: string | null;
    ddd_empresa?: string | null;
    fone_empresa?: string | null;
    cnpj_empresa?: string | null;
    ie_empresa?: string | null;
    im_empresa?: string | null;
    cod_cidade?: number | null;
    certificado_empresa?: string | null;
    email_empresa?: string | null;
  };

  export type empresaUncheckedCreateInput = {
    cod_empresa: number;
    nome_empresa: string;
    razao_empresa?: string | null;
    end_empresa?: string | null;
    bairro_empresa?: string | null;
    cep_empresa?: string | null;
    ddd_empresa?: string | null;
    fone_empresa?: string | null;
    cnpj_empresa?: string | null;
    ie_empresa?: string | null;
    im_empresa?: string | null;
    cod_cidade?: number | null;
    certificado_empresa?: string | null;
    email_empresa?: string | null;
  };

  export type empresaUpdateInput = {
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    nome_empresa?: StringFieldUpdateOperationsInput | string;
    razao_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    end_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ddd_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    im_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    certificado_empresa?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type empresaUncheckedUpdateInput = {
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    nome_empresa?: StringFieldUpdateOperationsInput | string;
    razao_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    end_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ddd_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    im_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    certificado_empresa?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type empresaCreateManyInput = {
    cod_empresa: number;
    nome_empresa: string;
    razao_empresa?: string | null;
    end_empresa?: string | null;
    bairro_empresa?: string | null;
    cep_empresa?: string | null;
    ddd_empresa?: string | null;
    fone_empresa?: string | null;
    cnpj_empresa?: string | null;
    ie_empresa?: string | null;
    im_empresa?: string | null;
    cod_cidade?: number | null;
    certificado_empresa?: string | null;
    email_empresa?: string | null;
  };

  export type empresaUpdateManyMutationInput = {
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    nome_empresa?: StringFieldUpdateOperationsInput | string;
    razao_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    end_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ddd_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    im_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    certificado_empresa?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type empresaUncheckedUpdateManyInput = {
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    nome_empresa?: StringFieldUpdateOperationsInput | string;
    razao_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    end_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ddd_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    im_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    certificado_empresa?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    email_empresa?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type faseCreateInput = {
    cod_fase: number;
    nome_fase: string;
    meta?: metaCreateNestedManyWithoutFaseInput;
    tarefa?: tarefaCreateNestedManyWithoutFaseInput;
  };

  export type faseUncheckedCreateInput = {
    cod_fase: number;
    nome_fase: string;
    meta?: metaUncheckedCreateNestedManyWithoutFaseInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutFaseInput;
  };

  export type faseUpdateInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
    meta?: metaUpdateManyWithoutFaseNestedInput;
    tarefa?: tarefaUpdateManyWithoutFaseNestedInput;
  };

  export type faseUncheckedUpdateInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
    meta?: metaUncheckedUpdateManyWithoutFaseNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutFaseNestedInput;
  };

  export type faseCreateManyInput = {
    cod_fase: number;
    nome_fase: string;
  };

  export type faseUpdateManyMutationInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
  };

  export type faseUncheckedUpdateManyInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
  };

  export type fatdesCreateInput = {
    cod_fatdes: number;
    mesano_fatdes?: string | null;
    desc_fatdes: string;
    vrdesp_fatdes?: Decimal | DecimalJsLike | number | string;
    dtpag_fatdes?: Date | string | null;
    obs_fatdes?: Uint8Array | null;
    dtven_fatdes?: Date | string | null;
  };

  export type fatdesUncheckedCreateInput = {
    cod_fatdes: number;
    mesano_fatdes?: string | null;
    desc_fatdes: string;
    vrdesp_fatdes?: Decimal | DecimalJsLike | number | string;
    dtpag_fatdes?: Date | string | null;
    obs_fatdes?: Uint8Array | null;
    dtven_fatdes?: Date | string | null;
  };

  export type fatdesUpdateInput = {
    cod_fatdes?: IntFieldUpdateOperationsInput | number;
    mesano_fatdes?: NullableStringFieldUpdateOperationsInput | string | null;
    desc_fatdes?: StringFieldUpdateOperationsInput | string;
    vrdesp_fatdes?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatdes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtven_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type fatdesUncheckedUpdateInput = {
    cod_fatdes?: IntFieldUpdateOperationsInput | number;
    mesano_fatdes?: NullableStringFieldUpdateOperationsInput | string | null;
    desc_fatdes?: StringFieldUpdateOperationsInput | string;
    vrdesp_fatdes?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatdes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtven_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type fatdesCreateManyInput = {
    cod_fatdes: number;
    mesano_fatdes?: string | null;
    desc_fatdes: string;
    vrdesp_fatdes?: Decimal | DecimalJsLike | number | string;
    dtpag_fatdes?: Date | string | null;
    obs_fatdes?: Uint8Array | null;
    dtven_fatdes?: Date | string | null;
  };

  export type fatdesUpdateManyMutationInput = {
    cod_fatdes?: IntFieldUpdateOperationsInput | number;
    mesano_fatdes?: NullableStringFieldUpdateOperationsInput | string | null;
    desc_fatdes?: StringFieldUpdateOperationsInput | string;
    vrdesp_fatdes?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatdes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtven_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type fatdesUncheckedUpdateManyInput = {
    cod_fatdes?: IntFieldUpdateOperationsInput | number;
    mesano_fatdes?: NullableStringFieldUpdateOperationsInput | string | null;
    desc_fatdes?: StringFieldUpdateOperationsInput | string;
    vrdesp_fatdes?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatdes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtven_fatdes?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type fatfunCreateInput = {
    cod_fatfun: number;
    mesano_fatfun?: string | null;
    nome_fatfun: string;
    vrdesl_fatfun?: Decimal | DecimalJsLike | number | string;
    vralm_fatfun?: Decimal | DecimalJsLike | number | string;
    vrsal_fatfun?: Decimal | DecimalJsLike | number | string;
    dtpag_fatfun?: Date | string | null;
    obs_fatfun?: Uint8Array | null;
    dtpag1_fatfun?: Date | string | null;
    dtpag2_fatfun?: Date | string | null;
    cod_recurso?: number | null;
  };

  export type fatfunUncheckedCreateInput = {
    cod_fatfun: number;
    mesano_fatfun?: string | null;
    nome_fatfun: string;
    vrdesl_fatfun?: Decimal | DecimalJsLike | number | string;
    vralm_fatfun?: Decimal | DecimalJsLike | number | string;
    vrsal_fatfun?: Decimal | DecimalJsLike | number | string;
    dtpag_fatfun?: Date | string | null;
    obs_fatfun?: Uint8Array | null;
    dtpag1_fatfun?: Date | string | null;
    dtpag2_fatfun?: Date | string | null;
    cod_recurso?: number | null;
  };

  export type fatfunUpdateInput = {
    cod_fatfun?: IntFieldUpdateOperationsInput | number;
    mesano_fatfun?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_fatfun?: StringFieldUpdateOperationsInput | string;
    vrdesl_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vralm_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrsal_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatfun?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtpag1_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag2_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type fatfunUncheckedUpdateInput = {
    cod_fatfun?: IntFieldUpdateOperationsInput | number;
    mesano_fatfun?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_fatfun?: StringFieldUpdateOperationsInput | string;
    vrdesl_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vralm_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrsal_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatfun?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtpag1_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag2_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type fatfunCreateManyInput = {
    cod_fatfun: number;
    mesano_fatfun?: string | null;
    nome_fatfun: string;
    vrdesl_fatfun?: Decimal | DecimalJsLike | number | string;
    vralm_fatfun?: Decimal | DecimalJsLike | number | string;
    vrsal_fatfun?: Decimal | DecimalJsLike | number | string;
    dtpag_fatfun?: Date | string | null;
    obs_fatfun?: Uint8Array | null;
    dtpag1_fatfun?: Date | string | null;
    dtpag2_fatfun?: Date | string | null;
    cod_recurso?: number | null;
  };

  export type fatfunUpdateManyMutationInput = {
    cod_fatfun?: IntFieldUpdateOperationsInput | number;
    mesano_fatfun?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_fatfun?: StringFieldUpdateOperationsInput | string;
    vrdesl_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vralm_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrsal_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatfun?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtpag1_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag2_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type fatfunUncheckedUpdateManyInput = {
    cod_fatfun?: IntFieldUpdateOperationsInput | number;
    mesano_fatfun?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_fatfun?: StringFieldUpdateOperationsInput | string;
    vrdesl_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vralm_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrsal_fatfun?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpag_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    obs_fatfun?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtpag1_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag2_fatfun?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type fatrecCreateInput = {
    cod_fatrec: number;
    desc_fatrec: string;
    qtdhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrtot_fatrec?: Decimal | DecimalJsLike | number | string;
    dtvenc_fatrec?: Date | string | null;
    dtnf_fatrec?: Date | string | null;
    dtcob_fatrec?: Date | string | null;
    dtpag_fatrec?: Date | string | null;
    vrpag_fatrec?: Decimal | DecimalJsLike | number | string;
    imp_fatrec?: Decimal | DecimalJsLike | number | string;
    mesano_fatrec?: string | null;
    obs_fatrec?: Uint8Array | null;
    cod_recurso?: number | null;
    perccom_fatrec?: Decimal | DecimalJsLike | number | string;
    dtpgcom_fatrec?: Date | string | null;
    cod_empresa?: number | null;
    nf_fatrec?: string | null;
    cliente: clienteCreateNestedOneWithoutFatrecInput;
  };

  export type fatrecUncheckedCreateInput = {
    cod_fatrec: number;
    cod_cliente: number;
    desc_fatrec: string;
    qtdhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrtot_fatrec?: Decimal | DecimalJsLike | number | string;
    dtvenc_fatrec?: Date | string | null;
    dtnf_fatrec?: Date | string | null;
    dtcob_fatrec?: Date | string | null;
    dtpag_fatrec?: Date | string | null;
    vrpag_fatrec?: Decimal | DecimalJsLike | number | string;
    imp_fatrec?: Decimal | DecimalJsLike | number | string;
    mesano_fatrec?: string | null;
    obs_fatrec?: Uint8Array | null;
    cod_recurso?: number | null;
    perccom_fatrec?: Decimal | DecimalJsLike | number | string;
    dtpgcom_fatrec?: Date | string | null;
    cod_empresa?: number | null;
    nf_fatrec?: string | null;
  };

  export type fatrecUpdateInput = {
    cod_fatrec?: IntFieldUpdateOperationsInput | number;
    desc_fatrec?: StringFieldUpdateOperationsInput | string;
    qtdhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_fatrec?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    perccom_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_empresa?: NullableIntFieldUpdateOperationsInput | number | null;
    nf_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    cliente?: clienteUpdateOneRequiredWithoutFatrecNestedInput;
  };

  export type fatrecUncheckedUpdateInput = {
    cod_fatrec?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    desc_fatrec?: StringFieldUpdateOperationsInput | string;
    qtdhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_fatrec?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    perccom_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_empresa?: NullableIntFieldUpdateOperationsInput | number | null;
    nf_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type fatrecCreateManyInput = {
    cod_fatrec: number;
    cod_cliente: number;
    desc_fatrec: string;
    qtdhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrtot_fatrec?: Decimal | DecimalJsLike | number | string;
    dtvenc_fatrec?: Date | string | null;
    dtnf_fatrec?: Date | string | null;
    dtcob_fatrec?: Date | string | null;
    dtpag_fatrec?: Date | string | null;
    vrpag_fatrec?: Decimal | DecimalJsLike | number | string;
    imp_fatrec?: Decimal | DecimalJsLike | number | string;
    mesano_fatrec?: string | null;
    obs_fatrec?: Uint8Array | null;
    cod_recurso?: number | null;
    perccom_fatrec?: Decimal | DecimalJsLike | number | string;
    dtpgcom_fatrec?: Date | string | null;
    cod_empresa?: number | null;
    nf_fatrec?: string | null;
  };

  export type fatrecUpdateManyMutationInput = {
    cod_fatrec?: IntFieldUpdateOperationsInput | number;
    desc_fatrec?: StringFieldUpdateOperationsInput | string;
    qtdhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_fatrec?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    perccom_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_empresa?: NullableIntFieldUpdateOperationsInput | number | null;
    nf_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type fatrecUncheckedUpdateManyInput = {
    cod_fatrec?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    desc_fatrec?: StringFieldUpdateOperationsInput | string;
    qtdhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_fatrec?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    perccom_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_empresa?: NullableIntFieldUpdateOperationsInput | number | null;
    nf_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type faturaCreateInput = {
    cod_fatura: number;
    mesano_fatura: string;
    desp_fatura?: Decimal | DecimalJsLike | number | string | null;
    imp_fatura?: Decimal | DecimalJsLike | number | string | null;
    lucro_fatura?: Decimal | DecimalJsLike | number | string | null;
  };

  export type faturaUncheckedCreateInput = {
    cod_fatura: number;
    mesano_fatura: string;
    desp_fatura?: Decimal | DecimalJsLike | number | string | null;
    imp_fatura?: Decimal | DecimalJsLike | number | string | null;
    lucro_fatura?: Decimal | DecimalJsLike | number | string | null;
  };

  export type faturaUpdateInput = {
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    mesano_fatura?: StringFieldUpdateOperationsInput | string;
    desp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    imp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    lucro_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type faturaUncheckedUpdateInput = {
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    mesano_fatura?: StringFieldUpdateOperationsInput | string;
    desp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    imp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    lucro_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type faturaCreateManyInput = {
    cod_fatura: number;
    mesano_fatura: string;
    desp_fatura?: Decimal | DecimalJsLike | number | string | null;
    imp_fatura?: Decimal | DecimalJsLike | number | string | null;
    lucro_fatura?: Decimal | DecimalJsLike | number | string | null;
  };

  export type faturaUpdateManyMutationInput = {
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    mesano_fatura?: StringFieldUpdateOperationsInput | string;
    desp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    imp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    lucro_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type faturaUncheckedUpdateManyInput = {
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    mesano_fatura?: StringFieldUpdateOperationsInput | string;
    desp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    imp_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    lucro_fatura?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type faturamentoCreateInput = {
    cod_faturamento: number;
    data_faturamento: Date | string;
    hora_faturamento: string;
    usu_faturamento?: string | null;
    ini_faturamento: Date | string;
    fim_faturamento: Date | string;
    status_faturamento?: string;
    mesano_faturamento?: string | null;
  };

  export type faturamentoUncheckedCreateInput = {
    cod_faturamento: number;
    data_faturamento: Date | string;
    hora_faturamento: string;
    usu_faturamento?: string | null;
    ini_faturamento: Date | string;
    fim_faturamento: Date | string;
    status_faturamento?: string;
    mesano_faturamento?: string | null;
  };

  export type faturamentoUpdateInput = {
    cod_faturamento?: IntFieldUpdateOperationsInput | number;
    data_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_faturamento?: StringFieldUpdateOperationsInput | string;
    usu_faturamento?: NullableStringFieldUpdateOperationsInput | string | null;
    ini_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    fim_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    status_faturamento?: StringFieldUpdateOperationsInput | string;
    mesano_faturamento?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type faturamentoUncheckedUpdateInput = {
    cod_faturamento?: IntFieldUpdateOperationsInput | number;
    data_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_faturamento?: StringFieldUpdateOperationsInput | string;
    usu_faturamento?: NullableStringFieldUpdateOperationsInput | string | null;
    ini_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    fim_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    status_faturamento?: StringFieldUpdateOperationsInput | string;
    mesano_faturamento?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type faturamentoCreateManyInput = {
    cod_faturamento: number;
    data_faturamento: Date | string;
    hora_faturamento: string;
    usu_faturamento?: string | null;
    ini_faturamento: Date | string;
    fim_faturamento: Date | string;
    status_faturamento?: string;
    mesano_faturamento?: string | null;
  };

  export type faturamentoUpdateManyMutationInput = {
    cod_faturamento?: IntFieldUpdateOperationsInput | number;
    data_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_faturamento?: StringFieldUpdateOperationsInput | string;
    usu_faturamento?: NullableStringFieldUpdateOperationsInput | string | null;
    ini_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    fim_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    status_faturamento?: StringFieldUpdateOperationsInput | string;
    mesano_faturamento?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type faturamentoUncheckedUpdateManyInput = {
    cod_faturamento?: IntFieldUpdateOperationsInput | number;
    data_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_faturamento?: StringFieldUpdateOperationsInput | string;
    usu_faturamento?: NullableStringFieldUpdateOperationsInput | string | null;
    ini_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    fim_faturamento?: DateTimeFieldUpdateOperationsInput | Date | string;
    status_faturamento?: StringFieldUpdateOperationsInput | string;
    mesano_faturamento?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
  };

  export type grupoCreateInput = {
    cod_grupo: number;
    desc_grupo: string;
  };

  export type grupoUncheckedCreateInput = {
    cod_grupo: number;
    desc_grupo: string;
  };

  export type grupoUpdateInput = {
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    desc_grupo?: StringFieldUpdateOperationsInput | string;
  };

  export type grupoUncheckedUpdateInput = {
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    desc_grupo?: StringFieldUpdateOperationsInput | string;
  };

  export type grupoCreateManyInput = {
    cod_grupo: number;
    desc_grupo: string;
  };

  export type grupoUpdateManyMutationInput = {
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    desc_grupo?: StringFieldUpdateOperationsInput | string;
  };

  export type grupoUncheckedUpdateManyInput = {
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    desc_grupo?: StringFieldUpdateOperationsInput | string;
  };

  export type histchamadoCreateInput = {
    cod_histchamado: number;
    cod_chamado: number;
    data_histchamado: Date | string;
    hora_histchamado: string;
    desc_histchamado?: string | null;
  };

  export type histchamadoUncheckedCreateInput = {
    cod_histchamado: number;
    cod_chamado: number;
    data_histchamado: Date | string;
    hora_histchamado: string;
    desc_histchamado?: string | null;
  };

  export type histchamadoUpdateInput = {
    cod_histchamado?: IntFieldUpdateOperationsInput | number;
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_histchamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_histchamado?: StringFieldUpdateOperationsInput | string;
    desc_histchamado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type histchamadoUncheckedUpdateInput = {
    cod_histchamado?: IntFieldUpdateOperationsInput | number;
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_histchamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_histchamado?: StringFieldUpdateOperationsInput | string;
    desc_histchamado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type histchamadoCreateManyInput = {
    cod_histchamado: number;
    cod_chamado: number;
    data_histchamado: Date | string;
    hora_histchamado: string;
    desc_histchamado?: string | null;
  };

  export type histchamadoUpdateManyMutationInput = {
    cod_histchamado?: IntFieldUpdateOperationsInput | number;
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_histchamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_histchamado?: StringFieldUpdateOperationsInput | string;
    desc_histchamado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type histchamadoUncheckedUpdateManyInput = {
    cod_histchamado?: IntFieldUpdateOperationsInput | number;
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_histchamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_histchamado?: StringFieldUpdateOperationsInput | string;
    desc_histchamado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type itavaliadoCreateInput = {
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
    avaliado: avaliadoCreateNestedOneWithoutItavaliadoInput;
    itmatriz: itmatrizCreateNestedOneWithoutItavaliadoInput;
  };

  export type itavaliadoUncheckedCreateInput = {
    codaval_itavaliado: number;
    codrec_itavaliado: number;
    codmat_itavaliado: number;
    coditmat_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
  };

  export type itavaliadoUpdateInput = {
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    avaliado?: avaliadoUpdateOneRequiredWithoutItavaliadoNestedInput;
    itmatriz?: itmatrizUpdateOneRequiredWithoutItavaliadoNestedInput;
  };

  export type itavaliadoUncheckedUpdateInput = {
    codaval_itavaliado?: IntFieldUpdateOperationsInput | number;
    codrec_itavaliado?: IntFieldUpdateOperationsInput | number;
    codmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    coditmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type itavaliadoCreateManyInput = {
    codaval_itavaliado: number;
    codrec_itavaliado: number;
    codmat_itavaliado: number;
    coditmat_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
  };

  export type itavaliadoUpdateManyMutationInput = {
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type itavaliadoUncheckedUpdateManyInput = {
    codaval_itavaliado?: IntFieldUpdateOperationsInput | number;
    codrec_itavaliado?: IntFieldUpdateOperationsInput | number;
    codmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    coditmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type itmatrizCreateInput = {
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
    itavaliado?: itavaliadoCreateNestedManyWithoutItmatrizInput;
    matriz: matrizCreateNestedOneWithoutItmatrizInput;
  };

  export type itmatrizUncheckedCreateInput = {
    codmat_itmatriz: number;
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
    itavaliado?: itavaliadoUncheckedCreateNestedManyWithoutItmatrizInput;
  };

  export type itmatrizUpdateInput = {
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    itavaliado?: itavaliadoUpdateManyWithoutItmatrizNestedInput;
    matriz?: matrizUpdateOneRequiredWithoutItmatrizNestedInput;
  };

  export type itmatrizUncheckedUpdateInput = {
    codmat_itmatriz?: IntFieldUpdateOperationsInput | number;
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    itavaliado?: itavaliadoUncheckedUpdateManyWithoutItmatrizNestedInput;
  };

  export type itmatrizCreateManyInput = {
    codmat_itmatriz: number;
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
  };

  export type itmatrizUpdateManyMutationInput = {
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
  };

  export type itmatrizUncheckedUpdateManyInput = {
    codmat_itmatriz?: IntFieldUpdateOperationsInput | number;
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
  };

  export type layoutCreateInput = {
    cod_layout: number;
    tabela_layout?: string | null;
    campo_layout?: string | null;
    posicao_layout?: number | null;
  };

  export type layoutUncheckedCreateInput = {
    cod_layout: number;
    tabela_layout?: string | null;
    campo_layout?: string | null;
    posicao_layout?: number | null;
  };

  export type layoutUpdateInput = {
    cod_layout?: IntFieldUpdateOperationsInput | number;
    tabela_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    campo_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    posicao_layout?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type layoutUncheckedUpdateInput = {
    cod_layout?: IntFieldUpdateOperationsInput | number;
    tabela_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    campo_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    posicao_layout?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type layoutCreateManyInput = {
    cod_layout: number;
    tabela_layout?: string | null;
    campo_layout?: string | null;
    posicao_layout?: number | null;
  };

  export type layoutUpdateManyMutationInput = {
    cod_layout?: IntFieldUpdateOperationsInput | number;
    tabela_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    campo_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    posicao_layout?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type layoutUncheckedUpdateManyInput = {
    cod_layout?: IntFieldUpdateOperationsInput | number;
    tabela_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    campo_layout?: NullableStringFieldUpdateOperationsInput | string | null;
    posicao_layout?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type listaCreateInput = {
    cod_lista: number;
    cod_grupo: number;
    cod_status?: number;
    cgccpf_lista: string;
    id_lista?: string | null;
    nome_lista: string;
    end_lista?: string | null;
    num_lista?: string | null;
    comp_lista?: string | null;
    cep_lista?: string | null;
    bairro_lista?: string | null;
    cidade_lista?: string | null;
    uf_lista?: string | null;
    email_lista?: string | null;
    dtcontactar_lista: Date | string;
    dtcad_lista: Date | string;
    obs_lista?: Uint8Array | null;
  };

  export type listaUncheckedCreateInput = {
    cod_lista: number;
    cod_grupo: number;
    cod_status?: number;
    cgccpf_lista: string;
    id_lista?: string | null;
    nome_lista: string;
    end_lista?: string | null;
    num_lista?: string | null;
    comp_lista?: string | null;
    cep_lista?: string | null;
    bairro_lista?: string | null;
    cidade_lista?: string | null;
    uf_lista?: string | null;
    email_lista?: string | null;
    dtcontactar_lista: Date | string;
    dtcad_lista: Date | string;
    obs_lista?: Uint8Array | null;
  };

  export type listaUpdateInput = {
    cod_lista?: IntFieldUpdateOperationsInput | number;
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    cod_status?: IntFieldUpdateOperationsInput | number;
    cgccpf_lista?: StringFieldUpdateOperationsInput | string;
    id_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_lista?: StringFieldUpdateOperationsInput | string;
    end_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    num_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    comp_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cidade_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    email_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcontactar_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    dtcad_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    obs_lista?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type listaUncheckedUpdateInput = {
    cod_lista?: IntFieldUpdateOperationsInput | number;
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    cod_status?: IntFieldUpdateOperationsInput | number;
    cgccpf_lista?: StringFieldUpdateOperationsInput | string;
    id_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_lista?: StringFieldUpdateOperationsInput | string;
    end_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    num_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    comp_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cidade_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    email_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcontactar_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    dtcad_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    obs_lista?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type listaCreateManyInput = {
    cod_lista: number;
    cod_grupo: number;
    cod_status?: number;
    cgccpf_lista: string;
    id_lista?: string | null;
    nome_lista: string;
    end_lista?: string | null;
    num_lista?: string | null;
    comp_lista?: string | null;
    cep_lista?: string | null;
    bairro_lista?: string | null;
    cidade_lista?: string | null;
    uf_lista?: string | null;
    email_lista?: string | null;
    dtcontactar_lista: Date | string;
    dtcad_lista: Date | string;
    obs_lista?: Uint8Array | null;
  };

  export type listaUpdateManyMutationInput = {
    cod_lista?: IntFieldUpdateOperationsInput | number;
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    cod_status?: IntFieldUpdateOperationsInput | number;
    cgccpf_lista?: StringFieldUpdateOperationsInput | string;
    id_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_lista?: StringFieldUpdateOperationsInput | string;
    end_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    num_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    comp_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cidade_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    email_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcontactar_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    dtcad_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    obs_lista?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type listaUncheckedUpdateManyInput = {
    cod_lista?: IntFieldUpdateOperationsInput | number;
    cod_grupo?: IntFieldUpdateOperationsInput | number;
    cod_status?: IntFieldUpdateOperationsInput | number;
    cgccpf_lista?: StringFieldUpdateOperationsInput | string;
    id_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    nome_lista?: StringFieldUpdateOperationsInput | string;
    end_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    num_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    comp_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    cidade_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    email_lista?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcontactar_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    dtcad_lista?: DateTimeFieldUpdateOperationsInput | Date | string;
    obs_lista?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type matrizCreateInput = {
    cod_matriz: number;
    desc_matriz: string;
    status_matriz: string;
    itmatriz?: itmatrizCreateNestedManyWithoutMatrizInput;
  };

  export type matrizUncheckedCreateInput = {
    cod_matriz: number;
    desc_matriz: string;
    status_matriz: string;
    itmatriz?: itmatrizUncheckedCreateNestedManyWithoutMatrizInput;
  };

  export type matrizUpdateInput = {
    cod_matriz?: IntFieldUpdateOperationsInput | number;
    desc_matriz?: StringFieldUpdateOperationsInput | string;
    status_matriz?: StringFieldUpdateOperationsInput | string;
    itmatriz?: itmatrizUpdateManyWithoutMatrizNestedInput;
  };

  export type matrizUncheckedUpdateInput = {
    cod_matriz?: IntFieldUpdateOperationsInput | number;
    desc_matriz?: StringFieldUpdateOperationsInput | string;
    status_matriz?: StringFieldUpdateOperationsInput | string;
    itmatriz?: itmatrizUncheckedUpdateManyWithoutMatrizNestedInput;
  };

  export type matrizCreateManyInput = {
    cod_matriz: number;
    desc_matriz: string;
    status_matriz: string;
  };

  export type matrizUpdateManyMutationInput = {
    cod_matriz?: IntFieldUpdateOperationsInput | number;
    desc_matriz?: StringFieldUpdateOperationsInput | string;
    status_matriz?: StringFieldUpdateOperationsInput | string;
  };

  export type matrizUncheckedUpdateManyInput = {
    cod_matriz?: IntFieldUpdateOperationsInput | number;
    desc_matriz?: StringFieldUpdateOperationsInput | string;
    status_matriz?: StringFieldUpdateOperationsInput | string;
  };

  export type mensagemCreateInput = {
    cod_mensagem: number;
    desc_mensagem: string;
  };

  export type mensagemUncheckedCreateInput = {
    cod_mensagem: number;
    desc_mensagem: string;
  };

  export type mensagemUpdateInput = {
    cod_mensagem?: IntFieldUpdateOperationsInput | number;
    desc_mensagem?: StringFieldUpdateOperationsInput | string;
  };

  export type mensagemUncheckedUpdateInput = {
    cod_mensagem?: IntFieldUpdateOperationsInput | number;
    desc_mensagem?: StringFieldUpdateOperationsInput | string;
  };

  export type mensagemCreateManyInput = {
    cod_mensagem: number;
    desc_mensagem: string;
  };

  export type mensagemUpdateManyMutationInput = {
    cod_mensagem?: IntFieldUpdateOperationsInput | number;
    desc_mensagem?: StringFieldUpdateOperationsInput | string;
  };

  export type mensagemUncheckedUpdateManyInput = {
    cod_mensagem?: IntFieldUpdateOperationsInput | number;
    desc_mensagem?: StringFieldUpdateOperationsInput | string;
  };

  export type metaCreateInput = {
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
    area: areaCreateNestedOneWithoutMetaInput;
    fase: faseCreateNestedOneWithoutMetaInput;
    projeto: projetoCreateNestedOneWithoutMetaInput;
  };

  export type metaUncheckedCreateInput = {
    codproj_meta: number;
    codarea_meta: number;
    codfase_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type metaUpdateInput = {
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    area?: areaUpdateOneRequiredWithoutMetaNestedInput;
    fase?: faseUpdateOneRequiredWithoutMetaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutMetaNestedInput;
  };

  export type metaUncheckedUpdateInput = {
    codproj_meta?: IntFieldUpdateOperationsInput | number;
    codarea_meta?: IntFieldUpdateOperationsInput | number;
    codfase_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type metaCreateManyInput = {
    codproj_meta: number;
    codarea_meta: number;
    codfase_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type metaUpdateManyMutationInput = {
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type metaUncheckedUpdateManyInput = {
    codproj_meta?: IntFieldUpdateOperationsInput | number;
    codarea_meta?: IntFieldUpdateOperationsInput | number;
    codfase_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type modulo_sistemaCreateInput = {
    cod_modulo: number;
    desc_modulo: string;
    acesso_sistema?: acesso_sistemaCreateNestedManyWithoutModulo_sistemaInput;
    tela_sistema?: tela_sistemaCreateNestedManyWithoutModulo_sistemaInput;
  };

  export type modulo_sistemaUncheckedCreateInput = {
    cod_modulo: number;
    desc_modulo: string;
    acesso_sistema?: acesso_sistemaUncheckedCreateNestedManyWithoutModulo_sistemaInput;
    tela_sistema?: tela_sistemaUncheckedCreateNestedManyWithoutModulo_sistemaInput;
  };

  export type modulo_sistemaUpdateInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUpdateManyWithoutModulo_sistemaNestedInput;
    tela_sistema?: tela_sistemaUpdateManyWithoutModulo_sistemaNestedInput;
  };

  export type modulo_sistemaUncheckedUpdateInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUncheckedUpdateManyWithoutModulo_sistemaNestedInput;
    tela_sistema?: tela_sistemaUncheckedUpdateManyWithoutModulo_sistemaNestedInput;
  };

  export type modulo_sistemaCreateManyInput = {
    cod_modulo: number;
    desc_modulo: string;
  };

  export type modulo_sistemaUpdateManyMutationInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
  };

  export type modulo_sistemaUncheckedUpdateManyInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
  };

  export type nfseCreateInput = {
    cod_nfse: number;
    num_nfse?: string | null;
    dtemissao_nfse: Date | string;
    hremissao_nfse: string;
    cod_empresa: number;
    cod_cliente: number;
    discr_nfse?: Uint8Array | null;
    cod_ctiss: number;
    natoper_nfse: number;
    regtrib_nfse: number;
    vrtot_nfse?: Decimal | DecimalJsLike | number | string;
    vrded_nfse?: Decimal | DecimalJsLike | number | string;
    vrdesc1_nfse?: Decimal | DecimalJsLike | number | string;
    vrdesc2_nfse?: Decimal | DecimalJsLike | number | string;
    vrir_nfse?: Decimal | DecimalJsLike | number | string;
    vrpis_nfse?: Decimal | DecimalJsLike | number | string;
    vrcofins_nfse?: Decimal | DecimalJsLike | number | string;
    vrcsll_nfse?: Decimal | DecimalJsLike | number | string;
    vrout_nfse?: Decimal | DecimalJsLike | number | string;
    issret_nfse?: number;
    aliqiss_nfse?: Decimal | DecimalJsLike | number | string;
    vrinss_nfse?: Decimal | DecimalJsLike | number | string;
    doc_nfse?: string | null;
    aliqissret_nfse?: Decimal | DecimalJsLike | number | string;
    xml_nfse?: Uint8Array | null;
    codver_nfse?: string | null;
    logtrans_nfse?: Uint8Array | null;
    logcan_nfse?: Uint8Array | null;
    xmlformat_nfse?: Uint8Array | null;
    prot_nfse?: string | null;
    chvcan_nfse?: string | null;
    dtcanc_nfse?: string | null;
    tipoper_nfse: number;
    opsimnac_nfse: number;
    csll_nfse: Decimal | DecimalJsLike | number | string;
    pis_nfse: Decimal | DecimalJsLike | number | string;
    cofins_nfse: Decimal | DecimalJsLike | number | string;
    irrf_nfse: Decimal | DecimalJsLike | number | string;
  };

  export type nfseUncheckedCreateInput = {
    cod_nfse: number;
    num_nfse?: string | null;
    dtemissao_nfse: Date | string;
    hremissao_nfse: string;
    cod_empresa: number;
    cod_cliente: number;
    discr_nfse?: Uint8Array | null;
    cod_ctiss: number;
    natoper_nfse: number;
    regtrib_nfse: number;
    vrtot_nfse?: Decimal | DecimalJsLike | number | string;
    vrded_nfse?: Decimal | DecimalJsLike | number | string;
    vrdesc1_nfse?: Decimal | DecimalJsLike | number | string;
    vrdesc2_nfse?: Decimal | DecimalJsLike | number | string;
    vrir_nfse?: Decimal | DecimalJsLike | number | string;
    vrpis_nfse?: Decimal | DecimalJsLike | number | string;
    vrcofins_nfse?: Decimal | DecimalJsLike | number | string;
    vrcsll_nfse?: Decimal | DecimalJsLike | number | string;
    vrout_nfse?: Decimal | DecimalJsLike | number | string;
    issret_nfse?: number;
    aliqiss_nfse?: Decimal | DecimalJsLike | number | string;
    vrinss_nfse?: Decimal | DecimalJsLike | number | string;
    doc_nfse?: string | null;
    aliqissret_nfse?: Decimal | DecimalJsLike | number | string;
    xml_nfse?: Uint8Array | null;
    codver_nfse?: string | null;
    logtrans_nfse?: Uint8Array | null;
    logcan_nfse?: Uint8Array | null;
    xmlformat_nfse?: Uint8Array | null;
    prot_nfse?: string | null;
    chvcan_nfse?: string | null;
    dtcanc_nfse?: string | null;
    tipoper_nfse: number;
    opsimnac_nfse: number;
    csll_nfse: Decimal | DecimalJsLike | number | string;
    pis_nfse: Decimal | DecimalJsLike | number | string;
    cofins_nfse: Decimal | DecimalJsLike | number | string;
    irrf_nfse: Decimal | DecimalJsLike | number | string;
  };

  export type nfseUpdateInput = {
    cod_nfse?: IntFieldUpdateOperationsInput | number;
    num_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtemissao_nfse?: DateTimeFieldUpdateOperationsInput | Date | string;
    hremissao_nfse?: StringFieldUpdateOperationsInput | string;
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    discr_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    natoper_nfse?: IntFieldUpdateOperationsInput | number;
    regtrib_nfse?: IntFieldUpdateOperationsInput | number;
    vrtot_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrded_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc1_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc2_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrir_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrpis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcsll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrout_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    issret_nfse?: IntFieldUpdateOperationsInput | number;
    aliqiss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrinss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    doc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    aliqissret_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    xml_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    codver_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    logtrans_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    logcan_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    xmlformat_nfse?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    prot_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    chvcan_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcanc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    tipoper_nfse?: IntFieldUpdateOperationsInput | number;
    opsimnac_nfse?: IntFieldUpdateOperationsInput | number;
    csll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nfseUncheckedUpdateInput = {
    cod_nfse?: IntFieldUpdateOperationsInput | number;
    num_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtemissao_nfse?: DateTimeFieldUpdateOperationsInput | Date | string;
    hremissao_nfse?: StringFieldUpdateOperationsInput | string;
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    discr_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    natoper_nfse?: IntFieldUpdateOperationsInput | number;
    regtrib_nfse?: IntFieldUpdateOperationsInput | number;
    vrtot_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrded_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc1_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc2_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrir_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrpis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcsll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrout_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    issret_nfse?: IntFieldUpdateOperationsInput | number;
    aliqiss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrinss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    doc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    aliqissret_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    xml_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    codver_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    logtrans_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    logcan_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    xmlformat_nfse?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    prot_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    chvcan_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcanc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    tipoper_nfse?: IntFieldUpdateOperationsInput | number;
    opsimnac_nfse?: IntFieldUpdateOperationsInput | number;
    csll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nfseCreateManyInput = {
    cod_nfse: number;
    num_nfse?: string | null;
    dtemissao_nfse: Date | string;
    hremissao_nfse: string;
    cod_empresa: number;
    cod_cliente: number;
    discr_nfse?: Uint8Array | null;
    cod_ctiss: number;
    natoper_nfse: number;
    regtrib_nfse: number;
    vrtot_nfse?: Decimal | DecimalJsLike | number | string;
    vrded_nfse?: Decimal | DecimalJsLike | number | string;
    vrdesc1_nfse?: Decimal | DecimalJsLike | number | string;
    vrdesc2_nfse?: Decimal | DecimalJsLike | number | string;
    vrir_nfse?: Decimal | DecimalJsLike | number | string;
    vrpis_nfse?: Decimal | DecimalJsLike | number | string;
    vrcofins_nfse?: Decimal | DecimalJsLike | number | string;
    vrcsll_nfse?: Decimal | DecimalJsLike | number | string;
    vrout_nfse?: Decimal | DecimalJsLike | number | string;
    issret_nfse?: number;
    aliqiss_nfse?: Decimal | DecimalJsLike | number | string;
    vrinss_nfse?: Decimal | DecimalJsLike | number | string;
    doc_nfse?: string | null;
    aliqissret_nfse?: Decimal | DecimalJsLike | number | string;
    xml_nfse?: Uint8Array | null;
    codver_nfse?: string | null;
    logtrans_nfse?: Uint8Array | null;
    logcan_nfse?: Uint8Array | null;
    xmlformat_nfse?: Uint8Array | null;
    prot_nfse?: string | null;
    chvcan_nfse?: string | null;
    dtcanc_nfse?: string | null;
    tipoper_nfse: number;
    opsimnac_nfse: number;
    csll_nfse: Decimal | DecimalJsLike | number | string;
    pis_nfse: Decimal | DecimalJsLike | number | string;
    cofins_nfse: Decimal | DecimalJsLike | number | string;
    irrf_nfse: Decimal | DecimalJsLike | number | string;
  };

  export type nfseUpdateManyMutationInput = {
    cod_nfse?: IntFieldUpdateOperationsInput | number;
    num_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtemissao_nfse?: DateTimeFieldUpdateOperationsInput | Date | string;
    hremissao_nfse?: StringFieldUpdateOperationsInput | string;
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    discr_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    natoper_nfse?: IntFieldUpdateOperationsInput | number;
    regtrib_nfse?: IntFieldUpdateOperationsInput | number;
    vrtot_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrded_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc1_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc2_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrir_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrpis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcsll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrout_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    issret_nfse?: IntFieldUpdateOperationsInput | number;
    aliqiss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrinss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    doc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    aliqissret_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    xml_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    codver_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    logtrans_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    logcan_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    xmlformat_nfse?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    prot_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    chvcan_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcanc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    tipoper_nfse?: IntFieldUpdateOperationsInput | number;
    opsimnac_nfse?: IntFieldUpdateOperationsInput | number;
    csll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nfseUncheckedUpdateManyInput = {
    cod_nfse?: IntFieldUpdateOperationsInput | number;
    num_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtemissao_nfse?: DateTimeFieldUpdateOperationsInput | Date | string;
    hremissao_nfse?: StringFieldUpdateOperationsInput | string;
    cod_empresa?: IntFieldUpdateOperationsInput | number;
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    discr_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_ctiss?: IntFieldUpdateOperationsInput | number;
    natoper_nfse?: IntFieldUpdateOperationsInput | number;
    regtrib_nfse?: IntFieldUpdateOperationsInput | number;
    vrtot_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrded_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc1_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrdesc2_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrir_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrpis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrcsll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrout_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    issret_nfse?: IntFieldUpdateOperationsInput | number;
    aliqiss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrinss_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    doc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    aliqissret_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    xml_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    codver_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    logtrans_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    logcan_nfse?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    xmlformat_nfse?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    prot_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    chvcan_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    dtcanc_nfse?: NullableStringFieldUpdateOperationsInput | string | null;
    tipoper_nfse?: IntFieldUpdateOperationsInput | number;
    opsimnac_nfse?: IntFieldUpdateOperationsInput | number;
    csll_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    pis_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    cofins_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    irrf_nfse?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nivelCreateInput = {
    cod_nivel: number;
    nome_nivel: string;
    perc_nivel?: Decimal | DecimalJsLike | number | string;
    recurso?: recursoCreateNestedManyWithoutNivelInput;
  };

  export type nivelUncheckedCreateInput = {
    cod_nivel: number;
    nome_nivel: string;
    perc_nivel?: Decimal | DecimalJsLike | number | string;
    recurso?: recursoUncheckedCreateNestedManyWithoutNivelInput;
  };

  export type nivelUpdateInput = {
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    nome_nivel?: StringFieldUpdateOperationsInput | string;
    perc_nivel?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    recurso?: recursoUpdateManyWithoutNivelNestedInput;
  };

  export type nivelUncheckedUpdateInput = {
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    nome_nivel?: StringFieldUpdateOperationsInput | string;
    perc_nivel?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    recurso?: recursoUncheckedUpdateManyWithoutNivelNestedInput;
  };

  export type nivelCreateManyInput = {
    cod_nivel: number;
    nome_nivel: string;
    perc_nivel?: Decimal | DecimalJsLike | number | string;
  };

  export type nivelUpdateManyMutationInput = {
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    nome_nivel?: StringFieldUpdateOperationsInput | string;
    perc_nivel?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nivelUncheckedUpdateManyInput = {
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    nome_nivel?: StringFieldUpdateOperationsInput | string;
    perc_nivel?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type osCreateInput = {
    cod_os: number;
    dtini_os: Date | string;
    hrini_os: string;
    hrfim_os: string;
    obs_os?: string | null;
    status_os?: number;
    produtivo_os?: string;
    codrec_os: number;
    produtivo2_os?: string;
    respcli_os: string;
    remdes_os?: string;
    abono_os?: string;
    desloc_os?: string | null;
    obs?: Uint8Array | null;
    dtinc_os: Date | string;
    faturado_os?: string;
    perc_os?: number;
    cod_faturamento?: number | null;
    comp_os?: string | null;
    valid_os?: string;
    vrhr_os?: Decimal | DecimalJsLike | number | string;
    num_os?: string | null;
    chamado_os?: string | null;
    tarefa: tarefaCreateNestedOneWithoutOsInput;
  };

  export type osUncheckedCreateInput = {
    cod_os: number;
    codtrf_os: number;
    dtini_os: Date | string;
    hrini_os: string;
    hrfim_os: string;
    obs_os?: string | null;
    status_os?: number;
    produtivo_os?: string;
    codrec_os: number;
    produtivo2_os?: string;
    respcli_os: string;
    remdes_os?: string;
    abono_os?: string;
    desloc_os?: string | null;
    obs?: Uint8Array | null;
    dtinc_os: Date | string;
    faturado_os?: string;
    perc_os?: number;
    cod_faturamento?: number | null;
    comp_os?: string | null;
    valid_os?: string;
    vrhr_os?: Decimal | DecimalJsLike | number | string;
    num_os?: string | null;
    chamado_os?: string | null;
  };

  export type osUpdateInput = {
    cod_os?: IntFieldUpdateOperationsInput | number;
    dtini_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_os?: StringFieldUpdateOperationsInput | string;
    hrfim_os?: StringFieldUpdateOperationsInput | string;
    obs_os?: NullableStringFieldUpdateOperationsInput | string | null;
    status_os?: IntFieldUpdateOperationsInput | number;
    produtivo_os?: StringFieldUpdateOperationsInput | string;
    codrec_os?: IntFieldUpdateOperationsInput | number;
    produtivo2_os?: StringFieldUpdateOperationsInput | string;
    respcli_os?: StringFieldUpdateOperationsInput | string;
    remdes_os?: StringFieldUpdateOperationsInput | string;
    abono_os?: StringFieldUpdateOperationsInput | string;
    desloc_os?: NullableStringFieldUpdateOperationsInput | string | null;
    obs?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtinc_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    faturado_os?: StringFieldUpdateOperationsInput | string;
    perc_os?: IntFieldUpdateOperationsInput | number;
    cod_faturamento?: NullableIntFieldUpdateOperationsInput | number | null;
    comp_os?: NullableStringFieldUpdateOperationsInput | string | null;
    valid_os?: StringFieldUpdateOperationsInput | string;
    vrhr_os?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: NullableStringFieldUpdateOperationsInput | string | null;
    chamado_os?: NullableStringFieldUpdateOperationsInput | string | null;
    tarefa?: tarefaUpdateOneRequiredWithoutOsNestedInput;
  };

  export type osUncheckedUpdateInput = {
    cod_os?: IntFieldUpdateOperationsInput | number;
    codtrf_os?: IntFieldUpdateOperationsInput | number;
    dtini_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_os?: StringFieldUpdateOperationsInput | string;
    hrfim_os?: StringFieldUpdateOperationsInput | string;
    obs_os?: NullableStringFieldUpdateOperationsInput | string | null;
    status_os?: IntFieldUpdateOperationsInput | number;
    produtivo_os?: StringFieldUpdateOperationsInput | string;
    codrec_os?: IntFieldUpdateOperationsInput | number;
    produtivo2_os?: StringFieldUpdateOperationsInput | string;
    respcli_os?: StringFieldUpdateOperationsInput | string;
    remdes_os?: StringFieldUpdateOperationsInput | string;
    abono_os?: StringFieldUpdateOperationsInput | string;
    desloc_os?: NullableStringFieldUpdateOperationsInput | string | null;
    obs?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtinc_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    faturado_os?: StringFieldUpdateOperationsInput | string;
    perc_os?: IntFieldUpdateOperationsInput | number;
    cod_faturamento?: NullableIntFieldUpdateOperationsInput | number | null;
    comp_os?: NullableStringFieldUpdateOperationsInput | string | null;
    valid_os?: StringFieldUpdateOperationsInput | string;
    vrhr_os?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: NullableStringFieldUpdateOperationsInput | string | null;
    chamado_os?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type osCreateManyInput = {
    cod_os: number;
    codtrf_os: number;
    dtini_os: Date | string;
    hrini_os: string;
    hrfim_os: string;
    obs_os?: string | null;
    status_os?: number;
    produtivo_os?: string;
    codrec_os: number;
    produtivo2_os?: string;
    respcli_os: string;
    remdes_os?: string;
    abono_os?: string;
    desloc_os?: string | null;
    obs?: Uint8Array | null;
    dtinc_os: Date | string;
    faturado_os?: string;
    perc_os?: number;
    cod_faturamento?: number | null;
    comp_os?: string | null;
    valid_os?: string;
    vrhr_os?: Decimal | DecimalJsLike | number | string;
    num_os?: string | null;
    chamado_os?: string | null;
  };

  export type osUpdateManyMutationInput = {
    cod_os?: IntFieldUpdateOperationsInput | number;
    dtini_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_os?: StringFieldUpdateOperationsInput | string;
    hrfim_os?: StringFieldUpdateOperationsInput | string;
    obs_os?: NullableStringFieldUpdateOperationsInput | string | null;
    status_os?: IntFieldUpdateOperationsInput | number;
    produtivo_os?: StringFieldUpdateOperationsInput | string;
    codrec_os?: IntFieldUpdateOperationsInput | number;
    produtivo2_os?: StringFieldUpdateOperationsInput | string;
    respcli_os?: StringFieldUpdateOperationsInput | string;
    remdes_os?: StringFieldUpdateOperationsInput | string;
    abono_os?: StringFieldUpdateOperationsInput | string;
    desloc_os?: NullableStringFieldUpdateOperationsInput | string | null;
    obs?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtinc_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    faturado_os?: StringFieldUpdateOperationsInput | string;
    perc_os?: IntFieldUpdateOperationsInput | number;
    cod_faturamento?: NullableIntFieldUpdateOperationsInput | number | null;
    comp_os?: NullableStringFieldUpdateOperationsInput | string | null;
    valid_os?: StringFieldUpdateOperationsInput | string;
    vrhr_os?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: NullableStringFieldUpdateOperationsInput | string | null;
    chamado_os?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type osUncheckedUpdateManyInput = {
    cod_os?: IntFieldUpdateOperationsInput | number;
    codtrf_os?: IntFieldUpdateOperationsInput | number;
    dtini_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_os?: StringFieldUpdateOperationsInput | string;
    hrfim_os?: StringFieldUpdateOperationsInput | string;
    obs_os?: NullableStringFieldUpdateOperationsInput | string | null;
    status_os?: IntFieldUpdateOperationsInput | number;
    produtivo_os?: StringFieldUpdateOperationsInput | string;
    codrec_os?: IntFieldUpdateOperationsInput | number;
    produtivo2_os?: StringFieldUpdateOperationsInput | string;
    respcli_os?: StringFieldUpdateOperationsInput | string;
    remdes_os?: StringFieldUpdateOperationsInput | string;
    abono_os?: StringFieldUpdateOperationsInput | string;
    desloc_os?: NullableStringFieldUpdateOperationsInput | string | null;
    obs?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtinc_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    faturado_os?: StringFieldUpdateOperationsInput | string;
    perc_os?: IntFieldUpdateOperationsInput | number;
    cod_faturamento?: NullableIntFieldUpdateOperationsInput | number | null;
    comp_os?: NullableStringFieldUpdateOperationsInput | string | null;
    valid_os?: StringFieldUpdateOperationsInput | string;
    vrhr_os?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: NullableStringFieldUpdateOperationsInput | string | null;
    chamado_os?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parametrosCreateInput = {
    cod_parametro: number;
    descr_parametro: string;
    valor_parametro?: string | null;
  };

  export type parametrosUncheckedCreateInput = {
    cod_parametro: number;
    descr_parametro: string;
    valor_parametro?: string | null;
  };

  export type parametrosUpdateInput = {
    cod_parametro?: IntFieldUpdateOperationsInput | number;
    descr_parametro?: StringFieldUpdateOperationsInput | string;
    valor_parametro?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parametrosUncheckedUpdateInput = {
    cod_parametro?: IntFieldUpdateOperationsInput | number;
    descr_parametro?: StringFieldUpdateOperationsInput | string;
    valor_parametro?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parametrosCreateManyInput = {
    cod_parametro: number;
    descr_parametro: string;
    valor_parametro?: string | null;
  };

  export type parametrosUpdateManyMutationInput = {
    cod_parametro?: IntFieldUpdateOperationsInput | number;
    descr_parametro?: StringFieldUpdateOperationsInput | string;
    valor_parametro?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parametrosUncheckedUpdateManyInput = {
    cod_parametro?: IntFieldUpdateOperationsInput | number;
    descr_parametro?: StringFieldUpdateOperationsInput | string;
    valor_parametro?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parcelaCreateInput = {
    cod_parcela: number;
    cod_lista: number;
    data_parcela?: string | null;
    venc_parcela?: string | null;
    pag_parcela?: string | null;
    valor_parcela?: Decimal | DecimalJsLike | number | string | null;
    juros_parcela?: Decimal | DecimalJsLike | number | string | null;
    multa_parcela?: Decimal | DecimalJsLike | number | string | null;
    desconto_parcela?: Decimal | DecimalJsLike | number | string | null;
    status_parcela?: string;
    id_parcela?: string | null;
  };

  export type parcelaUncheckedCreateInput = {
    cod_parcela: number;
    cod_lista: number;
    data_parcela?: string | null;
    venc_parcela?: string | null;
    pag_parcela?: string | null;
    valor_parcela?: Decimal | DecimalJsLike | number | string | null;
    juros_parcela?: Decimal | DecimalJsLike | number | string | null;
    multa_parcela?: Decimal | DecimalJsLike | number | string | null;
    desconto_parcela?: Decimal | DecimalJsLike | number | string | null;
    status_parcela?: string;
    id_parcela?: string | null;
  };

  export type parcelaUpdateInput = {
    cod_parcela?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    data_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    venc_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    pag_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    valor_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    juros_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    multa_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desconto_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    status_parcela?: StringFieldUpdateOperationsInput | string;
    id_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parcelaUncheckedUpdateInput = {
    cod_parcela?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    data_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    venc_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    pag_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    valor_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    juros_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    multa_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desconto_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    status_parcela?: StringFieldUpdateOperationsInput | string;
    id_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parcelaCreateManyInput = {
    cod_parcela: number;
    cod_lista: number;
    data_parcela?: string | null;
    venc_parcela?: string | null;
    pag_parcela?: string | null;
    valor_parcela?: Decimal | DecimalJsLike | number | string | null;
    juros_parcela?: Decimal | DecimalJsLike | number | string | null;
    multa_parcela?: Decimal | DecimalJsLike | number | string | null;
    desconto_parcela?: Decimal | DecimalJsLike | number | string | null;
    status_parcela?: string;
    id_parcela?: string | null;
  };

  export type parcelaUpdateManyMutationInput = {
    cod_parcela?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    data_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    venc_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    pag_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    valor_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    juros_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    multa_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desconto_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    status_parcela?: StringFieldUpdateOperationsInput | string;
    id_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type parcelaUncheckedUpdateManyInput = {
    cod_parcela?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    data_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    venc_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    pag_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
    valor_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    juros_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    multa_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desconto_parcela?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    status_parcela?: StringFieldUpdateOperationsInput | string;
    id_parcela?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type pautaCreateInput = {
    cod_pauta: number;
    cod_recurso: number;
    data_pauta: Date | string;
    prazo_pauta: Date | string;
    concl_pauta?: Date | string | null;
    desc_pauta?: string | null;
    obs_pauta?: Uint8Array | null;
  };

  export type pautaUncheckedCreateInput = {
    cod_pauta: number;
    cod_recurso: number;
    data_pauta: Date | string;
    prazo_pauta: Date | string;
    concl_pauta?: Date | string | null;
    desc_pauta?: string | null;
    obs_pauta?: Uint8Array | null;
  };

  export type pautaUpdateInput = {
    cod_pauta?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    data_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    prazo_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    concl_pauta?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    desc_pauta?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_pauta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type pautaUncheckedUpdateInput = {
    cod_pauta?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    data_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    prazo_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    concl_pauta?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    desc_pauta?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_pauta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type pautaCreateManyInput = {
    cod_pauta: number;
    cod_recurso: number;
    data_pauta: Date | string;
    prazo_pauta: Date | string;
    concl_pauta?: Date | string | null;
    desc_pauta?: string | null;
    obs_pauta?: Uint8Array | null;
  };

  export type pautaUpdateManyMutationInput = {
    cod_pauta?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    data_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    prazo_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    concl_pauta?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    desc_pauta?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_pauta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type pautaUncheckedUpdateManyInput = {
    cod_pauta?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    data_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    prazo_pauta?: DateTimeFieldUpdateOperationsInput | Date | string;
    concl_pauta?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    desc_pauta?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_pauta?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
  };

  export type pontoCreateInput = {
    cod_ponto: number;
    entrada_ponto: Date | string;
    saida_ponto?: Date | string | null;
    cod_recurso: number;
  };

  export type pontoUncheckedCreateInput = {
    cod_ponto: number;
    entrada_ponto: Date | string;
    saida_ponto?: Date | string | null;
    cod_recurso: number;
  };

  export type pontoUpdateInput = {
    cod_ponto?: IntFieldUpdateOperationsInput | number;
    entrada_ponto?: DateTimeFieldUpdateOperationsInput | Date | string;
    saida_ponto?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
  };

  export type pontoUncheckedUpdateInput = {
    cod_ponto?: IntFieldUpdateOperationsInput | number;
    entrada_ponto?: DateTimeFieldUpdateOperationsInput | Date | string;
    saida_ponto?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
  };

  export type pontoCreateManyInput = {
    cod_ponto: number;
    entrada_ponto: Date | string;
    saida_ponto?: Date | string | null;
    cod_recurso: number;
  };

  export type pontoUpdateManyMutationInput = {
    cod_ponto?: IntFieldUpdateOperationsInput | number;
    entrada_ponto?: DateTimeFieldUpdateOperationsInput | Date | string;
    saida_ponto?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
  };

  export type pontoUncheckedUpdateManyInput = {
    cod_ponto?: IntFieldUpdateOperationsInput | number;
    entrada_ponto?: DateTimeFieldUpdateOperationsInput | Date | string;
    saida_ponto?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
  };

  export type projetoCreateInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoCreateNestedManyWithoutProjetoInput;
    meta?: metaCreateNestedManyWithoutProjetoInput;
    cliente: clienteCreateNestedOneWithoutProjetoInput;
    recurso: recursoCreateNestedOneWithoutProjetoInput;
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput;
    valor?: valorCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUncheckedCreateInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoUncheckedCreateNestedManyWithoutProjetoInput;
    meta?: metaUncheckedCreateNestedManyWithoutProjetoInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput;
    valor?: valorUncheckedCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUpdateInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUpdateManyWithoutProjetoNestedInput;
    meta?: metaUpdateManyWithoutProjetoNestedInput;
    cliente?: clienteUpdateOneRequiredWithoutProjetoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutProjetoNestedInput;
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput;
    valor?: valorUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUncheckedUpdateManyWithoutProjetoNestedInput;
    meta?: metaUncheckedUpdateManyWithoutProjetoNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput;
    valor?: valorUncheckedUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoCreateManyInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
  };

  export type projetoUpdateManyMutationInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
  };

  export type projetoUncheckedUpdateManyInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
  };

  export type recursoCreateInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
    projeto?: projetoCreateNestedManyWithoutRecursoInput;
    nivel: nivelCreateNestedOneWithoutRecursoInput;
    usuario: usuarioCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUncheckedCreateInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUpdateInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUpdateManyWithoutRecursoNestedInput;
    nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoCreateManyInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
  };

  export type recursoUpdateManyMutationInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type recursoUncheckedUpdateManyInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type resconCreateInput = {
    cod_rescon: number;
    cod_fatura: number;
    cod_recurso: number;
    hrfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    hrnfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    vrfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    vrnfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    realizado_rescon?: Decimal | DecimalJsLike | number | string | null;
    disponivel_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc1_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc2_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc3_rescon?: Decimal | DecimalJsLike | number | string | null;
    custo_rescon?: Decimal | DecimalJsLike | number | string | null;
    contrib_rescon?: Decimal | DecimalJsLike | number | string | null;
    perccontrib_rescon?: Decimal | DecimalJsLike | number | string | null;
    hrbase_rescon?: Decimal | DecimalJsLike | number | string | null;
    mo_rescon?: Decimal | DecimalJsLike | number | string | null;
    desp_rescon?: Decimal | DecimalJsLike | number | string | null;
  };

  export type resconUncheckedCreateInput = {
    cod_rescon: number;
    cod_fatura: number;
    cod_recurso: number;
    hrfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    hrnfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    vrfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    vrnfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    realizado_rescon?: Decimal | DecimalJsLike | number | string | null;
    disponivel_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc1_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc2_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc3_rescon?: Decimal | DecimalJsLike | number | string | null;
    custo_rescon?: Decimal | DecimalJsLike | number | string | null;
    contrib_rescon?: Decimal | DecimalJsLike | number | string | null;
    perccontrib_rescon?: Decimal | DecimalJsLike | number | string | null;
    hrbase_rescon?: Decimal | DecimalJsLike | number | string | null;
    mo_rescon?: Decimal | DecimalJsLike | number | string | null;
    desp_rescon?: Decimal | DecimalJsLike | number | string | null;
  };

  export type resconUpdateInput = {
    cod_rescon?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    realizado_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    disponivel_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc1_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc2_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc3_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    custo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    contrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perccontrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrbase_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    mo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desp_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type resconUncheckedUpdateInput = {
    cod_rescon?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    realizado_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    disponivel_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc1_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc2_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc3_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    custo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    contrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perccontrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrbase_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    mo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desp_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type resconCreateManyInput = {
    cod_rescon: number;
    cod_fatura: number;
    cod_recurso: number;
    hrfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    hrnfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    vrfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    vrnfat_rescon?: Decimal | DecimalJsLike | number | string | null;
    realizado_rescon?: Decimal | DecimalJsLike | number | string | null;
    disponivel_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc1_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc2_rescon?: Decimal | DecimalJsLike | number | string | null;
    perc3_rescon?: Decimal | DecimalJsLike | number | string | null;
    custo_rescon?: Decimal | DecimalJsLike | number | string | null;
    contrib_rescon?: Decimal | DecimalJsLike | number | string | null;
    perccontrib_rescon?: Decimal | DecimalJsLike | number | string | null;
    hrbase_rescon?: Decimal | DecimalJsLike | number | string | null;
    mo_rescon?: Decimal | DecimalJsLike | number | string | null;
    desp_rescon?: Decimal | DecimalJsLike | number | string | null;
  };

  export type resconUpdateManyMutationInput = {
    cod_rescon?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    realizado_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    disponivel_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc1_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc2_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc3_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    custo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    contrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perccontrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrbase_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    mo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desp_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type resconUncheckedUpdateManyInput = {
    cod_rescon?: IntFieldUpdateOperationsInput | number;
    cod_fatura?: IntFieldUpdateOperationsInput | number;
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    hrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    vrnfat_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    realizado_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    disponivel_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc1_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc2_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perc3_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    custo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    contrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    perccontrib_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hrbase_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    mo_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    desp_rescon?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type statusCreateInput = {
    cod_status: number;
    desc_status: string;
  };

  export type statusUncheckedCreateInput = {
    cod_status: number;
    desc_status: string;
  };

  export type statusUpdateInput = {
    cod_status?: IntFieldUpdateOperationsInput | number;
    desc_status?: StringFieldUpdateOperationsInput | string;
  };

  export type statusUncheckedUpdateInput = {
    cod_status?: IntFieldUpdateOperationsInput | number;
    desc_status?: StringFieldUpdateOperationsInput | string;
  };

  export type statusCreateManyInput = {
    cod_status: number;
    desc_status: string;
  };

  export type statusUpdateManyMutationInput = {
    cod_status?: IntFieldUpdateOperationsInput | number;
    desc_status?: StringFieldUpdateOperationsInput | string;
  };

  export type statusUncheckedUpdateManyInput = {
    cod_status?: IntFieldUpdateOperationsInput | number;
    desc_status?: StringFieldUpdateOperationsInput | string;
  };

  export type tarefaCreateInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osCreateNestedManyWithoutTarefaInput;
    area: areaCreateNestedOneWithoutTarefaInput;
    fase: faseCreateNestedOneWithoutTarefaInput;
    projeto: projetoCreateNestedOneWithoutTarefaInput;
    recurso_tarefa_codrecresp_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
    recurso_tarefa_codrec_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
  };

  export type tarefaUncheckedCreateInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osUncheckedCreateNestedManyWithoutTarefaInput;
  };

  export type tarefaUpdateInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUpdateManyWithoutTarefaNestedInput;
    area?: areaUpdateOneRequiredWithoutTarefaNestedInput;
    fase?: faseUpdateOneRequiredWithoutTarefaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutTarefaNestedInput;
    recurso_tarefa_codrecresp_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrecresp_tarefaTorecursoNestedInput;
    recurso_tarefa_codrec_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrec_tarefaTorecursoNestedInput;
  };

  export type tarefaUncheckedUpdateInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codpro_tarefa?: IntFieldUpdateOperationsInput | number;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_area?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_fase?: IntFieldUpdateOperationsInput | number;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUncheckedUpdateManyWithoutTarefaNestedInput;
  };

  export type tarefaCreateManyInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
  };

  export type tarefaUpdateManyMutationInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type tarefaUncheckedUpdateManyInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codpro_tarefa?: IntFieldUpdateOperationsInput | number;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_area?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_fase?: IntFieldUpdateOperationsInput | number;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type tela_sistemaCreateInput = {
    cod_tela: number;
    desc_tela: string;
    acesso_sistema?: acesso_sistemaCreateNestedManyWithoutTela_sistemaInput;
    modulo_sistema: modulo_sistemaCreateNestedOneWithoutTela_sistemaInput;
  };

  export type tela_sistemaUncheckedCreateInput = {
    cod_tela: number;
    cod_modulo: number;
    desc_tela: string;
    acesso_sistema?: acesso_sistemaUncheckedCreateNestedManyWithoutTela_sistemaInput;
  };

  export type tela_sistemaUpdateInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUpdateManyWithoutTela_sistemaNestedInput;
    modulo_sistema?: modulo_sistemaUpdateOneRequiredWithoutTela_sistemaNestedInput;
  };

  export type tela_sistemaUncheckedUpdateInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUncheckedUpdateManyWithoutTela_sistemaNestedInput;
  };

  export type tela_sistemaCreateManyInput = {
    cod_tela: number;
    cod_modulo: number;
    desc_tela: string;
  };

  export type tela_sistemaUpdateManyMutationInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
  };

  export type tela_sistemaUncheckedUpdateManyInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
  };

  export type telefoneCreateInput = {
    cod_telefone: number;
    cod_lista: number;
    ddd_telefone?: string | null;
    numero_telefone: string;
    desc_telefone?: string | null;
  };

  export type telefoneUncheckedCreateInput = {
    cod_telefone: number;
    cod_lista: number;
    ddd_telefone?: string | null;
    numero_telefone: string;
    desc_telefone?: string | null;
  };

  export type telefoneUpdateInput = {
    cod_telefone?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    ddd_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
    numero_telefone?: StringFieldUpdateOperationsInput | string;
    desc_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type telefoneUncheckedUpdateInput = {
    cod_telefone?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    ddd_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
    numero_telefone?: StringFieldUpdateOperationsInput | string;
    desc_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type telefoneCreateManyInput = {
    cod_telefone: number;
    cod_lista: number;
    ddd_telefone?: string | null;
    numero_telefone: string;
    desc_telefone?: string | null;
  };

  export type telefoneUpdateManyMutationInput = {
    cod_telefone?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    ddd_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
    numero_telefone?: StringFieldUpdateOperationsInput | string;
    desc_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type telefoneUncheckedUpdateManyInput = {
    cod_telefone?: IntFieldUpdateOperationsInput | number;
    cod_lista?: IntFieldUpdateOperationsInput | number;
    ddd_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
    numero_telefone?: StringFieldUpdateOperationsInput | string;
    desc_telefone?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type tipotrfCreateInput = {
    cod_tipotrf: number;
    nome_tipotrf: string;
    valor?: valorCreateNestedManyWithoutTipotrfInput;
  };

  export type tipotrfUncheckedCreateInput = {
    cod_tipotrf: number;
    nome_tipotrf: string;
    valor?: valorUncheckedCreateNestedManyWithoutTipotrfInput;
  };

  export type tipotrfUpdateInput = {
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    nome_tipotrf?: StringFieldUpdateOperationsInput | string;
    valor?: valorUpdateManyWithoutTipotrfNestedInput;
  };

  export type tipotrfUncheckedUpdateInput = {
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    nome_tipotrf?: StringFieldUpdateOperationsInput | string;
    valor?: valorUncheckedUpdateManyWithoutTipotrfNestedInput;
  };

  export type tipotrfCreateManyInput = {
    cod_tipotrf: number;
    nome_tipotrf: string;
  };

  export type tipotrfUpdateManyMutationInput = {
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    nome_tipotrf?: StringFieldUpdateOperationsInput | string;
  };

  export type tipotrfUncheckedUpdateManyInput = {
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    nome_tipotrf?: StringFieldUpdateOperationsInput | string;
  };

  export type tpdespCreateInput = {
    cod_tpdesp: number;
    nome_tpdesp: string;
  };

  export type tpdespUncheckedCreateInput = {
    cod_tpdesp: number;
    nome_tpdesp: string;
  };

  export type tpdespUpdateInput = {
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    nome_tpdesp?: StringFieldUpdateOperationsInput | string;
  };

  export type tpdespUncheckedUpdateInput = {
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    nome_tpdesp?: StringFieldUpdateOperationsInput | string;
  };

  export type tpdespCreateManyInput = {
    cod_tpdesp: number;
    nome_tpdesp: string;
  };

  export type tpdespUpdateManyMutationInput = {
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    nome_tpdesp?: StringFieldUpdateOperationsInput | string;
  };

  export type tpdespUncheckedUpdateManyInput = {
    cod_tpdesp?: IntFieldUpdateOperationsInput | number;
    nome_tpdesp?: StringFieldUpdateOperationsInput | string;
  };

  export type usuarioCreateInput = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha?: string | null;
    tipo_usuario?: string;
    permtar_usuario?: string;
    altsen_usuario?: number;
    perproj1_usuario?: string;
    perproj2_usuario?: string;
    tela1_usuario?: number | null;
    tela2_usuario?: number | null;
    tela3_usuario?: number | null;
    tela4_usuario?: number | null;
    acesso_sistema?: acesso_sistemaCreateNestedManyWithoutUsuarioInput;
    recurso?: recursoCreateNestedManyWithoutUsuarioInput;
  };

  export type usuarioUncheckedCreateInput = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha?: string | null;
    tipo_usuario?: string;
    permtar_usuario?: string;
    altsen_usuario?: number;
    perproj1_usuario?: string;
    perproj2_usuario?: string;
    tela1_usuario?: number | null;
    tela2_usuario?: number | null;
    tela3_usuario?: number | null;
    tela4_usuario?: number | null;
    acesso_sistema?: acesso_sistemaUncheckedCreateNestedManyWithoutUsuarioInput;
    recurso?: recursoUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type usuarioUpdateInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    acesso_sistema?: acesso_sistemaUpdateManyWithoutUsuarioNestedInput;
    recurso?: recursoUpdateManyWithoutUsuarioNestedInput;
  };

  export type usuarioUncheckedUpdateInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    acesso_sistema?: acesso_sistemaUncheckedUpdateManyWithoutUsuarioNestedInput;
    recurso?: recursoUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type usuarioCreateManyInput = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha?: string | null;
    tipo_usuario?: string;
    permtar_usuario?: string;
    altsen_usuario?: number;
    perproj1_usuario?: string;
    perproj2_usuario?: string;
    tela1_usuario?: number | null;
    tela2_usuario?: number | null;
    tela3_usuario?: number | null;
    tela4_usuario?: number | null;
  };

  export type usuarioUpdateManyMutationInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type usuarioUncheckedUpdateManyInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type valorCreateInput = {
    preco_valor: Decimal | DecimalJsLike | number | string;
    projeto: projetoCreateNestedOneWithoutValorInput;
    tipotrf: tipotrfCreateNestedOneWithoutValorInput;
  };

  export type valorUncheckedCreateInput = {
    codproj_valor: number;
    codtipo_valor: number;
    preco_valor: Decimal | DecimalJsLike | number | string;
  };

  export type valorUpdateInput = {
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    projeto?: projetoUpdateOneRequiredWithoutValorNestedInput;
    tipotrf?: tipotrfUpdateOneRequiredWithoutValorNestedInput;
  };

  export type valorUncheckedUpdateInput = {
    codproj_valor?: IntFieldUpdateOperationsInput | number;
    codtipo_valor?: IntFieldUpdateOperationsInput | number;
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type valorCreateManyInput = {
    codproj_valor: number;
    codtipo_valor: number;
    preco_valor: Decimal | DecimalJsLike | number | string;
  };

  export type valorUpdateManyMutationInput = {
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type valorUncheckedUpdateManyInput = {
    codproj_valor?: IntFieldUpdateOperationsInput | number;
    codtipo_valor?: IntFieldUpdateOperationsInput | number;
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type Modulo_sistemaScalarRelationFilter = {
    is?: modulo_sistemaWhereInput;
    isNot?: modulo_sistemaWhereInput;
  };

  export type Tela_sistemaScalarRelationFilter = {
    is?: tela_sistemaWhereInput;
    isNot?: tela_sistemaWhereInput;
  };

  export type UsuarioScalarRelationFilter = {
    is?: usuarioWhereInput;
    isNot?: usuarioWhereInput;
  };

  export type acesso_sistemaCod_usuarioCod_moduloCod_telaCompoundUniqueInput = {
    cod_usuario: number;
    cod_modulo: number;
    cod_tela: number;
  };

  export type acesso_sistemaCountOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    cod_modulo?: SortOrder;
    cod_tela?: SortOrder;
    incluir?: SortOrder;
    modificar?: SortOrder;
    eliminar?: SortOrder;
  };

  export type acesso_sistemaAvgOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    cod_modulo?: SortOrder;
    cod_tela?: SortOrder;
  };

  export type acesso_sistemaMaxOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    cod_modulo?: SortOrder;
    cod_tela?: SortOrder;
    incluir?: SortOrder;
    modificar?: SortOrder;
    eliminar?: SortOrder;
  };

  export type acesso_sistemaMinOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    cod_modulo?: SortOrder;
    cod_tela?: SortOrder;
    incluir?: SortOrder;
    modificar?: SortOrder;
    eliminar?: SortOrder;
  };

  export type acesso_sistemaSumOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    cod_modulo?: SortOrder;
    cod_tela?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type RecursoScalarRelationFilter = {
    is?: recursoWhereInput;
    isNot?: recursoWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type agenrecCountOrderByAggregateInput = {
    cod_agenrec?: SortOrder;
    cod_recurso?: SortOrder;
    data_agenrec?: SortOrder;
    hrini_agenrec?: SortOrder;
    hrfim_agenrec?: SortOrder;
    status_agenrec?: SortOrder;
    obs_agenrec?: SortOrder;
    custo_agenrec?: SortOrder;
    receita_agenrec?: SortOrder;
    tpcusto_agenrec?: SortOrder;
  };

  export type agenrecAvgOrderByAggregateInput = {
    cod_agenrec?: SortOrder;
    cod_recurso?: SortOrder;
    status_agenrec?: SortOrder;
    custo_agenrec?: SortOrder;
    receita_agenrec?: SortOrder;
    tpcusto_agenrec?: SortOrder;
  };

  export type agenrecMaxOrderByAggregateInput = {
    cod_agenrec?: SortOrder;
    cod_recurso?: SortOrder;
    data_agenrec?: SortOrder;
    hrini_agenrec?: SortOrder;
    hrfim_agenrec?: SortOrder;
    status_agenrec?: SortOrder;
    obs_agenrec?: SortOrder;
    custo_agenrec?: SortOrder;
    receita_agenrec?: SortOrder;
    tpcusto_agenrec?: SortOrder;
  };

  export type agenrecMinOrderByAggregateInput = {
    cod_agenrec?: SortOrder;
    cod_recurso?: SortOrder;
    data_agenrec?: SortOrder;
    hrini_agenrec?: SortOrder;
    hrfim_agenrec?: SortOrder;
    status_agenrec?: SortOrder;
    obs_agenrec?: SortOrder;
    custo_agenrec?: SortOrder;
    receita_agenrec?: SortOrder;
    tpcusto_agenrec?: SortOrder;
  };

  export type agenrecSumOrderByAggregateInput = {
    cod_agenrec?: SortOrder;
    cod_recurso?: SortOrder;
    status_agenrec?: SortOrder;
    custo_agenrec?: SortOrder;
    receita_agenrec?: SortOrder;
    tpcusto_agenrec?: SortOrder;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type MetaListRelationFilter = {
    every?: metaWhereInput;
    some?: metaWhereInput;
    none?: metaWhereInput;
  };

  export type TarefaListRelationFilter = {
    every?: tarefaWhereInput;
    some?: tarefaWhereInput;
    none?: tarefaWhereInput;
  };

  export type metaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type tarefaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type areaCountOrderByAggregateInput = {
    cod_area?: SortOrder;
    nome_area?: SortOrder;
  };

  export type areaAvgOrderByAggregateInput = {
    cod_area?: SortOrder;
  };

  export type areaMaxOrderByAggregateInput = {
    cod_area?: SortOrder;
    nome_area?: SortOrder;
  };

  export type areaMinOrderByAggregateInput = {
    cod_area?: SortOrder;
    nome_area?: SortOrder;
  };

  export type areaSumOrderByAggregateInput = {
    cod_area?: SortOrder;
  };

  export type ProjetoScalarRelationFilter = {
    is?: projetoWhereInput;
    isNot?: projetoWhereInput;
  };

  export type AvaliadoListRelationFilter = {
    every?: avaliadoWhereInput;
    some?: avaliadoWhereInput;
    none?: avaliadoWhereInput;
  };

  export type avaliadoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type avaliacaoCountOrderByAggregateInput = {
    cod_avaliacao?: SortOrder;
    anomes_avaliacao?: SortOrder;
    data_avaliacao?: SortOrder;
    codrec_avaliacao?: SortOrder;
    status_avaliacao?: SortOrder;
    codpro_avaliacao?: SortOrder;
  };

  export type avaliacaoAvgOrderByAggregateInput = {
    cod_avaliacao?: SortOrder;
    codrec_avaliacao?: SortOrder;
    codpro_avaliacao?: SortOrder;
  };

  export type avaliacaoMaxOrderByAggregateInput = {
    cod_avaliacao?: SortOrder;
    anomes_avaliacao?: SortOrder;
    data_avaliacao?: SortOrder;
    codrec_avaliacao?: SortOrder;
    status_avaliacao?: SortOrder;
    codpro_avaliacao?: SortOrder;
  };

  export type avaliacaoMinOrderByAggregateInput = {
    cod_avaliacao?: SortOrder;
    anomes_avaliacao?: SortOrder;
    data_avaliacao?: SortOrder;
    codrec_avaliacao?: SortOrder;
    status_avaliacao?: SortOrder;
    codpro_avaliacao?: SortOrder;
  };

  export type avaliacaoSumOrderByAggregateInput = {
    cod_avaliacao?: SortOrder;
    codrec_avaliacao?: SortOrder;
    codpro_avaliacao?: SortOrder;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type AvaliacaoScalarRelationFilter = {
    is?: avaliacaoWhereInput;
    isNot?: avaliacaoWhereInput;
  };

  export type ItavaliadoListRelationFilter = {
    every?: itavaliadoWhereInput;
    some?: itavaliadoWhereInput;
    none?: itavaliadoWhereInput;
  };

  export type itavaliadoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type avaliadoCodaval_avaliadoCodrec_avaliadoCompoundUniqueInput = {
    codaval_avaliado: number;
    codrec_avaliado: number;
  };

  export type avaliadoCountOrderByAggregateInput = {
    codaval_avaliado?: SortOrder;
    codrec_avaliado?: SortOrder;
    status_avaliado?: SortOrder;
    data_avaliado?: SortOrder;
    hora_avaliado?: SortOrder;
    usuario_avaliado?: SortOrder;
  };

  export type avaliadoAvgOrderByAggregateInput = {
    codaval_avaliado?: SortOrder;
    codrec_avaliado?: SortOrder;
  };

  export type avaliadoMaxOrderByAggregateInput = {
    codaval_avaliado?: SortOrder;
    codrec_avaliado?: SortOrder;
    status_avaliado?: SortOrder;
    data_avaliado?: SortOrder;
    hora_avaliado?: SortOrder;
    usuario_avaliado?: SortOrder;
  };

  export type avaliadoMinOrderByAggregateInput = {
    codaval_avaliado?: SortOrder;
    codrec_avaliado?: SortOrder;
    status_avaliado?: SortOrder;
    data_avaliado?: SortOrder;
    hora_avaliado?: SortOrder;
    usuario_avaliado?: SortOrder;
  };

  export type avaliadoSumOrderByAggregateInput = {
    codaval_avaliado?: SortOrder;
    codrec_avaliado?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null;
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null;
  };

  export type ClienteNullableScalarRelationFilter = {
    is?: clienteWhereInput | null;
    isNot?: clienteWhereInput | null;
  };

  export type RecursoNullableScalarRelationFilter = {
    is?: recursoWhereInput | null;
    isNot?: recursoWhereInput | null;
  };

  export type chamadoCountOrderByAggregateInput = {
    cod_chamado?: SortOrder;
    data_chamado?: SortOrder;
    hora_chamado?: SortOrder;
    solicitacao_chamado?: SortOrder;
    conclusao_chamado?: SortOrder;
    status_chamado?: SortOrder;
    dtenvio_chamado?: SortOrder;
    cod_recurso?: SortOrder;
    cliente_chamado?: SortOrder;
    codtrf_chamado?: SortOrder;
    cod_cliente?: SortOrder;
    solicitacao2_chamado?: SortOrder;
    assunto_chamado?: SortOrder;
    email_chamado?: SortOrder;
    prior_chamado?: SortOrder;
    cod_classificacao?: SortOrder;
  };

  export type chamadoAvgOrderByAggregateInput = {
    cod_chamado?: SortOrder;
    cod_recurso?: SortOrder;
    codtrf_chamado?: SortOrder;
    cod_cliente?: SortOrder;
    prior_chamado?: SortOrder;
    cod_classificacao?: SortOrder;
  };

  export type chamadoMaxOrderByAggregateInput = {
    cod_chamado?: SortOrder;
    data_chamado?: SortOrder;
    hora_chamado?: SortOrder;
    solicitacao_chamado?: SortOrder;
    conclusao_chamado?: SortOrder;
    status_chamado?: SortOrder;
    dtenvio_chamado?: SortOrder;
    cod_recurso?: SortOrder;
    cliente_chamado?: SortOrder;
    codtrf_chamado?: SortOrder;
    cod_cliente?: SortOrder;
    solicitacao2_chamado?: SortOrder;
    assunto_chamado?: SortOrder;
    email_chamado?: SortOrder;
    prior_chamado?: SortOrder;
    cod_classificacao?: SortOrder;
  };

  export type chamadoMinOrderByAggregateInput = {
    cod_chamado?: SortOrder;
    data_chamado?: SortOrder;
    hora_chamado?: SortOrder;
    solicitacao_chamado?: SortOrder;
    conclusao_chamado?: SortOrder;
    status_chamado?: SortOrder;
    dtenvio_chamado?: SortOrder;
    cod_recurso?: SortOrder;
    cliente_chamado?: SortOrder;
    codtrf_chamado?: SortOrder;
    cod_cliente?: SortOrder;
    solicitacao2_chamado?: SortOrder;
    assunto_chamado?: SortOrder;
    email_chamado?: SortOrder;
    prior_chamado?: SortOrder;
    cod_classificacao?: SortOrder;
  };

  export type chamadoSumOrderByAggregateInput = {
    cod_chamado?: SortOrder;
    cod_recurso?: SortOrder;
    codtrf_chamado?: SortOrder;
    cod_cliente?: SortOrder;
    prior_chamado?: SortOrder;
    cod_classificacao?: SortOrder;
  };

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null;
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    not?:
      | NestedBytesNullableWithAggregatesFilter<$PrismaModel>
      | Uint8Array
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBytesNullableFilter<$PrismaModel>;
    _max?: NestedBytesNullableFilter<$PrismaModel>;
  };

  export type cidadeCountOrderByAggregateInput = {
    cod_cidade?: SortOrder;
    nome_cidade?: SortOrder;
    codibge_cidade?: SortOrder;
    uf_cidade?: SortOrder;
  };

  export type cidadeAvgOrderByAggregateInput = {
    cod_cidade?: SortOrder;
  };

  export type cidadeMaxOrderByAggregateInput = {
    cod_cidade?: SortOrder;
    nome_cidade?: SortOrder;
    codibge_cidade?: SortOrder;
    uf_cidade?: SortOrder;
  };

  export type cidadeMinOrderByAggregateInput = {
    cod_cidade?: SortOrder;
    nome_cidade?: SortOrder;
    codibge_cidade?: SortOrder;
    uf_cidade?: SortOrder;
  };

  export type cidadeSumOrderByAggregateInput = {
    cod_cidade?: SortOrder;
  };

  export type classificacaoCountOrderByAggregateInput = {
    cod_classificacao?: SortOrder;
    nome_classificacao?: SortOrder;
    ativo_classificacao?: SortOrder;
  };

  export type classificacaoAvgOrderByAggregateInput = {
    cod_classificacao?: SortOrder;
  };

  export type classificacaoMaxOrderByAggregateInput = {
    cod_classificacao?: SortOrder;
    nome_classificacao?: SortOrder;
    ativo_classificacao?: SortOrder;
  };

  export type classificacaoMinOrderByAggregateInput = {
    cod_classificacao?: SortOrder;
    nome_classificacao?: SortOrder;
    ativo_classificacao?: SortOrder;
  };

  export type classificacaoSumOrderByAggregateInput = {
    cod_classificacao?: SortOrder;
  };

  export type ChamadoListRelationFilter = {
    every?: chamadoWhereInput;
    some?: chamadoWhereInput;
    none?: chamadoWhereInput;
  };

  export type FatrecListRelationFilter = {
    every?: fatrecWhereInput;
    some?: fatrecWhereInput;
    none?: fatrecWhereInput;
  };

  export type ProjetoListRelationFilter = {
    every?: projetoWhereInput;
    some?: projetoWhereInput;
    none?: projetoWhereInput;
  };

  export type chamadoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type fatrecOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type projetoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type clienteCountOrderByAggregateInput = {
    cod_cliente?: SortOrder;
    nome_cliente?: SortOrder;
    razao_cliente?: SortOrder;
    end_cliente?: SortOrder;
    bairro_cliente?: SortOrder;
    cep_cliente?: SortOrder;
    fone_cliente?: SortOrder;
    cnpj_cliente?: SortOrder;
    ie_cliente?: SortOrder;
    uf_cliente?: SortOrder;
    fax_cliente?: SortOrder;
    contato_cliente?: SortOrder;
    funccontato_cliente?: SortOrder;
    endcob_cliente?: SortOrder;
    bairrocob_cliente?: SortOrder;
    cepcob_cliente?: SortOrder;
    cidadecob_cliente?: SortOrder;
    ufcob_cliente?: SortOrder;
    ativo_cliente?: SortOrder;
    obs_cliente?: SortOrder;
    im_cliente?: SortOrder;
    cod_cidade?: SortOrder;
    numend_cliente?: SortOrder;
    comend_cliente?: SortOrder;
    email_cliente?: SortOrder;
    codbanco_cliente?: SortOrder;
    sla_cliente?: SortOrder;
  };

  export type clienteAvgOrderByAggregateInput = {
    cod_cliente?: SortOrder;
    ativo_cliente?: SortOrder;
    cod_cidade?: SortOrder;
    sla_cliente?: SortOrder;
  };

  export type clienteMaxOrderByAggregateInput = {
    cod_cliente?: SortOrder;
    nome_cliente?: SortOrder;
    razao_cliente?: SortOrder;
    end_cliente?: SortOrder;
    bairro_cliente?: SortOrder;
    cep_cliente?: SortOrder;
    fone_cliente?: SortOrder;
    cnpj_cliente?: SortOrder;
    ie_cliente?: SortOrder;
    uf_cliente?: SortOrder;
    fax_cliente?: SortOrder;
    contato_cliente?: SortOrder;
    funccontato_cliente?: SortOrder;
    endcob_cliente?: SortOrder;
    bairrocob_cliente?: SortOrder;
    cepcob_cliente?: SortOrder;
    cidadecob_cliente?: SortOrder;
    ufcob_cliente?: SortOrder;
    ativo_cliente?: SortOrder;
    obs_cliente?: SortOrder;
    im_cliente?: SortOrder;
    cod_cidade?: SortOrder;
    numend_cliente?: SortOrder;
    comend_cliente?: SortOrder;
    email_cliente?: SortOrder;
    codbanco_cliente?: SortOrder;
    sla_cliente?: SortOrder;
  };

  export type clienteMinOrderByAggregateInput = {
    cod_cliente?: SortOrder;
    nome_cliente?: SortOrder;
    razao_cliente?: SortOrder;
    end_cliente?: SortOrder;
    bairro_cliente?: SortOrder;
    cep_cliente?: SortOrder;
    fone_cliente?: SortOrder;
    cnpj_cliente?: SortOrder;
    ie_cliente?: SortOrder;
    uf_cliente?: SortOrder;
    fax_cliente?: SortOrder;
    contato_cliente?: SortOrder;
    funccontato_cliente?: SortOrder;
    endcob_cliente?: SortOrder;
    bairrocob_cliente?: SortOrder;
    cepcob_cliente?: SortOrder;
    cidadecob_cliente?: SortOrder;
    ufcob_cliente?: SortOrder;
    ativo_cliente?: SortOrder;
    obs_cliente?: SortOrder;
    im_cliente?: SortOrder;
    cod_cidade?: SortOrder;
    numend_cliente?: SortOrder;
    comend_cliente?: SortOrder;
    email_cliente?: SortOrder;
    codbanco_cliente?: SortOrder;
    sla_cliente?: SortOrder;
  };

  export type clienteSumOrderByAggregateInput = {
    cod_cliente?: SortOrder;
    ativo_cliente?: SortOrder;
    cod_cidade?: SortOrder;
    sla_cliente?: SortOrder;
  };

  export type composicaoCountOrderByAggregateInput = {
    cod_composicao?: SortOrder;
    cod_fatura?: SortOrder;
    cod_cliente?: SortOrder;
    cod_projeto?: SortOrder;
    cod_tarefa?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_composicao?: SortOrder;
    hrnfat_composicao?: SortOrder;
    vrhr_composicao?: SortOrder;
    vrfat_composicao?: SortOrder;
  };

  export type composicaoAvgOrderByAggregateInput = {
    cod_composicao?: SortOrder;
    cod_fatura?: SortOrder;
    cod_cliente?: SortOrder;
    cod_projeto?: SortOrder;
    cod_tarefa?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_composicao?: SortOrder;
    hrnfat_composicao?: SortOrder;
    vrhr_composicao?: SortOrder;
    vrfat_composicao?: SortOrder;
  };

  export type composicaoMaxOrderByAggregateInput = {
    cod_composicao?: SortOrder;
    cod_fatura?: SortOrder;
    cod_cliente?: SortOrder;
    cod_projeto?: SortOrder;
    cod_tarefa?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_composicao?: SortOrder;
    hrnfat_composicao?: SortOrder;
    vrhr_composicao?: SortOrder;
    vrfat_composicao?: SortOrder;
  };

  export type composicaoMinOrderByAggregateInput = {
    cod_composicao?: SortOrder;
    cod_fatura?: SortOrder;
    cod_cliente?: SortOrder;
    cod_projeto?: SortOrder;
    cod_tarefa?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_composicao?: SortOrder;
    hrnfat_composicao?: SortOrder;
    vrhr_composicao?: SortOrder;
    vrfat_composicao?: SortOrder;
  };

  export type composicaoSumOrderByAggregateInput = {
    cod_composicao?: SortOrder;
    cod_fatura?: SortOrder;
    cod_cliente?: SortOrder;
    cod_projeto?: SortOrder;
    cod_tarefa?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_composicao?: SortOrder;
    hrnfat_composicao?: SortOrder;
    vrhr_composicao?: SortOrder;
    vrfat_composicao?: SortOrder;
  };

  export type contatoCountOrderByAggregateInput = {
    cod_contato?: SortOrder;
    data_contato?: SortOrder;
    hora_contato?: SortOrder;
    nomeusuario_contato?: SortOrder;
    desc_contato?: SortOrder;
    cod_lista?: SortOrder;
  };

  export type contatoAvgOrderByAggregateInput = {
    cod_contato?: SortOrder;
    cod_lista?: SortOrder;
  };

  export type contatoMaxOrderByAggregateInput = {
    cod_contato?: SortOrder;
    data_contato?: SortOrder;
    hora_contato?: SortOrder;
    nomeusuario_contato?: SortOrder;
    desc_contato?: SortOrder;
    cod_lista?: SortOrder;
  };

  export type contatoMinOrderByAggregateInput = {
    cod_contato?: SortOrder;
    data_contato?: SortOrder;
    hora_contato?: SortOrder;
    nomeusuario_contato?: SortOrder;
    desc_contato?: SortOrder;
    cod_lista?: SortOrder;
  };

  export type contatoSumOrderByAggregateInput = {
    cod_contato?: SortOrder;
    cod_lista?: SortOrder;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type ctissCountOrderByAggregateInput = {
    cod_ctiss?: SortOrder;
    num_ctiss?: SortOrder;
    subitem_ctiss?: SortOrder;
    descr_ctiss?: SortOrder;
    csll_ctiss?: SortOrder;
    pis_ctiss?: SortOrder;
    cofins_ctiss?: SortOrder;
    irrf_ctiss?: SortOrder;
    aliq_ctiss?: SortOrder;
    aliqret_ctiss?: SortOrder;
  };

  export type ctissAvgOrderByAggregateInput = {
    cod_ctiss?: SortOrder;
    csll_ctiss?: SortOrder;
    pis_ctiss?: SortOrder;
    cofins_ctiss?: SortOrder;
    irrf_ctiss?: SortOrder;
    aliq_ctiss?: SortOrder;
    aliqret_ctiss?: SortOrder;
  };

  export type ctissMaxOrderByAggregateInput = {
    cod_ctiss?: SortOrder;
    num_ctiss?: SortOrder;
    subitem_ctiss?: SortOrder;
    descr_ctiss?: SortOrder;
    csll_ctiss?: SortOrder;
    pis_ctiss?: SortOrder;
    cofins_ctiss?: SortOrder;
    irrf_ctiss?: SortOrder;
    aliq_ctiss?: SortOrder;
    aliqret_ctiss?: SortOrder;
  };

  export type ctissMinOrderByAggregateInput = {
    cod_ctiss?: SortOrder;
    num_ctiss?: SortOrder;
    subitem_ctiss?: SortOrder;
    descr_ctiss?: SortOrder;
    csll_ctiss?: SortOrder;
    pis_ctiss?: SortOrder;
    cofins_ctiss?: SortOrder;
    irrf_ctiss?: SortOrder;
    aliq_ctiss?: SortOrder;
    aliqret_ctiss?: SortOrder;
  };

  export type ctissSumOrderByAggregateInput = {
    cod_ctiss?: SortOrder;
    csll_ctiss?: SortOrder;
    pis_ctiss?: SortOrder;
    cofins_ctiss?: SortOrder;
    irrf_ctiss?: SortOrder;
    aliq_ctiss?: SortOrder;
    aliqret_ctiss?: SortOrder;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type despesaCountOrderByAggregateInput = {
    cod_despesa?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_despesa?: SortOrder;
    mesano_despesa?: SortOrder;
  };

  export type despesaAvgOrderByAggregateInput = {
    cod_despesa?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_despesa?: SortOrder;
  };

  export type despesaMaxOrderByAggregateInput = {
    cod_despesa?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_despesa?: SortOrder;
    mesano_despesa?: SortOrder;
  };

  export type despesaMinOrderByAggregateInput = {
    cod_despesa?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_despesa?: SortOrder;
    mesano_despesa?: SortOrder;
  };

  export type despesaSumOrderByAggregateInput = {
    cod_despesa?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_despesa?: SortOrder;
  };

  export type desprecCountOrderByAggregateInput = {
    cod_desprec?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_desprec?: SortOrder;
  };

  export type desprecAvgOrderByAggregateInput = {
    cod_desprec?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_desprec?: SortOrder;
  };

  export type desprecMaxOrderByAggregateInput = {
    cod_desprec?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_desprec?: SortOrder;
  };

  export type desprecMinOrderByAggregateInput = {
    cod_desprec?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_desprec?: SortOrder;
  };

  export type desprecSumOrderByAggregateInput = {
    cod_desprec?: SortOrder;
    cod_recurso?: SortOrder;
    cod_tpdesp?: SortOrder;
    valor_desprec?: SortOrder;
  };

  export type empresaCountOrderByAggregateInput = {
    cod_empresa?: SortOrder;
    nome_empresa?: SortOrder;
    razao_empresa?: SortOrder;
    end_empresa?: SortOrder;
    bairro_empresa?: SortOrder;
    cep_empresa?: SortOrder;
    ddd_empresa?: SortOrder;
    fone_empresa?: SortOrder;
    cnpj_empresa?: SortOrder;
    ie_empresa?: SortOrder;
    im_empresa?: SortOrder;
    cod_cidade?: SortOrder;
    certificado_empresa?: SortOrder;
    email_empresa?: SortOrder;
  };

  export type empresaAvgOrderByAggregateInput = {
    cod_empresa?: SortOrder;
    cod_cidade?: SortOrder;
  };

  export type empresaMaxOrderByAggregateInput = {
    cod_empresa?: SortOrder;
    nome_empresa?: SortOrder;
    razao_empresa?: SortOrder;
    end_empresa?: SortOrder;
    bairro_empresa?: SortOrder;
    cep_empresa?: SortOrder;
    ddd_empresa?: SortOrder;
    fone_empresa?: SortOrder;
    cnpj_empresa?: SortOrder;
    ie_empresa?: SortOrder;
    im_empresa?: SortOrder;
    cod_cidade?: SortOrder;
    certificado_empresa?: SortOrder;
    email_empresa?: SortOrder;
  };

  export type empresaMinOrderByAggregateInput = {
    cod_empresa?: SortOrder;
    nome_empresa?: SortOrder;
    razao_empresa?: SortOrder;
    end_empresa?: SortOrder;
    bairro_empresa?: SortOrder;
    cep_empresa?: SortOrder;
    ddd_empresa?: SortOrder;
    fone_empresa?: SortOrder;
    cnpj_empresa?: SortOrder;
    ie_empresa?: SortOrder;
    im_empresa?: SortOrder;
    cod_cidade?: SortOrder;
    certificado_empresa?: SortOrder;
    email_empresa?: SortOrder;
  };

  export type empresaSumOrderByAggregateInput = {
    cod_empresa?: SortOrder;
    cod_cidade?: SortOrder;
  };

  export type faseCountOrderByAggregateInput = {
    cod_fase?: SortOrder;
    nome_fase?: SortOrder;
  };

  export type faseAvgOrderByAggregateInput = {
    cod_fase?: SortOrder;
  };

  export type faseMaxOrderByAggregateInput = {
    cod_fase?: SortOrder;
    nome_fase?: SortOrder;
  };

  export type faseMinOrderByAggregateInput = {
    cod_fase?: SortOrder;
    nome_fase?: SortOrder;
  };

  export type faseSumOrderByAggregateInput = {
    cod_fase?: SortOrder;
  };

  export type fatdesCountOrderByAggregateInput = {
    cod_fatdes?: SortOrder;
    mesano_fatdes?: SortOrder;
    desc_fatdes?: SortOrder;
    vrdesp_fatdes?: SortOrder;
    dtpag_fatdes?: SortOrder;
    obs_fatdes?: SortOrder;
    dtven_fatdes?: SortOrder;
  };

  export type fatdesAvgOrderByAggregateInput = {
    cod_fatdes?: SortOrder;
    vrdesp_fatdes?: SortOrder;
  };

  export type fatdesMaxOrderByAggregateInput = {
    cod_fatdes?: SortOrder;
    mesano_fatdes?: SortOrder;
    desc_fatdes?: SortOrder;
    vrdesp_fatdes?: SortOrder;
    dtpag_fatdes?: SortOrder;
    obs_fatdes?: SortOrder;
    dtven_fatdes?: SortOrder;
  };

  export type fatdesMinOrderByAggregateInput = {
    cod_fatdes?: SortOrder;
    mesano_fatdes?: SortOrder;
    desc_fatdes?: SortOrder;
    vrdesp_fatdes?: SortOrder;
    dtpag_fatdes?: SortOrder;
    obs_fatdes?: SortOrder;
    dtven_fatdes?: SortOrder;
  };

  export type fatdesSumOrderByAggregateInput = {
    cod_fatdes?: SortOrder;
    vrdesp_fatdes?: SortOrder;
  };

  export type fatfunCountOrderByAggregateInput = {
    cod_fatfun?: SortOrder;
    mesano_fatfun?: SortOrder;
    nome_fatfun?: SortOrder;
    vrdesl_fatfun?: SortOrder;
    vralm_fatfun?: SortOrder;
    vrsal_fatfun?: SortOrder;
    dtpag_fatfun?: SortOrder;
    obs_fatfun?: SortOrder;
    dtpag1_fatfun?: SortOrder;
    dtpag2_fatfun?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type fatfunAvgOrderByAggregateInput = {
    cod_fatfun?: SortOrder;
    vrdesl_fatfun?: SortOrder;
    vralm_fatfun?: SortOrder;
    vrsal_fatfun?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type fatfunMaxOrderByAggregateInput = {
    cod_fatfun?: SortOrder;
    mesano_fatfun?: SortOrder;
    nome_fatfun?: SortOrder;
    vrdesl_fatfun?: SortOrder;
    vralm_fatfun?: SortOrder;
    vrsal_fatfun?: SortOrder;
    dtpag_fatfun?: SortOrder;
    obs_fatfun?: SortOrder;
    dtpag1_fatfun?: SortOrder;
    dtpag2_fatfun?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type fatfunMinOrderByAggregateInput = {
    cod_fatfun?: SortOrder;
    mesano_fatfun?: SortOrder;
    nome_fatfun?: SortOrder;
    vrdesl_fatfun?: SortOrder;
    vralm_fatfun?: SortOrder;
    vrsal_fatfun?: SortOrder;
    dtpag_fatfun?: SortOrder;
    obs_fatfun?: SortOrder;
    dtpag1_fatfun?: SortOrder;
    dtpag2_fatfun?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type fatfunSumOrderByAggregateInput = {
    cod_fatfun?: SortOrder;
    vrdesl_fatfun?: SortOrder;
    vralm_fatfun?: SortOrder;
    vrsal_fatfun?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type ClienteScalarRelationFilter = {
    is?: clienteWhereInput;
    isNot?: clienteWhereInput;
  };

  export type fatrecCountOrderByAggregateInput = {
    cod_fatrec?: SortOrder;
    cod_cliente?: SortOrder;
    desc_fatrec?: SortOrder;
    qtdhora_fatrec?: SortOrder;
    vrhora_fatrec?: SortOrder;
    vrtot_fatrec?: SortOrder;
    dtvenc_fatrec?: SortOrder;
    dtnf_fatrec?: SortOrder;
    dtcob_fatrec?: SortOrder;
    dtpag_fatrec?: SortOrder;
    vrpag_fatrec?: SortOrder;
    imp_fatrec?: SortOrder;
    mesano_fatrec?: SortOrder;
    obs_fatrec?: SortOrder;
    cod_recurso?: SortOrder;
    perccom_fatrec?: SortOrder;
    dtpgcom_fatrec?: SortOrder;
    cod_empresa?: SortOrder;
    nf_fatrec?: SortOrder;
  };

  export type fatrecAvgOrderByAggregateInput = {
    cod_fatrec?: SortOrder;
    cod_cliente?: SortOrder;
    qtdhora_fatrec?: SortOrder;
    vrhora_fatrec?: SortOrder;
    vrtot_fatrec?: SortOrder;
    vrpag_fatrec?: SortOrder;
    imp_fatrec?: SortOrder;
    cod_recurso?: SortOrder;
    perccom_fatrec?: SortOrder;
    cod_empresa?: SortOrder;
  };

  export type fatrecMaxOrderByAggregateInput = {
    cod_fatrec?: SortOrder;
    cod_cliente?: SortOrder;
    desc_fatrec?: SortOrder;
    qtdhora_fatrec?: SortOrder;
    vrhora_fatrec?: SortOrder;
    vrtot_fatrec?: SortOrder;
    dtvenc_fatrec?: SortOrder;
    dtnf_fatrec?: SortOrder;
    dtcob_fatrec?: SortOrder;
    dtpag_fatrec?: SortOrder;
    vrpag_fatrec?: SortOrder;
    imp_fatrec?: SortOrder;
    mesano_fatrec?: SortOrder;
    obs_fatrec?: SortOrder;
    cod_recurso?: SortOrder;
    perccom_fatrec?: SortOrder;
    dtpgcom_fatrec?: SortOrder;
    cod_empresa?: SortOrder;
    nf_fatrec?: SortOrder;
  };

  export type fatrecMinOrderByAggregateInput = {
    cod_fatrec?: SortOrder;
    cod_cliente?: SortOrder;
    desc_fatrec?: SortOrder;
    qtdhora_fatrec?: SortOrder;
    vrhora_fatrec?: SortOrder;
    vrtot_fatrec?: SortOrder;
    dtvenc_fatrec?: SortOrder;
    dtnf_fatrec?: SortOrder;
    dtcob_fatrec?: SortOrder;
    dtpag_fatrec?: SortOrder;
    vrpag_fatrec?: SortOrder;
    imp_fatrec?: SortOrder;
    mesano_fatrec?: SortOrder;
    obs_fatrec?: SortOrder;
    cod_recurso?: SortOrder;
    perccom_fatrec?: SortOrder;
    dtpgcom_fatrec?: SortOrder;
    cod_empresa?: SortOrder;
    nf_fatrec?: SortOrder;
  };

  export type fatrecSumOrderByAggregateInput = {
    cod_fatrec?: SortOrder;
    cod_cliente?: SortOrder;
    qtdhora_fatrec?: SortOrder;
    vrhora_fatrec?: SortOrder;
    vrtot_fatrec?: SortOrder;
    vrpag_fatrec?: SortOrder;
    imp_fatrec?: SortOrder;
    cod_recurso?: SortOrder;
    perccom_fatrec?: SortOrder;
    cod_empresa?: SortOrder;
  };

  export type faturaCountOrderByAggregateInput = {
    cod_fatura?: SortOrder;
    mesano_fatura?: SortOrder;
    desp_fatura?: SortOrder;
    imp_fatura?: SortOrder;
    lucro_fatura?: SortOrder;
  };

  export type faturaAvgOrderByAggregateInput = {
    cod_fatura?: SortOrder;
    desp_fatura?: SortOrder;
    imp_fatura?: SortOrder;
    lucro_fatura?: SortOrder;
  };

  export type faturaMaxOrderByAggregateInput = {
    cod_fatura?: SortOrder;
    mesano_fatura?: SortOrder;
    desp_fatura?: SortOrder;
    imp_fatura?: SortOrder;
    lucro_fatura?: SortOrder;
  };

  export type faturaMinOrderByAggregateInput = {
    cod_fatura?: SortOrder;
    mesano_fatura?: SortOrder;
    desp_fatura?: SortOrder;
    imp_fatura?: SortOrder;
    lucro_fatura?: SortOrder;
  };

  export type faturaSumOrderByAggregateInput = {
    cod_fatura?: SortOrder;
    desp_fatura?: SortOrder;
    imp_fatura?: SortOrder;
    lucro_fatura?: SortOrder;
  };

  export type faturamentoCountOrderByAggregateInput = {
    cod_faturamento?: SortOrder;
    data_faturamento?: SortOrder;
    hora_faturamento?: SortOrder;
    usu_faturamento?: SortOrder;
    ini_faturamento?: SortOrder;
    fim_faturamento?: SortOrder;
    status_faturamento?: SortOrder;
    mesano_faturamento?: SortOrder;
  };

  export type faturamentoAvgOrderByAggregateInput = {
    cod_faturamento?: SortOrder;
  };

  export type faturamentoMaxOrderByAggregateInput = {
    cod_faturamento?: SortOrder;
    data_faturamento?: SortOrder;
    hora_faturamento?: SortOrder;
    usu_faturamento?: SortOrder;
    ini_faturamento?: SortOrder;
    fim_faturamento?: SortOrder;
    status_faturamento?: SortOrder;
    mesano_faturamento?: SortOrder;
  };

  export type faturamentoMinOrderByAggregateInput = {
    cod_faturamento?: SortOrder;
    data_faturamento?: SortOrder;
    hora_faturamento?: SortOrder;
    usu_faturamento?: SortOrder;
    ini_faturamento?: SortOrder;
    fim_faturamento?: SortOrder;
    status_faturamento?: SortOrder;
    mesano_faturamento?: SortOrder;
  };

  export type faturamentoSumOrderByAggregateInput = {
    cod_faturamento?: SortOrder;
  };

  export type grupoCountOrderByAggregateInput = {
    cod_grupo?: SortOrder;
    desc_grupo?: SortOrder;
  };

  export type grupoAvgOrderByAggregateInput = {
    cod_grupo?: SortOrder;
  };

  export type grupoMaxOrderByAggregateInput = {
    cod_grupo?: SortOrder;
    desc_grupo?: SortOrder;
  };

  export type grupoMinOrderByAggregateInput = {
    cod_grupo?: SortOrder;
    desc_grupo?: SortOrder;
  };

  export type grupoSumOrderByAggregateInput = {
    cod_grupo?: SortOrder;
  };

  export type histchamadoCountOrderByAggregateInput = {
    cod_histchamado?: SortOrder;
    cod_chamado?: SortOrder;
    data_histchamado?: SortOrder;
    hora_histchamado?: SortOrder;
    desc_histchamado?: SortOrder;
  };

  export type histchamadoAvgOrderByAggregateInput = {
    cod_histchamado?: SortOrder;
    cod_chamado?: SortOrder;
  };

  export type histchamadoMaxOrderByAggregateInput = {
    cod_histchamado?: SortOrder;
    cod_chamado?: SortOrder;
    data_histchamado?: SortOrder;
    hora_histchamado?: SortOrder;
    desc_histchamado?: SortOrder;
  };

  export type histchamadoMinOrderByAggregateInput = {
    cod_histchamado?: SortOrder;
    cod_chamado?: SortOrder;
    data_histchamado?: SortOrder;
    hora_histchamado?: SortOrder;
    desc_histchamado?: SortOrder;
  };

  export type histchamadoSumOrderByAggregateInput = {
    cod_histchamado?: SortOrder;
    cod_chamado?: SortOrder;
  };

  export type AvaliadoScalarRelationFilter = {
    is?: avaliadoWhereInput;
    isNot?: avaliadoWhereInput;
  };

  export type ItmatrizScalarRelationFilter = {
    is?: itmatrizWhereInput;
    isNot?: itmatrizWhereInput;
  };

  export type itavaliadoCodaval_itavaliadoCodrec_itavaliadoCodmat_itavaliadoCoditmat_itavaliadoCompoundUniqueInput =
    {
      codaval_itavaliado: number;
      codrec_itavaliado: number;
      codmat_itavaliado: number;
      coditmat_itavaliado: number;
    };

  export type itavaliadoCountOrderByAggregateInput = {
    codaval_itavaliado?: SortOrder;
    codrec_itavaliado?: SortOrder;
    codmat_itavaliado?: SortOrder;
    coditmat_itavaliado?: SortOrder;
    ptoger_itavaliado?: SortOrder;
    ptorec_itavaliado?: SortOrder;
    obs_itavaliado?: SortOrder;
    nota1_itavaliado?: SortOrder;
    nota2_itavaliado?: SortOrder;
    nota3_itavaliado?: SortOrder;
  };

  export type itavaliadoAvgOrderByAggregateInput = {
    codaval_itavaliado?: SortOrder;
    codrec_itavaliado?: SortOrder;
    codmat_itavaliado?: SortOrder;
    coditmat_itavaliado?: SortOrder;
    ptoger_itavaliado?: SortOrder;
    ptorec_itavaliado?: SortOrder;
    nota1_itavaliado?: SortOrder;
    nota2_itavaliado?: SortOrder;
    nota3_itavaliado?: SortOrder;
  };

  export type itavaliadoMaxOrderByAggregateInput = {
    codaval_itavaliado?: SortOrder;
    codrec_itavaliado?: SortOrder;
    codmat_itavaliado?: SortOrder;
    coditmat_itavaliado?: SortOrder;
    ptoger_itavaliado?: SortOrder;
    ptorec_itavaliado?: SortOrder;
    obs_itavaliado?: SortOrder;
    nota1_itavaliado?: SortOrder;
    nota2_itavaliado?: SortOrder;
    nota3_itavaliado?: SortOrder;
  };

  export type itavaliadoMinOrderByAggregateInput = {
    codaval_itavaliado?: SortOrder;
    codrec_itavaliado?: SortOrder;
    codmat_itavaliado?: SortOrder;
    coditmat_itavaliado?: SortOrder;
    ptoger_itavaliado?: SortOrder;
    ptorec_itavaliado?: SortOrder;
    obs_itavaliado?: SortOrder;
    nota1_itavaliado?: SortOrder;
    nota2_itavaliado?: SortOrder;
    nota3_itavaliado?: SortOrder;
  };

  export type itavaliadoSumOrderByAggregateInput = {
    codaval_itavaliado?: SortOrder;
    codrec_itavaliado?: SortOrder;
    codmat_itavaliado?: SortOrder;
    coditmat_itavaliado?: SortOrder;
    ptoger_itavaliado?: SortOrder;
    ptorec_itavaliado?: SortOrder;
    nota1_itavaliado?: SortOrder;
    nota2_itavaliado?: SortOrder;
    nota3_itavaliado?: SortOrder;
  };

  export type MatrizScalarRelationFilter = {
    is?: matrizWhereInput;
    isNot?: matrizWhereInput;
  };

  export type itmatrizCodmat_itmatrizCod_itmatrizCompoundUniqueInput = {
    codmat_itmatriz: number;
    cod_itmatriz: number;
  };

  export type itmatrizCountOrderByAggregateInput = {
    codmat_itmatriz?: SortOrder;
    cod_itmatriz?: SortOrder;
    nota1_itmatriz?: SortOrder;
    nota2_itmatriz?: SortOrder;
    nota3_itmatriz?: SortOrder;
    questao_itmatriz?: SortOrder;
  };

  export type itmatrizAvgOrderByAggregateInput = {
    codmat_itmatriz?: SortOrder;
    cod_itmatriz?: SortOrder;
    nota1_itmatriz?: SortOrder;
    nota2_itmatriz?: SortOrder;
    nota3_itmatriz?: SortOrder;
  };

  export type itmatrizMaxOrderByAggregateInput = {
    codmat_itmatriz?: SortOrder;
    cod_itmatriz?: SortOrder;
    nota1_itmatriz?: SortOrder;
    nota2_itmatriz?: SortOrder;
    nota3_itmatriz?: SortOrder;
    questao_itmatriz?: SortOrder;
  };

  export type itmatrizMinOrderByAggregateInput = {
    codmat_itmatriz?: SortOrder;
    cod_itmatriz?: SortOrder;
    nota1_itmatriz?: SortOrder;
    nota2_itmatriz?: SortOrder;
    nota3_itmatriz?: SortOrder;
    questao_itmatriz?: SortOrder;
  };

  export type itmatrizSumOrderByAggregateInput = {
    codmat_itmatriz?: SortOrder;
    cod_itmatriz?: SortOrder;
    nota1_itmatriz?: SortOrder;
    nota2_itmatriz?: SortOrder;
    nota3_itmatriz?: SortOrder;
  };

  export type layoutCountOrderByAggregateInput = {
    cod_layout?: SortOrder;
    tabela_layout?: SortOrder;
    campo_layout?: SortOrder;
    posicao_layout?: SortOrder;
  };

  export type layoutAvgOrderByAggregateInput = {
    cod_layout?: SortOrder;
    posicao_layout?: SortOrder;
  };

  export type layoutMaxOrderByAggregateInput = {
    cod_layout?: SortOrder;
    tabela_layout?: SortOrder;
    campo_layout?: SortOrder;
    posicao_layout?: SortOrder;
  };

  export type layoutMinOrderByAggregateInput = {
    cod_layout?: SortOrder;
    tabela_layout?: SortOrder;
    campo_layout?: SortOrder;
    posicao_layout?: SortOrder;
  };

  export type layoutSumOrderByAggregateInput = {
    cod_layout?: SortOrder;
    posicao_layout?: SortOrder;
  };

  export type listaCountOrderByAggregateInput = {
    cod_lista?: SortOrder;
    cod_grupo?: SortOrder;
    cod_status?: SortOrder;
    cgccpf_lista?: SortOrder;
    id_lista?: SortOrder;
    nome_lista?: SortOrder;
    end_lista?: SortOrder;
    num_lista?: SortOrder;
    comp_lista?: SortOrder;
    cep_lista?: SortOrder;
    bairro_lista?: SortOrder;
    cidade_lista?: SortOrder;
    uf_lista?: SortOrder;
    email_lista?: SortOrder;
    dtcontactar_lista?: SortOrder;
    dtcad_lista?: SortOrder;
    obs_lista?: SortOrder;
  };

  export type listaAvgOrderByAggregateInput = {
    cod_lista?: SortOrder;
    cod_grupo?: SortOrder;
    cod_status?: SortOrder;
  };

  export type listaMaxOrderByAggregateInput = {
    cod_lista?: SortOrder;
    cod_grupo?: SortOrder;
    cod_status?: SortOrder;
    cgccpf_lista?: SortOrder;
    id_lista?: SortOrder;
    nome_lista?: SortOrder;
    end_lista?: SortOrder;
    num_lista?: SortOrder;
    comp_lista?: SortOrder;
    cep_lista?: SortOrder;
    bairro_lista?: SortOrder;
    cidade_lista?: SortOrder;
    uf_lista?: SortOrder;
    email_lista?: SortOrder;
    dtcontactar_lista?: SortOrder;
    dtcad_lista?: SortOrder;
    obs_lista?: SortOrder;
  };

  export type listaMinOrderByAggregateInput = {
    cod_lista?: SortOrder;
    cod_grupo?: SortOrder;
    cod_status?: SortOrder;
    cgccpf_lista?: SortOrder;
    id_lista?: SortOrder;
    nome_lista?: SortOrder;
    end_lista?: SortOrder;
    num_lista?: SortOrder;
    comp_lista?: SortOrder;
    cep_lista?: SortOrder;
    bairro_lista?: SortOrder;
    cidade_lista?: SortOrder;
    uf_lista?: SortOrder;
    email_lista?: SortOrder;
    dtcontactar_lista?: SortOrder;
    dtcad_lista?: SortOrder;
    obs_lista?: SortOrder;
  };

  export type listaSumOrderByAggregateInput = {
    cod_lista?: SortOrder;
    cod_grupo?: SortOrder;
    cod_status?: SortOrder;
  };

  export type ItmatrizListRelationFilter = {
    every?: itmatrizWhereInput;
    some?: itmatrizWhereInput;
    none?: itmatrizWhereInput;
  };

  export type itmatrizOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type matrizCountOrderByAggregateInput = {
    cod_matriz?: SortOrder;
    desc_matriz?: SortOrder;
    status_matriz?: SortOrder;
  };

  export type matrizAvgOrderByAggregateInput = {
    cod_matriz?: SortOrder;
  };

  export type matrizMaxOrderByAggregateInput = {
    cod_matriz?: SortOrder;
    desc_matriz?: SortOrder;
    status_matriz?: SortOrder;
  };

  export type matrizMinOrderByAggregateInput = {
    cod_matriz?: SortOrder;
    desc_matriz?: SortOrder;
    status_matriz?: SortOrder;
  };

  export type matrizSumOrderByAggregateInput = {
    cod_matriz?: SortOrder;
  };

  export type mensagemCountOrderByAggregateInput = {
    cod_mensagem?: SortOrder;
    desc_mensagem?: SortOrder;
  };

  export type mensagemAvgOrderByAggregateInput = {
    cod_mensagem?: SortOrder;
  };

  export type mensagemMaxOrderByAggregateInput = {
    cod_mensagem?: SortOrder;
    desc_mensagem?: SortOrder;
  };

  export type mensagemMinOrderByAggregateInput = {
    cod_mensagem?: SortOrder;
    desc_mensagem?: SortOrder;
  };

  export type mensagemSumOrderByAggregateInput = {
    cod_mensagem?: SortOrder;
  };

  export type AreaScalarRelationFilter = {
    is?: areaWhereInput;
    isNot?: areaWhereInput;
  };

  export type FaseScalarRelationFilter = {
    is?: faseWhereInput;
    isNot?: faseWhereInput;
  };

  export type metaCodproj_metaCodarea_metaCodfase_metaCompoundUniqueInput = {
    codproj_meta: number;
    codarea_meta: number;
    codfase_meta: number;
  };

  export type metaCountOrderByAggregateInput = {
    codproj_meta?: SortOrder;
    codarea_meta?: SortOrder;
    codfase_meta?: SortOrder;
    tempo_meta?: SortOrder;
    altesc_meta?: SortOrder;
  };

  export type metaAvgOrderByAggregateInput = {
    codproj_meta?: SortOrder;
    codarea_meta?: SortOrder;
    codfase_meta?: SortOrder;
    tempo_meta?: SortOrder;
    altesc_meta?: SortOrder;
  };

  export type metaMaxOrderByAggregateInput = {
    codproj_meta?: SortOrder;
    codarea_meta?: SortOrder;
    codfase_meta?: SortOrder;
    tempo_meta?: SortOrder;
    altesc_meta?: SortOrder;
  };

  export type metaMinOrderByAggregateInput = {
    codproj_meta?: SortOrder;
    codarea_meta?: SortOrder;
    codfase_meta?: SortOrder;
    tempo_meta?: SortOrder;
    altesc_meta?: SortOrder;
  };

  export type metaSumOrderByAggregateInput = {
    codproj_meta?: SortOrder;
    codarea_meta?: SortOrder;
    codfase_meta?: SortOrder;
    tempo_meta?: SortOrder;
    altesc_meta?: SortOrder;
  };

  export type Acesso_sistemaListRelationFilter = {
    every?: acesso_sistemaWhereInput;
    some?: acesso_sistemaWhereInput;
    none?: acesso_sistemaWhereInput;
  };

  export type Tela_sistemaListRelationFilter = {
    every?: tela_sistemaWhereInput;
    some?: tela_sistemaWhereInput;
    none?: tela_sistemaWhereInput;
  };

  export type acesso_sistemaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type tela_sistemaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type modulo_sistemaCountOrderByAggregateInput = {
    cod_modulo?: SortOrder;
    desc_modulo?: SortOrder;
  };

  export type modulo_sistemaAvgOrderByAggregateInput = {
    cod_modulo?: SortOrder;
  };

  export type modulo_sistemaMaxOrderByAggregateInput = {
    cod_modulo?: SortOrder;
    desc_modulo?: SortOrder;
  };

  export type modulo_sistemaMinOrderByAggregateInput = {
    cod_modulo?: SortOrder;
    desc_modulo?: SortOrder;
  };

  export type modulo_sistemaSumOrderByAggregateInput = {
    cod_modulo?: SortOrder;
  };

  export type nfseCountOrderByAggregateInput = {
    cod_nfse?: SortOrder;
    num_nfse?: SortOrder;
    dtemissao_nfse?: SortOrder;
    hremissao_nfse?: SortOrder;
    cod_empresa?: SortOrder;
    cod_cliente?: SortOrder;
    discr_nfse?: SortOrder;
    cod_ctiss?: SortOrder;
    natoper_nfse?: SortOrder;
    regtrib_nfse?: SortOrder;
    vrtot_nfse?: SortOrder;
    vrded_nfse?: SortOrder;
    vrdesc1_nfse?: SortOrder;
    vrdesc2_nfse?: SortOrder;
    vrir_nfse?: SortOrder;
    vrpis_nfse?: SortOrder;
    vrcofins_nfse?: SortOrder;
    vrcsll_nfse?: SortOrder;
    vrout_nfse?: SortOrder;
    issret_nfse?: SortOrder;
    aliqiss_nfse?: SortOrder;
    vrinss_nfse?: SortOrder;
    doc_nfse?: SortOrder;
    aliqissret_nfse?: SortOrder;
    xml_nfse?: SortOrder;
    codver_nfse?: SortOrder;
    logtrans_nfse?: SortOrder;
    logcan_nfse?: SortOrder;
    xmlformat_nfse?: SortOrder;
    prot_nfse?: SortOrder;
    chvcan_nfse?: SortOrder;
    dtcanc_nfse?: SortOrder;
    tipoper_nfse?: SortOrder;
    opsimnac_nfse?: SortOrder;
    csll_nfse?: SortOrder;
    pis_nfse?: SortOrder;
    cofins_nfse?: SortOrder;
    irrf_nfse?: SortOrder;
  };

  export type nfseAvgOrderByAggregateInput = {
    cod_nfse?: SortOrder;
    cod_empresa?: SortOrder;
    cod_cliente?: SortOrder;
    cod_ctiss?: SortOrder;
    natoper_nfse?: SortOrder;
    regtrib_nfse?: SortOrder;
    vrtot_nfse?: SortOrder;
    vrded_nfse?: SortOrder;
    vrdesc1_nfse?: SortOrder;
    vrdesc2_nfse?: SortOrder;
    vrir_nfse?: SortOrder;
    vrpis_nfse?: SortOrder;
    vrcofins_nfse?: SortOrder;
    vrcsll_nfse?: SortOrder;
    vrout_nfse?: SortOrder;
    issret_nfse?: SortOrder;
    aliqiss_nfse?: SortOrder;
    vrinss_nfse?: SortOrder;
    aliqissret_nfse?: SortOrder;
    tipoper_nfse?: SortOrder;
    opsimnac_nfse?: SortOrder;
    csll_nfse?: SortOrder;
    pis_nfse?: SortOrder;
    cofins_nfse?: SortOrder;
    irrf_nfse?: SortOrder;
  };

  export type nfseMaxOrderByAggregateInput = {
    cod_nfse?: SortOrder;
    num_nfse?: SortOrder;
    dtemissao_nfse?: SortOrder;
    hremissao_nfse?: SortOrder;
    cod_empresa?: SortOrder;
    cod_cliente?: SortOrder;
    discr_nfse?: SortOrder;
    cod_ctiss?: SortOrder;
    natoper_nfse?: SortOrder;
    regtrib_nfse?: SortOrder;
    vrtot_nfse?: SortOrder;
    vrded_nfse?: SortOrder;
    vrdesc1_nfse?: SortOrder;
    vrdesc2_nfse?: SortOrder;
    vrir_nfse?: SortOrder;
    vrpis_nfse?: SortOrder;
    vrcofins_nfse?: SortOrder;
    vrcsll_nfse?: SortOrder;
    vrout_nfse?: SortOrder;
    issret_nfse?: SortOrder;
    aliqiss_nfse?: SortOrder;
    vrinss_nfse?: SortOrder;
    doc_nfse?: SortOrder;
    aliqissret_nfse?: SortOrder;
    xml_nfse?: SortOrder;
    codver_nfse?: SortOrder;
    logtrans_nfse?: SortOrder;
    logcan_nfse?: SortOrder;
    xmlformat_nfse?: SortOrder;
    prot_nfse?: SortOrder;
    chvcan_nfse?: SortOrder;
    dtcanc_nfse?: SortOrder;
    tipoper_nfse?: SortOrder;
    opsimnac_nfse?: SortOrder;
    csll_nfse?: SortOrder;
    pis_nfse?: SortOrder;
    cofins_nfse?: SortOrder;
    irrf_nfse?: SortOrder;
  };

  export type nfseMinOrderByAggregateInput = {
    cod_nfse?: SortOrder;
    num_nfse?: SortOrder;
    dtemissao_nfse?: SortOrder;
    hremissao_nfse?: SortOrder;
    cod_empresa?: SortOrder;
    cod_cliente?: SortOrder;
    discr_nfse?: SortOrder;
    cod_ctiss?: SortOrder;
    natoper_nfse?: SortOrder;
    regtrib_nfse?: SortOrder;
    vrtot_nfse?: SortOrder;
    vrded_nfse?: SortOrder;
    vrdesc1_nfse?: SortOrder;
    vrdesc2_nfse?: SortOrder;
    vrir_nfse?: SortOrder;
    vrpis_nfse?: SortOrder;
    vrcofins_nfse?: SortOrder;
    vrcsll_nfse?: SortOrder;
    vrout_nfse?: SortOrder;
    issret_nfse?: SortOrder;
    aliqiss_nfse?: SortOrder;
    vrinss_nfse?: SortOrder;
    doc_nfse?: SortOrder;
    aliqissret_nfse?: SortOrder;
    xml_nfse?: SortOrder;
    codver_nfse?: SortOrder;
    logtrans_nfse?: SortOrder;
    logcan_nfse?: SortOrder;
    xmlformat_nfse?: SortOrder;
    prot_nfse?: SortOrder;
    chvcan_nfse?: SortOrder;
    dtcanc_nfse?: SortOrder;
    tipoper_nfse?: SortOrder;
    opsimnac_nfse?: SortOrder;
    csll_nfse?: SortOrder;
    pis_nfse?: SortOrder;
    cofins_nfse?: SortOrder;
    irrf_nfse?: SortOrder;
  };

  export type nfseSumOrderByAggregateInput = {
    cod_nfse?: SortOrder;
    cod_empresa?: SortOrder;
    cod_cliente?: SortOrder;
    cod_ctiss?: SortOrder;
    natoper_nfse?: SortOrder;
    regtrib_nfse?: SortOrder;
    vrtot_nfse?: SortOrder;
    vrded_nfse?: SortOrder;
    vrdesc1_nfse?: SortOrder;
    vrdesc2_nfse?: SortOrder;
    vrir_nfse?: SortOrder;
    vrpis_nfse?: SortOrder;
    vrcofins_nfse?: SortOrder;
    vrcsll_nfse?: SortOrder;
    vrout_nfse?: SortOrder;
    issret_nfse?: SortOrder;
    aliqiss_nfse?: SortOrder;
    vrinss_nfse?: SortOrder;
    aliqissret_nfse?: SortOrder;
    tipoper_nfse?: SortOrder;
    opsimnac_nfse?: SortOrder;
    csll_nfse?: SortOrder;
    pis_nfse?: SortOrder;
    cofins_nfse?: SortOrder;
    irrf_nfse?: SortOrder;
  };

  export type RecursoListRelationFilter = {
    every?: recursoWhereInput;
    some?: recursoWhereInput;
    none?: recursoWhereInput;
  };

  export type recursoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type nivelCountOrderByAggregateInput = {
    cod_nivel?: SortOrder;
    nome_nivel?: SortOrder;
    perc_nivel?: SortOrder;
  };

  export type nivelAvgOrderByAggregateInput = {
    cod_nivel?: SortOrder;
    perc_nivel?: SortOrder;
  };

  export type nivelMaxOrderByAggregateInput = {
    cod_nivel?: SortOrder;
    nome_nivel?: SortOrder;
    perc_nivel?: SortOrder;
  };

  export type nivelMinOrderByAggregateInput = {
    cod_nivel?: SortOrder;
    nome_nivel?: SortOrder;
    perc_nivel?: SortOrder;
  };

  export type nivelSumOrderByAggregateInput = {
    cod_nivel?: SortOrder;
    perc_nivel?: SortOrder;
  };

  export type TarefaScalarRelationFilter = {
    is?: tarefaWhereInput;
    isNot?: tarefaWhereInput;
  };

  export type osCountOrderByAggregateInput = {
    cod_os?: SortOrder;
    codtrf_os?: SortOrder;
    dtini_os?: SortOrder;
    hrini_os?: SortOrder;
    hrfim_os?: SortOrder;
    obs_os?: SortOrder;
    status_os?: SortOrder;
    produtivo_os?: SortOrder;
    codrec_os?: SortOrder;
    produtivo2_os?: SortOrder;
    respcli_os?: SortOrder;
    remdes_os?: SortOrder;
    abono_os?: SortOrder;
    desloc_os?: SortOrder;
    obs?: SortOrder;
    dtinc_os?: SortOrder;
    faturado_os?: SortOrder;
    perc_os?: SortOrder;
    cod_faturamento?: SortOrder;
    comp_os?: SortOrder;
    valid_os?: SortOrder;
    vrhr_os?: SortOrder;
    num_os?: SortOrder;
    chamado_os?: SortOrder;
  };

  export type osAvgOrderByAggregateInput = {
    cod_os?: SortOrder;
    codtrf_os?: SortOrder;
    status_os?: SortOrder;
    codrec_os?: SortOrder;
    perc_os?: SortOrder;
    cod_faturamento?: SortOrder;
    vrhr_os?: SortOrder;
  };

  export type osMaxOrderByAggregateInput = {
    cod_os?: SortOrder;
    codtrf_os?: SortOrder;
    dtini_os?: SortOrder;
    hrini_os?: SortOrder;
    hrfim_os?: SortOrder;
    obs_os?: SortOrder;
    status_os?: SortOrder;
    produtivo_os?: SortOrder;
    codrec_os?: SortOrder;
    produtivo2_os?: SortOrder;
    respcli_os?: SortOrder;
    remdes_os?: SortOrder;
    abono_os?: SortOrder;
    desloc_os?: SortOrder;
    obs?: SortOrder;
    dtinc_os?: SortOrder;
    faturado_os?: SortOrder;
    perc_os?: SortOrder;
    cod_faturamento?: SortOrder;
    comp_os?: SortOrder;
    valid_os?: SortOrder;
    vrhr_os?: SortOrder;
    num_os?: SortOrder;
    chamado_os?: SortOrder;
  };

  export type osMinOrderByAggregateInput = {
    cod_os?: SortOrder;
    codtrf_os?: SortOrder;
    dtini_os?: SortOrder;
    hrini_os?: SortOrder;
    hrfim_os?: SortOrder;
    obs_os?: SortOrder;
    status_os?: SortOrder;
    produtivo_os?: SortOrder;
    codrec_os?: SortOrder;
    produtivo2_os?: SortOrder;
    respcli_os?: SortOrder;
    remdes_os?: SortOrder;
    abono_os?: SortOrder;
    desloc_os?: SortOrder;
    obs?: SortOrder;
    dtinc_os?: SortOrder;
    faturado_os?: SortOrder;
    perc_os?: SortOrder;
    cod_faturamento?: SortOrder;
    comp_os?: SortOrder;
    valid_os?: SortOrder;
    vrhr_os?: SortOrder;
    num_os?: SortOrder;
    chamado_os?: SortOrder;
  };

  export type osSumOrderByAggregateInput = {
    cod_os?: SortOrder;
    codtrf_os?: SortOrder;
    status_os?: SortOrder;
    codrec_os?: SortOrder;
    perc_os?: SortOrder;
    cod_faturamento?: SortOrder;
    vrhr_os?: SortOrder;
  };

  export type parametrosCountOrderByAggregateInput = {
    cod_parametro?: SortOrder;
    descr_parametro?: SortOrder;
    valor_parametro?: SortOrder;
  };

  export type parametrosAvgOrderByAggregateInput = {
    cod_parametro?: SortOrder;
  };

  export type parametrosMaxOrderByAggregateInput = {
    cod_parametro?: SortOrder;
    descr_parametro?: SortOrder;
    valor_parametro?: SortOrder;
  };

  export type parametrosMinOrderByAggregateInput = {
    cod_parametro?: SortOrder;
    descr_parametro?: SortOrder;
    valor_parametro?: SortOrder;
  };

  export type parametrosSumOrderByAggregateInput = {
    cod_parametro?: SortOrder;
  };

  export type parcelaCountOrderByAggregateInput = {
    cod_parcela?: SortOrder;
    cod_lista?: SortOrder;
    data_parcela?: SortOrder;
    venc_parcela?: SortOrder;
    pag_parcela?: SortOrder;
    valor_parcela?: SortOrder;
    juros_parcela?: SortOrder;
    multa_parcela?: SortOrder;
    desconto_parcela?: SortOrder;
    status_parcela?: SortOrder;
    id_parcela?: SortOrder;
  };

  export type parcelaAvgOrderByAggregateInput = {
    cod_parcela?: SortOrder;
    cod_lista?: SortOrder;
    valor_parcela?: SortOrder;
    juros_parcela?: SortOrder;
    multa_parcela?: SortOrder;
    desconto_parcela?: SortOrder;
  };

  export type parcelaMaxOrderByAggregateInput = {
    cod_parcela?: SortOrder;
    cod_lista?: SortOrder;
    data_parcela?: SortOrder;
    venc_parcela?: SortOrder;
    pag_parcela?: SortOrder;
    valor_parcela?: SortOrder;
    juros_parcela?: SortOrder;
    multa_parcela?: SortOrder;
    desconto_parcela?: SortOrder;
    status_parcela?: SortOrder;
    id_parcela?: SortOrder;
  };

  export type parcelaMinOrderByAggregateInput = {
    cod_parcela?: SortOrder;
    cod_lista?: SortOrder;
    data_parcela?: SortOrder;
    venc_parcela?: SortOrder;
    pag_parcela?: SortOrder;
    valor_parcela?: SortOrder;
    juros_parcela?: SortOrder;
    multa_parcela?: SortOrder;
    desconto_parcela?: SortOrder;
    status_parcela?: SortOrder;
    id_parcela?: SortOrder;
  };

  export type parcelaSumOrderByAggregateInput = {
    cod_parcela?: SortOrder;
    cod_lista?: SortOrder;
    valor_parcela?: SortOrder;
    juros_parcela?: SortOrder;
    multa_parcela?: SortOrder;
    desconto_parcela?: SortOrder;
  };

  export type pautaCountOrderByAggregateInput = {
    cod_pauta?: SortOrder;
    cod_recurso?: SortOrder;
    data_pauta?: SortOrder;
    prazo_pauta?: SortOrder;
    concl_pauta?: SortOrder;
    desc_pauta?: SortOrder;
    obs_pauta?: SortOrder;
  };

  export type pautaAvgOrderByAggregateInput = {
    cod_pauta?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type pautaMaxOrderByAggregateInput = {
    cod_pauta?: SortOrder;
    cod_recurso?: SortOrder;
    data_pauta?: SortOrder;
    prazo_pauta?: SortOrder;
    concl_pauta?: SortOrder;
    desc_pauta?: SortOrder;
    obs_pauta?: SortOrder;
  };

  export type pautaMinOrderByAggregateInput = {
    cod_pauta?: SortOrder;
    cod_recurso?: SortOrder;
    data_pauta?: SortOrder;
    prazo_pauta?: SortOrder;
    concl_pauta?: SortOrder;
    desc_pauta?: SortOrder;
    obs_pauta?: SortOrder;
  };

  export type pautaSumOrderByAggregateInput = {
    cod_pauta?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type pontoCountOrderByAggregateInput = {
    cod_ponto?: SortOrder;
    entrada_ponto?: SortOrder;
    saida_ponto?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type pontoAvgOrderByAggregateInput = {
    cod_ponto?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type pontoMaxOrderByAggregateInput = {
    cod_ponto?: SortOrder;
    entrada_ponto?: SortOrder;
    saida_ponto?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type pontoMinOrderByAggregateInput = {
    cod_ponto?: SortOrder;
    entrada_ponto?: SortOrder;
    saida_ponto?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type pontoSumOrderByAggregateInput = {
    cod_ponto?: SortOrder;
    cod_recurso?: SortOrder;
  };

  export type AvaliacaoListRelationFilter = {
    every?: avaliacaoWhereInput;
    some?: avaliacaoWhereInput;
    none?: avaliacaoWhereInput;
  };

  export type ValorListRelationFilter = {
    every?: valorWhereInput;
    some?: valorWhereInput;
    none?: valorWhereInput;
  };

  export type avaliacaoOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type valorOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type projetoCountOrderByAggregateInput = {
    cod_projeto?: SortOrder;
    nome_projeto?: SortOrder;
    codcli_projeto?: SortOrder;
    respcli_projeto?: SortOrder;
    proposta_projeto?: SortOrder;
    codrec_projeto?: SortOrder;
    perc_projeto?: SortOrder;
    loginc_projeto?: SortOrder;
    logalt_projeto?: SortOrder;
    qtdhoras_projeto?: SortOrder;
    status_projeto?: SortOrder;
  };

  export type projetoAvgOrderByAggregateInput = {
    cod_projeto?: SortOrder;
    codcli_projeto?: SortOrder;
    codrec_projeto?: SortOrder;
    perc_projeto?: SortOrder;
    qtdhoras_projeto?: SortOrder;
  };

  export type projetoMaxOrderByAggregateInput = {
    cod_projeto?: SortOrder;
    nome_projeto?: SortOrder;
    codcli_projeto?: SortOrder;
    respcli_projeto?: SortOrder;
    proposta_projeto?: SortOrder;
    codrec_projeto?: SortOrder;
    perc_projeto?: SortOrder;
    loginc_projeto?: SortOrder;
    logalt_projeto?: SortOrder;
    qtdhoras_projeto?: SortOrder;
    status_projeto?: SortOrder;
  };

  export type projetoMinOrderByAggregateInput = {
    cod_projeto?: SortOrder;
    nome_projeto?: SortOrder;
    codcli_projeto?: SortOrder;
    respcli_projeto?: SortOrder;
    proposta_projeto?: SortOrder;
    codrec_projeto?: SortOrder;
    perc_projeto?: SortOrder;
    loginc_projeto?: SortOrder;
    logalt_projeto?: SortOrder;
    qtdhoras_projeto?: SortOrder;
    status_projeto?: SortOrder;
  };

  export type projetoSumOrderByAggregateInput = {
    cod_projeto?: SortOrder;
    codcli_projeto?: SortOrder;
    codrec_projeto?: SortOrder;
    perc_projeto?: SortOrder;
    qtdhoras_projeto?: SortOrder;
  };

  export type AgenrecListRelationFilter = {
    every?: agenrecWhereInput;
    some?: agenrecWhereInput;
    none?: agenrecWhereInput;
  };

  export type NivelScalarRelationFilter = {
    is?: nivelWhereInput;
    isNot?: nivelWhereInput;
  };

  export type agenrecOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type recursoCountOrderByAggregateInput = {
    cod_recurso?: SortOrder;
    nome_recurso?: SortOrder;
    fone_recurso?: SortOrder;
    ativo_recurso?: SortOrder;
    codusr_recurso?: SortOrder;
    cod_nivel?: SortOrder;
    hrdia_recurso?: SortOrder;
    percprod_recurso?: SortOrder;
    email_recurso?: SortOrder;
    dtlimite_recurso?: SortOrder;
    permapo_recurso?: SortOrder;
    matr_recurso?: SortOrder;
    obs_recurso?: SortOrder;
    custo_recurso?: SortOrder;
    receita_recurso?: SortOrder;
    tpcusto_recurso?: SortOrder;
  };

  export type recursoAvgOrderByAggregateInput = {
    cod_recurso?: SortOrder;
    ativo_recurso?: SortOrder;
    codusr_recurso?: SortOrder;
    cod_nivel?: SortOrder;
    percprod_recurso?: SortOrder;
    custo_recurso?: SortOrder;
    receita_recurso?: SortOrder;
    tpcusto_recurso?: SortOrder;
  };

  export type recursoMaxOrderByAggregateInput = {
    cod_recurso?: SortOrder;
    nome_recurso?: SortOrder;
    fone_recurso?: SortOrder;
    ativo_recurso?: SortOrder;
    codusr_recurso?: SortOrder;
    cod_nivel?: SortOrder;
    hrdia_recurso?: SortOrder;
    percprod_recurso?: SortOrder;
    email_recurso?: SortOrder;
    dtlimite_recurso?: SortOrder;
    permapo_recurso?: SortOrder;
    matr_recurso?: SortOrder;
    obs_recurso?: SortOrder;
    custo_recurso?: SortOrder;
    receita_recurso?: SortOrder;
    tpcusto_recurso?: SortOrder;
  };

  export type recursoMinOrderByAggregateInput = {
    cod_recurso?: SortOrder;
    nome_recurso?: SortOrder;
    fone_recurso?: SortOrder;
    ativo_recurso?: SortOrder;
    codusr_recurso?: SortOrder;
    cod_nivel?: SortOrder;
    hrdia_recurso?: SortOrder;
    percprod_recurso?: SortOrder;
    email_recurso?: SortOrder;
    dtlimite_recurso?: SortOrder;
    permapo_recurso?: SortOrder;
    matr_recurso?: SortOrder;
    obs_recurso?: SortOrder;
    custo_recurso?: SortOrder;
    receita_recurso?: SortOrder;
    tpcusto_recurso?: SortOrder;
  };

  export type recursoSumOrderByAggregateInput = {
    cod_recurso?: SortOrder;
    ativo_recurso?: SortOrder;
    codusr_recurso?: SortOrder;
    cod_nivel?: SortOrder;
    percprod_recurso?: SortOrder;
    custo_recurso?: SortOrder;
    receita_recurso?: SortOrder;
    tpcusto_recurso?: SortOrder;
  };

  export type resconCountOrderByAggregateInput = {
    cod_rescon?: SortOrder;
    cod_fatura?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_rescon?: SortOrder;
    hrnfat_rescon?: SortOrder;
    vrfat_rescon?: SortOrder;
    vrnfat_rescon?: SortOrder;
    realizado_rescon?: SortOrder;
    disponivel_rescon?: SortOrder;
    perc1_rescon?: SortOrder;
    perc2_rescon?: SortOrder;
    perc3_rescon?: SortOrder;
    custo_rescon?: SortOrder;
    contrib_rescon?: SortOrder;
    perccontrib_rescon?: SortOrder;
    hrbase_rescon?: SortOrder;
    mo_rescon?: SortOrder;
    desp_rescon?: SortOrder;
  };

  export type resconAvgOrderByAggregateInput = {
    cod_rescon?: SortOrder;
    cod_fatura?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_rescon?: SortOrder;
    hrnfat_rescon?: SortOrder;
    vrfat_rescon?: SortOrder;
    vrnfat_rescon?: SortOrder;
    realizado_rescon?: SortOrder;
    disponivel_rescon?: SortOrder;
    perc1_rescon?: SortOrder;
    perc2_rescon?: SortOrder;
    perc3_rescon?: SortOrder;
    custo_rescon?: SortOrder;
    contrib_rescon?: SortOrder;
    perccontrib_rescon?: SortOrder;
    hrbase_rescon?: SortOrder;
    mo_rescon?: SortOrder;
    desp_rescon?: SortOrder;
  };

  export type resconMaxOrderByAggregateInput = {
    cod_rescon?: SortOrder;
    cod_fatura?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_rescon?: SortOrder;
    hrnfat_rescon?: SortOrder;
    vrfat_rescon?: SortOrder;
    vrnfat_rescon?: SortOrder;
    realizado_rescon?: SortOrder;
    disponivel_rescon?: SortOrder;
    perc1_rescon?: SortOrder;
    perc2_rescon?: SortOrder;
    perc3_rescon?: SortOrder;
    custo_rescon?: SortOrder;
    contrib_rescon?: SortOrder;
    perccontrib_rescon?: SortOrder;
    hrbase_rescon?: SortOrder;
    mo_rescon?: SortOrder;
    desp_rescon?: SortOrder;
  };

  export type resconMinOrderByAggregateInput = {
    cod_rescon?: SortOrder;
    cod_fatura?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_rescon?: SortOrder;
    hrnfat_rescon?: SortOrder;
    vrfat_rescon?: SortOrder;
    vrnfat_rescon?: SortOrder;
    realizado_rescon?: SortOrder;
    disponivel_rescon?: SortOrder;
    perc1_rescon?: SortOrder;
    perc2_rescon?: SortOrder;
    perc3_rescon?: SortOrder;
    custo_rescon?: SortOrder;
    contrib_rescon?: SortOrder;
    perccontrib_rescon?: SortOrder;
    hrbase_rescon?: SortOrder;
    mo_rescon?: SortOrder;
    desp_rescon?: SortOrder;
  };

  export type resconSumOrderByAggregateInput = {
    cod_rescon?: SortOrder;
    cod_fatura?: SortOrder;
    cod_recurso?: SortOrder;
    hrfat_rescon?: SortOrder;
    hrnfat_rescon?: SortOrder;
    vrfat_rescon?: SortOrder;
    vrnfat_rescon?: SortOrder;
    realizado_rescon?: SortOrder;
    disponivel_rescon?: SortOrder;
    perc1_rescon?: SortOrder;
    perc2_rescon?: SortOrder;
    perc3_rescon?: SortOrder;
    custo_rescon?: SortOrder;
    contrib_rescon?: SortOrder;
    perccontrib_rescon?: SortOrder;
    hrbase_rescon?: SortOrder;
    mo_rescon?: SortOrder;
    desp_rescon?: SortOrder;
  };

  export type statusCountOrderByAggregateInput = {
    cod_status?: SortOrder;
    desc_status?: SortOrder;
  };

  export type statusAvgOrderByAggregateInput = {
    cod_status?: SortOrder;
  };

  export type statusMaxOrderByAggregateInput = {
    cod_status?: SortOrder;
    desc_status?: SortOrder;
  };

  export type statusMinOrderByAggregateInput = {
    cod_status?: SortOrder;
    desc_status?: SortOrder;
  };

  export type statusSumOrderByAggregateInput = {
    cod_status?: SortOrder;
  };

  export type OsListRelationFilter = {
    every?: osWhereInput;
    some?: osWhereInput;
    none?: osWhereInput;
  };

  export type osOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type tarefaCountOrderByAggregateInput = {
    cod_tarefa?: SortOrder;
    nome_tarefa?: SortOrder;
    codpro_tarefa?: SortOrder;
    codrec_tarefa?: SortOrder;
    dtsol_tarefa?: SortOrder;
    dtaprov_tarefa?: SortOrder;
    dtprevent_tarefa?: SortOrder;
    hrest_tarefa?: SortOrder;
    hratesc_tarefa?: SortOrder;
    margem_tarefa?: SortOrder;
    status_tarefa?: SortOrder;
    ordem_tarefa?: SortOrder;
    cod_area?: SortOrder;
    estimado_tarefa?: SortOrder;
    cod_tipotrf?: SortOrder;
    codrecresp_tarefa?: SortOrder;
    hrreal_tarefa?: SortOrder;
    fatest_tarefa?: SortOrder;
    cod_fase?: SortOrder;
    valini_tarefa?: SortOrder;
    valfim_tarefa?: SortOrder;
    perimp_tarefa?: SortOrder;
    dtinc_tarefa?: SortOrder;
    perc_tarefa?: SortOrder;
    fatura_tarefa?: SortOrder;
    valida_tarefa?: SortOrder;
    vrhr_tarefa?: SortOrder;
    obs_tarefa?: SortOrder;
    limmes_tarefa?: SortOrder;
    exibecham_tarefa?: SortOrder;
  };

  export type tarefaAvgOrderByAggregateInput = {
    cod_tarefa?: SortOrder;
    codpro_tarefa?: SortOrder;
    codrec_tarefa?: SortOrder;
    hrest_tarefa?: SortOrder;
    hratesc_tarefa?: SortOrder;
    status_tarefa?: SortOrder;
    ordem_tarefa?: SortOrder;
    cod_area?: SortOrder;
    cod_tipotrf?: SortOrder;
    codrecresp_tarefa?: SortOrder;
    hrreal_tarefa?: SortOrder;
    cod_fase?: SortOrder;
    perc_tarefa?: SortOrder;
    valida_tarefa?: SortOrder;
    vrhr_tarefa?: SortOrder;
    limmes_tarefa?: SortOrder;
    exibecham_tarefa?: SortOrder;
  };

  export type tarefaMaxOrderByAggregateInput = {
    cod_tarefa?: SortOrder;
    nome_tarefa?: SortOrder;
    codpro_tarefa?: SortOrder;
    codrec_tarefa?: SortOrder;
    dtsol_tarefa?: SortOrder;
    dtaprov_tarefa?: SortOrder;
    dtprevent_tarefa?: SortOrder;
    hrest_tarefa?: SortOrder;
    hratesc_tarefa?: SortOrder;
    margem_tarefa?: SortOrder;
    status_tarefa?: SortOrder;
    ordem_tarefa?: SortOrder;
    cod_area?: SortOrder;
    estimado_tarefa?: SortOrder;
    cod_tipotrf?: SortOrder;
    codrecresp_tarefa?: SortOrder;
    hrreal_tarefa?: SortOrder;
    fatest_tarefa?: SortOrder;
    cod_fase?: SortOrder;
    valini_tarefa?: SortOrder;
    valfim_tarefa?: SortOrder;
    perimp_tarefa?: SortOrder;
    dtinc_tarefa?: SortOrder;
    perc_tarefa?: SortOrder;
    fatura_tarefa?: SortOrder;
    valida_tarefa?: SortOrder;
    vrhr_tarefa?: SortOrder;
    obs_tarefa?: SortOrder;
    limmes_tarefa?: SortOrder;
    exibecham_tarefa?: SortOrder;
  };

  export type tarefaMinOrderByAggregateInput = {
    cod_tarefa?: SortOrder;
    nome_tarefa?: SortOrder;
    codpro_tarefa?: SortOrder;
    codrec_tarefa?: SortOrder;
    dtsol_tarefa?: SortOrder;
    dtaprov_tarefa?: SortOrder;
    dtprevent_tarefa?: SortOrder;
    hrest_tarefa?: SortOrder;
    hratesc_tarefa?: SortOrder;
    margem_tarefa?: SortOrder;
    status_tarefa?: SortOrder;
    ordem_tarefa?: SortOrder;
    cod_area?: SortOrder;
    estimado_tarefa?: SortOrder;
    cod_tipotrf?: SortOrder;
    codrecresp_tarefa?: SortOrder;
    hrreal_tarefa?: SortOrder;
    fatest_tarefa?: SortOrder;
    cod_fase?: SortOrder;
    valini_tarefa?: SortOrder;
    valfim_tarefa?: SortOrder;
    perimp_tarefa?: SortOrder;
    dtinc_tarefa?: SortOrder;
    perc_tarefa?: SortOrder;
    fatura_tarefa?: SortOrder;
    valida_tarefa?: SortOrder;
    vrhr_tarefa?: SortOrder;
    obs_tarefa?: SortOrder;
    limmes_tarefa?: SortOrder;
    exibecham_tarefa?: SortOrder;
  };

  export type tarefaSumOrderByAggregateInput = {
    cod_tarefa?: SortOrder;
    codpro_tarefa?: SortOrder;
    codrec_tarefa?: SortOrder;
    hrest_tarefa?: SortOrder;
    hratesc_tarefa?: SortOrder;
    status_tarefa?: SortOrder;
    ordem_tarefa?: SortOrder;
    cod_area?: SortOrder;
    cod_tipotrf?: SortOrder;
    codrecresp_tarefa?: SortOrder;
    hrreal_tarefa?: SortOrder;
    cod_fase?: SortOrder;
    perc_tarefa?: SortOrder;
    valida_tarefa?: SortOrder;
    vrhr_tarefa?: SortOrder;
    limmes_tarefa?: SortOrder;
    exibecham_tarefa?: SortOrder;
  };

  export type tela_sistemaCod_telaCod_moduloCompoundUniqueInput = {
    cod_tela: number;
    cod_modulo: number;
  };

  export type tela_sistemaCountOrderByAggregateInput = {
    cod_tela?: SortOrder;
    cod_modulo?: SortOrder;
    desc_tela?: SortOrder;
  };

  export type tela_sistemaAvgOrderByAggregateInput = {
    cod_tela?: SortOrder;
    cod_modulo?: SortOrder;
  };

  export type tela_sistemaMaxOrderByAggregateInput = {
    cod_tela?: SortOrder;
    cod_modulo?: SortOrder;
    desc_tela?: SortOrder;
  };

  export type tela_sistemaMinOrderByAggregateInput = {
    cod_tela?: SortOrder;
    cod_modulo?: SortOrder;
    desc_tela?: SortOrder;
  };

  export type tela_sistemaSumOrderByAggregateInput = {
    cod_tela?: SortOrder;
    cod_modulo?: SortOrder;
  };

  export type telefoneCountOrderByAggregateInput = {
    cod_telefone?: SortOrder;
    cod_lista?: SortOrder;
    ddd_telefone?: SortOrder;
    numero_telefone?: SortOrder;
    desc_telefone?: SortOrder;
  };

  export type telefoneAvgOrderByAggregateInput = {
    cod_telefone?: SortOrder;
    cod_lista?: SortOrder;
  };

  export type telefoneMaxOrderByAggregateInput = {
    cod_telefone?: SortOrder;
    cod_lista?: SortOrder;
    ddd_telefone?: SortOrder;
    numero_telefone?: SortOrder;
    desc_telefone?: SortOrder;
  };

  export type telefoneMinOrderByAggregateInput = {
    cod_telefone?: SortOrder;
    cod_lista?: SortOrder;
    ddd_telefone?: SortOrder;
    numero_telefone?: SortOrder;
    desc_telefone?: SortOrder;
  };

  export type telefoneSumOrderByAggregateInput = {
    cod_telefone?: SortOrder;
    cod_lista?: SortOrder;
  };

  export type tipotrfCountOrderByAggregateInput = {
    cod_tipotrf?: SortOrder;
    nome_tipotrf?: SortOrder;
  };

  export type tipotrfAvgOrderByAggregateInput = {
    cod_tipotrf?: SortOrder;
  };

  export type tipotrfMaxOrderByAggregateInput = {
    cod_tipotrf?: SortOrder;
    nome_tipotrf?: SortOrder;
  };

  export type tipotrfMinOrderByAggregateInput = {
    cod_tipotrf?: SortOrder;
    nome_tipotrf?: SortOrder;
  };

  export type tipotrfSumOrderByAggregateInput = {
    cod_tipotrf?: SortOrder;
  };

  export type tpdespCountOrderByAggregateInput = {
    cod_tpdesp?: SortOrder;
    nome_tpdesp?: SortOrder;
  };

  export type tpdespAvgOrderByAggregateInput = {
    cod_tpdesp?: SortOrder;
  };

  export type tpdespMaxOrderByAggregateInput = {
    cod_tpdesp?: SortOrder;
    nome_tpdesp?: SortOrder;
  };

  export type tpdespMinOrderByAggregateInput = {
    cod_tpdesp?: SortOrder;
    nome_tpdesp?: SortOrder;
  };

  export type tpdespSumOrderByAggregateInput = {
    cod_tpdesp?: SortOrder;
  };

  export type usuarioCountOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    nome_usuario?: SortOrder;
    id_usuario?: SortOrder;
    senha?: SortOrder;
    tipo_usuario?: SortOrder;
    permtar_usuario?: SortOrder;
    altsen_usuario?: SortOrder;
    perproj1_usuario?: SortOrder;
    perproj2_usuario?: SortOrder;
    tela1_usuario?: SortOrder;
    tela2_usuario?: SortOrder;
    tela3_usuario?: SortOrder;
    tela4_usuario?: SortOrder;
  };

  export type usuarioAvgOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    altsen_usuario?: SortOrder;
    tela1_usuario?: SortOrder;
    tela2_usuario?: SortOrder;
    tela3_usuario?: SortOrder;
    tela4_usuario?: SortOrder;
  };

  export type usuarioMaxOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    nome_usuario?: SortOrder;
    id_usuario?: SortOrder;
    senha?: SortOrder;
    tipo_usuario?: SortOrder;
    permtar_usuario?: SortOrder;
    altsen_usuario?: SortOrder;
    perproj1_usuario?: SortOrder;
    perproj2_usuario?: SortOrder;
    tela1_usuario?: SortOrder;
    tela2_usuario?: SortOrder;
    tela3_usuario?: SortOrder;
    tela4_usuario?: SortOrder;
  };

  export type usuarioMinOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    nome_usuario?: SortOrder;
    id_usuario?: SortOrder;
    senha?: SortOrder;
    tipo_usuario?: SortOrder;
    permtar_usuario?: SortOrder;
    altsen_usuario?: SortOrder;
    perproj1_usuario?: SortOrder;
    perproj2_usuario?: SortOrder;
    tela1_usuario?: SortOrder;
    tela2_usuario?: SortOrder;
    tela3_usuario?: SortOrder;
    tela4_usuario?: SortOrder;
  };

  export type usuarioSumOrderByAggregateInput = {
    cod_usuario?: SortOrder;
    altsen_usuario?: SortOrder;
    tela1_usuario?: SortOrder;
    tela2_usuario?: SortOrder;
    tela3_usuario?: SortOrder;
    tela4_usuario?: SortOrder;
  };

  export type TipotrfScalarRelationFilter = {
    is?: tipotrfWhereInput;
    isNot?: tipotrfWhereInput;
  };

  export type valorCodproj_valorCodtipo_valorCompoundUniqueInput = {
    codproj_valor: number;
    codtipo_valor: number;
  };

  export type valorCountOrderByAggregateInput = {
    codproj_valor?: SortOrder;
    codtipo_valor?: SortOrder;
    preco_valor?: SortOrder;
  };

  export type valorAvgOrderByAggregateInput = {
    codproj_valor?: SortOrder;
    codtipo_valor?: SortOrder;
    preco_valor?: SortOrder;
  };

  export type valorMaxOrderByAggregateInput = {
    codproj_valor?: SortOrder;
    codtipo_valor?: SortOrder;
    preco_valor?: SortOrder;
  };

  export type valorMinOrderByAggregateInput = {
    codproj_valor?: SortOrder;
    codtipo_valor?: SortOrder;
    preco_valor?: SortOrder;
  };

  export type valorSumOrderByAggregateInput = {
    codproj_valor?: SortOrder;
    codtipo_valor?: SortOrder;
    preco_valor?: SortOrder;
  };

  export type modulo_sistemaCreateNestedOneWithoutAcesso_sistemaInput = {
    create?: XOR<
      modulo_sistemaCreateWithoutAcesso_sistemaInput,
      modulo_sistemaUncheckedCreateWithoutAcesso_sistemaInput
    >;
    connectOrCreate?: modulo_sistemaCreateOrConnectWithoutAcesso_sistemaInput;
    connect?: modulo_sistemaWhereUniqueInput;
  };

  export type tela_sistemaCreateNestedOneWithoutAcesso_sistemaInput = {
    create?: XOR<
      tela_sistemaCreateWithoutAcesso_sistemaInput,
      tela_sistemaUncheckedCreateWithoutAcesso_sistemaInput
    >;
    connectOrCreate?: tela_sistemaCreateOrConnectWithoutAcesso_sistemaInput;
    connect?: tela_sistemaWhereUniqueInput;
  };

  export type usuarioCreateNestedOneWithoutAcesso_sistemaInput = {
    create?: XOR<
      usuarioCreateWithoutAcesso_sistemaInput,
      usuarioUncheckedCreateWithoutAcesso_sistemaInput
    >;
    connectOrCreate?: usuarioCreateOrConnectWithoutAcesso_sistemaInput;
    connect?: usuarioWhereUniqueInput;
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type modulo_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput =
    {
      create?: XOR<
        modulo_sistemaCreateWithoutAcesso_sistemaInput,
        modulo_sistemaUncheckedCreateWithoutAcesso_sistemaInput
      >;
      connectOrCreate?: modulo_sistemaCreateOrConnectWithoutAcesso_sistemaInput;
      upsert?: modulo_sistemaUpsertWithoutAcesso_sistemaInput;
      connect?: modulo_sistemaWhereUniqueInput;
      update?: XOR<
        XOR<
          modulo_sistemaUpdateToOneWithWhereWithoutAcesso_sistemaInput,
          modulo_sistemaUpdateWithoutAcesso_sistemaInput
        >,
        modulo_sistemaUncheckedUpdateWithoutAcesso_sistemaInput
      >;
    };

  export type tela_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput = {
    create?: XOR<
      tela_sistemaCreateWithoutAcesso_sistemaInput,
      tela_sistemaUncheckedCreateWithoutAcesso_sistemaInput
    >;
    connectOrCreate?: tela_sistemaCreateOrConnectWithoutAcesso_sistemaInput;
    upsert?: tela_sistemaUpsertWithoutAcesso_sistemaInput;
    connect?: tela_sistemaWhereUniqueInput;
    update?: XOR<
      XOR<
        tela_sistemaUpdateToOneWithWhereWithoutAcesso_sistemaInput,
        tela_sistemaUpdateWithoutAcesso_sistemaInput
      >,
      tela_sistemaUncheckedUpdateWithoutAcesso_sistemaInput
    >;
  };

  export type usuarioUpdateOneRequiredWithoutAcesso_sistemaNestedInput = {
    create?: XOR<
      usuarioCreateWithoutAcesso_sistemaInput,
      usuarioUncheckedCreateWithoutAcesso_sistemaInput
    >;
    connectOrCreate?: usuarioCreateOrConnectWithoutAcesso_sistemaInput;
    upsert?: usuarioUpsertWithoutAcesso_sistemaInput;
    connect?: usuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        usuarioUpdateToOneWithWhereWithoutAcesso_sistemaInput,
        usuarioUpdateWithoutAcesso_sistemaInput
      >,
      usuarioUncheckedUpdateWithoutAcesso_sistemaInput
    >;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type recursoCreateNestedOneWithoutAgenrecInput = {
    create?: XOR<
      recursoCreateWithoutAgenrecInput,
      recursoUncheckedCreateWithoutAgenrecInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutAgenrecInput;
    connect?: recursoWhereUniqueInput;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type recursoUpdateOneRequiredWithoutAgenrecNestedInput = {
    create?: XOR<
      recursoCreateWithoutAgenrecInput,
      recursoUncheckedCreateWithoutAgenrecInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutAgenrecInput;
    upsert?: recursoUpsertWithoutAgenrecInput;
    connect?: recursoWhereUniqueInput;
    update?: XOR<
      XOR<
        recursoUpdateToOneWithWhereWithoutAgenrecInput,
        recursoUpdateWithoutAgenrecInput
      >,
      recursoUncheckedUpdateWithoutAgenrecInput
    >;
  };

  export type metaCreateNestedManyWithoutAreaInput = {
    create?:
      | XOR<metaCreateWithoutAreaInput, metaUncheckedCreateWithoutAreaInput>
      | metaCreateWithoutAreaInput[]
      | metaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutAreaInput
      | metaCreateOrConnectWithoutAreaInput[];
    createMany?: metaCreateManyAreaInputEnvelope;
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
  };

  export type tarefaCreateNestedManyWithoutAreaInput = {
    create?:
      | XOR<tarefaCreateWithoutAreaInput, tarefaUncheckedCreateWithoutAreaInput>
      | tarefaCreateWithoutAreaInput[]
      | tarefaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutAreaInput
      | tarefaCreateOrConnectWithoutAreaInput[];
    createMany?: tarefaCreateManyAreaInputEnvelope;
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
  };

  export type metaUncheckedCreateNestedManyWithoutAreaInput = {
    create?:
      | XOR<metaCreateWithoutAreaInput, metaUncheckedCreateWithoutAreaInput>
      | metaCreateWithoutAreaInput[]
      | metaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutAreaInput
      | metaCreateOrConnectWithoutAreaInput[];
    createMany?: metaCreateManyAreaInputEnvelope;
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
  };

  export type tarefaUncheckedCreateNestedManyWithoutAreaInput = {
    create?:
      | XOR<tarefaCreateWithoutAreaInput, tarefaUncheckedCreateWithoutAreaInput>
      | tarefaCreateWithoutAreaInput[]
      | tarefaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutAreaInput
      | tarefaCreateOrConnectWithoutAreaInput[];
    createMany?: tarefaCreateManyAreaInputEnvelope;
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
  };

  export type metaUpdateManyWithoutAreaNestedInput = {
    create?:
      | XOR<metaCreateWithoutAreaInput, metaUncheckedCreateWithoutAreaInput>
      | metaCreateWithoutAreaInput[]
      | metaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutAreaInput
      | metaCreateOrConnectWithoutAreaInput[];
    upsert?:
      | metaUpsertWithWhereUniqueWithoutAreaInput
      | metaUpsertWithWhereUniqueWithoutAreaInput[];
    createMany?: metaCreateManyAreaInputEnvelope;
    set?: metaWhereUniqueInput | metaWhereUniqueInput[];
    disconnect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    delete?: metaWhereUniqueInput | metaWhereUniqueInput[];
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    update?:
      | metaUpdateWithWhereUniqueWithoutAreaInput
      | metaUpdateWithWhereUniqueWithoutAreaInput[];
    updateMany?:
      | metaUpdateManyWithWhereWithoutAreaInput
      | metaUpdateManyWithWhereWithoutAreaInput[];
    deleteMany?: metaScalarWhereInput | metaScalarWhereInput[];
  };

  export type tarefaUpdateManyWithoutAreaNestedInput = {
    create?:
      | XOR<tarefaCreateWithoutAreaInput, tarefaUncheckedCreateWithoutAreaInput>
      | tarefaCreateWithoutAreaInput[]
      | tarefaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutAreaInput
      | tarefaCreateOrConnectWithoutAreaInput[];
    upsert?:
      | tarefaUpsertWithWhereUniqueWithoutAreaInput
      | tarefaUpsertWithWhereUniqueWithoutAreaInput[];
    createMany?: tarefaCreateManyAreaInputEnvelope;
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    update?:
      | tarefaUpdateWithWhereUniqueWithoutAreaInput
      | tarefaUpdateWithWhereUniqueWithoutAreaInput[];
    updateMany?:
      | tarefaUpdateManyWithWhereWithoutAreaInput
      | tarefaUpdateManyWithWhereWithoutAreaInput[];
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
  };

  export type metaUncheckedUpdateManyWithoutAreaNestedInput = {
    create?:
      | XOR<metaCreateWithoutAreaInput, metaUncheckedCreateWithoutAreaInput>
      | metaCreateWithoutAreaInput[]
      | metaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutAreaInput
      | metaCreateOrConnectWithoutAreaInput[];
    upsert?:
      | metaUpsertWithWhereUniqueWithoutAreaInput
      | metaUpsertWithWhereUniqueWithoutAreaInput[];
    createMany?: metaCreateManyAreaInputEnvelope;
    set?: metaWhereUniqueInput | metaWhereUniqueInput[];
    disconnect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    delete?: metaWhereUniqueInput | metaWhereUniqueInput[];
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    update?:
      | metaUpdateWithWhereUniqueWithoutAreaInput
      | metaUpdateWithWhereUniqueWithoutAreaInput[];
    updateMany?:
      | metaUpdateManyWithWhereWithoutAreaInput
      | metaUpdateManyWithWhereWithoutAreaInput[];
    deleteMany?: metaScalarWhereInput | metaScalarWhereInput[];
  };

  export type tarefaUncheckedUpdateManyWithoutAreaNestedInput = {
    create?:
      | XOR<tarefaCreateWithoutAreaInput, tarefaUncheckedCreateWithoutAreaInput>
      | tarefaCreateWithoutAreaInput[]
      | tarefaUncheckedCreateWithoutAreaInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutAreaInput
      | tarefaCreateOrConnectWithoutAreaInput[];
    upsert?:
      | tarefaUpsertWithWhereUniqueWithoutAreaInput
      | tarefaUpsertWithWhereUniqueWithoutAreaInput[];
    createMany?: tarefaCreateManyAreaInputEnvelope;
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    update?:
      | tarefaUpdateWithWhereUniqueWithoutAreaInput
      | tarefaUpdateWithWhereUniqueWithoutAreaInput[];
    updateMany?:
      | tarefaUpdateManyWithWhereWithoutAreaInput
      | tarefaUpdateManyWithWhereWithoutAreaInput[];
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
  };

  export type projetoCreateNestedOneWithoutAvaliacaoInput = {
    create?: XOR<
      projetoCreateWithoutAvaliacaoInput,
      projetoUncheckedCreateWithoutAvaliacaoInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutAvaliacaoInput;
    connect?: projetoWhereUniqueInput;
  };

  export type avaliadoCreateNestedManyWithoutAvaliacaoInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutAvaliacaoInput,
          avaliadoUncheckedCreateWithoutAvaliacaoInput
        >
      | avaliadoCreateWithoutAvaliacaoInput[]
      | avaliadoUncheckedCreateWithoutAvaliacaoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutAvaliacaoInput
      | avaliadoCreateOrConnectWithoutAvaliacaoInput[];
    createMany?: avaliadoCreateManyAvaliacaoInputEnvelope;
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
  };

  export type avaliadoUncheckedCreateNestedManyWithoutAvaliacaoInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutAvaliacaoInput,
          avaliadoUncheckedCreateWithoutAvaliacaoInput
        >
      | avaliadoCreateWithoutAvaliacaoInput[]
      | avaliadoUncheckedCreateWithoutAvaliacaoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutAvaliacaoInput
      | avaliadoCreateOrConnectWithoutAvaliacaoInput[];
    createMany?: avaliadoCreateManyAvaliacaoInputEnvelope;
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
  };

  export type projetoUpdateOneRequiredWithoutAvaliacaoNestedInput = {
    create?: XOR<
      projetoCreateWithoutAvaliacaoInput,
      projetoUncheckedCreateWithoutAvaliacaoInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutAvaliacaoInput;
    upsert?: projetoUpsertWithoutAvaliacaoInput;
    connect?: projetoWhereUniqueInput;
    update?: XOR<
      XOR<
        projetoUpdateToOneWithWhereWithoutAvaliacaoInput,
        projetoUpdateWithoutAvaliacaoInput
      >,
      projetoUncheckedUpdateWithoutAvaliacaoInput
    >;
  };

  export type avaliadoUpdateManyWithoutAvaliacaoNestedInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutAvaliacaoInput,
          avaliadoUncheckedCreateWithoutAvaliacaoInput
        >
      | avaliadoCreateWithoutAvaliacaoInput[]
      | avaliadoUncheckedCreateWithoutAvaliacaoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutAvaliacaoInput
      | avaliadoCreateOrConnectWithoutAvaliacaoInput[];
    upsert?:
      | avaliadoUpsertWithWhereUniqueWithoutAvaliacaoInput
      | avaliadoUpsertWithWhereUniqueWithoutAvaliacaoInput[];
    createMany?: avaliadoCreateManyAvaliacaoInputEnvelope;
    set?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    disconnect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    delete?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    update?:
      | avaliadoUpdateWithWhereUniqueWithoutAvaliacaoInput
      | avaliadoUpdateWithWhereUniqueWithoutAvaliacaoInput[];
    updateMany?:
      | avaliadoUpdateManyWithWhereWithoutAvaliacaoInput
      | avaliadoUpdateManyWithWhereWithoutAvaliacaoInput[];
    deleteMany?: avaliadoScalarWhereInput | avaliadoScalarWhereInput[];
  };

  export type avaliadoUncheckedUpdateManyWithoutAvaliacaoNestedInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutAvaliacaoInput,
          avaliadoUncheckedCreateWithoutAvaliacaoInput
        >
      | avaliadoCreateWithoutAvaliacaoInput[]
      | avaliadoUncheckedCreateWithoutAvaliacaoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutAvaliacaoInput
      | avaliadoCreateOrConnectWithoutAvaliacaoInput[];
    upsert?:
      | avaliadoUpsertWithWhereUniqueWithoutAvaliacaoInput
      | avaliadoUpsertWithWhereUniqueWithoutAvaliacaoInput[];
    createMany?: avaliadoCreateManyAvaliacaoInputEnvelope;
    set?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    disconnect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    delete?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    update?:
      | avaliadoUpdateWithWhereUniqueWithoutAvaliacaoInput
      | avaliadoUpdateWithWhereUniqueWithoutAvaliacaoInput[];
    updateMany?:
      | avaliadoUpdateManyWithWhereWithoutAvaliacaoInput
      | avaliadoUpdateManyWithWhereWithoutAvaliacaoInput[];
    deleteMany?: avaliadoScalarWhereInput | avaliadoScalarWhereInput[];
  };

  export type avaliacaoCreateNestedOneWithoutAvaliadoInput = {
    create?: XOR<
      avaliacaoCreateWithoutAvaliadoInput,
      avaliacaoUncheckedCreateWithoutAvaliadoInput
    >;
    connectOrCreate?: avaliacaoCreateOrConnectWithoutAvaliadoInput;
    connect?: avaliacaoWhereUniqueInput;
  };

  export type recursoCreateNestedOneWithoutAvaliadoInput = {
    create?: XOR<
      recursoCreateWithoutAvaliadoInput,
      recursoUncheckedCreateWithoutAvaliadoInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutAvaliadoInput;
    connect?: recursoWhereUniqueInput;
  };

  export type itavaliadoCreateNestedManyWithoutAvaliadoInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutAvaliadoInput,
          itavaliadoUncheckedCreateWithoutAvaliadoInput
        >
      | itavaliadoCreateWithoutAvaliadoInput[]
      | itavaliadoUncheckedCreateWithoutAvaliadoInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutAvaliadoInput
      | itavaliadoCreateOrConnectWithoutAvaliadoInput[];
    createMany?: itavaliadoCreateManyAvaliadoInputEnvelope;
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
  };

  export type itavaliadoUncheckedCreateNestedManyWithoutAvaliadoInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutAvaliadoInput,
          itavaliadoUncheckedCreateWithoutAvaliadoInput
        >
      | itavaliadoCreateWithoutAvaliadoInput[]
      | itavaliadoUncheckedCreateWithoutAvaliadoInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutAvaliadoInput
      | itavaliadoCreateOrConnectWithoutAvaliadoInput[];
    createMany?: itavaliadoCreateManyAvaliadoInputEnvelope;
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type avaliacaoUpdateOneRequiredWithoutAvaliadoNestedInput = {
    create?: XOR<
      avaliacaoCreateWithoutAvaliadoInput,
      avaliacaoUncheckedCreateWithoutAvaliadoInput
    >;
    connectOrCreate?: avaliacaoCreateOrConnectWithoutAvaliadoInput;
    upsert?: avaliacaoUpsertWithoutAvaliadoInput;
    connect?: avaliacaoWhereUniqueInput;
    update?: XOR<
      XOR<
        avaliacaoUpdateToOneWithWhereWithoutAvaliadoInput,
        avaliacaoUpdateWithoutAvaliadoInput
      >,
      avaliacaoUncheckedUpdateWithoutAvaliadoInput
    >;
  };

  export type recursoUpdateOneRequiredWithoutAvaliadoNestedInput = {
    create?: XOR<
      recursoCreateWithoutAvaliadoInput,
      recursoUncheckedCreateWithoutAvaliadoInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutAvaliadoInput;
    upsert?: recursoUpsertWithoutAvaliadoInput;
    connect?: recursoWhereUniqueInput;
    update?: XOR<
      XOR<
        recursoUpdateToOneWithWhereWithoutAvaliadoInput,
        recursoUpdateWithoutAvaliadoInput
      >,
      recursoUncheckedUpdateWithoutAvaliadoInput
    >;
  };

  export type itavaliadoUpdateManyWithoutAvaliadoNestedInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutAvaliadoInput,
          itavaliadoUncheckedCreateWithoutAvaliadoInput
        >
      | itavaliadoCreateWithoutAvaliadoInput[]
      | itavaliadoUncheckedCreateWithoutAvaliadoInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutAvaliadoInput
      | itavaliadoCreateOrConnectWithoutAvaliadoInput[];
    upsert?:
      | itavaliadoUpsertWithWhereUniqueWithoutAvaliadoInput
      | itavaliadoUpsertWithWhereUniqueWithoutAvaliadoInput[];
    createMany?: itavaliadoCreateManyAvaliadoInputEnvelope;
    set?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    disconnect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    delete?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    update?:
      | itavaliadoUpdateWithWhereUniqueWithoutAvaliadoInput
      | itavaliadoUpdateWithWhereUniqueWithoutAvaliadoInput[];
    updateMany?:
      | itavaliadoUpdateManyWithWhereWithoutAvaliadoInput
      | itavaliadoUpdateManyWithWhereWithoutAvaliadoInput[];
    deleteMany?: itavaliadoScalarWhereInput | itavaliadoScalarWhereInput[];
  };

  export type itavaliadoUncheckedUpdateManyWithoutAvaliadoNestedInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutAvaliadoInput,
          itavaliadoUncheckedCreateWithoutAvaliadoInput
        >
      | itavaliadoCreateWithoutAvaliadoInput[]
      | itavaliadoUncheckedCreateWithoutAvaliadoInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutAvaliadoInput
      | itavaliadoCreateOrConnectWithoutAvaliadoInput[];
    upsert?:
      | itavaliadoUpsertWithWhereUniqueWithoutAvaliadoInput
      | itavaliadoUpsertWithWhereUniqueWithoutAvaliadoInput[];
    createMany?: itavaliadoCreateManyAvaliadoInputEnvelope;
    set?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    disconnect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    delete?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    update?:
      | itavaliadoUpdateWithWhereUniqueWithoutAvaliadoInput
      | itavaliadoUpdateWithWhereUniqueWithoutAvaliadoInput[];
    updateMany?:
      | itavaliadoUpdateManyWithWhereWithoutAvaliadoInput
      | itavaliadoUpdateManyWithWhereWithoutAvaliadoInput[];
    deleteMany?: itavaliadoScalarWhereInput | itavaliadoScalarWhereInput[];
  };

  export type clienteCreateNestedOneWithoutChamadosInput = {
    create?: XOR<
      clienteCreateWithoutChamadosInput,
      clienteUncheckedCreateWithoutChamadosInput
    >;
    connectOrCreate?: clienteCreateOrConnectWithoutChamadosInput;
    connect?: clienteWhereUniqueInput;
  };

  export type recursoCreateNestedOneWithoutChamadoInput = {
    create?: XOR<
      recursoCreateWithoutChamadoInput,
      recursoUncheckedCreateWithoutChamadoInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutChamadoInput;
    connect?: recursoWhereUniqueInput;
  };

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null;
  };

  export type clienteUpdateOneWithoutChamadosNestedInput = {
    create?: XOR<
      clienteCreateWithoutChamadosInput,
      clienteUncheckedCreateWithoutChamadosInput
    >;
    connectOrCreate?: clienteCreateOrConnectWithoutChamadosInput;
    upsert?: clienteUpsertWithoutChamadosInput;
    disconnect?: clienteWhereInput | boolean;
    delete?: clienteWhereInput | boolean;
    connect?: clienteWhereUniqueInput;
    update?: XOR<
      XOR<
        clienteUpdateToOneWithWhereWithoutChamadosInput,
        clienteUpdateWithoutChamadosInput
      >,
      clienteUncheckedUpdateWithoutChamadosInput
    >;
  };

  export type recursoUpdateOneWithoutChamadoNestedInput = {
    create?: XOR<
      recursoCreateWithoutChamadoInput,
      recursoUncheckedCreateWithoutChamadoInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutChamadoInput;
    upsert?: recursoUpsertWithoutChamadoInput;
    disconnect?: recursoWhereInput | boolean;
    delete?: recursoWhereInput | boolean;
    connect?: recursoWhereUniqueInput;
    update?: XOR<
      XOR<
        recursoUpdateToOneWithWhereWithoutChamadoInput,
        recursoUpdateWithoutChamadoInput
      >,
      recursoUncheckedUpdateWithoutChamadoInput
    >;
  };

  export type chamadoCreateNestedManyWithoutClienteInput = {
    create?:
      | XOR<
          chamadoCreateWithoutClienteInput,
          chamadoUncheckedCreateWithoutClienteInput
        >
      | chamadoCreateWithoutClienteInput[]
      | chamadoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutClienteInput
      | chamadoCreateOrConnectWithoutClienteInput[];
    createMany?: chamadoCreateManyClienteInputEnvelope;
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
  };

  export type fatrecCreateNestedManyWithoutClienteInput = {
    create?:
      | XOR<
          fatrecCreateWithoutClienteInput,
          fatrecUncheckedCreateWithoutClienteInput
        >
      | fatrecCreateWithoutClienteInput[]
      | fatrecUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | fatrecCreateOrConnectWithoutClienteInput
      | fatrecCreateOrConnectWithoutClienteInput[];
    createMany?: fatrecCreateManyClienteInputEnvelope;
    connect?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
  };

  export type projetoCreateNestedManyWithoutClienteInput = {
    create?:
      | XOR<
          projetoCreateWithoutClienteInput,
          projetoUncheckedCreateWithoutClienteInput
        >
      | projetoCreateWithoutClienteInput[]
      | projetoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutClienteInput
      | projetoCreateOrConnectWithoutClienteInput[];
    createMany?: projetoCreateManyClienteInputEnvelope;
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
  };

  export type chamadoUncheckedCreateNestedManyWithoutClienteInput = {
    create?:
      | XOR<
          chamadoCreateWithoutClienteInput,
          chamadoUncheckedCreateWithoutClienteInput
        >
      | chamadoCreateWithoutClienteInput[]
      | chamadoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutClienteInput
      | chamadoCreateOrConnectWithoutClienteInput[];
    createMany?: chamadoCreateManyClienteInputEnvelope;
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
  };

  export type fatrecUncheckedCreateNestedManyWithoutClienteInput = {
    create?:
      | XOR<
          fatrecCreateWithoutClienteInput,
          fatrecUncheckedCreateWithoutClienteInput
        >
      | fatrecCreateWithoutClienteInput[]
      | fatrecUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | fatrecCreateOrConnectWithoutClienteInput
      | fatrecCreateOrConnectWithoutClienteInput[];
    createMany?: fatrecCreateManyClienteInputEnvelope;
    connect?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
  };

  export type projetoUncheckedCreateNestedManyWithoutClienteInput = {
    create?:
      | XOR<
          projetoCreateWithoutClienteInput,
          projetoUncheckedCreateWithoutClienteInput
        >
      | projetoCreateWithoutClienteInput[]
      | projetoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutClienteInput
      | projetoCreateOrConnectWithoutClienteInput[];
    createMany?: projetoCreateManyClienteInputEnvelope;
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
  };

  export type chamadoUpdateManyWithoutClienteNestedInput = {
    create?:
      | XOR<
          chamadoCreateWithoutClienteInput,
          chamadoUncheckedCreateWithoutClienteInput
        >
      | chamadoCreateWithoutClienteInput[]
      | chamadoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutClienteInput
      | chamadoCreateOrConnectWithoutClienteInput[];
    upsert?:
      | chamadoUpsertWithWhereUniqueWithoutClienteInput
      | chamadoUpsertWithWhereUniqueWithoutClienteInput[];
    createMany?: chamadoCreateManyClienteInputEnvelope;
    set?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    disconnect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    delete?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    update?:
      | chamadoUpdateWithWhereUniqueWithoutClienteInput
      | chamadoUpdateWithWhereUniqueWithoutClienteInput[];
    updateMany?:
      | chamadoUpdateManyWithWhereWithoutClienteInput
      | chamadoUpdateManyWithWhereWithoutClienteInput[];
    deleteMany?: chamadoScalarWhereInput | chamadoScalarWhereInput[];
  };

  export type fatrecUpdateManyWithoutClienteNestedInput = {
    create?:
      | XOR<
          fatrecCreateWithoutClienteInput,
          fatrecUncheckedCreateWithoutClienteInput
        >
      | fatrecCreateWithoutClienteInput[]
      | fatrecUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | fatrecCreateOrConnectWithoutClienteInput
      | fatrecCreateOrConnectWithoutClienteInput[];
    upsert?:
      | fatrecUpsertWithWhereUniqueWithoutClienteInput
      | fatrecUpsertWithWhereUniqueWithoutClienteInput[];
    createMany?: fatrecCreateManyClienteInputEnvelope;
    set?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    disconnect?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    delete?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    connect?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    update?:
      | fatrecUpdateWithWhereUniqueWithoutClienteInput
      | fatrecUpdateWithWhereUniqueWithoutClienteInput[];
    updateMany?:
      | fatrecUpdateManyWithWhereWithoutClienteInput
      | fatrecUpdateManyWithWhereWithoutClienteInput[];
    deleteMany?: fatrecScalarWhereInput | fatrecScalarWhereInput[];
  };

  export type projetoUpdateManyWithoutClienteNestedInput = {
    create?:
      | XOR<
          projetoCreateWithoutClienteInput,
          projetoUncheckedCreateWithoutClienteInput
        >
      | projetoCreateWithoutClienteInput[]
      | projetoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutClienteInput
      | projetoCreateOrConnectWithoutClienteInput[];
    upsert?:
      | projetoUpsertWithWhereUniqueWithoutClienteInput
      | projetoUpsertWithWhereUniqueWithoutClienteInput[];
    createMany?: projetoCreateManyClienteInputEnvelope;
    set?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    disconnect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    delete?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    update?:
      | projetoUpdateWithWhereUniqueWithoutClienteInput
      | projetoUpdateWithWhereUniqueWithoutClienteInput[];
    updateMany?:
      | projetoUpdateManyWithWhereWithoutClienteInput
      | projetoUpdateManyWithWhereWithoutClienteInput[];
    deleteMany?: projetoScalarWhereInput | projetoScalarWhereInput[];
  };

  export type chamadoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?:
      | XOR<
          chamadoCreateWithoutClienteInput,
          chamadoUncheckedCreateWithoutClienteInput
        >
      | chamadoCreateWithoutClienteInput[]
      | chamadoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutClienteInput
      | chamadoCreateOrConnectWithoutClienteInput[];
    upsert?:
      | chamadoUpsertWithWhereUniqueWithoutClienteInput
      | chamadoUpsertWithWhereUniqueWithoutClienteInput[];
    createMany?: chamadoCreateManyClienteInputEnvelope;
    set?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    disconnect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    delete?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    update?:
      | chamadoUpdateWithWhereUniqueWithoutClienteInput
      | chamadoUpdateWithWhereUniqueWithoutClienteInput[];
    updateMany?:
      | chamadoUpdateManyWithWhereWithoutClienteInput
      | chamadoUpdateManyWithWhereWithoutClienteInput[];
    deleteMany?: chamadoScalarWhereInput | chamadoScalarWhereInput[];
  };

  export type fatrecUncheckedUpdateManyWithoutClienteNestedInput = {
    create?:
      | XOR<
          fatrecCreateWithoutClienteInput,
          fatrecUncheckedCreateWithoutClienteInput
        >
      | fatrecCreateWithoutClienteInput[]
      | fatrecUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | fatrecCreateOrConnectWithoutClienteInput
      | fatrecCreateOrConnectWithoutClienteInput[];
    upsert?:
      | fatrecUpsertWithWhereUniqueWithoutClienteInput
      | fatrecUpsertWithWhereUniqueWithoutClienteInput[];
    createMany?: fatrecCreateManyClienteInputEnvelope;
    set?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    disconnect?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    delete?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    connect?: fatrecWhereUniqueInput | fatrecWhereUniqueInput[];
    update?:
      | fatrecUpdateWithWhereUniqueWithoutClienteInput
      | fatrecUpdateWithWhereUniqueWithoutClienteInput[];
    updateMany?:
      | fatrecUpdateManyWithWhereWithoutClienteInput
      | fatrecUpdateManyWithWhereWithoutClienteInput[];
    deleteMany?: fatrecScalarWhereInput | fatrecScalarWhereInput[];
  };

  export type projetoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?:
      | XOR<
          projetoCreateWithoutClienteInput,
          projetoUncheckedCreateWithoutClienteInput
        >
      | projetoCreateWithoutClienteInput[]
      | projetoUncheckedCreateWithoutClienteInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutClienteInput
      | projetoCreateOrConnectWithoutClienteInput[];
    upsert?:
      | projetoUpsertWithWhereUniqueWithoutClienteInput
      | projetoUpsertWithWhereUniqueWithoutClienteInput[];
    createMany?: projetoCreateManyClienteInputEnvelope;
    set?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    disconnect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    delete?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    update?:
      | projetoUpdateWithWhereUniqueWithoutClienteInput
      | projetoUpdateWithWhereUniqueWithoutClienteInput[];
    updateMany?:
      | projetoUpdateManyWithWhereWithoutClienteInput
      | projetoUpdateManyWithWhereWithoutClienteInput[];
    deleteMany?: projetoScalarWhereInput | projetoScalarWhereInput[];
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type metaCreateNestedManyWithoutFaseInput = {
    create?:
      | XOR<metaCreateWithoutFaseInput, metaUncheckedCreateWithoutFaseInput>
      | metaCreateWithoutFaseInput[]
      | metaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutFaseInput
      | metaCreateOrConnectWithoutFaseInput[];
    createMany?: metaCreateManyFaseInputEnvelope;
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
  };

  export type tarefaCreateNestedManyWithoutFaseInput = {
    create?:
      | XOR<tarefaCreateWithoutFaseInput, tarefaUncheckedCreateWithoutFaseInput>
      | tarefaCreateWithoutFaseInput[]
      | tarefaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutFaseInput
      | tarefaCreateOrConnectWithoutFaseInput[];
    createMany?: tarefaCreateManyFaseInputEnvelope;
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
  };

  export type metaUncheckedCreateNestedManyWithoutFaseInput = {
    create?:
      | XOR<metaCreateWithoutFaseInput, metaUncheckedCreateWithoutFaseInput>
      | metaCreateWithoutFaseInput[]
      | metaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutFaseInput
      | metaCreateOrConnectWithoutFaseInput[];
    createMany?: metaCreateManyFaseInputEnvelope;
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
  };

  export type tarefaUncheckedCreateNestedManyWithoutFaseInput = {
    create?:
      | XOR<tarefaCreateWithoutFaseInput, tarefaUncheckedCreateWithoutFaseInput>
      | tarefaCreateWithoutFaseInput[]
      | tarefaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutFaseInput
      | tarefaCreateOrConnectWithoutFaseInput[];
    createMany?: tarefaCreateManyFaseInputEnvelope;
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
  };

  export type metaUpdateManyWithoutFaseNestedInput = {
    create?:
      | XOR<metaCreateWithoutFaseInput, metaUncheckedCreateWithoutFaseInput>
      | metaCreateWithoutFaseInput[]
      | metaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutFaseInput
      | metaCreateOrConnectWithoutFaseInput[];
    upsert?:
      | metaUpsertWithWhereUniqueWithoutFaseInput
      | metaUpsertWithWhereUniqueWithoutFaseInput[];
    createMany?: metaCreateManyFaseInputEnvelope;
    set?: metaWhereUniqueInput | metaWhereUniqueInput[];
    disconnect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    delete?: metaWhereUniqueInput | metaWhereUniqueInput[];
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    update?:
      | metaUpdateWithWhereUniqueWithoutFaseInput
      | metaUpdateWithWhereUniqueWithoutFaseInput[];
    updateMany?:
      | metaUpdateManyWithWhereWithoutFaseInput
      | metaUpdateManyWithWhereWithoutFaseInput[];
    deleteMany?: metaScalarWhereInput | metaScalarWhereInput[];
  };

  export type tarefaUpdateManyWithoutFaseNestedInput = {
    create?:
      | XOR<tarefaCreateWithoutFaseInput, tarefaUncheckedCreateWithoutFaseInput>
      | tarefaCreateWithoutFaseInput[]
      | tarefaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutFaseInput
      | tarefaCreateOrConnectWithoutFaseInput[];
    upsert?:
      | tarefaUpsertWithWhereUniqueWithoutFaseInput
      | tarefaUpsertWithWhereUniqueWithoutFaseInput[];
    createMany?: tarefaCreateManyFaseInputEnvelope;
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    update?:
      | tarefaUpdateWithWhereUniqueWithoutFaseInput
      | tarefaUpdateWithWhereUniqueWithoutFaseInput[];
    updateMany?:
      | tarefaUpdateManyWithWhereWithoutFaseInput
      | tarefaUpdateManyWithWhereWithoutFaseInput[];
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
  };

  export type metaUncheckedUpdateManyWithoutFaseNestedInput = {
    create?:
      | XOR<metaCreateWithoutFaseInput, metaUncheckedCreateWithoutFaseInput>
      | metaCreateWithoutFaseInput[]
      | metaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutFaseInput
      | metaCreateOrConnectWithoutFaseInput[];
    upsert?:
      | metaUpsertWithWhereUniqueWithoutFaseInput
      | metaUpsertWithWhereUniqueWithoutFaseInput[];
    createMany?: metaCreateManyFaseInputEnvelope;
    set?: metaWhereUniqueInput | metaWhereUniqueInput[];
    disconnect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    delete?: metaWhereUniqueInput | metaWhereUniqueInput[];
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    update?:
      | metaUpdateWithWhereUniqueWithoutFaseInput
      | metaUpdateWithWhereUniqueWithoutFaseInput[];
    updateMany?:
      | metaUpdateManyWithWhereWithoutFaseInput
      | metaUpdateManyWithWhereWithoutFaseInput[];
    deleteMany?: metaScalarWhereInput | metaScalarWhereInput[];
  };

  export type tarefaUncheckedUpdateManyWithoutFaseNestedInput = {
    create?:
      | XOR<tarefaCreateWithoutFaseInput, tarefaUncheckedCreateWithoutFaseInput>
      | tarefaCreateWithoutFaseInput[]
      | tarefaUncheckedCreateWithoutFaseInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutFaseInput
      | tarefaCreateOrConnectWithoutFaseInput[];
    upsert?:
      | tarefaUpsertWithWhereUniqueWithoutFaseInput
      | tarefaUpsertWithWhereUniqueWithoutFaseInput[];
    createMany?: tarefaCreateManyFaseInputEnvelope;
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    update?:
      | tarefaUpdateWithWhereUniqueWithoutFaseInput
      | tarefaUpdateWithWhereUniqueWithoutFaseInput[];
    updateMany?:
      | tarefaUpdateManyWithWhereWithoutFaseInput
      | tarefaUpdateManyWithWhereWithoutFaseInput[];
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
  };

  export type clienteCreateNestedOneWithoutFatrecInput = {
    create?: XOR<
      clienteCreateWithoutFatrecInput,
      clienteUncheckedCreateWithoutFatrecInput
    >;
    connectOrCreate?: clienteCreateOrConnectWithoutFatrecInput;
    connect?: clienteWhereUniqueInput;
  };

  export type clienteUpdateOneRequiredWithoutFatrecNestedInput = {
    create?: XOR<
      clienteCreateWithoutFatrecInput,
      clienteUncheckedCreateWithoutFatrecInput
    >;
    connectOrCreate?: clienteCreateOrConnectWithoutFatrecInput;
    upsert?: clienteUpsertWithoutFatrecInput;
    connect?: clienteWhereUniqueInput;
    update?: XOR<
      XOR<
        clienteUpdateToOneWithWhereWithoutFatrecInput,
        clienteUpdateWithoutFatrecInput
      >,
      clienteUncheckedUpdateWithoutFatrecInput
    >;
  };

  export type avaliadoCreateNestedOneWithoutItavaliadoInput = {
    create?: XOR<
      avaliadoCreateWithoutItavaliadoInput,
      avaliadoUncheckedCreateWithoutItavaliadoInput
    >;
    connectOrCreate?: avaliadoCreateOrConnectWithoutItavaliadoInput;
    connect?: avaliadoWhereUniqueInput;
  };

  export type itmatrizCreateNestedOneWithoutItavaliadoInput = {
    create?: XOR<
      itmatrizCreateWithoutItavaliadoInput,
      itmatrizUncheckedCreateWithoutItavaliadoInput
    >;
    connectOrCreate?: itmatrizCreateOrConnectWithoutItavaliadoInput;
    connect?: itmatrizWhereUniqueInput;
  };

  export type avaliadoUpdateOneRequiredWithoutItavaliadoNestedInput = {
    create?: XOR<
      avaliadoCreateWithoutItavaliadoInput,
      avaliadoUncheckedCreateWithoutItavaliadoInput
    >;
    connectOrCreate?: avaliadoCreateOrConnectWithoutItavaliadoInput;
    upsert?: avaliadoUpsertWithoutItavaliadoInput;
    connect?: avaliadoWhereUniqueInput;
    update?: XOR<
      XOR<
        avaliadoUpdateToOneWithWhereWithoutItavaliadoInput,
        avaliadoUpdateWithoutItavaliadoInput
      >,
      avaliadoUncheckedUpdateWithoutItavaliadoInput
    >;
  };

  export type itmatrizUpdateOneRequiredWithoutItavaliadoNestedInput = {
    create?: XOR<
      itmatrizCreateWithoutItavaliadoInput,
      itmatrizUncheckedCreateWithoutItavaliadoInput
    >;
    connectOrCreate?: itmatrizCreateOrConnectWithoutItavaliadoInput;
    upsert?: itmatrizUpsertWithoutItavaliadoInput;
    connect?: itmatrizWhereUniqueInput;
    update?: XOR<
      XOR<
        itmatrizUpdateToOneWithWhereWithoutItavaliadoInput,
        itmatrizUpdateWithoutItavaliadoInput
      >,
      itmatrizUncheckedUpdateWithoutItavaliadoInput
    >;
  };

  export type itavaliadoCreateNestedManyWithoutItmatrizInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutItmatrizInput,
          itavaliadoUncheckedCreateWithoutItmatrizInput
        >
      | itavaliadoCreateWithoutItmatrizInput[]
      | itavaliadoUncheckedCreateWithoutItmatrizInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutItmatrizInput
      | itavaliadoCreateOrConnectWithoutItmatrizInput[];
    createMany?: itavaliadoCreateManyItmatrizInputEnvelope;
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
  };

  export type matrizCreateNestedOneWithoutItmatrizInput = {
    create?: XOR<
      matrizCreateWithoutItmatrizInput,
      matrizUncheckedCreateWithoutItmatrizInput
    >;
    connectOrCreate?: matrizCreateOrConnectWithoutItmatrizInput;
    connect?: matrizWhereUniqueInput;
  };

  export type itavaliadoUncheckedCreateNestedManyWithoutItmatrizInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutItmatrizInput,
          itavaliadoUncheckedCreateWithoutItmatrizInput
        >
      | itavaliadoCreateWithoutItmatrizInput[]
      | itavaliadoUncheckedCreateWithoutItmatrizInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutItmatrizInput
      | itavaliadoCreateOrConnectWithoutItmatrizInput[];
    createMany?: itavaliadoCreateManyItmatrizInputEnvelope;
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
  };

  export type itavaliadoUpdateManyWithoutItmatrizNestedInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutItmatrizInput,
          itavaliadoUncheckedCreateWithoutItmatrizInput
        >
      | itavaliadoCreateWithoutItmatrizInput[]
      | itavaliadoUncheckedCreateWithoutItmatrizInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutItmatrizInput
      | itavaliadoCreateOrConnectWithoutItmatrizInput[];
    upsert?:
      | itavaliadoUpsertWithWhereUniqueWithoutItmatrizInput
      | itavaliadoUpsertWithWhereUniqueWithoutItmatrizInput[];
    createMany?: itavaliadoCreateManyItmatrizInputEnvelope;
    set?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    disconnect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    delete?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    update?:
      | itavaliadoUpdateWithWhereUniqueWithoutItmatrizInput
      | itavaliadoUpdateWithWhereUniqueWithoutItmatrizInput[];
    updateMany?:
      | itavaliadoUpdateManyWithWhereWithoutItmatrizInput
      | itavaliadoUpdateManyWithWhereWithoutItmatrizInput[];
    deleteMany?: itavaliadoScalarWhereInput | itavaliadoScalarWhereInput[];
  };

  export type matrizUpdateOneRequiredWithoutItmatrizNestedInput = {
    create?: XOR<
      matrizCreateWithoutItmatrizInput,
      matrizUncheckedCreateWithoutItmatrizInput
    >;
    connectOrCreate?: matrizCreateOrConnectWithoutItmatrizInput;
    upsert?: matrizUpsertWithoutItmatrizInput;
    connect?: matrizWhereUniqueInput;
    update?: XOR<
      XOR<
        matrizUpdateToOneWithWhereWithoutItmatrizInput,
        matrizUpdateWithoutItmatrizInput
      >,
      matrizUncheckedUpdateWithoutItmatrizInput
    >;
  };

  export type itavaliadoUncheckedUpdateManyWithoutItmatrizNestedInput = {
    create?:
      | XOR<
          itavaliadoCreateWithoutItmatrizInput,
          itavaliadoUncheckedCreateWithoutItmatrizInput
        >
      | itavaliadoCreateWithoutItmatrizInput[]
      | itavaliadoUncheckedCreateWithoutItmatrizInput[];
    connectOrCreate?:
      | itavaliadoCreateOrConnectWithoutItmatrizInput
      | itavaliadoCreateOrConnectWithoutItmatrizInput[];
    upsert?:
      | itavaliadoUpsertWithWhereUniqueWithoutItmatrizInput
      | itavaliadoUpsertWithWhereUniqueWithoutItmatrizInput[];
    createMany?: itavaliadoCreateManyItmatrizInputEnvelope;
    set?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    disconnect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    delete?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    connect?: itavaliadoWhereUniqueInput | itavaliadoWhereUniqueInput[];
    update?:
      | itavaliadoUpdateWithWhereUniqueWithoutItmatrizInput
      | itavaliadoUpdateWithWhereUniqueWithoutItmatrizInput[];
    updateMany?:
      | itavaliadoUpdateManyWithWhereWithoutItmatrizInput
      | itavaliadoUpdateManyWithWhereWithoutItmatrizInput[];
    deleteMany?: itavaliadoScalarWhereInput | itavaliadoScalarWhereInput[];
  };

  export type itmatrizCreateNestedManyWithoutMatrizInput = {
    create?:
      | XOR<
          itmatrizCreateWithoutMatrizInput,
          itmatrizUncheckedCreateWithoutMatrizInput
        >
      | itmatrizCreateWithoutMatrizInput[]
      | itmatrizUncheckedCreateWithoutMatrizInput[];
    connectOrCreate?:
      | itmatrizCreateOrConnectWithoutMatrizInput
      | itmatrizCreateOrConnectWithoutMatrizInput[];
    createMany?: itmatrizCreateManyMatrizInputEnvelope;
    connect?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
  };

  export type itmatrizUncheckedCreateNestedManyWithoutMatrizInput = {
    create?:
      | XOR<
          itmatrizCreateWithoutMatrizInput,
          itmatrizUncheckedCreateWithoutMatrizInput
        >
      | itmatrizCreateWithoutMatrizInput[]
      | itmatrizUncheckedCreateWithoutMatrizInput[];
    connectOrCreate?:
      | itmatrizCreateOrConnectWithoutMatrizInput
      | itmatrizCreateOrConnectWithoutMatrizInput[];
    createMany?: itmatrizCreateManyMatrizInputEnvelope;
    connect?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
  };

  export type itmatrizUpdateManyWithoutMatrizNestedInput = {
    create?:
      | XOR<
          itmatrizCreateWithoutMatrizInput,
          itmatrizUncheckedCreateWithoutMatrizInput
        >
      | itmatrizCreateWithoutMatrizInput[]
      | itmatrizUncheckedCreateWithoutMatrizInput[];
    connectOrCreate?:
      | itmatrizCreateOrConnectWithoutMatrizInput
      | itmatrizCreateOrConnectWithoutMatrizInput[];
    upsert?:
      | itmatrizUpsertWithWhereUniqueWithoutMatrizInput
      | itmatrizUpsertWithWhereUniqueWithoutMatrizInput[];
    createMany?: itmatrizCreateManyMatrizInputEnvelope;
    set?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    disconnect?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    delete?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    connect?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    update?:
      | itmatrizUpdateWithWhereUniqueWithoutMatrizInput
      | itmatrizUpdateWithWhereUniqueWithoutMatrizInput[];
    updateMany?:
      | itmatrizUpdateManyWithWhereWithoutMatrizInput
      | itmatrizUpdateManyWithWhereWithoutMatrizInput[];
    deleteMany?: itmatrizScalarWhereInput | itmatrizScalarWhereInput[];
  };

  export type itmatrizUncheckedUpdateManyWithoutMatrizNestedInput = {
    create?:
      | XOR<
          itmatrizCreateWithoutMatrizInput,
          itmatrizUncheckedCreateWithoutMatrizInput
        >
      | itmatrizCreateWithoutMatrizInput[]
      | itmatrizUncheckedCreateWithoutMatrizInput[];
    connectOrCreate?:
      | itmatrizCreateOrConnectWithoutMatrizInput
      | itmatrizCreateOrConnectWithoutMatrizInput[];
    upsert?:
      | itmatrizUpsertWithWhereUniqueWithoutMatrizInput
      | itmatrizUpsertWithWhereUniqueWithoutMatrizInput[];
    createMany?: itmatrizCreateManyMatrizInputEnvelope;
    set?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    disconnect?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    delete?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    connect?: itmatrizWhereUniqueInput | itmatrizWhereUniqueInput[];
    update?:
      | itmatrizUpdateWithWhereUniqueWithoutMatrizInput
      | itmatrizUpdateWithWhereUniqueWithoutMatrizInput[];
    updateMany?:
      | itmatrizUpdateManyWithWhereWithoutMatrizInput
      | itmatrizUpdateManyWithWhereWithoutMatrizInput[];
    deleteMany?: itmatrizScalarWhereInput | itmatrizScalarWhereInput[];
  };

  export type areaCreateNestedOneWithoutMetaInput = {
    create?: XOR<
      areaCreateWithoutMetaInput,
      areaUncheckedCreateWithoutMetaInput
    >;
    connectOrCreate?: areaCreateOrConnectWithoutMetaInput;
    connect?: areaWhereUniqueInput;
  };

  export type faseCreateNestedOneWithoutMetaInput = {
    create?: XOR<
      faseCreateWithoutMetaInput,
      faseUncheckedCreateWithoutMetaInput
    >;
    connectOrCreate?: faseCreateOrConnectWithoutMetaInput;
    connect?: faseWhereUniqueInput;
  };

  export type projetoCreateNestedOneWithoutMetaInput = {
    create?: XOR<
      projetoCreateWithoutMetaInput,
      projetoUncheckedCreateWithoutMetaInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutMetaInput;
    connect?: projetoWhereUniqueInput;
  };

  export type areaUpdateOneRequiredWithoutMetaNestedInput = {
    create?: XOR<
      areaCreateWithoutMetaInput,
      areaUncheckedCreateWithoutMetaInput
    >;
    connectOrCreate?: areaCreateOrConnectWithoutMetaInput;
    upsert?: areaUpsertWithoutMetaInput;
    connect?: areaWhereUniqueInput;
    update?: XOR<
      XOR<areaUpdateToOneWithWhereWithoutMetaInput, areaUpdateWithoutMetaInput>,
      areaUncheckedUpdateWithoutMetaInput
    >;
  };

  export type faseUpdateOneRequiredWithoutMetaNestedInput = {
    create?: XOR<
      faseCreateWithoutMetaInput,
      faseUncheckedCreateWithoutMetaInput
    >;
    connectOrCreate?: faseCreateOrConnectWithoutMetaInput;
    upsert?: faseUpsertWithoutMetaInput;
    connect?: faseWhereUniqueInput;
    update?: XOR<
      XOR<faseUpdateToOneWithWhereWithoutMetaInput, faseUpdateWithoutMetaInput>,
      faseUncheckedUpdateWithoutMetaInput
    >;
  };

  export type projetoUpdateOneRequiredWithoutMetaNestedInput = {
    create?: XOR<
      projetoCreateWithoutMetaInput,
      projetoUncheckedCreateWithoutMetaInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutMetaInput;
    upsert?: projetoUpsertWithoutMetaInput;
    connect?: projetoWhereUniqueInput;
    update?: XOR<
      XOR<
        projetoUpdateToOneWithWhereWithoutMetaInput,
        projetoUpdateWithoutMetaInput
      >,
      projetoUncheckedUpdateWithoutMetaInput
    >;
  };

  export type acesso_sistemaCreateNestedManyWithoutModulo_sistemaInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutModulo_sistemaInput,
          acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput
        >
      | acesso_sistemaCreateWithoutModulo_sistemaInput[]
      | acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput
      | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
    createMany?: acesso_sistemaCreateManyModulo_sistemaInputEnvelope;
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
  };

  export type tela_sistemaCreateNestedManyWithoutModulo_sistemaInput = {
    create?:
      | XOR<
          tela_sistemaCreateWithoutModulo_sistemaInput,
          tela_sistemaUncheckedCreateWithoutModulo_sistemaInput
        >
      | tela_sistemaCreateWithoutModulo_sistemaInput[]
      | tela_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
    connectOrCreate?:
      | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput
      | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
    createMany?: tela_sistemaCreateManyModulo_sistemaInputEnvelope;
    connect?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
  };

  export type acesso_sistemaUncheckedCreateNestedManyWithoutModulo_sistemaInput =
    {
      create?:
        | XOR<
            acesso_sistemaCreateWithoutModulo_sistemaInput,
            acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput
          >
        | acesso_sistemaCreateWithoutModulo_sistemaInput[]
        | acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
      connectOrCreate?:
        | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput
        | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
      createMany?: acesso_sistemaCreateManyModulo_sistemaInputEnvelope;
      connect?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
    };

  export type tela_sistemaUncheckedCreateNestedManyWithoutModulo_sistemaInput =
    {
      create?:
        | XOR<
            tela_sistemaCreateWithoutModulo_sistemaInput,
            tela_sistemaUncheckedCreateWithoutModulo_sistemaInput
          >
        | tela_sistemaCreateWithoutModulo_sistemaInput[]
        | tela_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
      connectOrCreate?:
        | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput
        | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
      createMany?: tela_sistemaCreateManyModulo_sistemaInputEnvelope;
      connect?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
    };

  export type acesso_sistemaUpdateManyWithoutModulo_sistemaNestedInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutModulo_sistemaInput,
          acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput
        >
      | acesso_sistemaCreateWithoutModulo_sistemaInput[]
      | acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput
      | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
    upsert?:
      | acesso_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput
      | acesso_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput[];
    createMany?: acesso_sistemaCreateManyModulo_sistemaInputEnvelope;
    set?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    disconnect?:
      | acesso_sistemaWhereUniqueInput
      | acesso_sistemaWhereUniqueInput[];
    delete?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    update?:
      | acesso_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput
      | acesso_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput[];
    updateMany?:
      | acesso_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput
      | acesso_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput[];
    deleteMany?:
      | acesso_sistemaScalarWhereInput
      | acesso_sistemaScalarWhereInput[];
  };

  export type tela_sistemaUpdateManyWithoutModulo_sistemaNestedInput = {
    create?:
      | XOR<
          tela_sistemaCreateWithoutModulo_sistemaInput,
          tela_sistemaUncheckedCreateWithoutModulo_sistemaInput
        >
      | tela_sistemaCreateWithoutModulo_sistemaInput[]
      | tela_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
    connectOrCreate?:
      | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput
      | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
    upsert?:
      | tela_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput
      | tela_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput[];
    createMany?: tela_sistemaCreateManyModulo_sistemaInputEnvelope;
    set?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
    disconnect?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
    delete?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
    connect?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
    update?:
      | tela_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput
      | tela_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput[];
    updateMany?:
      | tela_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput
      | tela_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput[];
    deleteMany?: tela_sistemaScalarWhereInput | tela_sistemaScalarWhereInput[];
  };

  export type acesso_sistemaUncheckedUpdateManyWithoutModulo_sistemaNestedInput =
    {
      create?:
        | XOR<
            acesso_sistemaCreateWithoutModulo_sistemaInput,
            acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput
          >
        | acesso_sistemaCreateWithoutModulo_sistemaInput[]
        | acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
      connectOrCreate?:
        | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput
        | acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
      upsert?:
        | acesso_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput
        | acesso_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput[];
      createMany?: acesso_sistemaCreateManyModulo_sistemaInputEnvelope;
      set?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
      disconnect?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
      delete?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
      connect?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
      update?:
        | acesso_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput
        | acesso_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput[];
      updateMany?:
        | acesso_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput
        | acesso_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput[];
      deleteMany?:
        | acesso_sistemaScalarWhereInput
        | acesso_sistemaScalarWhereInput[];
    };

  export type tela_sistemaUncheckedUpdateManyWithoutModulo_sistemaNestedInput =
    {
      create?:
        | XOR<
            tela_sistemaCreateWithoutModulo_sistemaInput,
            tela_sistemaUncheckedCreateWithoutModulo_sistemaInput
          >
        | tela_sistemaCreateWithoutModulo_sistemaInput[]
        | tela_sistemaUncheckedCreateWithoutModulo_sistemaInput[];
      connectOrCreate?:
        | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput
        | tela_sistemaCreateOrConnectWithoutModulo_sistemaInput[];
      upsert?:
        | tela_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput
        | tela_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput[];
      createMany?: tela_sistemaCreateManyModulo_sistemaInputEnvelope;
      set?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
      disconnect?:
        | tela_sistemaWhereUniqueInput
        | tela_sistemaWhereUniqueInput[];
      delete?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
      connect?: tela_sistemaWhereUniqueInput | tela_sistemaWhereUniqueInput[];
      update?:
        | tela_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput
        | tela_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput[];
      updateMany?:
        | tela_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput
        | tela_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput[];
      deleteMany?:
        | tela_sistemaScalarWhereInput
        | tela_sistemaScalarWhereInput[];
    };

  export type recursoCreateNestedManyWithoutNivelInput = {
    create?:
      | XOR<
          recursoCreateWithoutNivelInput,
          recursoUncheckedCreateWithoutNivelInput
        >
      | recursoCreateWithoutNivelInput[]
      | recursoUncheckedCreateWithoutNivelInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutNivelInput
      | recursoCreateOrConnectWithoutNivelInput[];
    createMany?: recursoCreateManyNivelInputEnvelope;
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
  };

  export type recursoUncheckedCreateNestedManyWithoutNivelInput = {
    create?:
      | XOR<
          recursoCreateWithoutNivelInput,
          recursoUncheckedCreateWithoutNivelInput
        >
      | recursoCreateWithoutNivelInput[]
      | recursoUncheckedCreateWithoutNivelInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutNivelInput
      | recursoCreateOrConnectWithoutNivelInput[];
    createMany?: recursoCreateManyNivelInputEnvelope;
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
  };

  export type recursoUpdateManyWithoutNivelNestedInput = {
    create?:
      | XOR<
          recursoCreateWithoutNivelInput,
          recursoUncheckedCreateWithoutNivelInput
        >
      | recursoCreateWithoutNivelInput[]
      | recursoUncheckedCreateWithoutNivelInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutNivelInput
      | recursoCreateOrConnectWithoutNivelInput[];
    upsert?:
      | recursoUpsertWithWhereUniqueWithoutNivelInput
      | recursoUpsertWithWhereUniqueWithoutNivelInput[];
    createMany?: recursoCreateManyNivelInputEnvelope;
    set?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    disconnect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    delete?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    update?:
      | recursoUpdateWithWhereUniqueWithoutNivelInput
      | recursoUpdateWithWhereUniqueWithoutNivelInput[];
    updateMany?:
      | recursoUpdateManyWithWhereWithoutNivelInput
      | recursoUpdateManyWithWhereWithoutNivelInput[];
    deleteMany?: recursoScalarWhereInput | recursoScalarWhereInput[];
  };

  export type recursoUncheckedUpdateManyWithoutNivelNestedInput = {
    create?:
      | XOR<
          recursoCreateWithoutNivelInput,
          recursoUncheckedCreateWithoutNivelInput
        >
      | recursoCreateWithoutNivelInput[]
      | recursoUncheckedCreateWithoutNivelInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutNivelInput
      | recursoCreateOrConnectWithoutNivelInput[];
    upsert?:
      | recursoUpsertWithWhereUniqueWithoutNivelInput
      | recursoUpsertWithWhereUniqueWithoutNivelInput[];
    createMany?: recursoCreateManyNivelInputEnvelope;
    set?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    disconnect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    delete?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    update?:
      | recursoUpdateWithWhereUniqueWithoutNivelInput
      | recursoUpdateWithWhereUniqueWithoutNivelInput[];
    updateMany?:
      | recursoUpdateManyWithWhereWithoutNivelInput
      | recursoUpdateManyWithWhereWithoutNivelInput[];
    deleteMany?: recursoScalarWhereInput | recursoScalarWhereInput[];
  };

  export type tarefaCreateNestedOneWithoutOsInput = {
    create?: XOR<
      tarefaCreateWithoutOsInput,
      tarefaUncheckedCreateWithoutOsInput
    >;
    connectOrCreate?: tarefaCreateOrConnectWithoutOsInput;
    connect?: tarefaWhereUniqueInput;
  };

  export type tarefaUpdateOneRequiredWithoutOsNestedInput = {
    create?: XOR<
      tarefaCreateWithoutOsInput,
      tarefaUncheckedCreateWithoutOsInput
    >;
    connectOrCreate?: tarefaCreateOrConnectWithoutOsInput;
    upsert?: tarefaUpsertWithoutOsInput;
    connect?: tarefaWhereUniqueInput;
    update?: XOR<
      XOR<tarefaUpdateToOneWithWhereWithoutOsInput, tarefaUpdateWithoutOsInput>,
      tarefaUncheckedUpdateWithoutOsInput
    >;
  };

  export type avaliacaoCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          avaliacaoCreateWithoutProjetoInput,
          avaliacaoUncheckedCreateWithoutProjetoInput
        >
      | avaliacaoCreateWithoutProjetoInput[]
      | avaliacaoUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | avaliacaoCreateOrConnectWithoutProjetoInput
      | avaliacaoCreateOrConnectWithoutProjetoInput[];
    createMany?: avaliacaoCreateManyProjetoInputEnvelope;
    connect?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
  };

  export type metaCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          metaCreateWithoutProjetoInput,
          metaUncheckedCreateWithoutProjetoInput
        >
      | metaCreateWithoutProjetoInput[]
      | metaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutProjetoInput
      | metaCreateOrConnectWithoutProjetoInput[];
    createMany?: metaCreateManyProjetoInputEnvelope;
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
  };

  export type clienteCreateNestedOneWithoutProjetoInput = {
    create?: XOR<
      clienteCreateWithoutProjetoInput,
      clienteUncheckedCreateWithoutProjetoInput
    >;
    connectOrCreate?: clienteCreateOrConnectWithoutProjetoInput;
    connect?: clienteWhereUniqueInput;
  };

  export type recursoCreateNestedOneWithoutProjetoInput = {
    create?: XOR<
      recursoCreateWithoutProjetoInput,
      recursoUncheckedCreateWithoutProjetoInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutProjetoInput;
    connect?: recursoWhereUniqueInput;
  };

  export type tarefaCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          tarefaCreateWithoutProjetoInput,
          tarefaUncheckedCreateWithoutProjetoInput
        >
      | tarefaCreateWithoutProjetoInput[]
      | tarefaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutProjetoInput
      | tarefaCreateOrConnectWithoutProjetoInput[];
    createMany?: tarefaCreateManyProjetoInputEnvelope;
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
  };

  export type valorCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          valorCreateWithoutProjetoInput,
          valorUncheckedCreateWithoutProjetoInput
        >
      | valorCreateWithoutProjetoInput[]
      | valorUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutProjetoInput
      | valorCreateOrConnectWithoutProjetoInput[];
    createMany?: valorCreateManyProjetoInputEnvelope;
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
  };

  export type avaliacaoUncheckedCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          avaliacaoCreateWithoutProjetoInput,
          avaliacaoUncheckedCreateWithoutProjetoInput
        >
      | avaliacaoCreateWithoutProjetoInput[]
      | avaliacaoUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | avaliacaoCreateOrConnectWithoutProjetoInput
      | avaliacaoCreateOrConnectWithoutProjetoInput[];
    createMany?: avaliacaoCreateManyProjetoInputEnvelope;
    connect?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
  };

  export type metaUncheckedCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          metaCreateWithoutProjetoInput,
          metaUncheckedCreateWithoutProjetoInput
        >
      | metaCreateWithoutProjetoInput[]
      | metaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutProjetoInput
      | metaCreateOrConnectWithoutProjetoInput[];
    createMany?: metaCreateManyProjetoInputEnvelope;
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
  };

  export type tarefaUncheckedCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          tarefaCreateWithoutProjetoInput,
          tarefaUncheckedCreateWithoutProjetoInput
        >
      | tarefaCreateWithoutProjetoInput[]
      | tarefaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutProjetoInput
      | tarefaCreateOrConnectWithoutProjetoInput[];
    createMany?: tarefaCreateManyProjetoInputEnvelope;
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
  };

  export type valorUncheckedCreateNestedManyWithoutProjetoInput = {
    create?:
      | XOR<
          valorCreateWithoutProjetoInput,
          valorUncheckedCreateWithoutProjetoInput
        >
      | valorCreateWithoutProjetoInput[]
      | valorUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutProjetoInput
      | valorCreateOrConnectWithoutProjetoInput[];
    createMany?: valorCreateManyProjetoInputEnvelope;
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
  };

  export type avaliacaoUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          avaliacaoCreateWithoutProjetoInput,
          avaliacaoUncheckedCreateWithoutProjetoInput
        >
      | avaliacaoCreateWithoutProjetoInput[]
      | avaliacaoUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | avaliacaoCreateOrConnectWithoutProjetoInput
      | avaliacaoCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | avaliacaoUpsertWithWhereUniqueWithoutProjetoInput
      | avaliacaoUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: avaliacaoCreateManyProjetoInputEnvelope;
    set?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    disconnect?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    delete?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    connect?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    update?:
      | avaliacaoUpdateWithWhereUniqueWithoutProjetoInput
      | avaliacaoUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | avaliacaoUpdateManyWithWhereWithoutProjetoInput
      | avaliacaoUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: avaliacaoScalarWhereInput | avaliacaoScalarWhereInput[];
  };

  export type metaUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          metaCreateWithoutProjetoInput,
          metaUncheckedCreateWithoutProjetoInput
        >
      | metaCreateWithoutProjetoInput[]
      | metaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutProjetoInput
      | metaCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | metaUpsertWithWhereUniqueWithoutProjetoInput
      | metaUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: metaCreateManyProjetoInputEnvelope;
    set?: metaWhereUniqueInput | metaWhereUniqueInput[];
    disconnect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    delete?: metaWhereUniqueInput | metaWhereUniqueInput[];
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    update?:
      | metaUpdateWithWhereUniqueWithoutProjetoInput
      | metaUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | metaUpdateManyWithWhereWithoutProjetoInput
      | metaUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: metaScalarWhereInput | metaScalarWhereInput[];
  };

  export type clienteUpdateOneRequiredWithoutProjetoNestedInput = {
    create?: XOR<
      clienteCreateWithoutProjetoInput,
      clienteUncheckedCreateWithoutProjetoInput
    >;
    connectOrCreate?: clienteCreateOrConnectWithoutProjetoInput;
    upsert?: clienteUpsertWithoutProjetoInput;
    connect?: clienteWhereUniqueInput;
    update?: XOR<
      XOR<
        clienteUpdateToOneWithWhereWithoutProjetoInput,
        clienteUpdateWithoutProjetoInput
      >,
      clienteUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type recursoUpdateOneRequiredWithoutProjetoNestedInput = {
    create?: XOR<
      recursoCreateWithoutProjetoInput,
      recursoUncheckedCreateWithoutProjetoInput
    >;
    connectOrCreate?: recursoCreateOrConnectWithoutProjetoInput;
    upsert?: recursoUpsertWithoutProjetoInput;
    connect?: recursoWhereUniqueInput;
    update?: XOR<
      XOR<
        recursoUpdateToOneWithWhereWithoutProjetoInput,
        recursoUpdateWithoutProjetoInput
      >,
      recursoUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type tarefaUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          tarefaCreateWithoutProjetoInput,
          tarefaUncheckedCreateWithoutProjetoInput
        >
      | tarefaCreateWithoutProjetoInput[]
      | tarefaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutProjetoInput
      | tarefaCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | tarefaUpsertWithWhereUniqueWithoutProjetoInput
      | tarefaUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: tarefaCreateManyProjetoInputEnvelope;
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    update?:
      | tarefaUpdateWithWhereUniqueWithoutProjetoInput
      | tarefaUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | tarefaUpdateManyWithWhereWithoutProjetoInput
      | tarefaUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
  };

  export type valorUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          valorCreateWithoutProjetoInput,
          valorUncheckedCreateWithoutProjetoInput
        >
      | valorCreateWithoutProjetoInput[]
      | valorUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutProjetoInput
      | valorCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | valorUpsertWithWhereUniqueWithoutProjetoInput
      | valorUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: valorCreateManyProjetoInputEnvelope;
    set?: valorWhereUniqueInput | valorWhereUniqueInput[];
    disconnect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    delete?: valorWhereUniqueInput | valorWhereUniqueInput[];
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    update?:
      | valorUpdateWithWhereUniqueWithoutProjetoInput
      | valorUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | valorUpdateManyWithWhereWithoutProjetoInput
      | valorUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: valorScalarWhereInput | valorScalarWhereInput[];
  };

  export type avaliacaoUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          avaliacaoCreateWithoutProjetoInput,
          avaliacaoUncheckedCreateWithoutProjetoInput
        >
      | avaliacaoCreateWithoutProjetoInput[]
      | avaliacaoUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | avaliacaoCreateOrConnectWithoutProjetoInput
      | avaliacaoCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | avaliacaoUpsertWithWhereUniqueWithoutProjetoInput
      | avaliacaoUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: avaliacaoCreateManyProjetoInputEnvelope;
    set?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    disconnect?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    delete?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    connect?: avaliacaoWhereUniqueInput | avaliacaoWhereUniqueInput[];
    update?:
      | avaliacaoUpdateWithWhereUniqueWithoutProjetoInput
      | avaliacaoUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | avaliacaoUpdateManyWithWhereWithoutProjetoInput
      | avaliacaoUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: avaliacaoScalarWhereInput | avaliacaoScalarWhereInput[];
  };

  export type metaUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          metaCreateWithoutProjetoInput,
          metaUncheckedCreateWithoutProjetoInput
        >
      | metaCreateWithoutProjetoInput[]
      | metaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | metaCreateOrConnectWithoutProjetoInput
      | metaCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | metaUpsertWithWhereUniqueWithoutProjetoInput
      | metaUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: metaCreateManyProjetoInputEnvelope;
    set?: metaWhereUniqueInput | metaWhereUniqueInput[];
    disconnect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    delete?: metaWhereUniqueInput | metaWhereUniqueInput[];
    connect?: metaWhereUniqueInput | metaWhereUniqueInput[];
    update?:
      | metaUpdateWithWhereUniqueWithoutProjetoInput
      | metaUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | metaUpdateManyWithWhereWithoutProjetoInput
      | metaUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: metaScalarWhereInput | metaScalarWhereInput[];
  };

  export type tarefaUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          tarefaCreateWithoutProjetoInput,
          tarefaUncheckedCreateWithoutProjetoInput
        >
      | tarefaCreateWithoutProjetoInput[]
      | tarefaUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | tarefaCreateOrConnectWithoutProjetoInput
      | tarefaCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | tarefaUpsertWithWhereUniqueWithoutProjetoInput
      | tarefaUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: tarefaCreateManyProjetoInputEnvelope;
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    update?:
      | tarefaUpdateWithWhereUniqueWithoutProjetoInput
      | tarefaUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | tarefaUpdateManyWithWhereWithoutProjetoInput
      | tarefaUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
  };

  export type valorUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?:
      | XOR<
          valorCreateWithoutProjetoInput,
          valorUncheckedCreateWithoutProjetoInput
        >
      | valorCreateWithoutProjetoInput[]
      | valorUncheckedCreateWithoutProjetoInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutProjetoInput
      | valorCreateOrConnectWithoutProjetoInput[];
    upsert?:
      | valorUpsertWithWhereUniqueWithoutProjetoInput
      | valorUpsertWithWhereUniqueWithoutProjetoInput[];
    createMany?: valorCreateManyProjetoInputEnvelope;
    set?: valorWhereUniqueInput | valorWhereUniqueInput[];
    disconnect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    delete?: valorWhereUniqueInput | valorWhereUniqueInput[];
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    update?:
      | valorUpdateWithWhereUniqueWithoutProjetoInput
      | valorUpdateWithWhereUniqueWithoutProjetoInput[];
    updateMany?:
      | valorUpdateManyWithWhereWithoutProjetoInput
      | valorUpdateManyWithWhereWithoutProjetoInput[];
    deleteMany?: valorScalarWhereInput | valorScalarWhereInput[];
  };

  export type agenrecCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          agenrecCreateWithoutRecursoInput,
          agenrecUncheckedCreateWithoutRecursoInput
        >
      | agenrecCreateWithoutRecursoInput[]
      | agenrecUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | agenrecCreateOrConnectWithoutRecursoInput
      | agenrecCreateOrConnectWithoutRecursoInput[];
    createMany?: agenrecCreateManyRecursoInputEnvelope;
    connect?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
  };

  export type avaliadoCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutRecursoInput,
          avaliadoUncheckedCreateWithoutRecursoInput
        >
      | avaliadoCreateWithoutRecursoInput[]
      | avaliadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutRecursoInput
      | avaliadoCreateOrConnectWithoutRecursoInput[];
    createMany?: avaliadoCreateManyRecursoInputEnvelope;
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
  };

  export type projetoCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          projetoCreateWithoutRecursoInput,
          projetoUncheckedCreateWithoutRecursoInput
        >
      | projetoCreateWithoutRecursoInput[]
      | projetoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutRecursoInput
      | projetoCreateOrConnectWithoutRecursoInput[];
    createMany?: projetoCreateManyRecursoInputEnvelope;
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
  };

  export type nivelCreateNestedOneWithoutRecursoInput = {
    create?: XOR<
      nivelCreateWithoutRecursoInput,
      nivelUncheckedCreateWithoutRecursoInput
    >;
    connectOrCreate?: nivelCreateOrConnectWithoutRecursoInput;
    connect?: nivelWhereUniqueInput;
  };

  export type usuarioCreateNestedOneWithoutRecursoInput = {
    create?: XOR<
      usuarioCreateWithoutRecursoInput,
      usuarioUncheckedCreateWithoutRecursoInput
    >;
    connectOrCreate?: usuarioCreateOrConnectWithoutRecursoInput;
    connect?: usuarioWhereUniqueInput;
  };

  export type tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInputEnvelope;
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    };

  export type tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInputEnvelope;
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    };

  export type chamadoCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          chamadoCreateWithoutRecursoInput,
          chamadoUncheckedCreateWithoutRecursoInput
        >
      | chamadoCreateWithoutRecursoInput[]
      | chamadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutRecursoInput
      | chamadoCreateOrConnectWithoutRecursoInput[];
    createMany?: chamadoCreateManyRecursoInputEnvelope;
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
  };

  export type agenrecUncheckedCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          agenrecCreateWithoutRecursoInput,
          agenrecUncheckedCreateWithoutRecursoInput
        >
      | agenrecCreateWithoutRecursoInput[]
      | agenrecUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | agenrecCreateOrConnectWithoutRecursoInput
      | agenrecCreateOrConnectWithoutRecursoInput[];
    createMany?: agenrecCreateManyRecursoInputEnvelope;
    connect?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
  };

  export type avaliadoUncheckedCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutRecursoInput,
          avaliadoUncheckedCreateWithoutRecursoInput
        >
      | avaliadoCreateWithoutRecursoInput[]
      | avaliadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutRecursoInput
      | avaliadoCreateOrConnectWithoutRecursoInput[];
    createMany?: avaliadoCreateManyRecursoInputEnvelope;
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
  };

  export type projetoUncheckedCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          projetoCreateWithoutRecursoInput,
          projetoUncheckedCreateWithoutRecursoInput
        >
      | projetoCreateWithoutRecursoInput[]
      | projetoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutRecursoInput
      | projetoCreateOrConnectWithoutRecursoInput[];
    createMany?: projetoCreateManyRecursoInputEnvelope;
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
  };

  export type tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInputEnvelope;
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    };

  export type tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInputEnvelope;
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
    };

  export type chamadoUncheckedCreateNestedManyWithoutRecursoInput = {
    create?:
      | XOR<
          chamadoCreateWithoutRecursoInput,
          chamadoUncheckedCreateWithoutRecursoInput
        >
      | chamadoCreateWithoutRecursoInput[]
      | chamadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutRecursoInput
      | chamadoCreateOrConnectWithoutRecursoInput[];
    createMany?: chamadoCreateManyRecursoInputEnvelope;
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
  };

  export type agenrecUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          agenrecCreateWithoutRecursoInput,
          agenrecUncheckedCreateWithoutRecursoInput
        >
      | agenrecCreateWithoutRecursoInput[]
      | agenrecUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | agenrecCreateOrConnectWithoutRecursoInput
      | agenrecCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | agenrecUpsertWithWhereUniqueWithoutRecursoInput
      | agenrecUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: agenrecCreateManyRecursoInputEnvelope;
    set?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    disconnect?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    delete?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    connect?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    update?:
      | agenrecUpdateWithWhereUniqueWithoutRecursoInput
      | agenrecUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | agenrecUpdateManyWithWhereWithoutRecursoInput
      | agenrecUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: agenrecScalarWhereInput | agenrecScalarWhereInput[];
  };

  export type avaliadoUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutRecursoInput,
          avaliadoUncheckedCreateWithoutRecursoInput
        >
      | avaliadoCreateWithoutRecursoInput[]
      | avaliadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutRecursoInput
      | avaliadoCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | avaliadoUpsertWithWhereUniqueWithoutRecursoInput
      | avaliadoUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: avaliadoCreateManyRecursoInputEnvelope;
    set?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    disconnect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    delete?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    update?:
      | avaliadoUpdateWithWhereUniqueWithoutRecursoInput
      | avaliadoUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | avaliadoUpdateManyWithWhereWithoutRecursoInput
      | avaliadoUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: avaliadoScalarWhereInput | avaliadoScalarWhereInput[];
  };

  export type projetoUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          projetoCreateWithoutRecursoInput,
          projetoUncheckedCreateWithoutRecursoInput
        >
      | projetoCreateWithoutRecursoInput[]
      | projetoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutRecursoInput
      | projetoCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | projetoUpsertWithWhereUniqueWithoutRecursoInput
      | projetoUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: projetoCreateManyRecursoInputEnvelope;
    set?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    disconnect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    delete?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    update?:
      | projetoUpdateWithWhereUniqueWithoutRecursoInput
      | projetoUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | projetoUpdateManyWithWhereWithoutRecursoInput
      | projetoUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: projetoScalarWhereInput | projetoScalarWhereInput[];
  };

  export type nivelUpdateOneRequiredWithoutRecursoNestedInput = {
    create?: XOR<
      nivelCreateWithoutRecursoInput,
      nivelUncheckedCreateWithoutRecursoInput
    >;
    connectOrCreate?: nivelCreateOrConnectWithoutRecursoInput;
    upsert?: nivelUpsertWithoutRecursoInput;
    connect?: nivelWhereUniqueInput;
    update?: XOR<
      XOR<
        nivelUpdateToOneWithWhereWithoutRecursoInput,
        nivelUpdateWithoutRecursoInput
      >,
      nivelUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type usuarioUpdateOneRequiredWithoutRecursoNestedInput = {
    create?: XOR<
      usuarioCreateWithoutRecursoInput,
      usuarioUncheckedCreateWithoutRecursoInput
    >;
    connectOrCreate?: usuarioCreateOrConnectWithoutRecursoInput;
    upsert?: usuarioUpsertWithoutRecursoInput;
    connect?: usuarioWhereUniqueInput;
    update?: XOR<
      XOR<
        usuarioUpdateToOneWithWhereWithoutRecursoInput,
        usuarioUpdateWithoutRecursoInput
      >,
      usuarioUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      upsert?:
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInputEnvelope;
      set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      update?:
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      updateMany?:
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
    };

  export type tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      upsert?:
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInputEnvelope;
      set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      update?:
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      updateMany?:
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
    };

  export type chamadoUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          chamadoCreateWithoutRecursoInput,
          chamadoUncheckedCreateWithoutRecursoInput
        >
      | chamadoCreateWithoutRecursoInput[]
      | chamadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutRecursoInput
      | chamadoCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | chamadoUpsertWithWhereUniqueWithoutRecursoInput
      | chamadoUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: chamadoCreateManyRecursoInputEnvelope;
    set?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    disconnect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    delete?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    update?:
      | chamadoUpdateWithWhereUniqueWithoutRecursoInput
      | chamadoUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | chamadoUpdateManyWithWhereWithoutRecursoInput
      | chamadoUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: chamadoScalarWhereInput | chamadoScalarWhereInput[];
  };

  export type agenrecUncheckedUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          agenrecCreateWithoutRecursoInput,
          agenrecUncheckedCreateWithoutRecursoInput
        >
      | agenrecCreateWithoutRecursoInput[]
      | agenrecUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | agenrecCreateOrConnectWithoutRecursoInput
      | agenrecCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | agenrecUpsertWithWhereUniqueWithoutRecursoInput
      | agenrecUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: agenrecCreateManyRecursoInputEnvelope;
    set?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    disconnect?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    delete?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    connect?: agenrecWhereUniqueInput | agenrecWhereUniqueInput[];
    update?:
      | agenrecUpdateWithWhereUniqueWithoutRecursoInput
      | agenrecUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | agenrecUpdateManyWithWhereWithoutRecursoInput
      | agenrecUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: agenrecScalarWhereInput | agenrecScalarWhereInput[];
  };

  export type avaliadoUncheckedUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          avaliadoCreateWithoutRecursoInput,
          avaliadoUncheckedCreateWithoutRecursoInput
        >
      | avaliadoCreateWithoutRecursoInput[]
      | avaliadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | avaliadoCreateOrConnectWithoutRecursoInput
      | avaliadoCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | avaliadoUpsertWithWhereUniqueWithoutRecursoInput
      | avaliadoUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: avaliadoCreateManyRecursoInputEnvelope;
    set?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    disconnect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    delete?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    connect?: avaliadoWhereUniqueInput | avaliadoWhereUniqueInput[];
    update?:
      | avaliadoUpdateWithWhereUniqueWithoutRecursoInput
      | avaliadoUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | avaliadoUpdateManyWithWhereWithoutRecursoInput
      | avaliadoUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: avaliadoScalarWhereInput | avaliadoScalarWhereInput[];
  };

  export type projetoUncheckedUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          projetoCreateWithoutRecursoInput,
          projetoUncheckedCreateWithoutRecursoInput
        >
      | projetoCreateWithoutRecursoInput[]
      | projetoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | projetoCreateOrConnectWithoutRecursoInput
      | projetoCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | projetoUpsertWithWhereUniqueWithoutRecursoInput
      | projetoUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: projetoCreateManyRecursoInputEnvelope;
    set?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    disconnect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    delete?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[];
    update?:
      | projetoUpdateWithWhereUniqueWithoutRecursoInput
      | projetoUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | projetoUpdateManyWithWhereWithoutRecursoInput
      | projetoUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: projetoScalarWhereInput | projetoScalarWhereInput[];
  };

  export type tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      upsert?:
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInputEnvelope;
      set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      update?:
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      updateMany?:
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
    };

  export type tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput =
    {
      create?:
        | XOR<
            tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
            tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
          >
        | tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[]
        | tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      connectOrCreate?:
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      upsert?:
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      createMany?: tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInputEnvelope;
      set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[];
      update?:
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      updateMany?:
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrec_tarefaTorecursoInput[];
      deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
    };

  export type chamadoUncheckedUpdateManyWithoutRecursoNestedInput = {
    create?:
      | XOR<
          chamadoCreateWithoutRecursoInput,
          chamadoUncheckedCreateWithoutRecursoInput
        >
      | chamadoCreateWithoutRecursoInput[]
      | chamadoUncheckedCreateWithoutRecursoInput[];
    connectOrCreate?:
      | chamadoCreateOrConnectWithoutRecursoInput
      | chamadoCreateOrConnectWithoutRecursoInput[];
    upsert?:
      | chamadoUpsertWithWhereUniqueWithoutRecursoInput
      | chamadoUpsertWithWhereUniqueWithoutRecursoInput[];
    createMany?: chamadoCreateManyRecursoInputEnvelope;
    set?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    disconnect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    delete?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    connect?: chamadoWhereUniqueInput | chamadoWhereUniqueInput[];
    update?:
      | chamadoUpdateWithWhereUniqueWithoutRecursoInput
      | chamadoUpdateWithWhereUniqueWithoutRecursoInput[];
    updateMany?:
      | chamadoUpdateManyWithWhereWithoutRecursoInput
      | chamadoUpdateManyWithWhereWithoutRecursoInput[];
    deleteMany?: chamadoScalarWhereInput | chamadoScalarWhereInput[];
  };

  export type osCreateNestedManyWithoutTarefaInput = {
    create?:
      | XOR<osCreateWithoutTarefaInput, osUncheckedCreateWithoutTarefaInput>
      | osCreateWithoutTarefaInput[]
      | osUncheckedCreateWithoutTarefaInput[];
    connectOrCreate?:
      | osCreateOrConnectWithoutTarefaInput
      | osCreateOrConnectWithoutTarefaInput[];
    createMany?: osCreateManyTarefaInputEnvelope;
    connect?: osWhereUniqueInput | osWhereUniqueInput[];
  };

  export type areaCreateNestedOneWithoutTarefaInput = {
    create?: XOR<
      areaCreateWithoutTarefaInput,
      areaUncheckedCreateWithoutTarefaInput
    >;
    connectOrCreate?: areaCreateOrConnectWithoutTarefaInput;
    connect?: areaWhereUniqueInput;
  };

  export type faseCreateNestedOneWithoutTarefaInput = {
    create?: XOR<
      faseCreateWithoutTarefaInput,
      faseUncheckedCreateWithoutTarefaInput
    >;
    connectOrCreate?: faseCreateOrConnectWithoutTarefaInput;
    connect?: faseWhereUniqueInput;
  };

  export type projetoCreateNestedOneWithoutTarefaInput = {
    create?: XOR<
      projetoCreateWithoutTarefaInput,
      projetoUncheckedCreateWithoutTarefaInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutTarefaInput;
    connect?: projetoWhereUniqueInput;
  };

  export type recursoCreateNestedOneWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      create?: XOR<
        recursoCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput,
        recursoUncheckedCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
      >;
      connectOrCreate?: recursoCreateOrConnectWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
      connect?: recursoWhereUniqueInput;
    };

  export type recursoCreateNestedOneWithoutTarefa_tarefa_codrec_tarefaTorecursoInput =
    {
      create?: XOR<
        recursoCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput,
        recursoUncheckedCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
      >;
      connectOrCreate?: recursoCreateOrConnectWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
      connect?: recursoWhereUniqueInput;
    };

  export type osUncheckedCreateNestedManyWithoutTarefaInput = {
    create?:
      | XOR<osCreateWithoutTarefaInput, osUncheckedCreateWithoutTarefaInput>
      | osCreateWithoutTarefaInput[]
      | osUncheckedCreateWithoutTarefaInput[];
    connectOrCreate?:
      | osCreateOrConnectWithoutTarefaInput
      | osCreateOrConnectWithoutTarefaInput[];
    createMany?: osCreateManyTarefaInputEnvelope;
    connect?: osWhereUniqueInput | osWhereUniqueInput[];
  };

  export type osUpdateManyWithoutTarefaNestedInput = {
    create?:
      | XOR<osCreateWithoutTarefaInput, osUncheckedCreateWithoutTarefaInput>
      | osCreateWithoutTarefaInput[]
      | osUncheckedCreateWithoutTarefaInput[];
    connectOrCreate?:
      | osCreateOrConnectWithoutTarefaInput
      | osCreateOrConnectWithoutTarefaInput[];
    upsert?:
      | osUpsertWithWhereUniqueWithoutTarefaInput
      | osUpsertWithWhereUniqueWithoutTarefaInput[];
    createMany?: osCreateManyTarefaInputEnvelope;
    set?: osWhereUniqueInput | osWhereUniqueInput[];
    disconnect?: osWhereUniqueInput | osWhereUniqueInput[];
    delete?: osWhereUniqueInput | osWhereUniqueInput[];
    connect?: osWhereUniqueInput | osWhereUniqueInput[];
    update?:
      | osUpdateWithWhereUniqueWithoutTarefaInput
      | osUpdateWithWhereUniqueWithoutTarefaInput[];
    updateMany?:
      | osUpdateManyWithWhereWithoutTarefaInput
      | osUpdateManyWithWhereWithoutTarefaInput[];
    deleteMany?: osScalarWhereInput | osScalarWhereInput[];
  };

  export type areaUpdateOneRequiredWithoutTarefaNestedInput = {
    create?: XOR<
      areaCreateWithoutTarefaInput,
      areaUncheckedCreateWithoutTarefaInput
    >;
    connectOrCreate?: areaCreateOrConnectWithoutTarefaInput;
    upsert?: areaUpsertWithoutTarefaInput;
    connect?: areaWhereUniqueInput;
    update?: XOR<
      XOR<
        areaUpdateToOneWithWhereWithoutTarefaInput,
        areaUpdateWithoutTarefaInput
      >,
      areaUncheckedUpdateWithoutTarefaInput
    >;
  };

  export type faseUpdateOneRequiredWithoutTarefaNestedInput = {
    create?: XOR<
      faseCreateWithoutTarefaInput,
      faseUncheckedCreateWithoutTarefaInput
    >;
    connectOrCreate?: faseCreateOrConnectWithoutTarefaInput;
    upsert?: faseUpsertWithoutTarefaInput;
    connect?: faseWhereUniqueInput;
    update?: XOR<
      XOR<
        faseUpdateToOneWithWhereWithoutTarefaInput,
        faseUpdateWithoutTarefaInput
      >,
      faseUncheckedUpdateWithoutTarefaInput
    >;
  };

  export type projetoUpdateOneRequiredWithoutTarefaNestedInput = {
    create?: XOR<
      projetoCreateWithoutTarefaInput,
      projetoUncheckedCreateWithoutTarefaInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutTarefaInput;
    upsert?: projetoUpsertWithoutTarefaInput;
    connect?: projetoWhereUniqueInput;
    update?: XOR<
      XOR<
        projetoUpdateToOneWithWhereWithoutTarefaInput,
        projetoUpdateWithoutTarefaInput
      >,
      projetoUncheckedUpdateWithoutTarefaInput
    >;
  };

  export type recursoUpdateOneRequiredWithoutTarefa_tarefa_codrecresp_tarefaTorecursoNestedInput =
    {
      create?: XOR<
        recursoCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput,
        recursoUncheckedCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
      >;
      connectOrCreate?: recursoCreateOrConnectWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
      upsert?: recursoUpsertWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
      connect?: recursoWhereUniqueInput;
      update?: XOR<
        XOR<
          recursoUpdateToOneWithWhereWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput,
          recursoUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
        >,
        recursoUncheckedUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
      >;
    };

  export type recursoUpdateOneRequiredWithoutTarefa_tarefa_codrec_tarefaTorecursoNestedInput =
    {
      create?: XOR<
        recursoCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput,
        recursoUncheckedCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
      >;
      connectOrCreate?: recursoCreateOrConnectWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
      upsert?: recursoUpsertWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
      connect?: recursoWhereUniqueInput;
      update?: XOR<
        XOR<
          recursoUpdateToOneWithWhereWithoutTarefa_tarefa_codrec_tarefaTorecursoInput,
          recursoUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
        >,
        recursoUncheckedUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
      >;
    };

  export type osUncheckedUpdateManyWithoutTarefaNestedInput = {
    create?:
      | XOR<osCreateWithoutTarefaInput, osUncheckedCreateWithoutTarefaInput>
      | osCreateWithoutTarefaInput[]
      | osUncheckedCreateWithoutTarefaInput[];
    connectOrCreate?:
      | osCreateOrConnectWithoutTarefaInput
      | osCreateOrConnectWithoutTarefaInput[];
    upsert?:
      | osUpsertWithWhereUniqueWithoutTarefaInput
      | osUpsertWithWhereUniqueWithoutTarefaInput[];
    createMany?: osCreateManyTarefaInputEnvelope;
    set?: osWhereUniqueInput | osWhereUniqueInput[];
    disconnect?: osWhereUniqueInput | osWhereUniqueInput[];
    delete?: osWhereUniqueInput | osWhereUniqueInput[];
    connect?: osWhereUniqueInput | osWhereUniqueInput[];
    update?:
      | osUpdateWithWhereUniqueWithoutTarefaInput
      | osUpdateWithWhereUniqueWithoutTarefaInput[];
    updateMany?:
      | osUpdateManyWithWhereWithoutTarefaInput
      | osUpdateManyWithWhereWithoutTarefaInput[];
    deleteMany?: osScalarWhereInput | osScalarWhereInput[];
  };

  export type acesso_sistemaCreateNestedManyWithoutTela_sistemaInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutTela_sistemaInput,
          acesso_sistemaUncheckedCreateWithoutTela_sistemaInput
        >
      | acesso_sistemaCreateWithoutTela_sistemaInput[]
      | acesso_sistemaUncheckedCreateWithoutTela_sistemaInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput
      | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput[];
    createMany?: acesso_sistemaCreateManyTela_sistemaInputEnvelope;
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
  };

  export type modulo_sistemaCreateNestedOneWithoutTela_sistemaInput = {
    create?: XOR<
      modulo_sistemaCreateWithoutTela_sistemaInput,
      modulo_sistemaUncheckedCreateWithoutTela_sistemaInput
    >;
    connectOrCreate?: modulo_sistemaCreateOrConnectWithoutTela_sistemaInput;
    connect?: modulo_sistemaWhereUniqueInput;
  };

  export type acesso_sistemaUncheckedCreateNestedManyWithoutTela_sistemaInput =
    {
      create?:
        | XOR<
            acesso_sistemaCreateWithoutTela_sistemaInput,
            acesso_sistemaUncheckedCreateWithoutTela_sistemaInput
          >
        | acesso_sistemaCreateWithoutTela_sistemaInput[]
        | acesso_sistemaUncheckedCreateWithoutTela_sistemaInput[];
      connectOrCreate?:
        | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput
        | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput[];
      createMany?: acesso_sistemaCreateManyTela_sistemaInputEnvelope;
      connect?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
    };

  export type acesso_sistemaUpdateManyWithoutTela_sistemaNestedInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutTela_sistemaInput,
          acesso_sistemaUncheckedCreateWithoutTela_sistemaInput
        >
      | acesso_sistemaCreateWithoutTela_sistemaInput[]
      | acesso_sistemaUncheckedCreateWithoutTela_sistemaInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput
      | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput[];
    upsert?:
      | acesso_sistemaUpsertWithWhereUniqueWithoutTela_sistemaInput
      | acesso_sistemaUpsertWithWhereUniqueWithoutTela_sistemaInput[];
    createMany?: acesso_sistemaCreateManyTela_sistemaInputEnvelope;
    set?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    disconnect?:
      | acesso_sistemaWhereUniqueInput
      | acesso_sistemaWhereUniqueInput[];
    delete?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    update?:
      | acesso_sistemaUpdateWithWhereUniqueWithoutTela_sistemaInput
      | acesso_sistemaUpdateWithWhereUniqueWithoutTela_sistemaInput[];
    updateMany?:
      | acesso_sistemaUpdateManyWithWhereWithoutTela_sistemaInput
      | acesso_sistemaUpdateManyWithWhereWithoutTela_sistemaInput[];
    deleteMany?:
      | acesso_sistemaScalarWhereInput
      | acesso_sistemaScalarWhereInput[];
  };

  export type modulo_sistemaUpdateOneRequiredWithoutTela_sistemaNestedInput = {
    create?: XOR<
      modulo_sistemaCreateWithoutTela_sistemaInput,
      modulo_sistemaUncheckedCreateWithoutTela_sistemaInput
    >;
    connectOrCreate?: modulo_sistemaCreateOrConnectWithoutTela_sistemaInput;
    upsert?: modulo_sistemaUpsertWithoutTela_sistemaInput;
    connect?: modulo_sistemaWhereUniqueInput;
    update?: XOR<
      XOR<
        modulo_sistemaUpdateToOneWithWhereWithoutTela_sistemaInput,
        modulo_sistemaUpdateWithoutTela_sistemaInput
      >,
      modulo_sistemaUncheckedUpdateWithoutTela_sistemaInput
    >;
  };

  export type acesso_sistemaUncheckedUpdateManyWithoutTela_sistemaNestedInput =
    {
      create?:
        | XOR<
            acesso_sistemaCreateWithoutTela_sistemaInput,
            acesso_sistemaUncheckedCreateWithoutTela_sistemaInput
          >
        | acesso_sistemaCreateWithoutTela_sistemaInput[]
        | acesso_sistemaUncheckedCreateWithoutTela_sistemaInput[];
      connectOrCreate?:
        | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput
        | acesso_sistemaCreateOrConnectWithoutTela_sistemaInput[];
      upsert?:
        | acesso_sistemaUpsertWithWhereUniqueWithoutTela_sistemaInput
        | acesso_sistemaUpsertWithWhereUniqueWithoutTela_sistemaInput[];
      createMany?: acesso_sistemaCreateManyTela_sistemaInputEnvelope;
      set?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
      disconnect?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
      delete?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
      connect?:
        | acesso_sistemaWhereUniqueInput
        | acesso_sistemaWhereUniqueInput[];
      update?:
        | acesso_sistemaUpdateWithWhereUniqueWithoutTela_sistemaInput
        | acesso_sistemaUpdateWithWhereUniqueWithoutTela_sistemaInput[];
      updateMany?:
        | acesso_sistemaUpdateManyWithWhereWithoutTela_sistemaInput
        | acesso_sistemaUpdateManyWithWhereWithoutTela_sistemaInput[];
      deleteMany?:
        | acesso_sistemaScalarWhereInput
        | acesso_sistemaScalarWhereInput[];
    };

  export type valorCreateNestedManyWithoutTipotrfInput = {
    create?:
      | XOR<
          valorCreateWithoutTipotrfInput,
          valorUncheckedCreateWithoutTipotrfInput
        >
      | valorCreateWithoutTipotrfInput[]
      | valorUncheckedCreateWithoutTipotrfInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutTipotrfInput
      | valorCreateOrConnectWithoutTipotrfInput[];
    createMany?: valorCreateManyTipotrfInputEnvelope;
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
  };

  export type valorUncheckedCreateNestedManyWithoutTipotrfInput = {
    create?:
      | XOR<
          valorCreateWithoutTipotrfInput,
          valorUncheckedCreateWithoutTipotrfInput
        >
      | valorCreateWithoutTipotrfInput[]
      | valorUncheckedCreateWithoutTipotrfInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutTipotrfInput
      | valorCreateOrConnectWithoutTipotrfInput[];
    createMany?: valorCreateManyTipotrfInputEnvelope;
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
  };

  export type valorUpdateManyWithoutTipotrfNestedInput = {
    create?:
      | XOR<
          valorCreateWithoutTipotrfInput,
          valorUncheckedCreateWithoutTipotrfInput
        >
      | valorCreateWithoutTipotrfInput[]
      | valorUncheckedCreateWithoutTipotrfInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutTipotrfInput
      | valorCreateOrConnectWithoutTipotrfInput[];
    upsert?:
      | valorUpsertWithWhereUniqueWithoutTipotrfInput
      | valorUpsertWithWhereUniqueWithoutTipotrfInput[];
    createMany?: valorCreateManyTipotrfInputEnvelope;
    set?: valorWhereUniqueInput | valorWhereUniqueInput[];
    disconnect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    delete?: valorWhereUniqueInput | valorWhereUniqueInput[];
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    update?:
      | valorUpdateWithWhereUniqueWithoutTipotrfInput
      | valorUpdateWithWhereUniqueWithoutTipotrfInput[];
    updateMany?:
      | valorUpdateManyWithWhereWithoutTipotrfInput
      | valorUpdateManyWithWhereWithoutTipotrfInput[];
    deleteMany?: valorScalarWhereInput | valorScalarWhereInput[];
  };

  export type valorUncheckedUpdateManyWithoutTipotrfNestedInput = {
    create?:
      | XOR<
          valorCreateWithoutTipotrfInput,
          valorUncheckedCreateWithoutTipotrfInput
        >
      | valorCreateWithoutTipotrfInput[]
      | valorUncheckedCreateWithoutTipotrfInput[];
    connectOrCreate?:
      | valorCreateOrConnectWithoutTipotrfInput
      | valorCreateOrConnectWithoutTipotrfInput[];
    upsert?:
      | valorUpsertWithWhereUniqueWithoutTipotrfInput
      | valorUpsertWithWhereUniqueWithoutTipotrfInput[];
    createMany?: valorCreateManyTipotrfInputEnvelope;
    set?: valorWhereUniqueInput | valorWhereUniqueInput[];
    disconnect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    delete?: valorWhereUniqueInput | valorWhereUniqueInput[];
    connect?: valorWhereUniqueInput | valorWhereUniqueInput[];
    update?:
      | valorUpdateWithWhereUniqueWithoutTipotrfInput
      | valorUpdateWithWhereUniqueWithoutTipotrfInput[];
    updateMany?:
      | valorUpdateManyWithWhereWithoutTipotrfInput
      | valorUpdateManyWithWhereWithoutTipotrfInput[];
    deleteMany?: valorScalarWhereInput | valorScalarWhereInput[];
  };

  export type acesso_sistemaCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutUsuarioInput,
          acesso_sistemaUncheckedCreateWithoutUsuarioInput
        >
      | acesso_sistemaCreateWithoutUsuarioInput[]
      | acesso_sistemaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput[];
    createMany?: acesso_sistemaCreateManyUsuarioInputEnvelope;
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
  };

  export type recursoCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          recursoCreateWithoutUsuarioInput,
          recursoUncheckedCreateWithoutUsuarioInput
        >
      | recursoCreateWithoutUsuarioInput[]
      | recursoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutUsuarioInput
      | recursoCreateOrConnectWithoutUsuarioInput[];
    createMany?: recursoCreateManyUsuarioInputEnvelope;
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
  };

  export type acesso_sistemaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutUsuarioInput,
          acesso_sistemaUncheckedCreateWithoutUsuarioInput
        >
      | acesso_sistemaCreateWithoutUsuarioInput[]
      | acesso_sistemaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput[];
    createMany?: acesso_sistemaCreateManyUsuarioInputEnvelope;
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
  };

  export type recursoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?:
      | XOR<
          recursoCreateWithoutUsuarioInput,
          recursoUncheckedCreateWithoutUsuarioInput
        >
      | recursoCreateWithoutUsuarioInput[]
      | recursoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutUsuarioInput
      | recursoCreateOrConnectWithoutUsuarioInput[];
    createMany?: recursoCreateManyUsuarioInputEnvelope;
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
  };

  export type acesso_sistemaUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutUsuarioInput,
          acesso_sistemaUncheckedCreateWithoutUsuarioInput
        >
      | acesso_sistemaCreateWithoutUsuarioInput[]
      | acesso_sistemaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | acesso_sistemaUpsertWithWhereUniqueWithoutUsuarioInput
      | acesso_sistemaUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: acesso_sistemaCreateManyUsuarioInputEnvelope;
    set?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    disconnect?:
      | acesso_sistemaWhereUniqueInput
      | acesso_sistemaWhereUniqueInput[];
    delete?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    update?:
      | acesso_sistemaUpdateWithWhereUniqueWithoutUsuarioInput
      | acesso_sistemaUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | acesso_sistemaUpdateManyWithWhereWithoutUsuarioInput
      | acesso_sistemaUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?:
      | acesso_sistemaScalarWhereInput
      | acesso_sistemaScalarWhereInput[];
  };

  export type recursoUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          recursoCreateWithoutUsuarioInput,
          recursoUncheckedCreateWithoutUsuarioInput
        >
      | recursoCreateWithoutUsuarioInput[]
      | recursoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutUsuarioInput
      | recursoCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | recursoUpsertWithWhereUniqueWithoutUsuarioInput
      | recursoUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: recursoCreateManyUsuarioInputEnvelope;
    set?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    disconnect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    delete?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    update?:
      | recursoUpdateWithWhereUniqueWithoutUsuarioInput
      | recursoUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | recursoUpdateManyWithWhereWithoutUsuarioInput
      | recursoUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: recursoScalarWhereInput | recursoScalarWhereInput[];
  };

  export type acesso_sistemaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          acesso_sistemaCreateWithoutUsuarioInput,
          acesso_sistemaUncheckedCreateWithoutUsuarioInput
        >
      | acesso_sistemaCreateWithoutUsuarioInput[]
      | acesso_sistemaUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput
      | acesso_sistemaCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | acesso_sistemaUpsertWithWhereUniqueWithoutUsuarioInput
      | acesso_sistemaUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: acesso_sistemaCreateManyUsuarioInputEnvelope;
    set?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    disconnect?:
      | acesso_sistemaWhereUniqueInput
      | acesso_sistemaWhereUniqueInput[];
    delete?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    connect?: acesso_sistemaWhereUniqueInput | acesso_sistemaWhereUniqueInput[];
    update?:
      | acesso_sistemaUpdateWithWhereUniqueWithoutUsuarioInput
      | acesso_sistemaUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | acesso_sistemaUpdateManyWithWhereWithoutUsuarioInput
      | acesso_sistemaUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?:
      | acesso_sistemaScalarWhereInput
      | acesso_sistemaScalarWhereInput[];
  };

  export type recursoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?:
      | XOR<
          recursoCreateWithoutUsuarioInput,
          recursoUncheckedCreateWithoutUsuarioInput
        >
      | recursoCreateWithoutUsuarioInput[]
      | recursoUncheckedCreateWithoutUsuarioInput[];
    connectOrCreate?:
      | recursoCreateOrConnectWithoutUsuarioInput
      | recursoCreateOrConnectWithoutUsuarioInput[];
    upsert?:
      | recursoUpsertWithWhereUniqueWithoutUsuarioInput
      | recursoUpsertWithWhereUniqueWithoutUsuarioInput[];
    createMany?: recursoCreateManyUsuarioInputEnvelope;
    set?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    disconnect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    delete?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[];
    update?:
      | recursoUpdateWithWhereUniqueWithoutUsuarioInput
      | recursoUpdateWithWhereUniqueWithoutUsuarioInput[];
    updateMany?:
      | recursoUpdateManyWithWhereWithoutUsuarioInput
      | recursoUpdateManyWithWhereWithoutUsuarioInput[];
    deleteMany?: recursoScalarWhereInput | recursoScalarWhereInput[];
  };

  export type projetoCreateNestedOneWithoutValorInput = {
    create?: XOR<
      projetoCreateWithoutValorInput,
      projetoUncheckedCreateWithoutValorInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutValorInput;
    connect?: projetoWhereUniqueInput;
  };

  export type tipotrfCreateNestedOneWithoutValorInput = {
    create?: XOR<
      tipotrfCreateWithoutValorInput,
      tipotrfUncheckedCreateWithoutValorInput
    >;
    connectOrCreate?: tipotrfCreateOrConnectWithoutValorInput;
    connect?: tipotrfWhereUniqueInput;
  };

  export type projetoUpdateOneRequiredWithoutValorNestedInput = {
    create?: XOR<
      projetoCreateWithoutValorInput,
      projetoUncheckedCreateWithoutValorInput
    >;
    connectOrCreate?: projetoCreateOrConnectWithoutValorInput;
    upsert?: projetoUpsertWithoutValorInput;
    connect?: projetoWhereUniqueInput;
    update?: XOR<
      XOR<
        projetoUpdateToOneWithWhereWithoutValorInput,
        projetoUpdateWithoutValorInput
      >,
      projetoUncheckedUpdateWithoutValorInput
    >;
  };

  export type tipotrfUpdateOneRequiredWithoutValorNestedInput = {
    create?: XOR<
      tipotrfCreateWithoutValorInput,
      tipotrfUncheckedCreateWithoutValorInput
    >;
    connectOrCreate?: tipotrfCreateOrConnectWithoutValorInput;
    upsert?: tipotrfUpsertWithoutValorInput;
    connect?: tipotrfWhereUniqueInput;
    update?: XOR<
      XOR<
        tipotrfUpdateToOneWithWhereWithoutValorInput,
        tipotrfUpdateWithoutValorInput
      >,
      tipotrfUncheckedUpdateWithoutValorInput
    >;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
        | null;
      in?:
        | Decimal[]
        | DecimalJsLike[]
        | number[]
        | string[]
        | ListDecimalFieldRefInput<$PrismaModel>
        | null;
      notIn?:
        | Decimal[]
        | DecimalJsLike[]
        | number[]
        | string[]
        | ListDecimalFieldRefInput<$PrismaModel>
        | null;
      lt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      lte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      gte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>;
      not?:
        | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _avg?: NestedDecimalNullableFilter<$PrismaModel>;
      _sum?: NestedDecimalNullableFilter<$PrismaModel>;
      _min?: NestedDecimalNullableFilter<$PrismaModel>;
      _max?: NestedDecimalNullableFilter<$PrismaModel>;
    };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null;
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null;
  };

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null;
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null;
    not?:
      | NestedBytesNullableWithAggregatesFilter<$PrismaModel>
      | Uint8Array
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBytesNullableFilter<$PrismaModel>;
    _max?: NestedBytesNullableFilter<$PrismaModel>;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type modulo_sistemaCreateWithoutAcesso_sistemaInput = {
    cod_modulo: number;
    desc_modulo: string;
    tela_sistema?: tela_sistemaCreateNestedManyWithoutModulo_sistemaInput;
  };

  export type modulo_sistemaUncheckedCreateWithoutAcesso_sistemaInput = {
    cod_modulo: number;
    desc_modulo: string;
    tela_sistema?: tela_sistemaUncheckedCreateNestedManyWithoutModulo_sistemaInput;
  };

  export type modulo_sistemaCreateOrConnectWithoutAcesso_sistemaInput = {
    where: modulo_sistemaWhereUniqueInput;
    create: XOR<
      modulo_sistemaCreateWithoutAcesso_sistemaInput,
      modulo_sistemaUncheckedCreateWithoutAcesso_sistemaInput
    >;
  };

  export type tela_sistemaCreateWithoutAcesso_sistemaInput = {
    cod_tela: number;
    desc_tela: string;
    modulo_sistema: modulo_sistemaCreateNestedOneWithoutTela_sistemaInput;
  };

  export type tela_sistemaUncheckedCreateWithoutAcesso_sistemaInput = {
    cod_tela: number;
    cod_modulo: number;
    desc_tela: string;
  };

  export type tela_sistemaCreateOrConnectWithoutAcesso_sistemaInput = {
    where: tela_sistemaWhereUniqueInput;
    create: XOR<
      tela_sistemaCreateWithoutAcesso_sistemaInput,
      tela_sistemaUncheckedCreateWithoutAcesso_sistemaInput
    >;
  };

  export type usuarioCreateWithoutAcesso_sistemaInput = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha?: string | null;
    tipo_usuario?: string;
    permtar_usuario?: string;
    altsen_usuario?: number;
    perproj1_usuario?: string;
    perproj2_usuario?: string;
    tela1_usuario?: number | null;
    tela2_usuario?: number | null;
    tela3_usuario?: number | null;
    tela4_usuario?: number | null;
    recurso?: recursoCreateNestedManyWithoutUsuarioInput;
  };

  export type usuarioUncheckedCreateWithoutAcesso_sistemaInput = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha?: string | null;
    tipo_usuario?: string;
    permtar_usuario?: string;
    altsen_usuario?: number;
    perproj1_usuario?: string;
    perproj2_usuario?: string;
    tela1_usuario?: number | null;
    tela2_usuario?: number | null;
    tela3_usuario?: number | null;
    tela4_usuario?: number | null;
    recurso?: recursoUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type usuarioCreateOrConnectWithoutAcesso_sistemaInput = {
    where: usuarioWhereUniqueInput;
    create: XOR<
      usuarioCreateWithoutAcesso_sistemaInput,
      usuarioUncheckedCreateWithoutAcesso_sistemaInput
    >;
  };

  export type modulo_sistemaUpsertWithoutAcesso_sistemaInput = {
    update: XOR<
      modulo_sistemaUpdateWithoutAcesso_sistemaInput,
      modulo_sistemaUncheckedUpdateWithoutAcesso_sistemaInput
    >;
    create: XOR<
      modulo_sistemaCreateWithoutAcesso_sistemaInput,
      modulo_sistemaUncheckedCreateWithoutAcesso_sistemaInput
    >;
    where?: modulo_sistemaWhereInput;
  };

  export type modulo_sistemaUpdateToOneWithWhereWithoutAcesso_sistemaInput = {
    where?: modulo_sistemaWhereInput;
    data: XOR<
      modulo_sistemaUpdateWithoutAcesso_sistemaInput,
      modulo_sistemaUncheckedUpdateWithoutAcesso_sistemaInput
    >;
  };

  export type modulo_sistemaUpdateWithoutAcesso_sistemaInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
    tela_sistema?: tela_sistemaUpdateManyWithoutModulo_sistemaNestedInput;
  };

  export type modulo_sistemaUncheckedUpdateWithoutAcesso_sistemaInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
    tela_sistema?: tela_sistemaUncheckedUpdateManyWithoutModulo_sistemaNestedInput;
  };

  export type tela_sistemaUpsertWithoutAcesso_sistemaInput = {
    update: XOR<
      tela_sistemaUpdateWithoutAcesso_sistemaInput,
      tela_sistemaUncheckedUpdateWithoutAcesso_sistemaInput
    >;
    create: XOR<
      tela_sistemaCreateWithoutAcesso_sistemaInput,
      tela_sistemaUncheckedCreateWithoutAcesso_sistemaInput
    >;
    where?: tela_sistemaWhereInput;
  };

  export type tela_sistemaUpdateToOneWithWhereWithoutAcesso_sistemaInput = {
    where?: tela_sistemaWhereInput;
    data: XOR<
      tela_sistemaUpdateWithoutAcesso_sistemaInput,
      tela_sistemaUncheckedUpdateWithoutAcesso_sistemaInput
    >;
  };

  export type tela_sistemaUpdateWithoutAcesso_sistemaInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
    modulo_sistema?: modulo_sistemaUpdateOneRequiredWithoutTela_sistemaNestedInput;
  };

  export type tela_sistemaUncheckedUpdateWithoutAcesso_sistemaInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
  };

  export type usuarioUpsertWithoutAcesso_sistemaInput = {
    update: XOR<
      usuarioUpdateWithoutAcesso_sistemaInput,
      usuarioUncheckedUpdateWithoutAcesso_sistemaInput
    >;
    create: XOR<
      usuarioCreateWithoutAcesso_sistemaInput,
      usuarioUncheckedCreateWithoutAcesso_sistemaInput
    >;
    where?: usuarioWhereInput;
  };

  export type usuarioUpdateToOneWithWhereWithoutAcesso_sistemaInput = {
    where?: usuarioWhereInput;
    data: XOR<
      usuarioUpdateWithoutAcesso_sistemaInput,
      usuarioUncheckedUpdateWithoutAcesso_sistemaInput
    >;
  };

  export type usuarioUpdateWithoutAcesso_sistemaInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    recurso?: recursoUpdateManyWithoutUsuarioNestedInput;
  };

  export type usuarioUncheckedUpdateWithoutAcesso_sistemaInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    recurso?: recursoUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type recursoCreateWithoutAgenrecInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
    projeto?: projetoCreateNestedManyWithoutRecursoInput;
    nivel: nivelCreateNestedOneWithoutRecursoInput;
    usuario: usuarioCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUncheckedCreateWithoutAgenrecInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
  };

  export type recursoCreateOrConnectWithoutAgenrecInput = {
    where: recursoWhereUniqueInput;
    create: XOR<
      recursoCreateWithoutAgenrecInput,
      recursoUncheckedCreateWithoutAgenrecInput
    >;
  };

  export type recursoUpsertWithoutAgenrecInput = {
    update: XOR<
      recursoUpdateWithoutAgenrecInput,
      recursoUncheckedUpdateWithoutAgenrecInput
    >;
    create: XOR<
      recursoCreateWithoutAgenrecInput,
      recursoUncheckedCreateWithoutAgenrecInput
    >;
    where?: recursoWhereInput;
  };

  export type recursoUpdateToOneWithWhereWithoutAgenrecInput = {
    where?: recursoWhereInput;
    data: XOR<
      recursoUpdateWithoutAgenrecInput,
      recursoUncheckedUpdateWithoutAgenrecInput
    >;
  };

  export type recursoUpdateWithoutAgenrecInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUpdateManyWithoutRecursoNestedInput;
    nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateWithoutAgenrecInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
  };

  export type metaCreateWithoutAreaInput = {
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
    fase: faseCreateNestedOneWithoutMetaInput;
    projeto: projetoCreateNestedOneWithoutMetaInput;
  };

  export type metaUncheckedCreateWithoutAreaInput = {
    codproj_meta: number;
    codfase_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type metaCreateOrConnectWithoutAreaInput = {
    where: metaWhereUniqueInput;
    create: XOR<
      metaCreateWithoutAreaInput,
      metaUncheckedCreateWithoutAreaInput
    >;
  };

  export type metaCreateManyAreaInputEnvelope = {
    data: metaCreateManyAreaInput | metaCreateManyAreaInput[];
    skipDuplicates?: boolean;
  };

  export type tarefaCreateWithoutAreaInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osCreateNestedManyWithoutTarefaInput;
    fase: faseCreateNestedOneWithoutTarefaInput;
    projeto: projetoCreateNestedOneWithoutTarefaInput;
    recurso_tarefa_codrecresp_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
    recurso_tarefa_codrec_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
  };

  export type tarefaUncheckedCreateWithoutAreaInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osUncheckedCreateNestedManyWithoutTarefaInput;
  };

  export type tarefaCreateOrConnectWithoutAreaInput = {
    where: tarefaWhereUniqueInput;
    create: XOR<
      tarefaCreateWithoutAreaInput,
      tarefaUncheckedCreateWithoutAreaInput
    >;
  };

  export type tarefaCreateManyAreaInputEnvelope = {
    data: tarefaCreateManyAreaInput | tarefaCreateManyAreaInput[];
    skipDuplicates?: boolean;
  };

  export type metaUpsertWithWhereUniqueWithoutAreaInput = {
    where: metaWhereUniqueInput;
    update: XOR<
      metaUpdateWithoutAreaInput,
      metaUncheckedUpdateWithoutAreaInput
    >;
    create: XOR<
      metaCreateWithoutAreaInput,
      metaUncheckedCreateWithoutAreaInput
    >;
  };

  export type metaUpdateWithWhereUniqueWithoutAreaInput = {
    where: metaWhereUniqueInput;
    data: XOR<metaUpdateWithoutAreaInput, metaUncheckedUpdateWithoutAreaInput>;
  };

  export type metaUpdateManyWithWhereWithoutAreaInput = {
    where: metaScalarWhereInput;
    data: XOR<
      metaUpdateManyMutationInput,
      metaUncheckedUpdateManyWithoutAreaInput
    >;
  };

  export type metaScalarWhereInput = {
    AND?: metaScalarWhereInput | metaScalarWhereInput[];
    OR?: metaScalarWhereInput[];
    NOT?: metaScalarWhereInput | metaScalarWhereInput[];
    codproj_meta?: IntFilter<'meta'> | number;
    codarea_meta?: IntFilter<'meta'> | number;
    codfase_meta?: IntFilter<'meta'> | number;
    tempo_meta?:
      | DecimalFilter<'meta'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFilter<'meta'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type tarefaUpsertWithWhereUniqueWithoutAreaInput = {
    where: tarefaWhereUniqueInput;
    update: XOR<
      tarefaUpdateWithoutAreaInput,
      tarefaUncheckedUpdateWithoutAreaInput
    >;
    create: XOR<
      tarefaCreateWithoutAreaInput,
      tarefaUncheckedCreateWithoutAreaInput
    >;
  };

  export type tarefaUpdateWithWhereUniqueWithoutAreaInput = {
    where: tarefaWhereUniqueInput;
    data: XOR<
      tarefaUpdateWithoutAreaInput,
      tarefaUncheckedUpdateWithoutAreaInput
    >;
  };

  export type tarefaUpdateManyWithWhereWithoutAreaInput = {
    where: tarefaScalarWhereInput;
    data: XOR<
      tarefaUpdateManyMutationInput,
      tarefaUncheckedUpdateManyWithoutAreaInput
    >;
  };

  export type tarefaScalarWhereInput = {
    AND?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
    OR?: tarefaScalarWhereInput[];
    NOT?: tarefaScalarWhereInput | tarefaScalarWhereInput[];
    cod_tarefa?: IntFilter<'tarefa'> | number;
    nome_tarefa?: StringFilter<'tarefa'> | string;
    codpro_tarefa?: IntFilter<'tarefa'> | number;
    codrec_tarefa?: IntFilter<'tarefa'> | number;
    dtsol_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
    dtaprov_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
    dtprevent_tarefa?: DateTimeNullableFilter<'tarefa'> | Date | string | null;
    hrest_tarefa?:
      | DecimalNullableFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | DecimalNullableFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFilter<'tarefa'> | string;
    status_tarefa?: IntFilter<'tarefa'> | number;
    ordem_tarefa?: IntFilter<'tarefa'> | number;
    cod_area?: IntFilter<'tarefa'> | number;
    estimado_tarefa?: StringFilter<'tarefa'> | string;
    cod_tipotrf?: IntFilter<'tarefa'> | number;
    codrecresp_tarefa?: IntFilter<'tarefa'> | number;
    hrreal_tarefa?:
      | DecimalNullableFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFilter<'tarefa'> | string;
    cod_fase?: IntFilter<'tarefa'> | number;
    valini_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
    valfim_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
    perimp_tarefa?: StringFilter<'tarefa'> | string;
    dtinc_tarefa?: DateTimeFilter<'tarefa'> | Date | string;
    perc_tarefa?: IntFilter<'tarefa'> | number;
    fatura_tarefa?: StringFilter<'tarefa'> | string;
    valida_tarefa?: IntFilter<'tarefa'> | number;
    vrhr_tarefa?:
      | DecimalFilter<'tarefa'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: BytesNullableFilter<'tarefa'> | Uint8Array | null;
    limmes_tarefa?: IntNullableFilter<'tarefa'> | number | null;
    exibecham_tarefa?: IntNullableFilter<'tarefa'> | number | null;
  };

  export type projetoCreateWithoutAvaliacaoInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    meta?: metaCreateNestedManyWithoutProjetoInput;
    cliente: clienteCreateNestedOneWithoutProjetoInput;
    recurso: recursoCreateNestedOneWithoutProjetoInput;
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput;
    valor?: valorCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUncheckedCreateWithoutAvaliacaoInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    meta?: metaUncheckedCreateNestedManyWithoutProjetoInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput;
    valor?: valorUncheckedCreateNestedManyWithoutProjetoInput;
  };

  export type projetoCreateOrConnectWithoutAvaliacaoInput = {
    where: projetoWhereUniqueInput;
    create: XOR<
      projetoCreateWithoutAvaliacaoInput,
      projetoUncheckedCreateWithoutAvaliacaoInput
    >;
  };

  export type avaliadoCreateWithoutAvaliacaoInput = {
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
    recurso: recursoCreateNestedOneWithoutAvaliadoInput;
    itavaliado?: itavaliadoCreateNestedManyWithoutAvaliadoInput;
  };

  export type avaliadoUncheckedCreateWithoutAvaliacaoInput = {
    codrec_avaliado: number;
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
    itavaliado?: itavaliadoUncheckedCreateNestedManyWithoutAvaliadoInput;
  };

  export type avaliadoCreateOrConnectWithoutAvaliacaoInput = {
    where: avaliadoWhereUniqueInput;
    create: XOR<
      avaliadoCreateWithoutAvaliacaoInput,
      avaliadoUncheckedCreateWithoutAvaliacaoInput
    >;
  };

  export type avaliadoCreateManyAvaliacaoInputEnvelope = {
    data: avaliadoCreateManyAvaliacaoInput | avaliadoCreateManyAvaliacaoInput[];
    skipDuplicates?: boolean;
  };

  export type projetoUpsertWithoutAvaliacaoInput = {
    update: XOR<
      projetoUpdateWithoutAvaliacaoInput,
      projetoUncheckedUpdateWithoutAvaliacaoInput
    >;
    create: XOR<
      projetoCreateWithoutAvaliacaoInput,
      projetoUncheckedCreateWithoutAvaliacaoInput
    >;
    where?: projetoWhereInput;
  };

  export type projetoUpdateToOneWithWhereWithoutAvaliacaoInput = {
    where?: projetoWhereInput;
    data: XOR<
      projetoUpdateWithoutAvaliacaoInput,
      projetoUncheckedUpdateWithoutAvaliacaoInput
    >;
  };

  export type projetoUpdateWithoutAvaliacaoInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    meta?: metaUpdateManyWithoutProjetoNestedInput;
    cliente?: clienteUpdateOneRequiredWithoutProjetoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutProjetoNestedInput;
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput;
    valor?: valorUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateWithoutAvaliacaoInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    meta?: metaUncheckedUpdateManyWithoutProjetoNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput;
    valor?: valorUncheckedUpdateManyWithoutProjetoNestedInput;
  };

  export type avaliadoUpsertWithWhereUniqueWithoutAvaliacaoInput = {
    where: avaliadoWhereUniqueInput;
    update: XOR<
      avaliadoUpdateWithoutAvaliacaoInput,
      avaliadoUncheckedUpdateWithoutAvaliacaoInput
    >;
    create: XOR<
      avaliadoCreateWithoutAvaliacaoInput,
      avaliadoUncheckedCreateWithoutAvaliacaoInput
    >;
  };

  export type avaliadoUpdateWithWhereUniqueWithoutAvaliacaoInput = {
    where: avaliadoWhereUniqueInput;
    data: XOR<
      avaliadoUpdateWithoutAvaliacaoInput,
      avaliadoUncheckedUpdateWithoutAvaliacaoInput
    >;
  };

  export type avaliadoUpdateManyWithWhereWithoutAvaliacaoInput = {
    where: avaliadoScalarWhereInput;
    data: XOR<
      avaliadoUpdateManyMutationInput,
      avaliadoUncheckedUpdateManyWithoutAvaliacaoInput
    >;
  };

  export type avaliadoScalarWhereInput = {
    AND?: avaliadoScalarWhereInput | avaliadoScalarWhereInput[];
    OR?: avaliadoScalarWhereInput[];
    NOT?: avaliadoScalarWhereInput | avaliadoScalarWhereInput[];
    codaval_avaliado?: IntFilter<'avaliado'> | number;
    codrec_avaliado?: IntFilter<'avaliado'> | number;
    status_avaliado?: StringFilter<'avaliado'> | string;
    data_avaliado?: DateTimeNullableFilter<'avaliado'> | Date | string | null;
    hora_avaliado?: StringNullableFilter<'avaliado'> | string | null;
    usuario_avaliado?: StringNullableFilter<'avaliado'> | string | null;
  };

  export type avaliacaoCreateWithoutAvaliadoInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
    projeto: projetoCreateNestedOneWithoutAvaliacaoInput;
  };

  export type avaliacaoUncheckedCreateWithoutAvaliadoInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
    codpro_avaliacao: number;
  };

  export type avaliacaoCreateOrConnectWithoutAvaliadoInput = {
    where: avaliacaoWhereUniqueInput;
    create: XOR<
      avaliacaoCreateWithoutAvaliadoInput,
      avaliacaoUncheckedCreateWithoutAvaliadoInput
    >;
  };

  export type recursoCreateWithoutAvaliadoInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
    projeto?: projetoCreateNestedManyWithoutRecursoInput;
    nivel: nivelCreateNestedOneWithoutRecursoInput;
    usuario: usuarioCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUncheckedCreateWithoutAvaliadoInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
  };

  export type recursoCreateOrConnectWithoutAvaliadoInput = {
    where: recursoWhereUniqueInput;
    create: XOR<
      recursoCreateWithoutAvaliadoInput,
      recursoUncheckedCreateWithoutAvaliadoInput
    >;
  };

  export type itavaliadoCreateWithoutAvaliadoInput = {
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
    itmatriz: itmatrizCreateNestedOneWithoutItavaliadoInput;
  };

  export type itavaliadoUncheckedCreateWithoutAvaliadoInput = {
    codmat_itavaliado: number;
    coditmat_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
  };

  export type itavaliadoCreateOrConnectWithoutAvaliadoInput = {
    where: itavaliadoWhereUniqueInput;
    create: XOR<
      itavaliadoCreateWithoutAvaliadoInput,
      itavaliadoUncheckedCreateWithoutAvaliadoInput
    >;
  };

  export type itavaliadoCreateManyAvaliadoInputEnvelope = {
    data:
      | itavaliadoCreateManyAvaliadoInput
      | itavaliadoCreateManyAvaliadoInput[];
    skipDuplicates?: boolean;
  };

  export type avaliacaoUpsertWithoutAvaliadoInput = {
    update: XOR<
      avaliacaoUpdateWithoutAvaliadoInput,
      avaliacaoUncheckedUpdateWithoutAvaliadoInput
    >;
    create: XOR<
      avaliacaoCreateWithoutAvaliadoInput,
      avaliacaoUncheckedCreateWithoutAvaliadoInput
    >;
    where?: avaliacaoWhereInput;
  };

  export type avaliacaoUpdateToOneWithWhereWithoutAvaliadoInput = {
    where?: avaliacaoWhereInput;
    data: XOR<
      avaliacaoUpdateWithoutAvaliadoInput,
      avaliacaoUncheckedUpdateWithoutAvaliadoInput
    >;
  };

  export type avaliacaoUpdateWithoutAvaliadoInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
    projeto?: projetoUpdateOneRequiredWithoutAvaliacaoNestedInput;
  };

  export type avaliacaoUncheckedUpdateWithoutAvaliadoInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
    codpro_avaliacao?: IntFieldUpdateOperationsInput | number;
  };

  export type recursoUpsertWithoutAvaliadoInput = {
    update: XOR<
      recursoUpdateWithoutAvaliadoInput,
      recursoUncheckedUpdateWithoutAvaliadoInput
    >;
    create: XOR<
      recursoCreateWithoutAvaliadoInput,
      recursoUncheckedCreateWithoutAvaliadoInput
    >;
    where?: recursoWhereInput;
  };

  export type recursoUpdateToOneWithWhereWithoutAvaliadoInput = {
    where?: recursoWhereInput;
    data: XOR<
      recursoUpdateWithoutAvaliadoInput,
      recursoUncheckedUpdateWithoutAvaliadoInput
    >;
  };

  export type recursoUpdateWithoutAvaliadoInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUpdateManyWithoutRecursoNestedInput;
    nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateWithoutAvaliadoInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
  };

  export type itavaliadoUpsertWithWhereUniqueWithoutAvaliadoInput = {
    where: itavaliadoWhereUniqueInput;
    update: XOR<
      itavaliadoUpdateWithoutAvaliadoInput,
      itavaliadoUncheckedUpdateWithoutAvaliadoInput
    >;
    create: XOR<
      itavaliadoCreateWithoutAvaliadoInput,
      itavaliadoUncheckedCreateWithoutAvaliadoInput
    >;
  };

  export type itavaliadoUpdateWithWhereUniqueWithoutAvaliadoInput = {
    where: itavaliadoWhereUniqueInput;
    data: XOR<
      itavaliadoUpdateWithoutAvaliadoInput,
      itavaliadoUncheckedUpdateWithoutAvaliadoInput
    >;
  };

  export type itavaliadoUpdateManyWithWhereWithoutAvaliadoInput = {
    where: itavaliadoScalarWhereInput;
    data: XOR<
      itavaliadoUpdateManyMutationInput,
      itavaliadoUncheckedUpdateManyWithoutAvaliadoInput
    >;
  };

  export type itavaliadoScalarWhereInput = {
    AND?: itavaliadoScalarWhereInput | itavaliadoScalarWhereInput[];
    OR?: itavaliadoScalarWhereInput[];
    NOT?: itavaliadoScalarWhereInput | itavaliadoScalarWhereInput[];
    codaval_itavaliado?: IntFilter<'itavaliado'> | number;
    codrec_itavaliado?: IntFilter<'itavaliado'> | number;
    codmat_itavaliado?: IntFilter<'itavaliado'> | number;
    coditmat_itavaliado?: IntFilter<'itavaliado'> | number;
    ptoger_itavaliado?: IntFilter<'itavaliado'> | number;
    ptorec_itavaliado?: IntFilter<'itavaliado'> | number;
    obs_itavaliado?: StringNullableFilter<'itavaliado'> | string | null;
    nota1_itavaliado?:
      | DecimalFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFilter<'itavaliado'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type clienteCreateWithoutChamadosInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    fatrec?: fatrecCreateNestedManyWithoutClienteInput;
    projeto?: projetoCreateNestedManyWithoutClienteInput;
  };

  export type clienteUncheckedCreateWithoutChamadosInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    fatrec?: fatrecUncheckedCreateNestedManyWithoutClienteInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutClienteInput;
  };

  export type clienteCreateOrConnectWithoutChamadosInput = {
    where: clienteWhereUniqueInput;
    create: XOR<
      clienteCreateWithoutChamadosInput,
      clienteUncheckedCreateWithoutChamadosInput
    >;
  };

  export type recursoCreateWithoutChamadoInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
    projeto?: projetoCreateNestedManyWithoutRecursoInput;
    nivel: nivelCreateNestedOneWithoutRecursoInput;
    usuario: usuarioCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
  };

  export type recursoUncheckedCreateWithoutChamadoInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
  };

  export type recursoCreateOrConnectWithoutChamadoInput = {
    where: recursoWhereUniqueInput;
    create: XOR<
      recursoCreateWithoutChamadoInput,
      recursoUncheckedCreateWithoutChamadoInput
    >;
  };

  export type clienteUpsertWithoutChamadosInput = {
    update: XOR<
      clienteUpdateWithoutChamadosInput,
      clienteUncheckedUpdateWithoutChamadosInput
    >;
    create: XOR<
      clienteCreateWithoutChamadosInput,
      clienteUncheckedCreateWithoutChamadosInput
    >;
    where?: clienteWhereInput;
  };

  export type clienteUpdateToOneWithWhereWithoutChamadosInput = {
    where?: clienteWhereInput;
    data: XOR<
      clienteUpdateWithoutChamadosInput,
      clienteUncheckedUpdateWithoutChamadosInput
    >;
  };

  export type clienteUpdateWithoutChamadosInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    fatrec?: fatrecUpdateManyWithoutClienteNestedInput;
    projeto?: projetoUpdateManyWithoutClienteNestedInput;
  };

  export type clienteUncheckedUpdateWithoutChamadosInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    fatrec?: fatrecUncheckedUpdateManyWithoutClienteNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutClienteNestedInput;
  };

  export type recursoUpsertWithoutChamadoInput = {
    update: XOR<
      recursoUpdateWithoutChamadoInput,
      recursoUncheckedUpdateWithoutChamadoInput
    >;
    create: XOR<
      recursoCreateWithoutChamadoInput,
      recursoUncheckedCreateWithoutChamadoInput
    >;
    where?: recursoWhereInput;
  };

  export type recursoUpdateToOneWithWhereWithoutChamadoInput = {
    where?: recursoWhereInput;
    data: XOR<
      recursoUpdateWithoutChamadoInput,
      recursoUncheckedUpdateWithoutChamadoInput
    >;
  };

  export type recursoUpdateWithoutChamadoInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUpdateManyWithoutRecursoNestedInput;
    nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
  };

  export type recursoUncheckedUpdateWithoutChamadoInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
  };

  export type chamadoCreateWithoutClienteInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
    recurso?: recursoCreateNestedOneWithoutChamadoInput;
  };

  export type chamadoUncheckedCreateWithoutClienteInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cod_recurso?: number | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
  };

  export type chamadoCreateOrConnectWithoutClienteInput = {
    where: chamadoWhereUniqueInput;
    create: XOR<
      chamadoCreateWithoutClienteInput,
      chamadoUncheckedCreateWithoutClienteInput
    >;
  };

  export type chamadoCreateManyClienteInputEnvelope = {
    data: chamadoCreateManyClienteInput | chamadoCreateManyClienteInput[];
    skipDuplicates?: boolean;
  };

  export type fatrecCreateWithoutClienteInput = {
    cod_fatrec: number;
    desc_fatrec: string;
    qtdhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrtot_fatrec?: Decimal | DecimalJsLike | number | string;
    dtvenc_fatrec?: Date | string | null;
    dtnf_fatrec?: Date | string | null;
    dtcob_fatrec?: Date | string | null;
    dtpag_fatrec?: Date | string | null;
    vrpag_fatrec?: Decimal | DecimalJsLike | number | string;
    imp_fatrec?: Decimal | DecimalJsLike | number | string;
    mesano_fatrec?: string | null;
    obs_fatrec?: Uint8Array | null;
    cod_recurso?: number | null;
    perccom_fatrec?: Decimal | DecimalJsLike | number | string;
    dtpgcom_fatrec?: Date | string | null;
    cod_empresa?: number | null;
    nf_fatrec?: string | null;
  };

  export type fatrecUncheckedCreateWithoutClienteInput = {
    cod_fatrec: number;
    desc_fatrec: string;
    qtdhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrtot_fatrec?: Decimal | DecimalJsLike | number | string;
    dtvenc_fatrec?: Date | string | null;
    dtnf_fatrec?: Date | string | null;
    dtcob_fatrec?: Date | string | null;
    dtpag_fatrec?: Date | string | null;
    vrpag_fatrec?: Decimal | DecimalJsLike | number | string;
    imp_fatrec?: Decimal | DecimalJsLike | number | string;
    mesano_fatrec?: string | null;
    obs_fatrec?: Uint8Array | null;
    cod_recurso?: number | null;
    perccom_fatrec?: Decimal | DecimalJsLike | number | string;
    dtpgcom_fatrec?: Date | string | null;
    cod_empresa?: number | null;
    nf_fatrec?: string | null;
  };

  export type fatrecCreateOrConnectWithoutClienteInput = {
    where: fatrecWhereUniqueInput;
    create: XOR<
      fatrecCreateWithoutClienteInput,
      fatrecUncheckedCreateWithoutClienteInput
    >;
  };

  export type fatrecCreateManyClienteInputEnvelope = {
    data: fatrecCreateManyClienteInput | fatrecCreateManyClienteInput[];
    skipDuplicates?: boolean;
  };

  export type projetoCreateWithoutClienteInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoCreateNestedManyWithoutProjetoInput;
    meta?: metaCreateNestedManyWithoutProjetoInput;
    recurso: recursoCreateNestedOneWithoutProjetoInput;
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput;
    valor?: valorCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUncheckedCreateWithoutClienteInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoUncheckedCreateNestedManyWithoutProjetoInput;
    meta?: metaUncheckedCreateNestedManyWithoutProjetoInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput;
    valor?: valorUncheckedCreateNestedManyWithoutProjetoInput;
  };

  export type projetoCreateOrConnectWithoutClienteInput = {
    where: projetoWhereUniqueInput;
    create: XOR<
      projetoCreateWithoutClienteInput,
      projetoUncheckedCreateWithoutClienteInput
    >;
  };

  export type projetoCreateManyClienteInputEnvelope = {
    data: projetoCreateManyClienteInput | projetoCreateManyClienteInput[];
    skipDuplicates?: boolean;
  };

  export type chamadoUpsertWithWhereUniqueWithoutClienteInput = {
    where: chamadoWhereUniqueInput;
    update: XOR<
      chamadoUpdateWithoutClienteInput,
      chamadoUncheckedUpdateWithoutClienteInput
    >;
    create: XOR<
      chamadoCreateWithoutClienteInput,
      chamadoUncheckedCreateWithoutClienteInput
    >;
  };

  export type chamadoUpdateWithWhereUniqueWithoutClienteInput = {
    where: chamadoWhereUniqueInput;
    data: XOR<
      chamadoUpdateWithoutClienteInput,
      chamadoUncheckedUpdateWithoutClienteInput
    >;
  };

  export type chamadoUpdateManyWithWhereWithoutClienteInput = {
    where: chamadoScalarWhereInput;
    data: XOR<
      chamadoUpdateManyMutationInput,
      chamadoUncheckedUpdateManyWithoutClienteInput
    >;
  };

  export type chamadoScalarWhereInput = {
    AND?: chamadoScalarWhereInput | chamadoScalarWhereInput[];
    OR?: chamadoScalarWhereInput[];
    NOT?: chamadoScalarWhereInput | chamadoScalarWhereInput[];
    cod_chamado?: IntFilter<'chamado'> | number;
    data_chamado?: DateTimeFilter<'chamado'> | Date | string;
    hora_chamado?: StringFilter<'chamado'> | string;
    solicitacao_chamado?: BytesNullableFilter<'chamado'> | Uint8Array | null;
    conclusao_chamado?:
      | DateTimeNullableFilter<'chamado'>
      | Date
      | string
      | null;
    status_chamado?: StringFilter<'chamado'> | string;
    dtenvio_chamado?: StringNullableFilter<'chamado'> | string | null;
    cod_recurso?: IntNullableFilter<'chamado'> | number | null;
    cliente_chamado?: StringNullableFilter<'chamado'> | string | null;
    codtrf_chamado?: IntNullableFilter<'chamado'> | number | null;
    cod_cliente?: IntNullableFilter<'chamado'> | number | null;
    solicitacao2_chamado?: BytesNullableFilter<'chamado'> | Uint8Array | null;
    assunto_chamado?: StringNullableFilter<'chamado'> | string | null;
    email_chamado?: StringNullableFilter<'chamado'> | string | null;
    prior_chamado?: IntNullableFilter<'chamado'> | number | null;
    cod_classificacao?: IntNullableFilter<'chamado'> | number | null;
  };

  export type fatrecUpsertWithWhereUniqueWithoutClienteInput = {
    where: fatrecWhereUniqueInput;
    update: XOR<
      fatrecUpdateWithoutClienteInput,
      fatrecUncheckedUpdateWithoutClienteInput
    >;
    create: XOR<
      fatrecCreateWithoutClienteInput,
      fatrecUncheckedCreateWithoutClienteInput
    >;
  };

  export type fatrecUpdateWithWhereUniqueWithoutClienteInput = {
    where: fatrecWhereUniqueInput;
    data: XOR<
      fatrecUpdateWithoutClienteInput,
      fatrecUncheckedUpdateWithoutClienteInput
    >;
  };

  export type fatrecUpdateManyWithWhereWithoutClienteInput = {
    where: fatrecScalarWhereInput;
    data: XOR<
      fatrecUpdateManyMutationInput,
      fatrecUncheckedUpdateManyWithoutClienteInput
    >;
  };

  export type fatrecScalarWhereInput = {
    AND?: fatrecScalarWhereInput | fatrecScalarWhereInput[];
    OR?: fatrecScalarWhereInput[];
    NOT?: fatrecScalarWhereInput | fatrecScalarWhereInput[];
    cod_fatrec?: IntFilter<'fatrec'> | number;
    cod_cliente?: IntFilter<'fatrec'> | number;
    desc_fatrec?: StringFilter<'fatrec'> | string;
    qtdhora_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    dtnf_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    dtcob_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    dtpag_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    vrpag_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: StringNullableFilter<'fatrec'> | string | null;
    obs_fatrec?: BytesNullableFilter<'fatrec'> | Uint8Array | null;
    cod_recurso?: IntNullableFilter<'fatrec'> | number | null;
    perccom_fatrec?:
      | DecimalFilter<'fatrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?: DateTimeNullableFilter<'fatrec'> | Date | string | null;
    cod_empresa?: IntNullableFilter<'fatrec'> | number | null;
    nf_fatrec?: StringNullableFilter<'fatrec'> | string | null;
  };

  export type projetoUpsertWithWhereUniqueWithoutClienteInput = {
    where: projetoWhereUniqueInput;
    update: XOR<
      projetoUpdateWithoutClienteInput,
      projetoUncheckedUpdateWithoutClienteInput
    >;
    create: XOR<
      projetoCreateWithoutClienteInput,
      projetoUncheckedCreateWithoutClienteInput
    >;
  };

  export type projetoUpdateWithWhereUniqueWithoutClienteInput = {
    where: projetoWhereUniqueInput;
    data: XOR<
      projetoUpdateWithoutClienteInput,
      projetoUncheckedUpdateWithoutClienteInput
    >;
  };

  export type projetoUpdateManyWithWhereWithoutClienteInput = {
    where: projetoScalarWhereInput;
    data: XOR<
      projetoUpdateManyMutationInput,
      projetoUncheckedUpdateManyWithoutClienteInput
    >;
  };

  export type projetoScalarWhereInput = {
    AND?: projetoScalarWhereInput | projetoScalarWhereInput[];
    OR?: projetoScalarWhereInput[];
    NOT?: projetoScalarWhereInput | projetoScalarWhereInput[];
    cod_projeto?: IntFilter<'projeto'> | number;
    nome_projeto?: StringFilter<'projeto'> | string;
    codcli_projeto?: IntFilter<'projeto'> | number;
    respcli_projeto?: StringFilter<'projeto'> | string;
    proposta_projeto?: StringNullableFilter<'projeto'> | string | null;
    codrec_projeto?: IntFilter<'projeto'> | number;
    perc_projeto?:
      | DecimalFilter<'projeto'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: StringNullableFilter<'projeto'> | string | null;
    logalt_projeto?: StringNullableFilter<'projeto'> | string | null;
    qtdhoras_projeto?:
      | DecimalFilter<'projeto'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFilter<'projeto'> | string;
  };

  export type metaCreateWithoutFaseInput = {
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
    area: areaCreateNestedOneWithoutMetaInput;
    projeto: projetoCreateNestedOneWithoutMetaInput;
  };

  export type metaUncheckedCreateWithoutFaseInput = {
    codproj_meta: number;
    codarea_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type metaCreateOrConnectWithoutFaseInput = {
    where: metaWhereUniqueInput;
    create: XOR<
      metaCreateWithoutFaseInput,
      metaUncheckedCreateWithoutFaseInput
    >;
  };

  export type metaCreateManyFaseInputEnvelope = {
    data: metaCreateManyFaseInput | metaCreateManyFaseInput[];
    skipDuplicates?: boolean;
  };

  export type tarefaCreateWithoutFaseInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osCreateNestedManyWithoutTarefaInput;
    area: areaCreateNestedOneWithoutTarefaInput;
    projeto: projetoCreateNestedOneWithoutTarefaInput;
    recurso_tarefa_codrecresp_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
    recurso_tarefa_codrec_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
  };

  export type tarefaUncheckedCreateWithoutFaseInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osUncheckedCreateNestedManyWithoutTarefaInput;
  };

  export type tarefaCreateOrConnectWithoutFaseInput = {
    where: tarefaWhereUniqueInput;
    create: XOR<
      tarefaCreateWithoutFaseInput,
      tarefaUncheckedCreateWithoutFaseInput
    >;
  };

  export type tarefaCreateManyFaseInputEnvelope = {
    data: tarefaCreateManyFaseInput | tarefaCreateManyFaseInput[];
    skipDuplicates?: boolean;
  };

  export type metaUpsertWithWhereUniqueWithoutFaseInput = {
    where: metaWhereUniqueInput;
    update: XOR<
      metaUpdateWithoutFaseInput,
      metaUncheckedUpdateWithoutFaseInput
    >;
    create: XOR<
      metaCreateWithoutFaseInput,
      metaUncheckedCreateWithoutFaseInput
    >;
  };

  export type metaUpdateWithWhereUniqueWithoutFaseInput = {
    where: metaWhereUniqueInput;
    data: XOR<metaUpdateWithoutFaseInput, metaUncheckedUpdateWithoutFaseInput>;
  };

  export type metaUpdateManyWithWhereWithoutFaseInput = {
    where: metaScalarWhereInput;
    data: XOR<
      metaUpdateManyMutationInput,
      metaUncheckedUpdateManyWithoutFaseInput
    >;
  };

  export type tarefaUpsertWithWhereUniqueWithoutFaseInput = {
    where: tarefaWhereUniqueInput;
    update: XOR<
      tarefaUpdateWithoutFaseInput,
      tarefaUncheckedUpdateWithoutFaseInput
    >;
    create: XOR<
      tarefaCreateWithoutFaseInput,
      tarefaUncheckedCreateWithoutFaseInput
    >;
  };

  export type tarefaUpdateWithWhereUniqueWithoutFaseInput = {
    where: tarefaWhereUniqueInput;
    data: XOR<
      tarefaUpdateWithoutFaseInput,
      tarefaUncheckedUpdateWithoutFaseInput
    >;
  };

  export type tarefaUpdateManyWithWhereWithoutFaseInput = {
    where: tarefaScalarWhereInput;
    data: XOR<
      tarefaUpdateManyMutationInput,
      tarefaUncheckedUpdateManyWithoutFaseInput
    >;
  };

  export type clienteCreateWithoutFatrecInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    chamados?: chamadoCreateNestedManyWithoutClienteInput;
    projeto?: projetoCreateNestedManyWithoutClienteInput;
  };

  export type clienteUncheckedCreateWithoutFatrecInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    chamados?: chamadoUncheckedCreateNestedManyWithoutClienteInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutClienteInput;
  };

  export type clienteCreateOrConnectWithoutFatrecInput = {
    where: clienteWhereUniqueInput;
    create: XOR<
      clienteCreateWithoutFatrecInput,
      clienteUncheckedCreateWithoutFatrecInput
    >;
  };

  export type clienteUpsertWithoutFatrecInput = {
    update: XOR<
      clienteUpdateWithoutFatrecInput,
      clienteUncheckedUpdateWithoutFatrecInput
    >;
    create: XOR<
      clienteCreateWithoutFatrecInput,
      clienteUncheckedCreateWithoutFatrecInput
    >;
    where?: clienteWhereInput;
  };

  export type clienteUpdateToOneWithWhereWithoutFatrecInput = {
    where?: clienteWhereInput;
    data: XOR<
      clienteUpdateWithoutFatrecInput,
      clienteUncheckedUpdateWithoutFatrecInput
    >;
  };

  export type clienteUpdateWithoutFatrecInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    chamados?: chamadoUpdateManyWithoutClienteNestedInput;
    projeto?: projetoUpdateManyWithoutClienteNestedInput;
  };

  export type clienteUncheckedUpdateWithoutFatrecInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    chamados?: chamadoUncheckedUpdateManyWithoutClienteNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutClienteNestedInput;
  };

  export type avaliadoCreateWithoutItavaliadoInput = {
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
    avaliacao: avaliacaoCreateNestedOneWithoutAvaliadoInput;
    recurso: recursoCreateNestedOneWithoutAvaliadoInput;
  };

  export type avaliadoUncheckedCreateWithoutItavaliadoInput = {
    codaval_avaliado: number;
    codrec_avaliado: number;
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
  };

  export type avaliadoCreateOrConnectWithoutItavaliadoInput = {
    where: avaliadoWhereUniqueInput;
    create: XOR<
      avaliadoCreateWithoutItavaliadoInput,
      avaliadoUncheckedCreateWithoutItavaliadoInput
    >;
  };

  export type itmatrizCreateWithoutItavaliadoInput = {
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
    matriz: matrizCreateNestedOneWithoutItmatrizInput;
  };

  export type itmatrizUncheckedCreateWithoutItavaliadoInput = {
    codmat_itmatriz: number;
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
  };

  export type itmatrizCreateOrConnectWithoutItavaliadoInput = {
    where: itmatrizWhereUniqueInput;
    create: XOR<
      itmatrizCreateWithoutItavaliadoInput,
      itmatrizUncheckedCreateWithoutItavaliadoInput
    >;
  };

  export type avaliadoUpsertWithoutItavaliadoInput = {
    update: XOR<
      avaliadoUpdateWithoutItavaliadoInput,
      avaliadoUncheckedUpdateWithoutItavaliadoInput
    >;
    create: XOR<
      avaliadoCreateWithoutItavaliadoInput,
      avaliadoUncheckedCreateWithoutItavaliadoInput
    >;
    where?: avaliadoWhereInput;
  };

  export type avaliadoUpdateToOneWithWhereWithoutItavaliadoInput = {
    where?: avaliadoWhereInput;
    data: XOR<
      avaliadoUpdateWithoutItavaliadoInput,
      avaliadoUncheckedUpdateWithoutItavaliadoInput
    >;
  };

  export type avaliadoUpdateWithoutItavaliadoInput = {
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    avaliacao?: avaliacaoUpdateOneRequiredWithoutAvaliadoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutAvaliadoNestedInput;
  };

  export type avaliadoUncheckedUpdateWithoutItavaliadoInput = {
    codaval_avaliado?: IntFieldUpdateOperationsInput | number;
    codrec_avaliado?: IntFieldUpdateOperationsInput | number;
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type itmatrizUpsertWithoutItavaliadoInput = {
    update: XOR<
      itmatrizUpdateWithoutItavaliadoInput,
      itmatrizUncheckedUpdateWithoutItavaliadoInput
    >;
    create: XOR<
      itmatrizCreateWithoutItavaliadoInput,
      itmatrizUncheckedCreateWithoutItavaliadoInput
    >;
    where?: itmatrizWhereInput;
  };

  export type itmatrizUpdateToOneWithWhereWithoutItavaliadoInput = {
    where?: itmatrizWhereInput;
    data: XOR<
      itmatrizUpdateWithoutItavaliadoInput,
      itmatrizUncheckedUpdateWithoutItavaliadoInput
    >;
  };

  export type itmatrizUpdateWithoutItavaliadoInput = {
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    matriz?: matrizUpdateOneRequiredWithoutItmatrizNestedInput;
  };

  export type itmatrizUncheckedUpdateWithoutItavaliadoInput = {
    codmat_itmatriz?: IntFieldUpdateOperationsInput | number;
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
  };

  export type itavaliadoCreateWithoutItmatrizInput = {
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
    avaliado: avaliadoCreateNestedOneWithoutItavaliadoInput;
  };

  export type itavaliadoUncheckedCreateWithoutItmatrizInput = {
    codaval_itavaliado: number;
    codrec_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
  };

  export type itavaliadoCreateOrConnectWithoutItmatrizInput = {
    where: itavaliadoWhereUniqueInput;
    create: XOR<
      itavaliadoCreateWithoutItmatrizInput,
      itavaliadoUncheckedCreateWithoutItmatrizInput
    >;
  };

  export type itavaliadoCreateManyItmatrizInputEnvelope = {
    data:
      | itavaliadoCreateManyItmatrizInput
      | itavaliadoCreateManyItmatrizInput[];
    skipDuplicates?: boolean;
  };

  export type matrizCreateWithoutItmatrizInput = {
    cod_matriz: number;
    desc_matriz: string;
    status_matriz: string;
  };

  export type matrizUncheckedCreateWithoutItmatrizInput = {
    cod_matriz: number;
    desc_matriz: string;
    status_matriz: string;
  };

  export type matrizCreateOrConnectWithoutItmatrizInput = {
    where: matrizWhereUniqueInput;
    create: XOR<
      matrizCreateWithoutItmatrizInput,
      matrizUncheckedCreateWithoutItmatrizInput
    >;
  };

  export type itavaliadoUpsertWithWhereUniqueWithoutItmatrizInput = {
    where: itavaliadoWhereUniqueInput;
    update: XOR<
      itavaliadoUpdateWithoutItmatrizInput,
      itavaliadoUncheckedUpdateWithoutItmatrizInput
    >;
    create: XOR<
      itavaliadoCreateWithoutItmatrizInput,
      itavaliadoUncheckedCreateWithoutItmatrizInput
    >;
  };

  export type itavaliadoUpdateWithWhereUniqueWithoutItmatrizInput = {
    where: itavaliadoWhereUniqueInput;
    data: XOR<
      itavaliadoUpdateWithoutItmatrizInput,
      itavaliadoUncheckedUpdateWithoutItmatrizInput
    >;
  };

  export type itavaliadoUpdateManyWithWhereWithoutItmatrizInput = {
    where: itavaliadoScalarWhereInput;
    data: XOR<
      itavaliadoUpdateManyMutationInput,
      itavaliadoUncheckedUpdateManyWithoutItmatrizInput
    >;
  };

  export type matrizUpsertWithoutItmatrizInput = {
    update: XOR<
      matrizUpdateWithoutItmatrizInput,
      matrizUncheckedUpdateWithoutItmatrizInput
    >;
    create: XOR<
      matrizCreateWithoutItmatrizInput,
      matrizUncheckedCreateWithoutItmatrizInput
    >;
    where?: matrizWhereInput;
  };

  export type matrizUpdateToOneWithWhereWithoutItmatrizInput = {
    where?: matrizWhereInput;
    data: XOR<
      matrizUpdateWithoutItmatrizInput,
      matrizUncheckedUpdateWithoutItmatrizInput
    >;
  };

  export type matrizUpdateWithoutItmatrizInput = {
    cod_matriz?: IntFieldUpdateOperationsInput | number;
    desc_matriz?: StringFieldUpdateOperationsInput | string;
    status_matriz?: StringFieldUpdateOperationsInput | string;
  };

  export type matrizUncheckedUpdateWithoutItmatrizInput = {
    cod_matriz?: IntFieldUpdateOperationsInput | number;
    desc_matriz?: StringFieldUpdateOperationsInput | string;
    status_matriz?: StringFieldUpdateOperationsInput | string;
  };

  export type itmatrizCreateWithoutMatrizInput = {
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
    itavaliado?: itavaliadoCreateNestedManyWithoutItmatrizInput;
  };

  export type itmatrizUncheckedCreateWithoutMatrizInput = {
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
    itavaliado?: itavaliadoUncheckedCreateNestedManyWithoutItmatrizInput;
  };

  export type itmatrizCreateOrConnectWithoutMatrizInput = {
    where: itmatrizWhereUniqueInput;
    create: XOR<
      itmatrizCreateWithoutMatrizInput,
      itmatrizUncheckedCreateWithoutMatrizInput
    >;
  };

  export type itmatrizCreateManyMatrizInputEnvelope = {
    data: itmatrizCreateManyMatrizInput | itmatrizCreateManyMatrizInput[];
    skipDuplicates?: boolean;
  };

  export type itmatrizUpsertWithWhereUniqueWithoutMatrizInput = {
    where: itmatrizWhereUniqueInput;
    update: XOR<
      itmatrizUpdateWithoutMatrizInput,
      itmatrizUncheckedUpdateWithoutMatrizInput
    >;
    create: XOR<
      itmatrizCreateWithoutMatrizInput,
      itmatrizUncheckedCreateWithoutMatrizInput
    >;
  };

  export type itmatrizUpdateWithWhereUniqueWithoutMatrizInput = {
    where: itmatrizWhereUniqueInput;
    data: XOR<
      itmatrizUpdateWithoutMatrizInput,
      itmatrizUncheckedUpdateWithoutMatrizInput
    >;
  };

  export type itmatrizUpdateManyWithWhereWithoutMatrizInput = {
    where: itmatrizScalarWhereInput;
    data: XOR<
      itmatrizUpdateManyMutationInput,
      itmatrizUncheckedUpdateManyWithoutMatrizInput
    >;
  };

  export type itmatrizScalarWhereInput = {
    AND?: itmatrizScalarWhereInput | itmatrizScalarWhereInput[];
    OR?: itmatrizScalarWhereInput[];
    NOT?: itmatrizScalarWhereInput | itmatrizScalarWhereInput[];
    codmat_itmatriz?: IntFilter<'itmatriz'> | number;
    cod_itmatriz?: IntFilter<'itmatriz'> | number;
    nota1_itmatriz?:
      | DecimalFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFilter<'itmatriz'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?: BytesNullableFilter<'itmatriz'> | Uint8Array | null;
  };

  export type areaCreateWithoutMetaInput = {
    cod_area: number;
    nome_area: string;
    tarefa?: tarefaCreateNestedManyWithoutAreaInput;
  };

  export type areaUncheckedCreateWithoutMetaInput = {
    cod_area: number;
    nome_area: string;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutAreaInput;
  };

  export type areaCreateOrConnectWithoutMetaInput = {
    where: areaWhereUniqueInput;
    create: XOR<
      areaCreateWithoutMetaInput,
      areaUncheckedCreateWithoutMetaInput
    >;
  };

  export type faseCreateWithoutMetaInput = {
    cod_fase: number;
    nome_fase: string;
    tarefa?: tarefaCreateNestedManyWithoutFaseInput;
  };

  export type faseUncheckedCreateWithoutMetaInput = {
    cod_fase: number;
    nome_fase: string;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutFaseInput;
  };

  export type faseCreateOrConnectWithoutMetaInput = {
    where: faseWhereUniqueInput;
    create: XOR<
      faseCreateWithoutMetaInput,
      faseUncheckedCreateWithoutMetaInput
    >;
  };

  export type projetoCreateWithoutMetaInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoCreateNestedManyWithoutProjetoInput;
    cliente: clienteCreateNestedOneWithoutProjetoInput;
    recurso: recursoCreateNestedOneWithoutProjetoInput;
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput;
    valor?: valorCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUncheckedCreateWithoutMetaInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoUncheckedCreateNestedManyWithoutProjetoInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput;
    valor?: valorUncheckedCreateNestedManyWithoutProjetoInput;
  };

  export type projetoCreateOrConnectWithoutMetaInput = {
    where: projetoWhereUniqueInput;
    create: XOR<
      projetoCreateWithoutMetaInput,
      projetoUncheckedCreateWithoutMetaInput
    >;
  };

  export type areaUpsertWithoutMetaInput = {
    update: XOR<
      areaUpdateWithoutMetaInput,
      areaUncheckedUpdateWithoutMetaInput
    >;
    create: XOR<
      areaCreateWithoutMetaInput,
      areaUncheckedCreateWithoutMetaInput
    >;
    where?: areaWhereInput;
  };

  export type areaUpdateToOneWithWhereWithoutMetaInput = {
    where?: areaWhereInput;
    data: XOR<areaUpdateWithoutMetaInput, areaUncheckedUpdateWithoutMetaInput>;
  };

  export type areaUpdateWithoutMetaInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
    tarefa?: tarefaUpdateManyWithoutAreaNestedInput;
  };

  export type areaUncheckedUpdateWithoutMetaInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
    tarefa?: tarefaUncheckedUpdateManyWithoutAreaNestedInput;
  };

  export type faseUpsertWithoutMetaInput = {
    update: XOR<
      faseUpdateWithoutMetaInput,
      faseUncheckedUpdateWithoutMetaInput
    >;
    create: XOR<
      faseCreateWithoutMetaInput,
      faseUncheckedCreateWithoutMetaInput
    >;
    where?: faseWhereInput;
  };

  export type faseUpdateToOneWithWhereWithoutMetaInput = {
    where?: faseWhereInput;
    data: XOR<faseUpdateWithoutMetaInput, faseUncheckedUpdateWithoutMetaInput>;
  };

  export type faseUpdateWithoutMetaInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
    tarefa?: tarefaUpdateManyWithoutFaseNestedInput;
  };

  export type faseUncheckedUpdateWithoutMetaInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
    tarefa?: tarefaUncheckedUpdateManyWithoutFaseNestedInput;
  };

  export type projetoUpsertWithoutMetaInput = {
    update: XOR<
      projetoUpdateWithoutMetaInput,
      projetoUncheckedUpdateWithoutMetaInput
    >;
    create: XOR<
      projetoCreateWithoutMetaInput,
      projetoUncheckedCreateWithoutMetaInput
    >;
    where?: projetoWhereInput;
  };

  export type projetoUpdateToOneWithWhereWithoutMetaInput = {
    where?: projetoWhereInput;
    data: XOR<
      projetoUpdateWithoutMetaInput,
      projetoUncheckedUpdateWithoutMetaInput
    >;
  };

  export type projetoUpdateWithoutMetaInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUpdateManyWithoutProjetoNestedInput;
    cliente?: clienteUpdateOneRequiredWithoutProjetoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutProjetoNestedInput;
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput;
    valor?: valorUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateWithoutMetaInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUncheckedUpdateManyWithoutProjetoNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput;
    valor?: valorUncheckedUpdateManyWithoutProjetoNestedInput;
  };

  export type acesso_sistemaCreateWithoutModulo_sistemaInput = {
    incluir?: string;
    modificar?: string;
    eliminar?: string;
    tela_sistema: tela_sistemaCreateNestedOneWithoutAcesso_sistemaInput;
    usuario: usuarioCreateNestedOneWithoutAcesso_sistemaInput;
  };

  export type acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput = {
    cod_usuario: number;
    cod_tela: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type acesso_sistemaCreateOrConnectWithoutModulo_sistemaInput = {
    where: acesso_sistemaWhereUniqueInput;
    create: XOR<
      acesso_sistemaCreateWithoutModulo_sistemaInput,
      acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput
    >;
  };

  export type acesso_sistemaCreateManyModulo_sistemaInputEnvelope = {
    data:
      | acesso_sistemaCreateManyModulo_sistemaInput
      | acesso_sistemaCreateManyModulo_sistemaInput[];
    skipDuplicates?: boolean;
  };

  export type tela_sistemaCreateWithoutModulo_sistemaInput = {
    cod_tela: number;
    desc_tela: string;
    acesso_sistema?: acesso_sistemaCreateNestedManyWithoutTela_sistemaInput;
  };

  export type tela_sistemaUncheckedCreateWithoutModulo_sistemaInput = {
    cod_tela: number;
    desc_tela: string;
    acesso_sistema?: acesso_sistemaUncheckedCreateNestedManyWithoutTela_sistemaInput;
  };

  export type tela_sistemaCreateOrConnectWithoutModulo_sistemaInput = {
    where: tela_sistemaWhereUniqueInput;
    create: XOR<
      tela_sistemaCreateWithoutModulo_sistemaInput,
      tela_sistemaUncheckedCreateWithoutModulo_sistemaInput
    >;
  };

  export type tela_sistemaCreateManyModulo_sistemaInputEnvelope = {
    data:
      | tela_sistemaCreateManyModulo_sistemaInput
      | tela_sistemaCreateManyModulo_sistemaInput[];
    skipDuplicates?: boolean;
  };

  export type acesso_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput = {
    where: acesso_sistemaWhereUniqueInput;
    update: XOR<
      acesso_sistemaUpdateWithoutModulo_sistemaInput,
      acesso_sistemaUncheckedUpdateWithoutModulo_sistemaInput
    >;
    create: XOR<
      acesso_sistemaCreateWithoutModulo_sistemaInput,
      acesso_sistemaUncheckedCreateWithoutModulo_sistemaInput
    >;
  };

  export type acesso_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput = {
    where: acesso_sistemaWhereUniqueInput;
    data: XOR<
      acesso_sistemaUpdateWithoutModulo_sistemaInput,
      acesso_sistemaUncheckedUpdateWithoutModulo_sistemaInput
    >;
  };

  export type acesso_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput = {
    where: acesso_sistemaScalarWhereInput;
    data: XOR<
      acesso_sistemaUpdateManyMutationInput,
      acesso_sistemaUncheckedUpdateManyWithoutModulo_sistemaInput
    >;
  };

  export type acesso_sistemaScalarWhereInput = {
    AND?: acesso_sistemaScalarWhereInput | acesso_sistemaScalarWhereInput[];
    OR?: acesso_sistemaScalarWhereInput[];
    NOT?: acesso_sistemaScalarWhereInput | acesso_sistemaScalarWhereInput[];
    cod_usuario?: IntFilter<'acesso_sistema'> | number;
    cod_modulo?: IntFilter<'acesso_sistema'> | number;
    cod_tela?: IntFilter<'acesso_sistema'> | number;
    incluir?: StringFilter<'acesso_sistema'> | string;
    modificar?: StringFilter<'acesso_sistema'> | string;
    eliminar?: StringFilter<'acesso_sistema'> | string;
  };

  export type tela_sistemaUpsertWithWhereUniqueWithoutModulo_sistemaInput = {
    where: tela_sistemaWhereUniqueInput;
    update: XOR<
      tela_sistemaUpdateWithoutModulo_sistemaInput,
      tela_sistemaUncheckedUpdateWithoutModulo_sistemaInput
    >;
    create: XOR<
      tela_sistemaCreateWithoutModulo_sistemaInput,
      tela_sistemaUncheckedCreateWithoutModulo_sistemaInput
    >;
  };

  export type tela_sistemaUpdateWithWhereUniqueWithoutModulo_sistemaInput = {
    where: tela_sistemaWhereUniqueInput;
    data: XOR<
      tela_sistemaUpdateWithoutModulo_sistemaInput,
      tela_sistemaUncheckedUpdateWithoutModulo_sistemaInput
    >;
  };

  export type tela_sistemaUpdateManyWithWhereWithoutModulo_sistemaInput = {
    where: tela_sistemaScalarWhereInput;
    data: XOR<
      tela_sistemaUpdateManyMutationInput,
      tela_sistemaUncheckedUpdateManyWithoutModulo_sistemaInput
    >;
  };

  export type tela_sistemaScalarWhereInput = {
    AND?: tela_sistemaScalarWhereInput | tela_sistemaScalarWhereInput[];
    OR?: tela_sistemaScalarWhereInput[];
    NOT?: tela_sistemaScalarWhereInput | tela_sistemaScalarWhereInput[];
    cod_tela?: IntFilter<'tela_sistema'> | number;
    cod_modulo?: IntFilter<'tela_sistema'> | number;
    desc_tela?: StringFilter<'tela_sistema'> | string;
  };

  export type recursoCreateWithoutNivelInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
    projeto?: projetoCreateNestedManyWithoutRecursoInput;
    usuario: usuarioCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUncheckedCreateWithoutNivelInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
  };

  export type recursoCreateOrConnectWithoutNivelInput = {
    where: recursoWhereUniqueInput;
    create: XOR<
      recursoCreateWithoutNivelInput,
      recursoUncheckedCreateWithoutNivelInput
    >;
  };

  export type recursoCreateManyNivelInputEnvelope = {
    data: recursoCreateManyNivelInput | recursoCreateManyNivelInput[];
    skipDuplicates?: boolean;
  };

  export type recursoUpsertWithWhereUniqueWithoutNivelInput = {
    where: recursoWhereUniqueInput;
    update: XOR<
      recursoUpdateWithoutNivelInput,
      recursoUncheckedUpdateWithoutNivelInput
    >;
    create: XOR<
      recursoCreateWithoutNivelInput,
      recursoUncheckedCreateWithoutNivelInput
    >;
  };

  export type recursoUpdateWithWhereUniqueWithoutNivelInput = {
    where: recursoWhereUniqueInput;
    data: XOR<
      recursoUpdateWithoutNivelInput,
      recursoUncheckedUpdateWithoutNivelInput
    >;
  };

  export type recursoUpdateManyWithWhereWithoutNivelInput = {
    where: recursoScalarWhereInput;
    data: XOR<
      recursoUpdateManyMutationInput,
      recursoUncheckedUpdateManyWithoutNivelInput
    >;
  };

  export type recursoScalarWhereInput = {
    AND?: recursoScalarWhereInput | recursoScalarWhereInput[];
    OR?: recursoScalarWhereInput[];
    NOT?: recursoScalarWhereInput | recursoScalarWhereInput[];
    cod_recurso?: IntFilter<'recurso'> | number;
    nome_recurso?: StringFilter<'recurso'> | string;
    fone_recurso?: StringNullableFilter<'recurso'> | string | null;
    ativo_recurso?: IntFilter<'recurso'> | number;
    codusr_recurso?: IntFilter<'recurso'> | number;
    cod_nivel?: IntFilter<'recurso'> | number;
    hrdia_recurso?: StringNullableFilter<'recurso'> | string | null;
    percprod_recurso?:
      | DecimalNullableFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: StringNullableFilter<'recurso'> | string | null;
    dtlimite_recurso?: DateTimeNullableFilter<'recurso'> | Date | string | null;
    permapo_recurso?: StringFilter<'recurso'> | string;
    matr_recurso?: StringNullableFilter<'recurso'> | string | null;
    obs_recurso?: BytesNullableFilter<'recurso'> | Uint8Array | null;
    custo_recurso?:
      | DecimalNullableFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | DecimalNullableFilter<'recurso'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: IntNullableFilter<'recurso'> | number | null;
  };

  export type tarefaCreateWithoutOsInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    area: areaCreateNestedOneWithoutTarefaInput;
    fase: faseCreateNestedOneWithoutTarefaInput;
    projeto: projetoCreateNestedOneWithoutTarefaInput;
    recurso_tarefa_codrecresp_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
    recurso_tarefa_codrec_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
  };

  export type tarefaUncheckedCreateWithoutOsInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
  };

  export type tarefaCreateOrConnectWithoutOsInput = {
    where: tarefaWhereUniqueInput;
    create: XOR<
      tarefaCreateWithoutOsInput,
      tarefaUncheckedCreateWithoutOsInput
    >;
  };

  export type tarefaUpsertWithoutOsInput = {
    update: XOR<
      tarefaUpdateWithoutOsInput,
      tarefaUncheckedUpdateWithoutOsInput
    >;
    create: XOR<
      tarefaCreateWithoutOsInput,
      tarefaUncheckedCreateWithoutOsInput
    >;
    where?: tarefaWhereInput;
  };

  export type tarefaUpdateToOneWithWhereWithoutOsInput = {
    where?: tarefaWhereInput;
    data: XOR<tarefaUpdateWithoutOsInput, tarefaUncheckedUpdateWithoutOsInput>;
  };

  export type tarefaUpdateWithoutOsInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    area?: areaUpdateOneRequiredWithoutTarefaNestedInput;
    fase?: faseUpdateOneRequiredWithoutTarefaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutTarefaNestedInput;
    recurso_tarefa_codrecresp_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrecresp_tarefaTorecursoNestedInput;
    recurso_tarefa_codrec_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrec_tarefaTorecursoNestedInput;
  };

  export type tarefaUncheckedUpdateWithoutOsInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codpro_tarefa?: IntFieldUpdateOperationsInput | number;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_area?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_fase?: IntFieldUpdateOperationsInput | number;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type avaliacaoCreateWithoutProjetoInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
    avaliado?: avaliadoCreateNestedManyWithoutAvaliacaoInput;
  };

  export type avaliacaoUncheckedCreateWithoutProjetoInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutAvaliacaoInput;
  };

  export type avaliacaoCreateOrConnectWithoutProjetoInput = {
    where: avaliacaoWhereUniqueInput;
    create: XOR<
      avaliacaoCreateWithoutProjetoInput,
      avaliacaoUncheckedCreateWithoutProjetoInput
    >;
  };

  export type avaliacaoCreateManyProjetoInputEnvelope = {
    data: avaliacaoCreateManyProjetoInput | avaliacaoCreateManyProjetoInput[];
    skipDuplicates?: boolean;
  };

  export type metaCreateWithoutProjetoInput = {
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
    area: areaCreateNestedOneWithoutMetaInput;
    fase: faseCreateNestedOneWithoutMetaInput;
  };

  export type metaUncheckedCreateWithoutProjetoInput = {
    codarea_meta: number;
    codfase_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type metaCreateOrConnectWithoutProjetoInput = {
    where: metaWhereUniqueInput;
    create: XOR<
      metaCreateWithoutProjetoInput,
      metaUncheckedCreateWithoutProjetoInput
    >;
  };

  export type metaCreateManyProjetoInputEnvelope = {
    data: metaCreateManyProjetoInput | metaCreateManyProjetoInput[];
    skipDuplicates?: boolean;
  };

  export type clienteCreateWithoutProjetoInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    chamados?: chamadoCreateNestedManyWithoutClienteInput;
    fatrec?: fatrecCreateNestedManyWithoutClienteInput;
  };

  export type clienteUncheckedCreateWithoutProjetoInput = {
    cod_cliente: number;
    nome_cliente: string;
    razao_cliente?: string | null;
    end_cliente?: string | null;
    bairro_cliente?: string | null;
    cep_cliente?: string | null;
    fone_cliente?: string | null;
    cnpj_cliente?: string | null;
    ie_cliente?: string | null;
    uf_cliente?: string | null;
    fax_cliente?: string | null;
    contato_cliente?: string | null;
    funccontato_cliente?: string | null;
    endcob_cliente?: string | null;
    bairrocob_cliente?: string | null;
    cepcob_cliente?: string | null;
    cidadecob_cliente?: string | null;
    ufcob_cliente?: string | null;
    ativo_cliente?: number;
    obs_cliente?: Uint8Array | null;
    im_cliente?: string | null;
    cod_cidade?: number | null;
    numend_cliente?: string | null;
    comend_cliente?: string | null;
    email_cliente?: string | null;
    codbanco_cliente?: string | null;
    sla_cliente?: number;
    chamados?: chamadoUncheckedCreateNestedManyWithoutClienteInput;
    fatrec?: fatrecUncheckedCreateNestedManyWithoutClienteInput;
  };

  export type clienteCreateOrConnectWithoutProjetoInput = {
    where: clienteWhereUniqueInput;
    create: XOR<
      clienteCreateWithoutProjetoInput,
      clienteUncheckedCreateWithoutProjetoInput
    >;
  };

  export type recursoCreateWithoutProjetoInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
    nivel: nivelCreateNestedOneWithoutRecursoInput;
    usuario: usuarioCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUncheckedCreateWithoutProjetoInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
  };

  export type recursoCreateOrConnectWithoutProjetoInput = {
    where: recursoWhereUniqueInput;
    create: XOR<
      recursoCreateWithoutProjetoInput,
      recursoUncheckedCreateWithoutProjetoInput
    >;
  };

  export type tarefaCreateWithoutProjetoInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osCreateNestedManyWithoutTarefaInput;
    area: areaCreateNestedOneWithoutTarefaInput;
    fase: faseCreateNestedOneWithoutTarefaInput;
    recurso_tarefa_codrecresp_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
    recurso_tarefa_codrec_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
  };

  export type tarefaUncheckedCreateWithoutProjetoInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osUncheckedCreateNestedManyWithoutTarefaInput;
  };

  export type tarefaCreateOrConnectWithoutProjetoInput = {
    where: tarefaWhereUniqueInput;
    create: XOR<
      tarefaCreateWithoutProjetoInput,
      tarefaUncheckedCreateWithoutProjetoInput
    >;
  };

  export type tarefaCreateManyProjetoInputEnvelope = {
    data: tarefaCreateManyProjetoInput | tarefaCreateManyProjetoInput[];
    skipDuplicates?: boolean;
  };

  export type valorCreateWithoutProjetoInput = {
    preco_valor: Decimal | DecimalJsLike | number | string;
    tipotrf: tipotrfCreateNestedOneWithoutValorInput;
  };

  export type valorUncheckedCreateWithoutProjetoInput = {
    codtipo_valor: number;
    preco_valor: Decimal | DecimalJsLike | number | string;
  };

  export type valorCreateOrConnectWithoutProjetoInput = {
    where: valorWhereUniqueInput;
    create: XOR<
      valorCreateWithoutProjetoInput,
      valorUncheckedCreateWithoutProjetoInput
    >;
  };

  export type valorCreateManyProjetoInputEnvelope = {
    data: valorCreateManyProjetoInput | valorCreateManyProjetoInput[];
    skipDuplicates?: boolean;
  };

  export type avaliacaoUpsertWithWhereUniqueWithoutProjetoInput = {
    where: avaliacaoWhereUniqueInput;
    update: XOR<
      avaliacaoUpdateWithoutProjetoInput,
      avaliacaoUncheckedUpdateWithoutProjetoInput
    >;
    create: XOR<
      avaliacaoCreateWithoutProjetoInput,
      avaliacaoUncheckedCreateWithoutProjetoInput
    >;
  };

  export type avaliacaoUpdateWithWhereUniqueWithoutProjetoInput = {
    where: avaliacaoWhereUniqueInput;
    data: XOR<
      avaliacaoUpdateWithoutProjetoInput,
      avaliacaoUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type avaliacaoUpdateManyWithWhereWithoutProjetoInput = {
    where: avaliacaoScalarWhereInput;
    data: XOR<
      avaliacaoUpdateManyMutationInput,
      avaliacaoUncheckedUpdateManyWithoutProjetoInput
    >;
  };

  export type avaliacaoScalarWhereInput = {
    AND?: avaliacaoScalarWhereInput | avaliacaoScalarWhereInput[];
    OR?: avaliacaoScalarWhereInput[];
    NOT?: avaliacaoScalarWhereInput | avaliacaoScalarWhereInput[];
    cod_avaliacao?: IntFilter<'avaliacao'> | number;
    anomes_avaliacao?: StringFilter<'avaliacao'> | string;
    data_avaliacao?: DateTimeFilter<'avaliacao'> | Date | string;
    codrec_avaliacao?: IntFilter<'avaliacao'> | number;
    status_avaliacao?: StringFilter<'avaliacao'> | string;
    codpro_avaliacao?: IntFilter<'avaliacao'> | number;
  };

  export type metaUpsertWithWhereUniqueWithoutProjetoInput = {
    where: metaWhereUniqueInput;
    update: XOR<
      metaUpdateWithoutProjetoInput,
      metaUncheckedUpdateWithoutProjetoInput
    >;
    create: XOR<
      metaCreateWithoutProjetoInput,
      metaUncheckedCreateWithoutProjetoInput
    >;
  };

  export type metaUpdateWithWhereUniqueWithoutProjetoInput = {
    where: metaWhereUniqueInput;
    data: XOR<
      metaUpdateWithoutProjetoInput,
      metaUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type metaUpdateManyWithWhereWithoutProjetoInput = {
    where: metaScalarWhereInput;
    data: XOR<
      metaUpdateManyMutationInput,
      metaUncheckedUpdateManyWithoutProjetoInput
    >;
  };

  export type clienteUpsertWithoutProjetoInput = {
    update: XOR<
      clienteUpdateWithoutProjetoInput,
      clienteUncheckedUpdateWithoutProjetoInput
    >;
    create: XOR<
      clienteCreateWithoutProjetoInput,
      clienteUncheckedCreateWithoutProjetoInput
    >;
    where?: clienteWhereInput;
  };

  export type clienteUpdateToOneWithWhereWithoutProjetoInput = {
    where?: clienteWhereInput;
    data: XOR<
      clienteUpdateWithoutProjetoInput,
      clienteUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type clienteUpdateWithoutProjetoInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    chamados?: chamadoUpdateManyWithoutClienteNestedInput;
    fatrec?: fatrecUpdateManyWithoutClienteNestedInput;
  };

  export type clienteUncheckedUpdateWithoutProjetoInput = {
    cod_cliente?: IntFieldUpdateOperationsInput | number;
    nome_cliente?: StringFieldUpdateOperationsInput | string;
    razao_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    end_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairro_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cep_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fone_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cnpj_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ie_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    uf_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    fax_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    contato_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    funccontato_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    endcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    bairrocob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    cepcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cidadecob_cliente?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    ufcob_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_cliente?: IntFieldUpdateOperationsInput | number;
    obs_cliente?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    im_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_cidade?: NullableIntFieldUpdateOperationsInput | number | null;
    numend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    comend_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    email_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    codbanco_cliente?: NullableStringFieldUpdateOperationsInput | string | null;
    sla_cliente?: IntFieldUpdateOperationsInput | number;
    chamados?: chamadoUncheckedUpdateManyWithoutClienteNestedInput;
    fatrec?: fatrecUncheckedUpdateManyWithoutClienteNestedInput;
  };

  export type recursoUpsertWithoutProjetoInput = {
    update: XOR<
      recursoUpdateWithoutProjetoInput,
      recursoUncheckedUpdateWithoutProjetoInput
    >;
    create: XOR<
      recursoCreateWithoutProjetoInput,
      recursoUncheckedCreateWithoutProjetoInput
    >;
    where?: recursoWhereInput;
  };

  export type recursoUpdateToOneWithWhereWithoutProjetoInput = {
    where?: recursoWhereInput;
    data: XOR<
      recursoUpdateWithoutProjetoInput,
      recursoUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type recursoUpdateWithoutProjetoInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
    nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateWithoutProjetoInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
  };

  export type tarefaUpsertWithWhereUniqueWithoutProjetoInput = {
    where: tarefaWhereUniqueInput;
    update: XOR<
      tarefaUpdateWithoutProjetoInput,
      tarefaUncheckedUpdateWithoutProjetoInput
    >;
    create: XOR<
      tarefaCreateWithoutProjetoInput,
      tarefaUncheckedCreateWithoutProjetoInput
    >;
  };

  export type tarefaUpdateWithWhereUniqueWithoutProjetoInput = {
    where: tarefaWhereUniqueInput;
    data: XOR<
      tarefaUpdateWithoutProjetoInput,
      tarefaUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type tarefaUpdateManyWithWhereWithoutProjetoInput = {
    where: tarefaScalarWhereInput;
    data: XOR<
      tarefaUpdateManyMutationInput,
      tarefaUncheckedUpdateManyWithoutProjetoInput
    >;
  };

  export type valorUpsertWithWhereUniqueWithoutProjetoInput = {
    where: valorWhereUniqueInput;
    update: XOR<
      valorUpdateWithoutProjetoInput,
      valorUncheckedUpdateWithoutProjetoInput
    >;
    create: XOR<
      valorCreateWithoutProjetoInput,
      valorUncheckedCreateWithoutProjetoInput
    >;
  };

  export type valorUpdateWithWhereUniqueWithoutProjetoInput = {
    where: valorWhereUniqueInput;
    data: XOR<
      valorUpdateWithoutProjetoInput,
      valorUncheckedUpdateWithoutProjetoInput
    >;
  };

  export type valorUpdateManyWithWhereWithoutProjetoInput = {
    where: valorScalarWhereInput;
    data: XOR<
      valorUpdateManyMutationInput,
      valorUncheckedUpdateManyWithoutProjetoInput
    >;
  };

  export type valorScalarWhereInput = {
    AND?: valorScalarWhereInput | valorScalarWhereInput[];
    OR?: valorScalarWhereInput[];
    NOT?: valorScalarWhereInput | valorScalarWhereInput[];
    codproj_valor?: IntFilter<'valor'> | number;
    codtipo_valor?: IntFilter<'valor'> | number;
    preco_valor?:
      | DecimalFilter<'valor'>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type agenrecCreateWithoutRecursoInput = {
    cod_agenrec: number;
    data_agenrec: Date | string;
    hrini_agenrec: string;
    hrfim_agenrec: string;
    status_agenrec?: number;
    obs_agenrec?: string | null;
    custo_agenrec?: Decimal | DecimalJsLike | number | string | null;
    receita_agenrec?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_agenrec?: number | null;
  };

  export type agenrecUncheckedCreateWithoutRecursoInput = {
    cod_agenrec: number;
    data_agenrec: Date | string;
    hrini_agenrec: string;
    hrfim_agenrec: string;
    status_agenrec?: number;
    obs_agenrec?: string | null;
    custo_agenrec?: Decimal | DecimalJsLike | number | string | null;
    receita_agenrec?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_agenrec?: number | null;
  };

  export type agenrecCreateOrConnectWithoutRecursoInput = {
    where: agenrecWhereUniqueInput;
    create: XOR<
      agenrecCreateWithoutRecursoInput,
      agenrecUncheckedCreateWithoutRecursoInput
    >;
  };

  export type agenrecCreateManyRecursoInputEnvelope = {
    data: agenrecCreateManyRecursoInput | agenrecCreateManyRecursoInput[];
    skipDuplicates?: boolean;
  };

  export type avaliadoCreateWithoutRecursoInput = {
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
    avaliacao: avaliacaoCreateNestedOneWithoutAvaliadoInput;
    itavaliado?: itavaliadoCreateNestedManyWithoutAvaliadoInput;
  };

  export type avaliadoUncheckedCreateWithoutRecursoInput = {
    codaval_avaliado: number;
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
    itavaliado?: itavaliadoUncheckedCreateNestedManyWithoutAvaliadoInput;
  };

  export type avaliadoCreateOrConnectWithoutRecursoInput = {
    where: avaliadoWhereUniqueInput;
    create: XOR<
      avaliadoCreateWithoutRecursoInput,
      avaliadoUncheckedCreateWithoutRecursoInput
    >;
  };

  export type avaliadoCreateManyRecursoInputEnvelope = {
    data: avaliadoCreateManyRecursoInput | avaliadoCreateManyRecursoInput[];
    skipDuplicates?: boolean;
  };

  export type projetoCreateWithoutRecursoInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoCreateNestedManyWithoutProjetoInput;
    meta?: metaCreateNestedManyWithoutProjetoInput;
    cliente: clienteCreateNestedOneWithoutProjetoInput;
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput;
    valor?: valorCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUncheckedCreateWithoutRecursoInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoUncheckedCreateNestedManyWithoutProjetoInput;
    meta?: metaUncheckedCreateNestedManyWithoutProjetoInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput;
    valor?: valorUncheckedCreateNestedManyWithoutProjetoInput;
  };

  export type projetoCreateOrConnectWithoutRecursoInput = {
    where: projetoWhereUniqueInput;
    create: XOR<
      projetoCreateWithoutRecursoInput,
      projetoUncheckedCreateWithoutRecursoInput
    >;
  };

  export type projetoCreateManyRecursoInputEnvelope = {
    data: projetoCreateManyRecursoInput | projetoCreateManyRecursoInput[];
    skipDuplicates?: boolean;
  };

  export type nivelCreateWithoutRecursoInput = {
    cod_nivel: number;
    nome_nivel: string;
    perc_nivel?: Decimal | DecimalJsLike | number | string;
  };

  export type nivelUncheckedCreateWithoutRecursoInput = {
    cod_nivel: number;
    nome_nivel: string;
    perc_nivel?: Decimal | DecimalJsLike | number | string;
  };

  export type nivelCreateOrConnectWithoutRecursoInput = {
    where: nivelWhereUniqueInput;
    create: XOR<
      nivelCreateWithoutRecursoInput,
      nivelUncheckedCreateWithoutRecursoInput
    >;
  };

  export type usuarioCreateWithoutRecursoInput = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha?: string | null;
    tipo_usuario?: string;
    permtar_usuario?: string;
    altsen_usuario?: number;
    perproj1_usuario?: string;
    perproj2_usuario?: string;
    tela1_usuario?: number | null;
    tela2_usuario?: number | null;
    tela3_usuario?: number | null;
    tela4_usuario?: number | null;
    acesso_sistema?: acesso_sistemaCreateNestedManyWithoutUsuarioInput;
  };

  export type usuarioUncheckedCreateWithoutRecursoInput = {
    cod_usuario: number;
    nome_usuario: string;
    id_usuario: string;
    senha?: string | null;
    tipo_usuario?: string;
    permtar_usuario?: string;
    altsen_usuario?: number;
    perproj1_usuario?: string;
    perproj2_usuario?: string;
    tela1_usuario?: number | null;
    tela2_usuario?: number | null;
    tela3_usuario?: number | null;
    tela4_usuario?: number | null;
    acesso_sistema?: acesso_sistemaUncheckedCreateNestedManyWithoutUsuarioInput;
  };

  export type usuarioCreateOrConnectWithoutRecursoInput = {
    where: usuarioWhereUniqueInput;
    create: XOR<
      usuarioCreateWithoutRecursoInput,
      usuarioUncheckedCreateWithoutRecursoInput
    >;
  };

  export type tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_tarefa: number;
      nome_tarefa: string;
      dtsol_tarefa?: Date | string | null;
      dtaprov_tarefa?: Date | string | null;
      dtprevent_tarefa?: Date | string | null;
      hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
      hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
      margem_tarefa?: string;
      status_tarefa?: number;
      ordem_tarefa: number;
      estimado_tarefa?: string;
      cod_tipotrf: number;
      hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
      fatest_tarefa?: string;
      valini_tarefa: Date | string;
      valfim_tarefa: Date | string;
      perimp_tarefa?: string;
      dtinc_tarefa: Date | string;
      perc_tarefa?: number;
      fatura_tarefa?: string;
      valida_tarefa?: number;
      vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
      obs_tarefa?: Uint8Array | null;
      limmes_tarefa?: number | null;
      exibecham_tarefa?: number | null;
      os?: osCreateNestedManyWithoutTarefaInput;
      area: areaCreateNestedOneWithoutTarefaInput;
      fase: faseCreateNestedOneWithoutTarefaInput;
      projeto: projetoCreateNestedOneWithoutTarefaInput;
      recurso_tarefa_codrec_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrec_tarefaTorecursoInput;
    };

  export type tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_tarefa: number;
      nome_tarefa: string;
      codpro_tarefa: number;
      codrec_tarefa: number;
      dtsol_tarefa?: Date | string | null;
      dtaprov_tarefa?: Date | string | null;
      dtprevent_tarefa?: Date | string | null;
      hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
      hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
      margem_tarefa?: string;
      status_tarefa?: number;
      ordem_tarefa: number;
      cod_area: number;
      estimado_tarefa?: string;
      cod_tipotrf: number;
      hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
      fatest_tarefa?: string;
      cod_fase: number;
      valini_tarefa: Date | string;
      valfim_tarefa: Date | string;
      perimp_tarefa?: string;
      dtinc_tarefa: Date | string;
      perc_tarefa?: number;
      fatura_tarefa?: string;
      valida_tarefa?: number;
      vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
      obs_tarefa?: Uint8Array | null;
      limmes_tarefa?: number | null;
      exibecham_tarefa?: number | null;
      os?: osUncheckedCreateNestedManyWithoutTarefaInput;
    };

  export type tarefaCreateOrConnectWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      where: tarefaWhereUniqueInput;
      create: XOR<
        tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
        tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
      >;
    };

  export type tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInputEnvelope =
    {
      data:
        | tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInput
        | tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInput[];
      skipDuplicates?: boolean;
    };

  export type tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
    os?: osCreateNestedManyWithoutTarefaInput;
    area: areaCreateNestedOneWithoutTarefaInput;
    fase: faseCreateNestedOneWithoutTarefaInput;
    projeto: projetoCreateNestedOneWithoutTarefaInput;
    recurso_tarefa_codrecresp_tarefaTorecurso: recursoCreateNestedOneWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput;
  };

  export type tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      cod_tarefa: number;
      nome_tarefa: string;
      codpro_tarefa: number;
      dtsol_tarefa?: Date | string | null;
      dtaprov_tarefa?: Date | string | null;
      dtprevent_tarefa?: Date | string | null;
      hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
      hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
      margem_tarefa?: string;
      status_tarefa?: number;
      ordem_tarefa: number;
      cod_area: number;
      estimado_tarefa?: string;
      cod_tipotrf: number;
      codrecresp_tarefa: number;
      hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
      fatest_tarefa?: string;
      cod_fase: number;
      valini_tarefa: Date | string;
      valfim_tarefa: Date | string;
      perimp_tarefa?: string;
      dtinc_tarefa: Date | string;
      perc_tarefa?: number;
      fatura_tarefa?: string;
      valida_tarefa?: number;
      vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
      obs_tarefa?: Uint8Array | null;
      limmes_tarefa?: number | null;
      exibecham_tarefa?: number | null;
      os?: osUncheckedCreateNestedManyWithoutTarefaInput;
    };

  export type tarefaCreateOrConnectWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      where: tarefaWhereUniqueInput;
      create: XOR<
        tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
        tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
      >;
    };

  export type tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInputEnvelope =
    {
      data:
        | tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInput
        | tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInput[];
      skipDuplicates?: boolean;
    };

  export type chamadoCreateWithoutRecursoInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
    cliente?: clienteCreateNestedOneWithoutChamadosInput;
  };

  export type chamadoUncheckedCreateWithoutRecursoInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    cod_cliente?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
  };

  export type chamadoCreateOrConnectWithoutRecursoInput = {
    where: chamadoWhereUniqueInput;
    create: XOR<
      chamadoCreateWithoutRecursoInput,
      chamadoUncheckedCreateWithoutRecursoInput
    >;
  };

  export type chamadoCreateManyRecursoInputEnvelope = {
    data: chamadoCreateManyRecursoInput | chamadoCreateManyRecursoInput[];
    skipDuplicates?: boolean;
  };

  export type agenrecUpsertWithWhereUniqueWithoutRecursoInput = {
    where: agenrecWhereUniqueInput;
    update: XOR<
      agenrecUpdateWithoutRecursoInput,
      agenrecUncheckedUpdateWithoutRecursoInput
    >;
    create: XOR<
      agenrecCreateWithoutRecursoInput,
      agenrecUncheckedCreateWithoutRecursoInput
    >;
  };

  export type agenrecUpdateWithWhereUniqueWithoutRecursoInput = {
    where: agenrecWhereUniqueInput;
    data: XOR<
      agenrecUpdateWithoutRecursoInput,
      agenrecUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type agenrecUpdateManyWithWhereWithoutRecursoInput = {
    where: agenrecScalarWhereInput;
    data: XOR<
      agenrecUpdateManyMutationInput,
      agenrecUncheckedUpdateManyWithoutRecursoInput
    >;
  };

  export type agenrecScalarWhereInput = {
    AND?: agenrecScalarWhereInput | agenrecScalarWhereInput[];
    OR?: agenrecScalarWhereInput[];
    NOT?: agenrecScalarWhereInput | agenrecScalarWhereInput[];
    cod_agenrec?: IntFilter<'agenrec'> | number;
    cod_recurso?: IntFilter<'agenrec'> | number;
    data_agenrec?: DateTimeFilter<'agenrec'> | Date | string;
    hrini_agenrec?: StringFilter<'agenrec'> | string;
    hrfim_agenrec?: StringFilter<'agenrec'> | string;
    status_agenrec?: IntFilter<'agenrec'> | number;
    obs_agenrec?: StringNullableFilter<'agenrec'> | string | null;
    custo_agenrec?:
      | DecimalNullableFilter<'agenrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | DecimalNullableFilter<'agenrec'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: IntNullableFilter<'agenrec'> | number | null;
  };

  export type avaliadoUpsertWithWhereUniqueWithoutRecursoInput = {
    where: avaliadoWhereUniqueInput;
    update: XOR<
      avaliadoUpdateWithoutRecursoInput,
      avaliadoUncheckedUpdateWithoutRecursoInput
    >;
    create: XOR<
      avaliadoCreateWithoutRecursoInput,
      avaliadoUncheckedCreateWithoutRecursoInput
    >;
  };

  export type avaliadoUpdateWithWhereUniqueWithoutRecursoInput = {
    where: avaliadoWhereUniqueInput;
    data: XOR<
      avaliadoUpdateWithoutRecursoInput,
      avaliadoUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type avaliadoUpdateManyWithWhereWithoutRecursoInput = {
    where: avaliadoScalarWhereInput;
    data: XOR<
      avaliadoUpdateManyMutationInput,
      avaliadoUncheckedUpdateManyWithoutRecursoInput
    >;
  };

  export type projetoUpsertWithWhereUniqueWithoutRecursoInput = {
    where: projetoWhereUniqueInput;
    update: XOR<
      projetoUpdateWithoutRecursoInput,
      projetoUncheckedUpdateWithoutRecursoInput
    >;
    create: XOR<
      projetoCreateWithoutRecursoInput,
      projetoUncheckedCreateWithoutRecursoInput
    >;
  };

  export type projetoUpdateWithWhereUniqueWithoutRecursoInput = {
    where: projetoWhereUniqueInput;
    data: XOR<
      projetoUpdateWithoutRecursoInput,
      projetoUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type projetoUpdateManyWithWhereWithoutRecursoInput = {
    where: projetoScalarWhereInput;
    data: XOR<
      projetoUpdateManyMutationInput,
      projetoUncheckedUpdateManyWithoutRecursoInput
    >;
  };

  export type nivelUpsertWithoutRecursoInput = {
    update: XOR<
      nivelUpdateWithoutRecursoInput,
      nivelUncheckedUpdateWithoutRecursoInput
    >;
    create: XOR<
      nivelCreateWithoutRecursoInput,
      nivelUncheckedCreateWithoutRecursoInput
    >;
    where?: nivelWhereInput;
  };

  export type nivelUpdateToOneWithWhereWithoutRecursoInput = {
    where?: nivelWhereInput;
    data: XOR<
      nivelUpdateWithoutRecursoInput,
      nivelUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type nivelUpdateWithoutRecursoInput = {
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    nome_nivel?: StringFieldUpdateOperationsInput | string;
    perc_nivel?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type nivelUncheckedUpdateWithoutRecursoInput = {
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    nome_nivel?: StringFieldUpdateOperationsInput | string;
    perc_nivel?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type usuarioUpsertWithoutRecursoInput = {
    update: XOR<
      usuarioUpdateWithoutRecursoInput,
      usuarioUncheckedUpdateWithoutRecursoInput
    >;
    create: XOR<
      usuarioCreateWithoutRecursoInput,
      usuarioUncheckedCreateWithoutRecursoInput
    >;
    where?: usuarioWhereInput;
  };

  export type usuarioUpdateToOneWithWhereWithoutRecursoInput = {
    where?: usuarioWhereInput;
    data: XOR<
      usuarioUpdateWithoutRecursoInput,
      usuarioUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type usuarioUpdateWithoutRecursoInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    acesso_sistema?: acesso_sistemaUpdateManyWithoutUsuarioNestedInput;
  };

  export type usuarioUncheckedUpdateWithoutRecursoInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    nome_usuario?: StringFieldUpdateOperationsInput | string;
    id_usuario?: StringFieldUpdateOperationsInput | string;
    senha?: NullableStringFieldUpdateOperationsInput | string | null;
    tipo_usuario?: StringFieldUpdateOperationsInput | string;
    permtar_usuario?: StringFieldUpdateOperationsInput | string;
    altsen_usuario?: IntFieldUpdateOperationsInput | number;
    perproj1_usuario?: StringFieldUpdateOperationsInput | string;
    perproj2_usuario?: StringFieldUpdateOperationsInput | string;
    tela1_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela2_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela3_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    tela4_usuario?: NullableIntFieldUpdateOperationsInput | number | null;
    acesso_sistema?: acesso_sistemaUncheckedUpdateManyWithoutUsuarioNestedInput;
  };

  export type tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      where: tarefaWhereUniqueInput;
      update: XOR<
        tarefaUpdateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
        tarefaUncheckedUpdateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
      >;
      create: XOR<
        tarefaCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
        tarefaUncheckedCreateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
      >;
    };

  export type tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      where: tarefaWhereUniqueInput;
      data: XOR<
        tarefaUpdateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput,
        tarefaUncheckedUpdateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
      >;
    };

  export type tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      where: tarefaScalarWhereInput;
      data: XOR<
        tarefaUpdateManyMutationInput,
        tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput
      >;
    };

  export type tarefaUpsertWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      where: tarefaWhereUniqueInput;
      update: XOR<
        tarefaUpdateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
        tarefaUncheckedUpdateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
      >;
      create: XOR<
        tarefaCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
        tarefaUncheckedCreateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
      >;
    };

  export type tarefaUpdateWithWhereUniqueWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      where: tarefaWhereUniqueInput;
      data: XOR<
        tarefaUpdateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput,
        tarefaUncheckedUpdateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
      >;
    };

  export type tarefaUpdateManyWithWhereWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      where: tarefaScalarWhereInput;
      data: XOR<
        tarefaUpdateManyMutationInput,
        tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput
      >;
    };

  export type chamadoUpsertWithWhereUniqueWithoutRecursoInput = {
    where: chamadoWhereUniqueInput;
    update: XOR<
      chamadoUpdateWithoutRecursoInput,
      chamadoUncheckedUpdateWithoutRecursoInput
    >;
    create: XOR<
      chamadoCreateWithoutRecursoInput,
      chamadoUncheckedCreateWithoutRecursoInput
    >;
  };

  export type chamadoUpdateWithWhereUniqueWithoutRecursoInput = {
    where: chamadoWhereUniqueInput;
    data: XOR<
      chamadoUpdateWithoutRecursoInput,
      chamadoUncheckedUpdateWithoutRecursoInput
    >;
  };

  export type chamadoUpdateManyWithWhereWithoutRecursoInput = {
    where: chamadoScalarWhereInput;
    data: XOR<
      chamadoUpdateManyMutationInput,
      chamadoUncheckedUpdateManyWithoutRecursoInput
    >;
  };

  export type osCreateWithoutTarefaInput = {
    cod_os: number;
    dtini_os: Date | string;
    hrini_os: string;
    hrfim_os: string;
    obs_os?: string | null;
    status_os?: number;
    produtivo_os?: string;
    codrec_os: number;
    produtivo2_os?: string;
    respcli_os: string;
    remdes_os?: string;
    abono_os?: string;
    desloc_os?: string | null;
    obs?: Uint8Array | null;
    dtinc_os: Date | string;
    faturado_os?: string;
    perc_os?: number;
    cod_faturamento?: number | null;
    comp_os?: string | null;
    valid_os?: string;
    vrhr_os?: Decimal | DecimalJsLike | number | string;
    num_os?: string | null;
    chamado_os?: string | null;
  };

  export type osUncheckedCreateWithoutTarefaInput = {
    cod_os: number;
    dtini_os: Date | string;
    hrini_os: string;
    hrfim_os: string;
    obs_os?: string | null;
    status_os?: number;
    produtivo_os?: string;
    codrec_os: number;
    produtivo2_os?: string;
    respcli_os: string;
    remdes_os?: string;
    abono_os?: string;
    desloc_os?: string | null;
    obs?: Uint8Array | null;
    dtinc_os: Date | string;
    faturado_os?: string;
    perc_os?: number;
    cod_faturamento?: number | null;
    comp_os?: string | null;
    valid_os?: string;
    vrhr_os?: Decimal | DecimalJsLike | number | string;
    num_os?: string | null;
    chamado_os?: string | null;
  };

  export type osCreateOrConnectWithoutTarefaInput = {
    where: osWhereUniqueInput;
    create: XOR<
      osCreateWithoutTarefaInput,
      osUncheckedCreateWithoutTarefaInput
    >;
  };

  export type osCreateManyTarefaInputEnvelope = {
    data: osCreateManyTarefaInput | osCreateManyTarefaInput[];
    skipDuplicates?: boolean;
  };

  export type areaCreateWithoutTarefaInput = {
    cod_area: number;
    nome_area: string;
    meta?: metaCreateNestedManyWithoutAreaInput;
  };

  export type areaUncheckedCreateWithoutTarefaInput = {
    cod_area: number;
    nome_area: string;
    meta?: metaUncheckedCreateNestedManyWithoutAreaInput;
  };

  export type areaCreateOrConnectWithoutTarefaInput = {
    where: areaWhereUniqueInput;
    create: XOR<
      areaCreateWithoutTarefaInput,
      areaUncheckedCreateWithoutTarefaInput
    >;
  };

  export type faseCreateWithoutTarefaInput = {
    cod_fase: number;
    nome_fase: string;
    meta?: metaCreateNestedManyWithoutFaseInput;
  };

  export type faseUncheckedCreateWithoutTarefaInput = {
    cod_fase: number;
    nome_fase: string;
    meta?: metaUncheckedCreateNestedManyWithoutFaseInput;
  };

  export type faseCreateOrConnectWithoutTarefaInput = {
    where: faseWhereUniqueInput;
    create: XOR<
      faseCreateWithoutTarefaInput,
      faseUncheckedCreateWithoutTarefaInput
    >;
  };

  export type projetoCreateWithoutTarefaInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoCreateNestedManyWithoutProjetoInput;
    meta?: metaCreateNestedManyWithoutProjetoInput;
    cliente: clienteCreateNestedOneWithoutProjetoInput;
    recurso: recursoCreateNestedOneWithoutProjetoInput;
    valor?: valorCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUncheckedCreateWithoutTarefaInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoUncheckedCreateNestedManyWithoutProjetoInput;
    meta?: metaUncheckedCreateNestedManyWithoutProjetoInput;
    valor?: valorUncheckedCreateNestedManyWithoutProjetoInput;
  };

  export type projetoCreateOrConnectWithoutTarefaInput = {
    where: projetoWhereUniqueInput;
    create: XOR<
      projetoCreateWithoutTarefaInput,
      projetoUncheckedCreateWithoutTarefaInput
    >;
  };

  export type recursoCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_recurso: number;
      nome_recurso: string;
      fone_recurso?: string | null;
      ativo_recurso?: number;
      hrdia_recurso?: string | null;
      percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
      email_recurso?: string | null;
      dtlimite_recurso?: Date | string | null;
      permapo_recurso?: string;
      matr_recurso?: string | null;
      obs_recurso?: Uint8Array | null;
      custo_recurso?: Decimal | DecimalJsLike | number | string | null;
      receita_recurso?: Decimal | DecimalJsLike | number | string | null;
      tpcusto_recurso?: number | null;
      agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
      avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
      projeto?: projetoCreateNestedManyWithoutRecursoInput;
      nivel: nivelCreateNestedOneWithoutRecursoInput;
      usuario: usuarioCreateNestedOneWithoutRecursoInput;
      tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
      chamado?: chamadoCreateNestedManyWithoutRecursoInput;
    };

  export type recursoUncheckedCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_recurso: number;
      nome_recurso: string;
      fone_recurso?: string | null;
      ativo_recurso?: number;
      codusr_recurso: number;
      cod_nivel: number;
      hrdia_recurso?: string | null;
      percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
      email_recurso?: string | null;
      dtlimite_recurso?: Date | string | null;
      permapo_recurso?: string;
      matr_recurso?: string | null;
      obs_recurso?: Uint8Array | null;
      custo_recurso?: Decimal | DecimalJsLike | number | string | null;
      receita_recurso?: Decimal | DecimalJsLike | number | string | null;
      tpcusto_recurso?: number | null;
      agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
      avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
      projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
      tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
      chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
    };

  export type recursoCreateOrConnectWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      where: recursoWhereUniqueInput;
      create: XOR<
        recursoCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput,
        recursoUncheckedCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
      >;
    };

  export type recursoCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
    projeto?: projetoCreateNestedManyWithoutRecursoInput;
    nivel: nivelCreateNestedOneWithoutRecursoInput;
    usuario: usuarioCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    chamado?: chamadoCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUncheckedCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput =
    {
      cod_recurso: number;
      nome_recurso: string;
      fone_recurso?: string | null;
      ativo_recurso?: number;
      codusr_recurso: number;
      cod_nivel: number;
      hrdia_recurso?: string | null;
      percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
      email_recurso?: string | null;
      dtlimite_recurso?: Date | string | null;
      permapo_recurso?: string;
      matr_recurso?: string | null;
      obs_recurso?: Uint8Array | null;
      custo_recurso?: Decimal | DecimalJsLike | number | string | null;
      receita_recurso?: Decimal | DecimalJsLike | number | string | null;
      tpcusto_recurso?: number | null;
      agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
      avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
      projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
      tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
      chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
    };

  export type recursoCreateOrConnectWithoutTarefa_tarefa_codrec_tarefaTorecursoInput =
    {
      where: recursoWhereUniqueInput;
      create: XOR<
        recursoCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput,
        recursoUncheckedCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
      >;
    };

  export type osUpsertWithWhereUniqueWithoutTarefaInput = {
    where: osWhereUniqueInput;
    update: XOR<
      osUpdateWithoutTarefaInput,
      osUncheckedUpdateWithoutTarefaInput
    >;
    create: XOR<
      osCreateWithoutTarefaInput,
      osUncheckedCreateWithoutTarefaInput
    >;
  };

  export type osUpdateWithWhereUniqueWithoutTarefaInput = {
    where: osWhereUniqueInput;
    data: XOR<osUpdateWithoutTarefaInput, osUncheckedUpdateWithoutTarefaInput>;
  };

  export type osUpdateManyWithWhereWithoutTarefaInput = {
    where: osScalarWhereInput;
    data: XOR<
      osUpdateManyMutationInput,
      osUncheckedUpdateManyWithoutTarefaInput
    >;
  };

  export type osScalarWhereInput = {
    AND?: osScalarWhereInput | osScalarWhereInput[];
    OR?: osScalarWhereInput[];
    NOT?: osScalarWhereInput | osScalarWhereInput[];
    cod_os?: IntFilter<'os'> | number;
    codtrf_os?: IntFilter<'os'> | number;
    dtini_os?: DateTimeFilter<'os'> | Date | string;
    hrini_os?: StringFilter<'os'> | string;
    hrfim_os?: StringFilter<'os'> | string;
    obs_os?: StringNullableFilter<'os'> | string | null;
    status_os?: IntFilter<'os'> | number;
    produtivo_os?: StringFilter<'os'> | string;
    codrec_os?: IntFilter<'os'> | number;
    produtivo2_os?: StringFilter<'os'> | string;
    respcli_os?: StringFilter<'os'> | string;
    remdes_os?: StringFilter<'os'> | string;
    abono_os?: StringFilter<'os'> | string;
    desloc_os?: StringNullableFilter<'os'> | string | null;
    obs?: BytesNullableFilter<'os'> | Uint8Array | null;
    dtinc_os?: DateTimeFilter<'os'> | Date | string;
    faturado_os?: StringFilter<'os'> | string;
    perc_os?: IntFilter<'os'> | number;
    cod_faturamento?: IntNullableFilter<'os'> | number | null;
    comp_os?: StringNullableFilter<'os'> | string | null;
    valid_os?: StringFilter<'os'> | string;
    vrhr_os?: DecimalFilter<'os'> | Decimal | DecimalJsLike | number | string;
    num_os?: StringNullableFilter<'os'> | string | null;
    chamado_os?: StringNullableFilter<'os'> | string | null;
  };

  export type areaUpsertWithoutTarefaInput = {
    update: XOR<
      areaUpdateWithoutTarefaInput,
      areaUncheckedUpdateWithoutTarefaInput
    >;
    create: XOR<
      areaCreateWithoutTarefaInput,
      areaUncheckedCreateWithoutTarefaInput
    >;
    where?: areaWhereInput;
  };

  export type areaUpdateToOneWithWhereWithoutTarefaInput = {
    where?: areaWhereInput;
    data: XOR<
      areaUpdateWithoutTarefaInput,
      areaUncheckedUpdateWithoutTarefaInput
    >;
  };

  export type areaUpdateWithoutTarefaInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
    meta?: metaUpdateManyWithoutAreaNestedInput;
  };

  export type areaUncheckedUpdateWithoutTarefaInput = {
    cod_area?: IntFieldUpdateOperationsInput | number;
    nome_area?: StringFieldUpdateOperationsInput | string;
    meta?: metaUncheckedUpdateManyWithoutAreaNestedInput;
  };

  export type faseUpsertWithoutTarefaInput = {
    update: XOR<
      faseUpdateWithoutTarefaInput,
      faseUncheckedUpdateWithoutTarefaInput
    >;
    create: XOR<
      faseCreateWithoutTarefaInput,
      faseUncheckedCreateWithoutTarefaInput
    >;
    where?: faseWhereInput;
  };

  export type faseUpdateToOneWithWhereWithoutTarefaInput = {
    where?: faseWhereInput;
    data: XOR<
      faseUpdateWithoutTarefaInput,
      faseUncheckedUpdateWithoutTarefaInput
    >;
  };

  export type faseUpdateWithoutTarefaInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
    meta?: metaUpdateManyWithoutFaseNestedInput;
  };

  export type faseUncheckedUpdateWithoutTarefaInput = {
    cod_fase?: IntFieldUpdateOperationsInput | number;
    nome_fase?: StringFieldUpdateOperationsInput | string;
    meta?: metaUncheckedUpdateManyWithoutFaseNestedInput;
  };

  export type projetoUpsertWithoutTarefaInput = {
    update: XOR<
      projetoUpdateWithoutTarefaInput,
      projetoUncheckedUpdateWithoutTarefaInput
    >;
    create: XOR<
      projetoCreateWithoutTarefaInput,
      projetoUncheckedCreateWithoutTarefaInput
    >;
    where?: projetoWhereInput;
  };

  export type projetoUpdateToOneWithWhereWithoutTarefaInput = {
    where?: projetoWhereInput;
    data: XOR<
      projetoUpdateWithoutTarefaInput,
      projetoUncheckedUpdateWithoutTarefaInput
    >;
  };

  export type projetoUpdateWithoutTarefaInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUpdateManyWithoutProjetoNestedInput;
    meta?: metaUpdateManyWithoutProjetoNestedInput;
    cliente?: clienteUpdateOneRequiredWithoutProjetoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutProjetoNestedInput;
    valor?: valorUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateWithoutTarefaInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUncheckedUpdateManyWithoutProjetoNestedInput;
    meta?: metaUncheckedUpdateManyWithoutProjetoNestedInput;
    valor?: valorUncheckedUpdateManyWithoutProjetoNestedInput;
  };

  export type recursoUpsertWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      update: XOR<
        recursoUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput,
        recursoUncheckedUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
      >;
      create: XOR<
        recursoCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput,
        recursoUncheckedCreateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
      >;
      where?: recursoWhereInput;
    };

  export type recursoUpdateToOneWithWhereWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      where?: recursoWhereInput;
      data: XOR<
        recursoUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput,
        recursoUncheckedUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput
      >;
    };

  export type recursoUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_recurso?: IntFieldUpdateOperationsInput | number;
      nome_recurso?: StringFieldUpdateOperationsInput | string;
      fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      ativo_recurso?: IntFieldUpdateOperationsInput | number;
      hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      percprod_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      dtlimite_recurso?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      permapo_recurso?: StringFieldUpdateOperationsInput | string;
      matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      custo_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      receita_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
      agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
      avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
      projeto?: projetoUpdateManyWithoutRecursoNestedInput;
      nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
      usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
      tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
      chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
    };

  export type recursoUncheckedUpdateWithoutTarefa_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_recurso?: IntFieldUpdateOperationsInput | number;
      nome_recurso?: StringFieldUpdateOperationsInput | string;
      fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      ativo_recurso?: IntFieldUpdateOperationsInput | number;
      codusr_recurso?: IntFieldUpdateOperationsInput | number;
      cod_nivel?: IntFieldUpdateOperationsInput | number;
      hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      percprod_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      dtlimite_recurso?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      permapo_recurso?: StringFieldUpdateOperationsInput | string;
      matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      custo_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      receita_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
      agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
      avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
      projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
      tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
      chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
    };

  export type recursoUpsertWithoutTarefa_tarefa_codrec_tarefaTorecursoInput = {
    update: XOR<
      recursoUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput,
      recursoUncheckedUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
    >;
    create: XOR<
      recursoCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput,
      recursoUncheckedCreateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
    >;
    where?: recursoWhereInput;
  };

  export type recursoUpdateToOneWithWhereWithoutTarefa_tarefa_codrec_tarefaTorecursoInput =
    {
      where?: recursoWhereInput;
      data: XOR<
        recursoUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput,
        recursoUncheckedUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput
      >;
    };

  export type recursoUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUpdateManyWithoutRecursoNestedInput;
    nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateWithoutTarefa_tarefa_codrec_tarefaTorecursoInput =
    {
      cod_recurso?: IntFieldUpdateOperationsInput | number;
      nome_recurso?: StringFieldUpdateOperationsInput | string;
      fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      ativo_recurso?: IntFieldUpdateOperationsInput | number;
      codusr_recurso?: IntFieldUpdateOperationsInput | number;
      cod_nivel?: IntFieldUpdateOperationsInput | number;
      hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      percprod_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      dtlimite_recurso?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      permapo_recurso?: StringFieldUpdateOperationsInput | string;
      matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
      obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      custo_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      receita_recurso?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
      agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
      avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
      projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
      tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
      chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
    };

  export type acesso_sistemaCreateWithoutTela_sistemaInput = {
    incluir?: string;
    modificar?: string;
    eliminar?: string;
    modulo_sistema: modulo_sistemaCreateNestedOneWithoutAcesso_sistemaInput;
    usuario: usuarioCreateNestedOneWithoutAcesso_sistemaInput;
  };

  export type acesso_sistemaUncheckedCreateWithoutTela_sistemaInput = {
    cod_usuario: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type acesso_sistemaCreateOrConnectWithoutTela_sistemaInput = {
    where: acesso_sistemaWhereUniqueInput;
    create: XOR<
      acesso_sistemaCreateWithoutTela_sistemaInput,
      acesso_sistemaUncheckedCreateWithoutTela_sistemaInput
    >;
  };

  export type acesso_sistemaCreateManyTela_sistemaInputEnvelope = {
    data:
      | acesso_sistemaCreateManyTela_sistemaInput
      | acesso_sistemaCreateManyTela_sistemaInput[];
    skipDuplicates?: boolean;
  };

  export type modulo_sistemaCreateWithoutTela_sistemaInput = {
    cod_modulo: number;
    desc_modulo: string;
    acesso_sistema?: acesso_sistemaCreateNestedManyWithoutModulo_sistemaInput;
  };

  export type modulo_sistemaUncheckedCreateWithoutTela_sistemaInput = {
    cod_modulo: number;
    desc_modulo: string;
    acesso_sistema?: acesso_sistemaUncheckedCreateNestedManyWithoutModulo_sistemaInput;
  };

  export type modulo_sistemaCreateOrConnectWithoutTela_sistemaInput = {
    where: modulo_sistemaWhereUniqueInput;
    create: XOR<
      modulo_sistemaCreateWithoutTela_sistemaInput,
      modulo_sistemaUncheckedCreateWithoutTela_sistemaInput
    >;
  };

  export type acesso_sistemaUpsertWithWhereUniqueWithoutTela_sistemaInput = {
    where: acesso_sistemaWhereUniqueInput;
    update: XOR<
      acesso_sistemaUpdateWithoutTela_sistemaInput,
      acesso_sistemaUncheckedUpdateWithoutTela_sistemaInput
    >;
    create: XOR<
      acesso_sistemaCreateWithoutTela_sistemaInput,
      acesso_sistemaUncheckedCreateWithoutTela_sistemaInput
    >;
  };

  export type acesso_sistemaUpdateWithWhereUniqueWithoutTela_sistemaInput = {
    where: acesso_sistemaWhereUniqueInput;
    data: XOR<
      acesso_sistemaUpdateWithoutTela_sistemaInput,
      acesso_sistemaUncheckedUpdateWithoutTela_sistemaInput
    >;
  };

  export type acesso_sistemaUpdateManyWithWhereWithoutTela_sistemaInput = {
    where: acesso_sistemaScalarWhereInput;
    data: XOR<
      acesso_sistemaUpdateManyMutationInput,
      acesso_sistemaUncheckedUpdateManyWithoutTela_sistemaInput
    >;
  };

  export type modulo_sistemaUpsertWithoutTela_sistemaInput = {
    update: XOR<
      modulo_sistemaUpdateWithoutTela_sistemaInput,
      modulo_sistemaUncheckedUpdateWithoutTela_sistemaInput
    >;
    create: XOR<
      modulo_sistemaCreateWithoutTela_sistemaInput,
      modulo_sistemaUncheckedCreateWithoutTela_sistemaInput
    >;
    where?: modulo_sistemaWhereInput;
  };

  export type modulo_sistemaUpdateToOneWithWhereWithoutTela_sistemaInput = {
    where?: modulo_sistemaWhereInput;
    data: XOR<
      modulo_sistemaUpdateWithoutTela_sistemaInput,
      modulo_sistemaUncheckedUpdateWithoutTela_sistemaInput
    >;
  };

  export type modulo_sistemaUpdateWithoutTela_sistemaInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUpdateManyWithoutModulo_sistemaNestedInput;
  };

  export type modulo_sistemaUncheckedUpdateWithoutTela_sistemaInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    desc_modulo?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUncheckedUpdateManyWithoutModulo_sistemaNestedInput;
  };

  export type valorCreateWithoutTipotrfInput = {
    preco_valor: Decimal | DecimalJsLike | number | string;
    projeto: projetoCreateNestedOneWithoutValorInput;
  };

  export type valorUncheckedCreateWithoutTipotrfInput = {
    codproj_valor: number;
    preco_valor: Decimal | DecimalJsLike | number | string;
  };

  export type valorCreateOrConnectWithoutTipotrfInput = {
    where: valorWhereUniqueInput;
    create: XOR<
      valorCreateWithoutTipotrfInput,
      valorUncheckedCreateWithoutTipotrfInput
    >;
  };

  export type valorCreateManyTipotrfInputEnvelope = {
    data: valorCreateManyTipotrfInput | valorCreateManyTipotrfInput[];
    skipDuplicates?: boolean;
  };

  export type valorUpsertWithWhereUniqueWithoutTipotrfInput = {
    where: valorWhereUniqueInput;
    update: XOR<
      valorUpdateWithoutTipotrfInput,
      valorUncheckedUpdateWithoutTipotrfInput
    >;
    create: XOR<
      valorCreateWithoutTipotrfInput,
      valorUncheckedCreateWithoutTipotrfInput
    >;
  };

  export type valorUpdateWithWhereUniqueWithoutTipotrfInput = {
    where: valorWhereUniqueInput;
    data: XOR<
      valorUpdateWithoutTipotrfInput,
      valorUncheckedUpdateWithoutTipotrfInput
    >;
  };

  export type valorUpdateManyWithWhereWithoutTipotrfInput = {
    where: valorScalarWhereInput;
    data: XOR<
      valorUpdateManyMutationInput,
      valorUncheckedUpdateManyWithoutTipotrfInput
    >;
  };

  export type acesso_sistemaCreateWithoutUsuarioInput = {
    incluir?: string;
    modificar?: string;
    eliminar?: string;
    modulo_sistema: modulo_sistemaCreateNestedOneWithoutAcesso_sistemaInput;
    tela_sistema: tela_sistemaCreateNestedOneWithoutAcesso_sistemaInput;
  };

  export type acesso_sistemaUncheckedCreateWithoutUsuarioInput = {
    cod_modulo: number;
    cod_tela: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type acesso_sistemaCreateOrConnectWithoutUsuarioInput = {
    where: acesso_sistemaWhereUniqueInput;
    create: XOR<
      acesso_sistemaCreateWithoutUsuarioInput,
      acesso_sistemaUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type acesso_sistemaCreateManyUsuarioInputEnvelope = {
    data:
      | acesso_sistemaCreateManyUsuarioInput
      | acesso_sistemaCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type recursoCreateWithoutUsuarioInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoCreateNestedManyWithoutRecursoInput;
    projeto?: projetoCreateNestedManyWithoutRecursoInput;
    nivel: nivelCreateNestedOneWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoCreateNestedManyWithoutRecursoInput;
  };

  export type recursoUncheckedCreateWithoutUsuarioInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
    agenrec?: agenrecUncheckedCreateNestedManyWithoutRecursoInput;
    avaliado?: avaliadoUncheckedCreateNestedManyWithoutRecursoInput;
    projeto?: projetoUncheckedCreateNestedManyWithoutRecursoInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedCreateNestedManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput;
    chamado?: chamadoUncheckedCreateNestedManyWithoutRecursoInput;
  };

  export type recursoCreateOrConnectWithoutUsuarioInput = {
    where: recursoWhereUniqueInput;
    create: XOR<
      recursoCreateWithoutUsuarioInput,
      recursoUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type recursoCreateManyUsuarioInputEnvelope = {
    data: recursoCreateManyUsuarioInput | recursoCreateManyUsuarioInput[];
    skipDuplicates?: boolean;
  };

  export type acesso_sistemaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: acesso_sistemaWhereUniqueInput;
    update: XOR<
      acesso_sistemaUpdateWithoutUsuarioInput,
      acesso_sistemaUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      acesso_sistemaCreateWithoutUsuarioInput,
      acesso_sistemaUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type acesso_sistemaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: acesso_sistemaWhereUniqueInput;
    data: XOR<
      acesso_sistemaUpdateWithoutUsuarioInput,
      acesso_sistemaUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type acesso_sistemaUpdateManyWithWhereWithoutUsuarioInput = {
    where: acesso_sistemaScalarWhereInput;
    data: XOR<
      acesso_sistemaUpdateManyMutationInput,
      acesso_sistemaUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type recursoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: recursoWhereUniqueInput;
    update: XOR<
      recursoUpdateWithoutUsuarioInput,
      recursoUncheckedUpdateWithoutUsuarioInput
    >;
    create: XOR<
      recursoCreateWithoutUsuarioInput,
      recursoUncheckedCreateWithoutUsuarioInput
    >;
  };

  export type recursoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: recursoWhereUniqueInput;
    data: XOR<
      recursoUpdateWithoutUsuarioInput,
      recursoUncheckedUpdateWithoutUsuarioInput
    >;
  };

  export type recursoUpdateManyWithWhereWithoutUsuarioInput = {
    where: recursoScalarWhereInput;
    data: XOR<
      recursoUpdateManyMutationInput,
      recursoUncheckedUpdateManyWithoutUsuarioInput
    >;
  };

  export type projetoCreateWithoutValorInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoCreateNestedManyWithoutProjetoInput;
    meta?: metaCreateNestedManyWithoutProjetoInput;
    cliente: clienteCreateNestedOneWithoutProjetoInput;
    recurso: recursoCreateNestedOneWithoutProjetoInput;
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput;
  };

  export type projetoUncheckedCreateWithoutValorInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
    avaliacao?: avaliacaoUncheckedCreateNestedManyWithoutProjetoInput;
    meta?: metaUncheckedCreateNestedManyWithoutProjetoInput;
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput;
  };

  export type projetoCreateOrConnectWithoutValorInput = {
    where: projetoWhereUniqueInput;
    create: XOR<
      projetoCreateWithoutValorInput,
      projetoUncheckedCreateWithoutValorInput
    >;
  };

  export type tipotrfCreateWithoutValorInput = {
    cod_tipotrf: number;
    nome_tipotrf: string;
  };

  export type tipotrfUncheckedCreateWithoutValorInput = {
    cod_tipotrf: number;
    nome_tipotrf: string;
  };

  export type tipotrfCreateOrConnectWithoutValorInput = {
    where: tipotrfWhereUniqueInput;
    create: XOR<
      tipotrfCreateWithoutValorInput,
      tipotrfUncheckedCreateWithoutValorInput
    >;
  };

  export type projetoUpsertWithoutValorInput = {
    update: XOR<
      projetoUpdateWithoutValorInput,
      projetoUncheckedUpdateWithoutValorInput
    >;
    create: XOR<
      projetoCreateWithoutValorInput,
      projetoUncheckedCreateWithoutValorInput
    >;
    where?: projetoWhereInput;
  };

  export type projetoUpdateToOneWithWhereWithoutValorInput = {
    where?: projetoWhereInput;
    data: XOR<
      projetoUpdateWithoutValorInput,
      projetoUncheckedUpdateWithoutValorInput
    >;
  };

  export type projetoUpdateWithoutValorInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUpdateManyWithoutProjetoNestedInput;
    meta?: metaUpdateManyWithoutProjetoNestedInput;
    cliente?: clienteUpdateOneRequiredWithoutProjetoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutProjetoNestedInput;
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateWithoutValorInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUncheckedUpdateManyWithoutProjetoNestedInput;
    meta?: metaUncheckedUpdateManyWithoutProjetoNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput;
  };

  export type tipotrfUpsertWithoutValorInput = {
    update: XOR<
      tipotrfUpdateWithoutValorInput,
      tipotrfUncheckedUpdateWithoutValorInput
    >;
    create: XOR<
      tipotrfCreateWithoutValorInput,
      tipotrfUncheckedCreateWithoutValorInput
    >;
    where?: tipotrfWhereInput;
  };

  export type tipotrfUpdateToOneWithWhereWithoutValorInput = {
    where?: tipotrfWhereInput;
    data: XOR<
      tipotrfUpdateWithoutValorInput,
      tipotrfUncheckedUpdateWithoutValorInput
    >;
  };

  export type tipotrfUpdateWithoutValorInput = {
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    nome_tipotrf?: StringFieldUpdateOperationsInput | string;
  };

  export type tipotrfUncheckedUpdateWithoutValorInput = {
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    nome_tipotrf?: StringFieldUpdateOperationsInput | string;
  };

  export type metaCreateManyAreaInput = {
    codproj_meta: number;
    codfase_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type tarefaCreateManyAreaInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
  };

  export type metaUpdateWithoutAreaInput = {
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    fase?: faseUpdateOneRequiredWithoutMetaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutMetaNestedInput;
  };

  export type metaUncheckedUpdateWithoutAreaInput = {
    codproj_meta?: IntFieldUpdateOperationsInput | number;
    codfase_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type metaUncheckedUpdateManyWithoutAreaInput = {
    codproj_meta?: IntFieldUpdateOperationsInput | number;
    codfase_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type tarefaUpdateWithoutAreaInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUpdateManyWithoutTarefaNestedInput;
    fase?: faseUpdateOneRequiredWithoutTarefaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutTarefaNestedInput;
    recurso_tarefa_codrecresp_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrecresp_tarefaTorecursoNestedInput;
    recurso_tarefa_codrec_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrec_tarefaTorecursoNestedInput;
  };

  export type tarefaUncheckedUpdateWithoutAreaInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codpro_tarefa?: IntFieldUpdateOperationsInput | number;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_fase?: IntFieldUpdateOperationsInput | number;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUncheckedUpdateManyWithoutTarefaNestedInput;
  };

  export type tarefaUncheckedUpdateManyWithoutAreaInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codpro_tarefa?: IntFieldUpdateOperationsInput | number;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_fase?: IntFieldUpdateOperationsInput | number;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type avaliadoCreateManyAvaliacaoInput = {
    codrec_avaliado: number;
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
  };

  export type avaliadoUpdateWithoutAvaliacaoInput = {
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    recurso?: recursoUpdateOneRequiredWithoutAvaliadoNestedInput;
    itavaliado?: itavaliadoUpdateManyWithoutAvaliadoNestedInput;
  };

  export type avaliadoUncheckedUpdateWithoutAvaliacaoInput = {
    codrec_avaliado?: IntFieldUpdateOperationsInput | number;
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    itavaliado?: itavaliadoUncheckedUpdateManyWithoutAvaliadoNestedInput;
  };

  export type avaliadoUncheckedUpdateManyWithoutAvaliacaoInput = {
    codrec_avaliado?: IntFieldUpdateOperationsInput | number;
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type itavaliadoCreateManyAvaliadoInput = {
    codmat_itavaliado: number;
    coditmat_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
  };

  export type itavaliadoUpdateWithoutAvaliadoInput = {
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    itmatriz?: itmatrizUpdateOneRequiredWithoutItavaliadoNestedInput;
  };

  export type itavaliadoUncheckedUpdateWithoutAvaliadoInput = {
    codmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    coditmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type itavaliadoUncheckedUpdateManyWithoutAvaliadoInput = {
    codmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    coditmat_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type chamadoCreateManyClienteInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cod_recurso?: number | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
  };

  export type fatrecCreateManyClienteInput = {
    cod_fatrec: number;
    desc_fatrec: string;
    qtdhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrhora_fatrec?: Decimal | DecimalJsLike | number | string;
    vrtot_fatrec?: Decimal | DecimalJsLike | number | string;
    dtvenc_fatrec?: Date | string | null;
    dtnf_fatrec?: Date | string | null;
    dtcob_fatrec?: Date | string | null;
    dtpag_fatrec?: Date | string | null;
    vrpag_fatrec?: Decimal | DecimalJsLike | number | string;
    imp_fatrec?: Decimal | DecimalJsLike | number | string;
    mesano_fatrec?: string | null;
    obs_fatrec?: Uint8Array | null;
    cod_recurso?: number | null;
    perccom_fatrec?: Decimal | DecimalJsLike | number | string;
    dtpgcom_fatrec?: Date | string | null;
    cod_empresa?: number | null;
    nf_fatrec?: string | null;
  };

  export type projetoCreateManyClienteInput = {
    cod_projeto: number;
    nome_projeto: string;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    codrec_projeto: number;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
  };

  export type chamadoUpdateWithoutClienteInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
    recurso?: recursoUpdateOneWithoutChamadoNestedInput;
  };

  export type chamadoUncheckedUpdateWithoutClienteInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type chamadoUncheckedUpdateManyWithoutClienteInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type fatrecUpdateWithoutClienteInput = {
    cod_fatrec?: IntFieldUpdateOperationsInput | number;
    desc_fatrec?: StringFieldUpdateOperationsInput | string;
    qtdhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_fatrec?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    perccom_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_empresa?: NullableIntFieldUpdateOperationsInput | number | null;
    nf_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type fatrecUncheckedUpdateWithoutClienteInput = {
    cod_fatrec?: IntFieldUpdateOperationsInput | number;
    desc_fatrec?: StringFieldUpdateOperationsInput | string;
    qtdhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_fatrec?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    perccom_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_empresa?: NullableIntFieldUpdateOperationsInput | number | null;
    nf_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type fatrecUncheckedUpdateManyWithoutClienteInput = {
    cod_fatrec?: IntFieldUpdateOperationsInput | number;
    desc_fatrec?: StringFieldUpdateOperationsInput | string;
    qtdhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrhora_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    vrtot_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtvenc_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtnf_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtcob_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtpag_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    vrpag_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    imp_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    mesano_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_fatrec?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    cod_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    perccom_fatrec?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    dtpgcom_fatrec?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    cod_empresa?: NullableIntFieldUpdateOperationsInput | number | null;
    nf_fatrec?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type projetoUpdateWithoutClienteInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUpdateManyWithoutProjetoNestedInput;
    meta?: metaUpdateManyWithoutProjetoNestedInput;
    recurso?: recursoUpdateOneRequiredWithoutProjetoNestedInput;
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput;
    valor?: valorUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateWithoutClienteInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUncheckedUpdateManyWithoutProjetoNestedInput;
    meta?: metaUncheckedUpdateManyWithoutProjetoNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput;
    valor?: valorUncheckedUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateManyWithoutClienteInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    codrec_projeto?: IntFieldUpdateOperationsInput | number;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
  };

  export type metaCreateManyFaseInput = {
    codproj_meta: number;
    codarea_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type tarefaCreateManyFaseInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
  };

  export type metaUpdateWithoutFaseInput = {
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    area?: areaUpdateOneRequiredWithoutMetaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutMetaNestedInput;
  };

  export type metaUncheckedUpdateWithoutFaseInput = {
    codproj_meta?: IntFieldUpdateOperationsInput | number;
    codarea_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type metaUncheckedUpdateManyWithoutFaseInput = {
    codproj_meta?: IntFieldUpdateOperationsInput | number;
    codarea_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type tarefaUpdateWithoutFaseInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUpdateManyWithoutTarefaNestedInput;
    area?: areaUpdateOneRequiredWithoutTarefaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutTarefaNestedInput;
    recurso_tarefa_codrecresp_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrecresp_tarefaTorecursoNestedInput;
    recurso_tarefa_codrec_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrec_tarefaTorecursoNestedInput;
  };

  export type tarefaUncheckedUpdateWithoutFaseInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codpro_tarefa?: IntFieldUpdateOperationsInput | number;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_area?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUncheckedUpdateManyWithoutTarefaNestedInput;
  };

  export type tarefaUncheckedUpdateManyWithoutFaseInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codpro_tarefa?: IntFieldUpdateOperationsInput | number;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_area?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type itavaliadoCreateManyItmatrizInput = {
    codaval_itavaliado: number;
    codrec_itavaliado: number;
    ptoger_itavaliado: number;
    ptorec_itavaliado: number;
    obs_itavaliado?: string | null;
    nota1_itavaliado: Decimal | DecimalJsLike | number | string;
    nota2_itavaliado: Decimal | DecimalJsLike | number | string;
    nota3_itavaliado: Decimal | DecimalJsLike | number | string;
  };

  export type itavaliadoUpdateWithoutItmatrizInput = {
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    avaliado?: avaliadoUpdateOneRequiredWithoutItavaliadoNestedInput;
  };

  export type itavaliadoUncheckedUpdateWithoutItmatrizInput = {
    codaval_itavaliado?: IntFieldUpdateOperationsInput | number;
    codrec_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type itavaliadoUncheckedUpdateManyWithoutItmatrizInput = {
    codaval_itavaliado?: IntFieldUpdateOperationsInput | number;
    codrec_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptoger_itavaliado?: IntFieldUpdateOperationsInput | number;
    ptorec_itavaliado?: IntFieldUpdateOperationsInput | number;
    obs_itavaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    nota1_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itavaliado?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type itmatrizCreateManyMatrizInput = {
    cod_itmatriz: number;
    nota1_itmatriz: Decimal | DecimalJsLike | number | string;
    nota2_itmatriz: Decimal | DecimalJsLike | number | string;
    nota3_itmatriz: Decimal | DecimalJsLike | number | string;
    questao_itmatriz?: Uint8Array | null;
  };

  export type itmatrizUpdateWithoutMatrizInput = {
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    itavaliado?: itavaliadoUpdateManyWithoutItmatrizNestedInput;
  };

  export type itmatrizUncheckedUpdateWithoutMatrizInput = {
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    itavaliado?: itavaliadoUncheckedUpdateManyWithoutItmatrizNestedInput;
  };

  export type itmatrizUncheckedUpdateManyWithoutMatrizInput = {
    cod_itmatriz?: IntFieldUpdateOperationsInput | number;
    nota1_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota2_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    nota3_itmatriz?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    questao_itmatriz?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
  };

  export type acesso_sistemaCreateManyModulo_sistemaInput = {
    cod_usuario: number;
    cod_tela: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type tela_sistemaCreateManyModulo_sistemaInput = {
    cod_tela: number;
    desc_tela: string;
  };

  export type acesso_sistemaUpdateWithoutModulo_sistemaInput = {
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
    tela_sistema?: tela_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
  };

  export type acesso_sistemaUncheckedUpdateWithoutModulo_sistemaInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    cod_tela?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type acesso_sistemaUncheckedUpdateManyWithoutModulo_sistemaInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    cod_tela?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type tela_sistemaUpdateWithoutModulo_sistemaInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUpdateManyWithoutTela_sistemaNestedInput;
  };

  export type tela_sistemaUncheckedUpdateWithoutModulo_sistemaInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
    acesso_sistema?: acesso_sistemaUncheckedUpdateManyWithoutTela_sistemaNestedInput;
  };

  export type tela_sistemaUncheckedUpdateManyWithoutModulo_sistemaInput = {
    cod_tela?: IntFieldUpdateOperationsInput | number;
    desc_tela?: StringFieldUpdateOperationsInput | string;
  };

  export type recursoCreateManyNivelInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    codusr_recurso: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
  };

  export type recursoUpdateWithoutNivelInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUpdateManyWithoutRecursoNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateWithoutNivelInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateManyWithoutNivelInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    codusr_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type avaliacaoCreateManyProjetoInput = {
    cod_avaliacao: number;
    anomes_avaliacao: string;
    data_avaliacao: Date | string;
    codrec_avaliacao: number;
    status_avaliacao: string;
  };

  export type metaCreateManyProjetoInput = {
    codarea_meta: number;
    codfase_meta: number;
    tempo_meta: Decimal | DecimalJsLike | number | string;
    altesc_meta?: Decimal | DecimalJsLike | number | string;
  };

  export type tarefaCreateManyProjetoInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
  };

  export type valorCreateManyProjetoInput = {
    codtipo_valor: number;
    preco_valor: Decimal | DecimalJsLike | number | string;
  };

  export type avaliacaoUpdateWithoutProjetoInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
    avaliado?: avaliadoUpdateManyWithoutAvaliacaoNestedInput;
  };

  export type avaliacaoUncheckedUpdateWithoutProjetoInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
    avaliado?: avaliadoUncheckedUpdateManyWithoutAvaliacaoNestedInput;
  };

  export type avaliacaoUncheckedUpdateManyWithoutProjetoInput = {
    cod_avaliacao?: IntFieldUpdateOperationsInput | number;
    anomes_avaliacao?: StringFieldUpdateOperationsInput | string;
    data_avaliacao?: DateTimeFieldUpdateOperationsInput | Date | string;
    codrec_avaliacao?: IntFieldUpdateOperationsInput | number;
    status_avaliacao?: StringFieldUpdateOperationsInput | string;
  };

  export type metaUpdateWithoutProjetoInput = {
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    area?: areaUpdateOneRequiredWithoutMetaNestedInput;
    fase?: faseUpdateOneRequiredWithoutMetaNestedInput;
  };

  export type metaUncheckedUpdateWithoutProjetoInput = {
    codarea_meta?: IntFieldUpdateOperationsInput | number;
    codfase_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type metaUncheckedUpdateManyWithoutProjetoInput = {
    codarea_meta?: IntFieldUpdateOperationsInput | number;
    codfase_meta?: IntFieldUpdateOperationsInput | number;
    tempo_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    altesc_meta?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type tarefaUpdateWithoutProjetoInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUpdateManyWithoutTarefaNestedInput;
    area?: areaUpdateOneRequiredWithoutTarefaNestedInput;
    fase?: faseUpdateOneRequiredWithoutTarefaNestedInput;
    recurso_tarefa_codrecresp_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrecresp_tarefaTorecursoNestedInput;
    recurso_tarefa_codrec_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrec_tarefaTorecursoNestedInput;
  };

  export type tarefaUncheckedUpdateWithoutProjetoInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_area?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_fase?: IntFieldUpdateOperationsInput | number;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUncheckedUpdateManyWithoutTarefaNestedInput;
  };

  export type tarefaUncheckedUpdateManyWithoutProjetoInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    codrec_tarefa?: IntFieldUpdateOperationsInput | number;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    cod_area?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_fase?: IntFieldUpdateOperationsInput | number;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type valorUpdateWithoutProjetoInput = {
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tipotrf?: tipotrfUpdateOneRequiredWithoutValorNestedInput;
  };

  export type valorUncheckedUpdateWithoutProjetoInput = {
    codtipo_valor?: IntFieldUpdateOperationsInput | number;
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type valorUncheckedUpdateManyWithoutProjetoInput = {
    codtipo_valor?: IntFieldUpdateOperationsInput | number;
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type agenrecCreateManyRecursoInput = {
    cod_agenrec: number;
    data_agenrec: Date | string;
    hrini_agenrec: string;
    hrfim_agenrec: string;
    status_agenrec?: number;
    obs_agenrec?: string | null;
    custo_agenrec?: Decimal | DecimalJsLike | number | string | null;
    receita_agenrec?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_agenrec?: number | null;
  };

  export type avaliadoCreateManyRecursoInput = {
    codaval_avaliado: number;
    status_avaliado: string;
    data_avaliado?: Date | string | null;
    hora_avaliado?: string | null;
    usuario_avaliado?: string | null;
  };

  export type projetoCreateManyRecursoInput = {
    cod_projeto: number;
    nome_projeto: string;
    codcli_projeto: number;
    respcli_projeto: string;
    proposta_projeto?: string | null;
    perc_projeto?: Decimal | DecimalJsLike | number | string;
    loginc_projeto?: string | null;
    logalt_projeto?: string | null;
    qtdhoras_projeto?: Decimal | DecimalJsLike | number | string;
    status_projeto?: string;
  };

  export type tarefaCreateManyRecurso_tarefa_codrecresp_tarefaTorecursoInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    codrec_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
  };

  export type tarefaCreateManyRecurso_tarefa_codrec_tarefaTorecursoInput = {
    cod_tarefa: number;
    nome_tarefa: string;
    codpro_tarefa: number;
    dtsol_tarefa?: Date | string | null;
    dtaprov_tarefa?: Date | string | null;
    dtprevent_tarefa?: Date | string | null;
    hrest_tarefa?: Decimal | DecimalJsLike | number | string | null;
    hratesc_tarefa?: Decimal | DecimalJsLike | number | string | null;
    margem_tarefa?: string;
    status_tarefa?: number;
    ordem_tarefa: number;
    cod_area: number;
    estimado_tarefa?: string;
    cod_tipotrf: number;
    codrecresp_tarefa: number;
    hrreal_tarefa?: Decimal | DecimalJsLike | number | string | null;
    fatest_tarefa?: string;
    cod_fase: number;
    valini_tarefa: Date | string;
    valfim_tarefa: Date | string;
    perimp_tarefa?: string;
    dtinc_tarefa: Date | string;
    perc_tarefa?: number;
    fatura_tarefa?: string;
    valida_tarefa?: number;
    vrhr_tarefa?: Decimal | DecimalJsLike | number | string;
    obs_tarefa?: Uint8Array | null;
    limmes_tarefa?: number | null;
    exibecham_tarefa?: number | null;
  };

  export type chamadoCreateManyRecursoInput = {
    cod_chamado: number;
    data_chamado: Date | string;
    hora_chamado: string;
    solicitacao_chamado?: Uint8Array | null;
    conclusao_chamado?: Date | string | null;
    status_chamado: string;
    dtenvio_chamado?: string | null;
    cliente_chamado?: string | null;
    codtrf_chamado?: number | null;
    cod_cliente?: number | null;
    solicitacao2_chamado?: Uint8Array | null;
    assunto_chamado?: string | null;
    email_chamado?: string | null;
    prior_chamado?: number | null;
    cod_classificacao?: number | null;
  };

  export type agenrecUpdateWithoutRecursoInput = {
    cod_agenrec?: IntFieldUpdateOperationsInput | number;
    data_agenrec?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_agenrec?: StringFieldUpdateOperationsInput | string;
    hrfim_agenrec?: StringFieldUpdateOperationsInput | string;
    status_agenrec?: IntFieldUpdateOperationsInput | number;
    obs_agenrec?: NullableStringFieldUpdateOperationsInput | string | null;
    custo_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type agenrecUncheckedUpdateWithoutRecursoInput = {
    cod_agenrec?: IntFieldUpdateOperationsInput | number;
    data_agenrec?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_agenrec?: StringFieldUpdateOperationsInput | string;
    hrfim_agenrec?: StringFieldUpdateOperationsInput | string;
    status_agenrec?: IntFieldUpdateOperationsInput | number;
    obs_agenrec?: NullableStringFieldUpdateOperationsInput | string | null;
    custo_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type agenrecUncheckedUpdateManyWithoutRecursoInput = {
    cod_agenrec?: IntFieldUpdateOperationsInput | number;
    data_agenrec?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_agenrec?: StringFieldUpdateOperationsInput | string;
    hrfim_agenrec?: StringFieldUpdateOperationsInput | string;
    status_agenrec?: IntFieldUpdateOperationsInput | number;
    obs_agenrec?: NullableStringFieldUpdateOperationsInput | string | null;
    custo_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_agenrec?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_agenrec?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type avaliadoUpdateWithoutRecursoInput = {
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    avaliacao?: avaliacaoUpdateOneRequiredWithoutAvaliadoNestedInput;
    itavaliado?: itavaliadoUpdateManyWithoutAvaliadoNestedInput;
  };

  export type avaliadoUncheckedUpdateWithoutRecursoInput = {
    codaval_avaliado?: IntFieldUpdateOperationsInput | number;
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    itavaliado?: itavaliadoUncheckedUpdateManyWithoutAvaliadoNestedInput;
  };

  export type avaliadoUncheckedUpdateManyWithoutRecursoInput = {
    codaval_avaliado?: IntFieldUpdateOperationsInput | number;
    status_avaliado?: StringFieldUpdateOperationsInput | string;
    data_avaliado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hora_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
    usuario_avaliado?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type projetoUpdateWithoutRecursoInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUpdateManyWithoutProjetoNestedInput;
    meta?: metaUpdateManyWithoutProjetoNestedInput;
    cliente?: clienteUpdateOneRequiredWithoutProjetoNestedInput;
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput;
    valor?: valorUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateWithoutRecursoInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
    avaliacao?: avaliacaoUncheckedUpdateManyWithoutProjetoNestedInput;
    meta?: metaUncheckedUpdateManyWithoutProjetoNestedInput;
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput;
    valor?: valorUncheckedUpdateManyWithoutProjetoNestedInput;
  };

  export type projetoUncheckedUpdateManyWithoutRecursoInput = {
    cod_projeto?: IntFieldUpdateOperationsInput | number;
    nome_projeto?: StringFieldUpdateOperationsInput | string;
    codcli_projeto?: IntFieldUpdateOperationsInput | number;
    respcli_projeto?: StringFieldUpdateOperationsInput | string;
    proposta_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    perc_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    loginc_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    logalt_projeto?: NullableStringFieldUpdateOperationsInput | string | null;
    qtdhoras_projeto?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status_projeto?: StringFieldUpdateOperationsInput | string;
  };

  export type tarefaUpdateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_tarefa?: IntFieldUpdateOperationsInput | number;
      nome_tarefa?: StringFieldUpdateOperationsInput | string;
      dtsol_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtaprov_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtprevent_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      hrest_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hratesc_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      margem_tarefa?: StringFieldUpdateOperationsInput | string;
      status_tarefa?: IntFieldUpdateOperationsInput | number;
      ordem_tarefa?: IntFieldUpdateOperationsInput | number;
      estimado_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_tipotrf?: IntFieldUpdateOperationsInput | number;
      hrreal_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      fatest_tarefa?: StringFieldUpdateOperationsInput | string;
      valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perimp_tarefa?: StringFieldUpdateOperationsInput | string;
      dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perc_tarefa?: IntFieldUpdateOperationsInput | number;
      fatura_tarefa?: StringFieldUpdateOperationsInput | string;
      valida_tarefa?: IntFieldUpdateOperationsInput | number;
      vrhr_tarefa?:
        | DecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string;
      obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      os?: osUpdateManyWithoutTarefaNestedInput;
      area?: areaUpdateOneRequiredWithoutTarefaNestedInput;
      fase?: faseUpdateOneRequiredWithoutTarefaNestedInput;
      projeto?: projetoUpdateOneRequiredWithoutTarefaNestedInput;
      recurso_tarefa_codrec_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrec_tarefaTorecursoNestedInput;
    };

  export type tarefaUncheckedUpdateWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_tarefa?: IntFieldUpdateOperationsInput | number;
      nome_tarefa?: StringFieldUpdateOperationsInput | string;
      codpro_tarefa?: IntFieldUpdateOperationsInput | number;
      codrec_tarefa?: IntFieldUpdateOperationsInput | number;
      dtsol_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtaprov_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtprevent_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      hrest_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hratesc_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      margem_tarefa?: StringFieldUpdateOperationsInput | string;
      status_tarefa?: IntFieldUpdateOperationsInput | number;
      ordem_tarefa?: IntFieldUpdateOperationsInput | number;
      cod_area?: IntFieldUpdateOperationsInput | number;
      estimado_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_tipotrf?: IntFieldUpdateOperationsInput | number;
      hrreal_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      fatest_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_fase?: IntFieldUpdateOperationsInput | number;
      valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perimp_tarefa?: StringFieldUpdateOperationsInput | string;
      dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perc_tarefa?: IntFieldUpdateOperationsInput | number;
      fatura_tarefa?: StringFieldUpdateOperationsInput | string;
      valida_tarefa?: IntFieldUpdateOperationsInput | number;
      vrhr_tarefa?:
        | DecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string;
      obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      os?: osUncheckedUpdateManyWithoutTarefaNestedInput;
    };

  export type tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoInput =
    {
      cod_tarefa?: IntFieldUpdateOperationsInput | number;
      nome_tarefa?: StringFieldUpdateOperationsInput | string;
      codpro_tarefa?: IntFieldUpdateOperationsInput | number;
      codrec_tarefa?: IntFieldUpdateOperationsInput | number;
      dtsol_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtaprov_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtprevent_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      hrest_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hratesc_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      margem_tarefa?: StringFieldUpdateOperationsInput | string;
      status_tarefa?: IntFieldUpdateOperationsInput | number;
      ordem_tarefa?: IntFieldUpdateOperationsInput | number;
      cod_area?: IntFieldUpdateOperationsInput | number;
      estimado_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_tipotrf?: IntFieldUpdateOperationsInput | number;
      hrreal_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      fatest_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_fase?: IntFieldUpdateOperationsInput | number;
      valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perimp_tarefa?: StringFieldUpdateOperationsInput | string;
      dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perc_tarefa?: IntFieldUpdateOperationsInput | number;
      fatura_tarefa?: StringFieldUpdateOperationsInput | string;
      valida_tarefa?: IntFieldUpdateOperationsInput | number;
      vrhr_tarefa?:
        | DecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string;
      obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    };

  export type tarefaUpdateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput = {
    cod_tarefa?: IntFieldUpdateOperationsInput | number;
    nome_tarefa?: StringFieldUpdateOperationsInput | string;
    dtsol_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtaprov_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    dtprevent_tarefa?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    hrest_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    hratesc_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    margem_tarefa?: StringFieldUpdateOperationsInput | string;
    status_tarefa?: IntFieldUpdateOperationsInput | number;
    ordem_tarefa?: IntFieldUpdateOperationsInput | number;
    estimado_tarefa?: StringFieldUpdateOperationsInput | string;
    cod_tipotrf?: IntFieldUpdateOperationsInput | number;
    hrreal_tarefa?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    fatest_tarefa?: StringFieldUpdateOperationsInput | string;
    valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perimp_tarefa?: StringFieldUpdateOperationsInput | string;
    dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
    perc_tarefa?: IntFieldUpdateOperationsInput | number;
    fatura_tarefa?: StringFieldUpdateOperationsInput | string;
    valida_tarefa?: IntFieldUpdateOperationsInput | number;
    vrhr_tarefa?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    os?: osUpdateManyWithoutTarefaNestedInput;
    area?: areaUpdateOneRequiredWithoutTarefaNestedInput;
    fase?: faseUpdateOneRequiredWithoutTarefaNestedInput;
    projeto?: projetoUpdateOneRequiredWithoutTarefaNestedInput;
    recurso_tarefa_codrecresp_tarefaTorecurso?: recursoUpdateOneRequiredWithoutTarefa_tarefa_codrecresp_tarefaTorecursoNestedInput;
  };

  export type tarefaUncheckedUpdateWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      cod_tarefa?: IntFieldUpdateOperationsInput | number;
      nome_tarefa?: StringFieldUpdateOperationsInput | string;
      codpro_tarefa?: IntFieldUpdateOperationsInput | number;
      dtsol_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtaprov_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtprevent_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      hrest_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hratesc_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      margem_tarefa?: StringFieldUpdateOperationsInput | string;
      status_tarefa?: IntFieldUpdateOperationsInput | number;
      ordem_tarefa?: IntFieldUpdateOperationsInput | number;
      cod_area?: IntFieldUpdateOperationsInput | number;
      estimado_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_tipotrf?: IntFieldUpdateOperationsInput | number;
      codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
      hrreal_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      fatest_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_fase?: IntFieldUpdateOperationsInput | number;
      valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perimp_tarefa?: StringFieldUpdateOperationsInput | string;
      dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perc_tarefa?: IntFieldUpdateOperationsInput | number;
      fatura_tarefa?: StringFieldUpdateOperationsInput | string;
      valida_tarefa?: IntFieldUpdateOperationsInput | number;
      vrhr_tarefa?:
        | DecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string;
      obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      os?: osUncheckedUpdateManyWithoutTarefaNestedInput;
    };

  export type tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoInput =
    {
      cod_tarefa?: IntFieldUpdateOperationsInput | number;
      nome_tarefa?: StringFieldUpdateOperationsInput | string;
      codpro_tarefa?: IntFieldUpdateOperationsInput | number;
      dtsol_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtaprov_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      dtprevent_tarefa?:
        | NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
      hrest_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      hratesc_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      margem_tarefa?: StringFieldUpdateOperationsInput | string;
      status_tarefa?: IntFieldUpdateOperationsInput | number;
      ordem_tarefa?: IntFieldUpdateOperationsInput | number;
      cod_area?: IntFieldUpdateOperationsInput | number;
      estimado_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_tipotrf?: IntFieldUpdateOperationsInput | number;
      codrecresp_tarefa?: IntFieldUpdateOperationsInput | number;
      hrreal_tarefa?:
        | NullableDecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      fatest_tarefa?: StringFieldUpdateOperationsInput | string;
      cod_fase?: IntFieldUpdateOperationsInput | number;
      valini_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      valfim_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perimp_tarefa?: StringFieldUpdateOperationsInput | string;
      dtinc_tarefa?: DateTimeFieldUpdateOperationsInput | Date | string;
      perc_tarefa?: IntFieldUpdateOperationsInput | number;
      fatura_tarefa?: StringFieldUpdateOperationsInput | string;
      valida_tarefa?: IntFieldUpdateOperationsInput | number;
      vrhr_tarefa?:
        | DecimalFieldUpdateOperationsInput
        | Decimal
        | DecimalJsLike
        | number
        | string;
      obs_tarefa?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
      limmes_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
      exibecham_tarefa?: NullableIntFieldUpdateOperationsInput | number | null;
    };

  export type chamadoUpdateWithoutRecursoInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
    cliente?: clienteUpdateOneWithoutChamadosNestedInput;
  };

  export type chamadoUncheckedUpdateWithoutRecursoInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_cliente?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type chamadoUncheckedUpdateManyWithoutRecursoInput = {
    cod_chamado?: IntFieldUpdateOperationsInput | number;
    data_chamado?: DateTimeFieldUpdateOperationsInput | Date | string;
    hora_chamado?: StringFieldUpdateOperationsInput | string;
    solicitacao_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    conclusao_chamado?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    status_chamado?: StringFieldUpdateOperationsInput | string;
    dtenvio_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    cliente_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    codtrf_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_cliente?: NullableIntFieldUpdateOperationsInput | number | null;
    solicitacao2_chamado?:
      | NullableBytesFieldUpdateOperationsInput
      | Uint8Array
      | null;
    assunto_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    email_chamado?: NullableStringFieldUpdateOperationsInput | string | null;
    prior_chamado?: NullableIntFieldUpdateOperationsInput | number | null;
    cod_classificacao?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type osCreateManyTarefaInput = {
    cod_os: number;
    dtini_os: Date | string;
    hrini_os: string;
    hrfim_os: string;
    obs_os?: string | null;
    status_os?: number;
    produtivo_os?: string;
    codrec_os: number;
    produtivo2_os?: string;
    respcli_os: string;
    remdes_os?: string;
    abono_os?: string;
    desloc_os?: string | null;
    obs?: Uint8Array | null;
    dtinc_os: Date | string;
    faturado_os?: string;
    perc_os?: number;
    cod_faturamento?: number | null;
    comp_os?: string | null;
    valid_os?: string;
    vrhr_os?: Decimal | DecimalJsLike | number | string;
    num_os?: string | null;
    chamado_os?: string | null;
  };

  export type osUpdateWithoutTarefaInput = {
    cod_os?: IntFieldUpdateOperationsInput | number;
    dtini_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_os?: StringFieldUpdateOperationsInput | string;
    hrfim_os?: StringFieldUpdateOperationsInput | string;
    obs_os?: NullableStringFieldUpdateOperationsInput | string | null;
    status_os?: IntFieldUpdateOperationsInput | number;
    produtivo_os?: StringFieldUpdateOperationsInput | string;
    codrec_os?: IntFieldUpdateOperationsInput | number;
    produtivo2_os?: StringFieldUpdateOperationsInput | string;
    respcli_os?: StringFieldUpdateOperationsInput | string;
    remdes_os?: StringFieldUpdateOperationsInput | string;
    abono_os?: StringFieldUpdateOperationsInput | string;
    desloc_os?: NullableStringFieldUpdateOperationsInput | string | null;
    obs?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtinc_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    faturado_os?: StringFieldUpdateOperationsInput | string;
    perc_os?: IntFieldUpdateOperationsInput | number;
    cod_faturamento?: NullableIntFieldUpdateOperationsInput | number | null;
    comp_os?: NullableStringFieldUpdateOperationsInput | string | null;
    valid_os?: StringFieldUpdateOperationsInput | string;
    vrhr_os?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: NullableStringFieldUpdateOperationsInput | string | null;
    chamado_os?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type osUncheckedUpdateWithoutTarefaInput = {
    cod_os?: IntFieldUpdateOperationsInput | number;
    dtini_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_os?: StringFieldUpdateOperationsInput | string;
    hrfim_os?: StringFieldUpdateOperationsInput | string;
    obs_os?: NullableStringFieldUpdateOperationsInput | string | null;
    status_os?: IntFieldUpdateOperationsInput | number;
    produtivo_os?: StringFieldUpdateOperationsInput | string;
    codrec_os?: IntFieldUpdateOperationsInput | number;
    produtivo2_os?: StringFieldUpdateOperationsInput | string;
    respcli_os?: StringFieldUpdateOperationsInput | string;
    remdes_os?: StringFieldUpdateOperationsInput | string;
    abono_os?: StringFieldUpdateOperationsInput | string;
    desloc_os?: NullableStringFieldUpdateOperationsInput | string | null;
    obs?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtinc_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    faturado_os?: StringFieldUpdateOperationsInput | string;
    perc_os?: IntFieldUpdateOperationsInput | number;
    cod_faturamento?: NullableIntFieldUpdateOperationsInput | number | null;
    comp_os?: NullableStringFieldUpdateOperationsInput | string | null;
    valid_os?: StringFieldUpdateOperationsInput | string;
    vrhr_os?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: NullableStringFieldUpdateOperationsInput | string | null;
    chamado_os?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type osUncheckedUpdateManyWithoutTarefaInput = {
    cod_os?: IntFieldUpdateOperationsInput | number;
    dtini_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    hrini_os?: StringFieldUpdateOperationsInput | string;
    hrfim_os?: StringFieldUpdateOperationsInput | string;
    obs_os?: NullableStringFieldUpdateOperationsInput | string | null;
    status_os?: IntFieldUpdateOperationsInput | number;
    produtivo_os?: StringFieldUpdateOperationsInput | string;
    codrec_os?: IntFieldUpdateOperationsInput | number;
    produtivo2_os?: StringFieldUpdateOperationsInput | string;
    respcli_os?: StringFieldUpdateOperationsInput | string;
    remdes_os?: StringFieldUpdateOperationsInput | string;
    abono_os?: StringFieldUpdateOperationsInput | string;
    desloc_os?: NullableStringFieldUpdateOperationsInput | string | null;
    obs?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    dtinc_os?: DateTimeFieldUpdateOperationsInput | Date | string;
    faturado_os?: StringFieldUpdateOperationsInput | string;
    perc_os?: IntFieldUpdateOperationsInput | number;
    cod_faturamento?: NullableIntFieldUpdateOperationsInput | number | null;
    comp_os?: NullableStringFieldUpdateOperationsInput | string | null;
    valid_os?: StringFieldUpdateOperationsInput | string;
    vrhr_os?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    num_os?: NullableStringFieldUpdateOperationsInput | string | null;
    chamado_os?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type acesso_sistemaCreateManyTela_sistemaInput = {
    cod_usuario: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type acesso_sistemaUpdateWithoutTela_sistemaInput = {
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
    modulo_sistema?: modulo_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
    usuario?: usuarioUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
  };

  export type acesso_sistemaUncheckedUpdateWithoutTela_sistemaInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type acesso_sistemaUncheckedUpdateManyWithoutTela_sistemaInput = {
    cod_usuario?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type valorCreateManyTipotrfInput = {
    codproj_valor: number;
    preco_valor: Decimal | DecimalJsLike | number | string;
  };

  export type valorUpdateWithoutTipotrfInput = {
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    projeto?: projetoUpdateOneRequiredWithoutValorNestedInput;
  };

  export type valorUncheckedUpdateWithoutTipotrfInput = {
    codproj_valor?: IntFieldUpdateOperationsInput | number;
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type valorUncheckedUpdateManyWithoutTipotrfInput = {
    codproj_valor?: IntFieldUpdateOperationsInput | number;
    preco_valor?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type acesso_sistemaCreateManyUsuarioInput = {
    cod_modulo: number;
    cod_tela: number;
    incluir?: string;
    modificar?: string;
    eliminar?: string;
  };

  export type recursoCreateManyUsuarioInput = {
    cod_recurso: number;
    nome_recurso: string;
    fone_recurso?: string | null;
    ativo_recurso?: number;
    cod_nivel: number;
    hrdia_recurso?: string | null;
    percprod_recurso?: Decimal | DecimalJsLike | number | string | null;
    email_recurso?: string | null;
    dtlimite_recurso?: Date | string | null;
    permapo_recurso?: string;
    matr_recurso?: string | null;
    obs_recurso?: Uint8Array | null;
    custo_recurso?: Decimal | DecimalJsLike | number | string | null;
    receita_recurso?: Decimal | DecimalJsLike | number | string | null;
    tpcusto_recurso?: number | null;
  };

  export type acesso_sistemaUpdateWithoutUsuarioInput = {
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
    modulo_sistema?: modulo_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
    tela_sistema?: tela_sistemaUpdateOneRequiredWithoutAcesso_sistemaNestedInput;
  };

  export type acesso_sistemaUncheckedUpdateWithoutUsuarioInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    cod_tela?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type acesso_sistemaUncheckedUpdateManyWithoutUsuarioInput = {
    cod_modulo?: IntFieldUpdateOperationsInput | number;
    cod_tela?: IntFieldUpdateOperationsInput | number;
    incluir?: StringFieldUpdateOperationsInput | string;
    modificar?: StringFieldUpdateOperationsInput | string;
    eliminar?: StringFieldUpdateOperationsInput | string;
  };

  export type recursoUpdateWithoutUsuarioInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUpdateManyWithoutRecursoNestedInput;
    nivel?: nivelUpdateOneRequiredWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateWithoutUsuarioInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
    agenrec?: agenrecUncheckedUpdateManyWithoutRecursoNestedInput;
    avaliado?: avaliadoUncheckedUpdateManyWithoutRecursoNestedInput;
    projeto?: projetoUncheckedUpdateManyWithoutRecursoNestedInput;
    tarefa_tarefa_codrecresp_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrecresp_tarefaTorecursoNestedInput;
    tarefa_tarefa_codrec_tarefaTorecurso?: tarefaUncheckedUpdateManyWithoutRecurso_tarefa_codrec_tarefaTorecursoNestedInput;
    chamado?: chamadoUncheckedUpdateManyWithoutRecursoNestedInput;
  };

  export type recursoUncheckedUpdateManyWithoutUsuarioInput = {
    cod_recurso?: IntFieldUpdateOperationsInput | number;
    nome_recurso?: StringFieldUpdateOperationsInput | string;
    fone_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    ativo_recurso?: IntFieldUpdateOperationsInput | number;
    cod_nivel?: IntFieldUpdateOperationsInput | number;
    hrdia_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    percprod_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    email_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    dtlimite_recurso?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    permapo_recurso?: StringFieldUpdateOperationsInput | string;
    matr_recurso?: NullableStringFieldUpdateOperationsInput | string | null;
    obs_recurso?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null;
    custo_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    receita_recurso?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    tpcusto_recurso?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
